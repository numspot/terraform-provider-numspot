// Package iaas provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package iaas

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for CreateVmsPerformance.
const (
	CreateVmsPerformanceHigh    CreateVmsPerformance = "high"
	CreateVmsPerformanceHighest CreateVmsPerformance = "highest"
	CreateVmsPerformanceMedium  CreateVmsPerformance = "medium"
)

// Defines values for ErrorDocumentationUrl.
const (
	HttpsdocsNumspotClouddocsdomainsclouderrorsAmbiguousGranularPermissionElements ErrorDocumentationUrl = "https://docs.numspot.cloud/docs/domains/cloud/errors#ambiguous_granular_permission_elements"
	HttpsdocsNumspotClouddocsdomainsclouderrorsAmbiguousPermissionElements         ErrorDocumentationUrl = "https://docs.numspot.cloud/docs/domains/cloud/errors#ambiguous_permission_elements"
	HttpsdocsNumspotClouddocsdomainsclouderrorsAmbiguousRoleElements               ErrorDocumentationUrl = "https://docs.numspot.cloud/docs/domains/cloud/errors#ambiguous_role_elements"
	HttpsdocsNumspotClouddocsdomainsclouderrorsDuplicateResource                   ErrorDocumentationUrl = "https://docs.numspot.cloud/docs/domains/cloud/errors#duplicate_resource"
	HttpsdocsNumspotClouddocsdomainsclouderrorsDuplicateRole                       ErrorDocumentationUrl = "https://docs.numspot.cloud/docs/domains/cloud/errors#duplicate_role"
	HttpsdocsNumspotClouddocsdomainsclouderrorsForbidden                           ErrorDocumentationUrl = "https://docs.numspot.cloud/docs/domains/cloud/errors#forbidden"
	HttpsdocsNumspotClouddocsdomainsclouderrorsForbiddenAccess                     ErrorDocumentationUrl = "https://docs.numspot.cloud/docs/domains/cloud/errors#forbidden_access"
	HttpsdocsNumspotClouddocsdomainsclouderrorsIdentityNotFound                    ErrorDocumentationUrl = "https://docs.numspot.cloud/docs/domains/cloud/errors#identity_not_found"
	HttpsdocsNumspotClouddocsdomainsclouderrorsInactiveToken                       ErrorDocumentationUrl = "https://docs.numspot.cloud/docs/domains/cloud/errors#inactive_token"
	HttpsdocsNumspotClouddocsdomainsclouderrorsInternalServerError                 ErrorDocumentationUrl = "https://docs.numspot.cloud/docs/domains/cloud/errors#internal_server_error"
	HttpsdocsNumspotClouddocsdomainsclouderrorsInvalidParameter                    ErrorDocumentationUrl = "https://docs.numspot.cloud/docs/domains/cloud/errors#invalid_parameter"
	HttpsdocsNumspotClouddocsdomainsclouderrorsMethodNotAllowed                    ErrorDocumentationUrl = "https://docs.numspot.cloud/docs/domains/cloud/errors#method_not_allowed"
	HttpsdocsNumspotClouddocsdomainsclouderrorsMissingRoles                        ErrorDocumentationUrl = "https://docs.numspot.cloud/docs/domains/cloud/errors#missing_roles"
	HttpsdocsNumspotClouddocsdomainsclouderrorsNamespaceNotFound                   ErrorDocumentationUrl = "https://docs.numspot.cloud/docs/domains/cloud/errors#namespace_not_found"
	HttpsdocsNumspotClouddocsdomainsclouderrorsNotInTenantRoles                    ErrorDocumentationUrl = "https://docs.numspot.cloud/docs/domains/cloud/errors#not_in_tenant_roles"
	HttpsdocsNumspotClouddocsdomainsclouderrorsPermissionNotFound                  ErrorDocumentationUrl = "https://docs.numspot.cloud/docs/domains/cloud/errors#permission_not_found"
	HttpsdocsNumspotClouddocsdomainsclouderrorsResourceNotFound                    ErrorDocumentationUrl = "https://docs.numspot.cloud/docs/domains/cloud/errors#resource_not_found"
	HttpsdocsNumspotClouddocsdomainsclouderrorsRoleNotFound                        ErrorDocumentationUrl = "https://docs.numspot.cloud/docs/domains/cloud/errors#role_not_found"
	HttpsdocsNumspotClouddocsdomainsclouderrorsUnauthenticatedAccess               ErrorDocumentationUrl = "https://docs.numspot.cloud/docs/domains/cloud/errors#unauthenticated_access"
	HttpsdocsNumspotClouddocsdomainsclouderrorsUnexpectedTokenUsage                ErrorDocumentationUrl = "https://docs.numspot.cloud/docs/domains/cloud/errors#unexpected_token_usage"
	HttpsdocsNumspotClouddocsdomainsclouderrorsUriTooLong                          ErrorDocumentationUrl = "https://docs.numspot.cloud/docs/domains/cloud/errors#uri_too_long"
)

// Defines values for UpdateDirectLinkInterfaceMtu.
const (
	N1500 UpdateDirectLinkInterfaceMtu = 1500
)

// Defines values for UpdateVmPerformance.
const (
	UpdateVmPerformanceHigh    UpdateVmPerformance = "high"
	UpdateVmPerformanceHighest UpdateVmPerformance = "highest"
	UpdateVmPerformanceMedium  UpdateVmPerformance = "medium"
)

// AcceptVpcPeering defines model for AcceptVpcPeering.
type AcceptVpcPeering struct {
	// VpcPeering Information about the Net peering.
	VpcPeering *VpcPeering `json:"vpcPeering,omitempty"`
}

// AccepterVpc Information about the accepter Net.
type AccepterVpc struct {
	// IpRange The IP range for the accepter Net, in CIDR notation (for example, `10.0.0.0/16`).
	IpRange *string `json:"ipRange,omitempty"`

	// VpcId The ID of the accepter Net.
	VpcId *string `json:"vpcId,omitempty"`
}

// Access Permissions for the resource.
type Access struct {
	// IsPublic A global permission for all accounts.<br />
	// (Request) Set this parameter to true to make the resource public (if the parent parameter is `Additions`) or to make the resource private (if the parent parameter is `Removals`).<br />
	// (Response) If true, the resource is public. If false, the resource is private.
	IsPublic *bool `json:"isPublic,omitempty"`
}

// AccessCreation Information about the permissions for the resource.<br />
// Specify either the `Additions` or the `Removals` parameter.
type AccessCreation struct {
	// Additions Permissions for the resource.
	Additions *Access `json:"additions,omitempty"`

	// Removals Permissions for the resource.
	Removals *Access `json:"removals,omitempty"`
}

// ApplicationStickyCookiePolicy Information about the stickiness policy.
type ApplicationStickyCookiePolicy struct {
	// CookieName The name of the application cookie used for stickiness.
	CookieName *string `json:"cookieName,omitempty"`

	// PolicyName The mnemonic name for the policy being created. The name must be unique within a set of policies for this load balancer.
	PolicyName *string `json:"policyName,omitempty"`
}

// BackendVmHealth Information about the health of a back-end VM.
type BackendVmHealth struct {
	// Description The description of the state of the back-end VM.
	Description *string `json:"description,omitempty"`

	// State The state of the back-end VM (`InService` \| `OutOfService` \| `Unknown`).
	State *string `json:"state,omitempty"`

	// StateReason Information about the cause of `OutOfService` VMs.<br />
	//  Specifically, whether the cause is Elastic Load Balancing or the VM (`ELB` \| `Instance` \| `N/A`).
	StateReason *string `json:"stateReason,omitempty"`

	// VmId The ID of the back-end VM.
	VmId *string `json:"vmId,omitempty"`
}

// BlockDeviceMappingCreated Information about the created block device mapping.
type BlockDeviceMappingCreated struct {
	// Bsu Information about the created BSU volume.
	Bsu *BsuCreated `json:"bsu,omitempty"`

	// DeviceName The name of the device.
	DeviceName *string `json:"deviceName,omitempty"`
}

// BlockDeviceMappingImage One or more parameters used to automatically set up volumes when the VM is created.
type BlockDeviceMappingImage struct {
	// Bsu Information about the BSU volume to create.
	Bsu *BsuToCreate `json:"bsu,omitempty"`

	// DeviceName The device name for the volume. For a root device, you must use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, and the second `X` is a letter between `a` and `z`).
	DeviceName *string `json:"deviceName,omitempty"`

	// VirtualDeviceName The name of the virtual device (`ephemeralN`).
	VirtualDeviceName *string `json:"virtualDeviceName,omitempty"`
}

// BlockDeviceMappingVmCreation Information about the block device mapping.
type BlockDeviceMappingVmCreation struct {
	// Bsu Information about the BSU volume to create.
	Bsu *BsuToCreate `json:"bsu,omitempty"`

	// DeviceName The device name for the volume. For a root device, you must use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, and the second `X` is a letter between `a` and `z`).
	DeviceName *string `json:"deviceName,omitempty"`

	// NoDevice Removes the device which is included in the block device mapping of the OMI.
	NoDevice *string `json:"noDevice,omitempty"`

	// VirtualDeviceName The name of the virtual device (`ephemeralN`).
	VirtualDeviceName *string `json:"virtualDeviceName,omitempty"`
}

// BlockDeviceMappingVmUpdate Information about the block device mapping.
type BlockDeviceMappingVmUpdate struct {
	// Bsu Information about the BSU volume.
	Bsu *BsuToUpdateVm `json:"bsu,omitempty"`

	// DeviceName The device name for the volume. For a root device, you must use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, and the second `X` is a letter between `a` and `z`).
	DeviceName *string `json:"deviceName,omitempty"`

	// NoDevice Removes the device which is included in the block device mapping of the OMI.
	NoDevice *string `json:"noDevice,omitempty"`

	// VirtualDeviceName The name of the virtual device (`ephemeralN`).
	VirtualDeviceName *string `json:"virtualDeviceName,omitempty"`
}

// BsuCreated Information about the created BSU volume.
type BsuCreated struct {
	// DeleteOnVmDeletion If true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.
	DeleteOnVmDeletion *bool `json:"deleteOnVmDeletion,omitempty"`

	// LinkDate The date and time of attachment of the volume to the VM, in ISO 8601 date-time format.
	LinkDate *time.Time `json:"linkDate,omitempty"`

	// State The state of the volume.
	State *string `json:"state,omitempty"`

	// VolumeId The ID of the volume.
	VolumeId *string `json:"volumeId,omitempty"`
}

// BsuToCreate Information about the BSU volume to create.
type BsuToCreate struct {
	// DeleteOnVmDeletion By default or if set to true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.
	DeleteOnVmDeletion *bool `json:"deleteOnVmDeletion,omitempty"`

	// Iops The number of I/O operations per second (IOPS). This parameter must be specified only if you create an `io1` volume. The maximum number of IOPS allowed for `io1` volumes is `13000` with a maximum performance ratio of 300 IOPS per gibibyte.
	Iops *int `json:"iops,omitempty"`

	// SnapshotId The ID of the snapshot used to create the volume.
	SnapshotId *string `json:"snapshotId,omitempty"`

	// VolumeSize The size of the volume, in gibibytes (GiB).<br />
	// If you specify a snapshot ID, the volume size must be at least equal to the snapshot size.<br />
	// If you specify a snapshot ID but no volume size, the volume is created with a size similar to the snapshot one.
	VolumeSize *int `json:"volumeSize,omitempty"`

	// VolumeType The type of the volume (`standard` \| `io1` \| `gp2`). If not specified in the request, a `standard` volume is created.<br />
	VolumeType *string `json:"volumeType,omitempty"`
}

// BsuToUpdateVm Information about the BSU volume.
type BsuToUpdateVm struct {
	// DeleteOnVmDeletion If set to true, the volume is deleted when terminating the VM. If set to false, the volume is not deleted when terminating the VM.
	DeleteOnVmDeletion *bool `json:"deleteOnVmDeletion,omitempty"`

	// VolumeId The ID of the volume.
	VolumeId *string `json:"volumeId,omitempty"`
}

// ClientGateway Information about the client gateway.
type ClientGateway struct {
	// BgpAsn The Autonomous System Number (ASN) used by the Border Gateway Protocol (BGP) to find the path to your client gateway through the Internet.
	BgpAsn *int `json:"bgpAsn,omitempty"`

	// ConnectionType The type of communication tunnel used by the client gateway (only `ipsec.1` is supported).
	ConnectionType *string `json:"connectionType,omitempty"`

	// Id The ID of the client gateway.
	Id *string `json:"id,omitempty"`

	// PublicIp The public IPv4 address of the client gateway (must be a fixed address into a NATed network).
	PublicIp *string `json:"publicIp,omitempty"`

	// State The state of the client gateway (`pending` \| `available` \| `deleting` \| `deleted`).
	State *string `json:"state,omitempty"`

	// Tags One or more tags associated with the client gateway.
	Tags *[]ResourceTag `json:"tags,omitempty"`
}

// CreateClientGateway defines model for CreateClientGateway.
type CreateClientGateway struct {
	// BgpAsn The Autonomous System Number (ASN) used by the Border Gateway Protocol (BGP) to find the path to your client gateway through the Internet. <br/>
	// This number must be between `1` and `4294967295`. If you do not have an ASN, you can choose one between 64512 and 65534, or between 4200000000 and 4294967294.
	BgpAsn int `json:"bgpAsn"`

	// ConnectionType The communication protocol used to establish tunnel with your client gateway (only `ipsec.1` is supported).
	ConnectionType string `json:"connectionType"`

	// PublicIp The public fixed IPv4 address of your client gateway.
	PublicIp string `json:"publicIp"`
}

// CreateDhcpOptions defines model for CreateDhcpOptions.
type CreateDhcpOptions struct {
	// DomainName Specify a domain name (for example, `MyCompany.com`). You can specify only one domain name. You must specify at least one of the following parameters: `DomainName`, `DomainNameServers`, `LogServers`, or `NtpServers`.
	DomainName *string `json:"domainName,omitempty"`

	// DomainNameServers The IPs of domain name servers. You must specify at least one of the following parameters: `DomainName`, `DomainNameServers`, `LogServers`, or `NtpServers`.
	DomainNameServers *[]string `json:"domainNameServers,omitempty"`

	// LogServers The IPs of the log servers. You must specify at least one of the following parameters: `DomainName`, `DomainNameServers`, `LogServers`, or `NtpServers`.
	LogServers *[]string `json:"logServers,omitempty"`

	// NtpServers The IPs of the Network Time Protocol (NTP) servers. You must specify at least one of the following parameters: `DomainName`, `DomainNameServers`, `LogServers`, or `NtpServers`.
	NtpServers *[]string `json:"ntpServers,omitempty"`
}

// CreateDirectLink defines model for CreateDirectLink.
type CreateDirectLink struct {
	// Bandwidth The bandwidth of the DirectLink (`1Gbps` \| `10Gbps`).
	Bandwidth string `json:"bandwidth"`

	// Location The code of the requested location for the DirectLink, returned by the [ReadLocations](#readlocations) method.
	Location string `json:"location"`

	// Name The name of the DirectLink.
	Name string `json:"name"`
}

// CreateDirectLinkInterface defines model for CreateDirectLinkInterface.
type CreateDirectLinkInterface struct {
	// DirectLinkId The ID of the existing DirectLink for which you want to create the DirectLink interface.
	DirectLinkId string `json:"directLinkId"`

	// DirectLinkInterface Information about the DirectLink interface.
	DirectLinkInterface DirectLinkInterface `json:"directLinkInterface"`
}

// CreateFlexibleGpu defines model for CreateFlexibleGpu.
type CreateFlexibleGpu struct {
	// AvailabilityZoneName The Subregion in which you want to create the fGPU.
	AvailabilityZoneName string `json:"availabilityZoneName"`

	// DeleteOnVmDeletion If true, the fGPU is deleted when the VM is terminated.
	DeleteOnVmDeletion *bool `json:"deleteOnVmDeletion,omitempty"`

	// Generation The processor generation that the fGPU must be compatible with. If not specified, the oldest possible processor generation is selected (as provided by [ReadFlexibleGpuCatalog](#readflexiblegpucatalog) for the specified model of fGPU).
	Generation *string `json:"generation,omitempty"`

	// ModelName The model of fGPU you want to allocate.
	ModelName string `json:"modelName"`
}

// CreateImage defines model for CreateImage.
type CreateImage struct {
	// Architecture **(when registering from a snapshot, or from a bucket without using a manifest file)** The architecture of the OMI (`i386` or `x84_64`).
	Architecture *string `json:"architecture,omitempty"`

	// BlockDeviceMappings **(when registering from a snapshot, or from a bucket without using a manifest file)** One or more block device mappings.
	BlockDeviceMappings *[]BlockDeviceMappingImage `json:"blockDeviceMappings,omitempty"`

	// Description A description for the new OMI.
	Description *string `json:"description,omitempty"`

	// Name A unique name for the new OMI.<br />
	// Constraints: 3-128 alphanumeric characters, underscores (`_`), spaces (` `), parentheses (`()`), slashes (`/`), periods (`.`), or dashes (`-`).
	Name *string `json:"name,omitempty"`

	// NoReboot **(when creating from a VM)** If false, the VM shuts down before creating the OMI and then reboots. If true, the VM does not.
	NoReboot *bool `json:"noReboot,omitempty"`

	// ProductCodes The product codes associated with the OMI.
	ProductCodes *[]string `json:"productCodes,omitempty"`

	// RootDeviceName **(when registering from a snapshot, or from a bucket without using a manifest file)** The name of the root device for the new OMI.
	RootDeviceName *string `json:"rootDeviceName,omitempty"`

	// SourceImageId **(when copying an OMI)** The ID of the OMI you want to copy.
	SourceImageId *string `json:"sourceImageId,omitempty"`

	// SourceRegionName **(when copying an OMI)** The name of the source Region (always the same as the Region of your account).
	SourceRegionName *string `json:"sourceRegionName,omitempty"`

	// VmId **(when creating from a VM)** The ID of the VM from which you want to create the OMI.
	VmId *string `json:"vmId,omitempty"`
}

// CreateKeypair Information about the created keypair.
type CreateKeypair struct {
	// Fingerprint The MD5 public key fingerprint, as specified in section 4 of RFC 4716.
	Fingerprint *string `json:"fingerprint,omitempty"`

	// Name The name of the keypair.
	Name *string `json:"name,omitempty"`

	// PrivateKey The private key, returned only if you are creating a keypair (not if you are importing). When you save this private key in a .rsa file, make sure you replace the `\n` escape sequences with real line breaks.
	PrivateKey *string `json:"privateKey,omitempty"`

	// Type The type of the keypair (`ssh-rsa`, `ssh-ed25519`, `ecdsa-sha2-nistp256`, `ecdsa-sha2-nistp384`, or `ecdsa-sha2-nistp521`).
	Type *string `json:"type,omitempty"`
}

// CreateListenerRule defines model for CreateListenerRule.
type CreateListenerRule struct {
	// Listener Information about the load balancer.
	Listener LoadBalancerLight `json:"listener"`

	// ListenerRule Information about the listener rule.
	ListenerRule ListenerRuleForCreation `json:"listenerRule"`

	// VmIds The IDs of the backend VMs.
	VmIds []string `json:"vmIds"`
}

// CreateLoadBalancer defines model for CreateLoadBalancer.
type CreateLoadBalancer struct {
	// AvailabilityZoneNames (public Cloud only) The Subregion in which you want to create the load balancer. Regardless of this Subregion, the load balancer can distribute traffic to all Subregions. This parameter is required in the public Cloud.
	AvailabilityZoneNames *[]string `json:"availabilityZoneNames,omitempty"`

	// Listeners One or more listeners to create.
	Listeners []ListenerForCreation `json:"listeners"`

	// Name The unique name of the load balancer (32 alphanumeric or hyphen characters maximum, but cannot start or end with a hyphen).
	Name string `json:"name"`

	// PublicIp (internet-facing only) The public IP you want to associate with the load balancer. If not specified, a public IP owned by NumSpot is associated.
	PublicIp *string `json:"publicIp,omitempty"`

	// SecurityGroups (Net only) One or more IDs of security groups you want to assign to the load balancer. If not specified, the default security group of the Net is assigned to the load balancer.
	SecurityGroups *[]string `json:"securityGroups,omitempty"`

	// Subnets (Net only) The ID of the Subnet in which you want to create the load balancer. Regardless of this Subnet, the load balancer can distribute traffic to all Subnets. This parameter is required in a Net.
	Subnets *[]string `json:"subnets,omitempty"`

	// Tags One or more tags assigned to the load balancer.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// Type The type of load balancer: `internet-facing` or `internal`. Use this parameter only for load balancers in a Net.
	Type *string `json:"type,omitempty"`
}

// CreateLoadBalancerListeners defines model for CreateLoadBalancerListeners.
type CreateLoadBalancerListeners struct {
	// Listeners One or more listeners for the load balancer.
	Listeners []ListenerForCreation `json:"listeners"`
}

// CreateLoadBalancerPolicy defines model for CreateLoadBalancerPolicy.
type CreateLoadBalancerPolicy struct {
	// CookieExpirationPeriod The lifetime of the cookie, in seconds. If not specified, the default value of this parameter is `1`, which means that the sticky session lasts for the duration of the browser session.
	CookieExpirationPeriod *int `json:"cookieExpirationPeriod,omitempty"`

	// CookieName The name of the application cookie used for stickiness. This parameter is required if you create a stickiness policy based on an application-generated cookie.
	CookieName *string `json:"cookieName,omitempty"`

	// PolicyName The name of the policy. This name must be unique and consist of alphanumeric characters and dashes (-).
	PolicyName string `json:"policyName"`

	// PolicyType The type of stickiness policy you want to create: `app` or `load_balancer`.
	PolicyType string `json:"policyType"`
}

// CreateLoadBalancerTags defines model for CreateLoadBalancerTags.
type CreateLoadBalancerTags struct {
	// Names One or more load balancer names.
	Names []string `json:"names"`

	// Tags One or more tags to add to the specified load balancers.
	Tags []ResourceTag `json:"tags"`
}

// CreateNatGateway defines model for CreateNatGateway.
type CreateNatGateway struct {
	// PublicIpId The allocation ID of the public IP to associate with the NAT service.<br />
	// If the public IP is already associated with another resource, you must first disassociate it.
	PublicIpId string `json:"publicIpId"`

	// SubnetId The ID of the Subnet in which you want to create the NAT service.
	SubnetId string `json:"subnetId"`
}

// CreateNic defines model for CreateNic.
type CreateNic struct {
	// Description A description for the NIC.
	Description *string `json:"description,omitempty"`

	// PrivateIps The primary private IP for the NIC.<br />
	// This IP must be within the IP range of the Subnet that you specify with the `SubnetId` attribute.<br />
	// If you do not specify this attribute, a random private IP is selected within the IP range of the Subnet.
	PrivateIps *[]PrivateIpLight `json:"privateIps,omitempty"`

	// SecurityGroupIds One or more IDs of security groups for the NIC.
	SecurityGroupIds *[]string `json:"securityGroupIds,omitempty"`

	// SubnetId The ID of the Subnet in which you want to create the NIC.
	SubnetId string `json:"subnetId"`
}

// CreateRoute defines model for CreateRoute.
type CreateRoute struct {
	// DestinationIpRange The IP range used for the destination match, in CIDR notation (for example, `10.0.0.0/24`).
	DestinationIpRange string `json:"destinationIpRange"`

	// GatewayId The ID of an Internet service or virtual gateway attached to your Net.
	GatewayId *string `json:"gatewayId,omitempty"`

	// NatGatewayId The ID of a NAT service.
	NatGatewayId *string `json:"natGatewayId,omitempty"`

	// NicId The ID of a NIC.
	NicId *string `json:"nicId,omitempty"`

	// VmId The ID of a NAT VM in your Net (attached to exactly one NIC).
	VmId *string `json:"vmId,omitempty"`

	// VpcPeeringId The ID of a Net peering.
	VpcPeeringId *string `json:"vpcPeeringId,omitempty"`
}

// CreateRouteTable defines model for CreateRouteTable.
type CreateRouteTable struct {
	// VpcId The ID of the Net for which you want to create a route table.
	VpcId string `json:"vpcId"`
}

// CreateSecurityGroup defines model for CreateSecurityGroup.
type CreateSecurityGroup struct {
	// Description A description for the security group.<br />
	// This description can contain between 1 and 255 characters. Allowed characters are `a-z`, `A-Z`, `0-9`, accented letters, spaces, and `_.-:/()#,@[]+=&;{}!$*`.
	Description string `json:"description"`

	// Name The name of the security group.<br />
	// This name must not start with `sg-`.<br />
	// This name must be unique and contain between 1 and 255 characters. Allowed characters are `a-z`, `A-Z`, `0-9`, spaces, and `_.-:/()#,@[]+=&;{}!$*`.
	Name string `json:"name"`

	// VpcId The ID of the Net for the security group.
	VpcId *string `json:"vpcId,omitempty"`
}

// CreateSecurityGroupRule defines model for CreateSecurityGroupRule.
type CreateSecurityGroupRule struct {
	// Flow The direction of the flow: `Inbound` or `Outbound`. You can specify `Outbound` for Nets only.
	Flow string `json:"flow"`

	// FromPortRange The beginning of the port range for the TCP and UDP protocols, or an ICMP type number. If you specify this parameter, you cannot specify the `Rules` parameter and its subparameters.
	FromPortRange *int `json:"fromPortRange,omitempty"`

	// IpProtocol The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all protocols). By default, `-1`. In a Net, this can also be an IP protocol number. For more information, see the [IANA.org website](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml). If you specify this parameter, you cannot specify the `Rules` parameter and its subparameters.
	IpProtocol *string `json:"ipProtocol,omitempty"`

	// IpRange The IP range for the security group rule, in CIDR notation (for example, 10.0.0.0/16). If you specify this parameter, you cannot specify the `Rules` parameter and its subparameters.
	IpRange *string `json:"ipRange,omitempty"`

	// Rules Information about the security group rule to create. If you specify this parent parameter and its subparameters, you cannot specify the following parent parameters: `FromPortRange`, `IpProtocol`, `IpRange`, and `ToPortRange`.
	Rules *[]SecurityGroupRule `json:"rules,omitempty"`

	// SecurityGroupAccountIdToLink The account ID that owns the source or destination security group specified in the `SecurityGroupNameToLink` parameter.
	SecurityGroupAccountIdToLink *string `json:"securityGroupAccountIdToLink,omitempty"`

	// SecurityGroupNameToLink The ID of a source or destination security group that you want to link to the security group of the rule.
	SecurityGroupNameToLink *string `json:"securityGroupNameToLink,omitempty"`

	// ToPortRange The end of the port range for the TCP and UDP protocols, or an ICMP code number. If you specify this parameter, you cannot specify the `Rules` parameter and its subparameters.
	ToPortRange *int `json:"toPortRange,omitempty"`
}

// CreateSnapshot defines model for CreateSnapshot.
type CreateSnapshot struct {
	// Description A description for the snapshot.
	Description *string `json:"description,omitempty"`

	// SourceRegionName **(when copying a snapshot)** The name of the source Region, which must be the same as the Region of your account.
	SourceRegionName *string `json:"sourceRegionName,omitempty"`

	// SourceSnapshotId **(when copying a snapshot)** The ID of the snapshot you want to copy.
	SourceSnapshotId *string `json:"sourceSnapshotId,omitempty"`

	// VolumeId **(when creating from a volume)** The ID of the volume you want to create a snapshot of.
	VolumeId *string `json:"volumeId,omitempty"`
}

// CreateSubnet defines model for CreateSubnet.
type CreateSubnet struct {
	// AvailabilityZoneName The name of the Subregion in which you want to create the Subnet.
	AvailabilityZoneName *string `json:"availabilityZoneName,omitempty"`

	// IpRange The IP range in the Subnet, in CIDR notation (for example, `10.0.0.0/16`).<br />
	// The IP range of the Subnet can be either the same as the Net one if you create only a single Subnet in this Net, or a subset of the Net one. In case of several Subnets in a Net, their IP ranges must not overlap. The smallest Subnet you can create uses a /29 netmask (eight IPs).
	IpRange string `json:"ipRange"`

	// VpcId The ID of the Net for which you want to create a Subnet.
	VpcId string `json:"vpcId"`
}

// CreateTags defines model for CreateTags.
type CreateTags struct {
	// ResourceIds One or more resource IDs.
	ResourceIds []string `json:"resourceIds"`

	// Tags One or more tags to add to the specified resources.
	Tags []ResourceTag `json:"tags"`
}

// CreateVirtualGateway defines model for CreateVirtualGateway.
type CreateVirtualGateway struct {
	// ConnectionType The type of VPN connection supported by the virtual gateway (only `ipsec.1` is supported).
	ConnectionType string `json:"connectionType"`
}

// CreateVms defines model for CreateVms.
type CreateVms struct {
	// BlockDeviceMappings One or more block device mappings.
	BlockDeviceMappings *[]BlockDeviceMappingVmCreation `json:"blockDeviceMappings,omitempty"`

	// BootOnCreation By default or if true, the VM is started on creation. If false, the VM is stopped on creation.
	BootOnCreation *bool `json:"bootOnCreation,omitempty"`

	// BsuOptimized This parameter is not available. It is present in our API for the sake of historical compatibility with AWS.
	BsuOptimized *bool `json:"bsuOptimized,omitempty"`

	// ClientToken A unique identifier which enables you to manage the idempotency.
	ClientToken *string `json:"clientToken,omitempty"`

	// DeletionProtection If true, you cannot delete the VM unless you change this parameter back to false.
	DeletionProtection *bool `json:"deletionProtection,omitempty"`

	// ImageId The ID of the OMI used to create the VM. You can find the list of OMIs by calling the [ReadImages](#readimages) method.
	ImageId string `json:"imageId"`

	// KeypairName The name of the keypair.
	KeypairName *string `json:"keypairName,omitempty"`

	// MaxVmsCount The maximum number of VMs you want to create. If all the VMs cannot be created, the largest possible number of VMs above MinVmsCount is created.
	MaxVmsCount *int `json:"maxVmsCount,omitempty"`

	// MinVmsCount The minimum number of VMs you want to create. If this number of VMs cannot be created, no VMs are created.
	MinVmsCount *int `json:"minVmsCount,omitempty"`

	// NestedVirtualization (dedicated tenancy only) If true, nested virtualization is enabled. If false, it is disabled.
	NestedVirtualization *bool `json:"nestedVirtualization,omitempty"`

	// Nics One or more NICs. If you specify this parameter, you must not specify the `SubnetId` and `SubregionName` parameters. You also must define one NIC as the primary network interface of the VM with `0` as its device number.
	Nics *[]NicForVmCreation `json:"nics,omitempty"`

	// Performance The performance of the VM (`medium` \| `high` \|  `highest`). By default, `high`. This parameter is ignored if you specify a performance flag directly in the `type` parameter.
	Performance *CreateVmsPerformance `json:"performance,omitempty"`

	// Placement Information about the placement of the VM.
	Placement *Placement `json:"placement,omitempty"`

	// PrivateIps One or more private IPs of the VM.
	PrivateIps *[]string `json:"privateIps,omitempty"`

	// SecurityGroupIds One or more IDs of security group for the VMs.
	SecurityGroupIds *[]string `json:"securityGroupIds,omitempty"`

	// SecurityGroups One or more names of security groups for the VMs.
	SecurityGroups *[]string `json:"securityGroups,omitempty"`

	// SubnetId The ID of the Subnet in which you want to create the VM. If you specify this parameter, you must not specify the `Nics` parameter.
	SubnetId *string `json:"subnetId,omitempty"`

	// Type The type of VM.
	Type *string `json:"type,omitempty"`

	// UserData Data or script used to add a specific configuration to the VM. It must be Base64-encoded and is limited to 500 kibibytes (KiB).
	UserData *string `json:"userData,omitempty"`

	// VmInitiatedShutdownBehavior The VM behavior when you stop it. By default or if set to `stop`, the VM stops. If set to `restart`, the VM stops then automatically restarts. If set to `terminate`, the VM stops and is terminated.
	VmInitiatedShutdownBehavior *string `json:"vmInitiatedShutdownBehavior,omitempty"`
}

// CreateVmsPerformance The performance of the VM (`medium` \| `high` \|  `highest`). By default, `high`. This parameter is ignored if you specify a performance flag directly in the `type` parameter.
type CreateVmsPerformance string

// CreateVolume defines model for CreateVolume.
type CreateVolume struct {
	// AvailabilityZoneName The Subregion in which you want to create the volume.
	AvailabilityZoneName string `json:"availabilityZoneName"`

	// Iops The number of I/O operations per second (IOPS). This parameter must be specified only if you create an `io1` volume. The maximum number of IOPS allowed for `io1` volumes is `13000` with a maximum performance ratio of 300 IOPS per gibibyte.
	Iops *int `json:"iops,omitempty"`

	// Size The size of the volume, in gibibytes (GiB). The maximum allowed size for a volume is 14901 GiB. This parameter is required if the volume is not created from a snapshot (`SnapshotId` unspecified).
	Size *int `json:"size,omitempty"`

	// SnapshotId The ID of the snapshot from which you want to create the volume.
	SnapshotId *string `json:"snapshotId,omitempty"`

	// Type The type of volume you want to create (`io1` \| `gp2` \ | `standard`). If not specified, a `standard` volume is created.<br />
	Type *string `json:"type,omitempty"`
}

// CreateVpc defines model for CreateVpc.
type CreateVpc struct {
	// IpRange The IP range for the Net, in CIDR notation (for example, `10.0.0.0/16`).
	IpRange string `json:"ipRange"`

	// Tenancy The tenancy options for the VMs:<br />
	// - `default` if a VM created in a Net can be launched with any tenancy.<br />
	// - `dedicated` if it can be launched with dedicated tenancy VMs running on single-tenant hardware.<br />
	// - `dedicated group ID`: if it can be launched in a dedicated group on single-tenant hardware.
	Tenancy *string `json:"tenancy,omitempty"`
}

// CreateVpcAccessPoint defines model for CreateVpcAccessPoint.
type CreateVpcAccessPoint struct {
	// RouteTableIds One or more IDs of route tables to use for the connection.
	RouteTableIds *[]string `json:"routeTableIds,omitempty"`

	// ServiceName The name of the service.
	ServiceName string `json:"serviceName"`

	// VpcId The ID of the Net.
	VpcId string `json:"vpcId"`
}

// CreateVpcPeering defines model for CreateVpcPeering.
type CreateVpcPeering struct {
	// AccepterVpcId The ID of the Net you want to connect with.
	AccepterVpcId string `json:"accepterVpcId"`

	// SourceVpcId The ID of the Net you send the peering request from.
	SourceVpcId string `json:"sourceVpcId"`
}

// CreateVpnConnection defines model for CreateVpnConnection.
type CreateVpnConnection struct {
	// ClientGatewayId The ID of the client gateway.
	ClientGatewayId string `json:"clientGatewayId"`

	// ConnectionType The type of VPN connection (only `ipsec.1` is supported).
	ConnectionType string `json:"connectionType"`

	// StaticRoutesOnly By default or if false, the VPN connection uses dynamic routing with Border Gateway Protocol (BGP). If true, routing is controlled using static routes. For more information about how to create and delete static routes, see [CreateVpnConnectionRoute](#createvpnconnectionroute) and [DeleteVpnConnectionRoute](#deletevpnconnectionroute).
	StaticRoutesOnly *bool `json:"staticRoutesOnly,omitempty"`

	// VirtualGatewayId The ID of the virtual gateway.
	VirtualGatewayId string `json:"virtualGatewayId"`
}

// CreateVpnConnectionRoute defines model for CreateVpnConnectionRoute.
type CreateVpnConnectionRoute struct {
	// DestinationIpRange The network prefix of the route, in CIDR notation (for example, `10.12.0.0/16`).
	DestinationIpRange string `json:"destinationIpRange"`
}

// DeleteLoadBalancerListeners defines model for DeleteLoadBalancerListeners.
type DeleteLoadBalancerListeners struct {
	// LoadBalancerPorts One or more port numbers of the listeners you want to delete.
	LoadBalancerPorts []int `json:"loadBalancerPorts"`
}

// DeleteLoadBalancerPolicy defines model for DeleteLoadBalancerPolicy.
type DeleteLoadBalancerPolicy struct {
	// PolicyName The name of the policy you want to delete.
	PolicyName string `json:"policyName"`
}

// DeleteLoadBalancerTags defines model for DeleteLoadBalancerTags.
type DeleteLoadBalancerTags struct {
	// Names One or more load balancer names.
	Names []string `json:"names"`

	// Tags One or more tags to delete from the load balancers.
	Tags []ResourceLoadBalancerTag `json:"tags"`
}

// DeleteRoute defines model for DeleteRoute.
type DeleteRoute struct {
	// DestinationIpRange The exact IP range for the route.
	DestinationIpRange string `json:"destinationIpRange"`
}

// DeleteSecurityGroupRule defines model for DeleteSecurityGroupRule.
type DeleteSecurityGroupRule struct {
	// Flow The direction of the flow: `Inbound` or `Outbound`. You can specify `Outbound` for Nets only.
	Flow string `json:"flow"`

	// FromPortRange The beginning of the port range for the TCP and UDP protocols, or an ICMP type number.
	FromPortRange *int `json:"fromPortRange,omitempty"`

	// IpProtocol The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all protocols). By default, `-1`. In a Net, this can also be an IP protocol number. For more information, see the [IANA.org website](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
	IpProtocol *string `json:"ipProtocol,omitempty"`

	// IpRange The IP range for the security group rule, in CIDR notation (for example, `10.0.0.0/16`).
	IpRange *string `json:"ipRange,omitempty"`

	// Rules One or more rules you want to delete from the security group.
	Rules *[]SecurityGroupRule `json:"rules,omitempty"`

	// SecurityGroupAccountIdToUnlink The account ID of the owner of the security group you want to delete a rule from.
	SecurityGroupAccountIdToUnlink *string `json:"securityGroupAccountIdToUnlink,omitempty"`

	// SecurityGroupNameToUnlink The ID of the source security group. If you are in the Public Cloud, you can also specify the name of the source security group.
	SecurityGroupNameToUnlink *string `json:"securityGroupNameToUnlink,omitempty"`

	// ToPortRange The end of the port range for the TCP and UDP protocols, or an ICMP code number.
	ToPortRange *int `json:"toPortRange,omitempty"`
}

// DeleteTags defines model for DeleteTags.
type DeleteTags struct {
	// ResourceIds One or more resource IDs.
	ResourceIds []string `json:"resourceIds"`

	// Tags One or more tags to delete (if you set a tag value, only the tags matching exactly this value are deleted).
	Tags []ResourceTag `json:"tags"`
}

// DeleteVpnConnectionRoute defines model for DeleteVpnConnectionRoute.
type DeleteVpnConnectionRoute struct {
	// DestinationIpRange The network prefix of the route to delete, in CIDR notation (for example, `10.12.0.0/16`).
	DestinationIpRange string `json:"destinationIpRange"`
}

// DhcpOptionsSet Information about the DHCP options set.
type DhcpOptionsSet struct {
	// Default If true, the DHCP options set is a default one. If false, it is not.
	Default *bool `json:"default,omitempty"`

	// DomainName The domain name.
	DomainName *string `json:"domainName,omitempty"`

	// DomainNameServers One or more IPs for the domain name servers.
	DomainNameServers *[]string `json:"domainNameServers,omitempty"`

	// Id The ID of the DHCP options set.
	Id *string `json:"id,omitempty"`

	// LogServers One or more IPs for the log servers.
	LogServers *[]string `json:"logServers,omitempty"`

	// NtpServers One or more IPs for the NTP servers.
	NtpServers *[]string `json:"ntpServers,omitempty"`

	// Tags One or more tags associated with the DHCP options set.
	Tags *[]ResourceTag `json:"tags,omitempty"`
}

// DirectLink Information about the DirectLink.
type DirectLink struct {
	// Bandwidth The physical link bandwidth (either 1 Gbps or 10 Gbps).
	Bandwidth *string `json:"bandwidth,omitempty"`

	// Id The ID of the DirectLink (for example, `dxcon-xxxxxxxx`).
	Id *string `json:"id,omitempty"`

	// Location The datacenter where the DirectLink is located.
	Location *string `json:"location,omitempty"`

	// Name The name of the DirectLink.
	Name *string `json:"name,omitempty"`

	// RegionName The Region in which the DirectLink has been created.
	RegionName *string `json:"regionName,omitempty"`

	// State The state of the DirectLink.<br />
	// * `requested`: The DirectLink is requested but the request has not been validated yet.<br />
	// * `pending`: The DirectLink request has been validated. It remains in the `pending` state until you establish the physical link.<br />
	// * `available`: The physical link is established and the connection is ready to use.<br />
	//  * `deleting`: The deletion process is in progress.<br />
	// * `deleted`: The DirectLink is deleted.
	State *string `json:"state,omitempty"`
}

// DirectLinkInterface Information about the DirectLink interface.
type DirectLinkInterface struct {
	// BgpAsn The BGP (Border Gateway Protocol) ASN (Autonomous System Number) on the customer's side of the DirectLink interface. This number must be between `64512` and `65534`.
	BgpAsn int `json:"bgpAsn"`

	// BgpKey The BGP authentication key.
	BgpKey *string `json:"bgpKey,omitempty"`

	// ClientPrivateIp The IP on the customer's side of the DirectLink interface.
	ClientPrivateIp *string `json:"clientPrivateIp,omitempty"`

	// Name The name of the DirectLink interface.
	Name string `json:"name"`

	// NumspotPrivateIp The IP on the NumSpot side of the DirectLink interface.
	NumspotPrivateIp *string `json:"numspotPrivateIp,omitempty"`

	// VirtualGatewayId The ID of the target virtual gateway.
	VirtualGatewayId string `json:"virtualGatewayId"`

	// Vlan The VLAN number associated with the DirectLink interface. This number must be unique and be between `2` and `4094`.
	Vlan int `json:"vlan"`
}

// DirectLinkInterfaces Information about the DirectLink interfaces.
type DirectLinkInterfaces struct {
	// BgpAsn The BGP (Border Gateway Protocol) ASN (Autonomous System Number) on the customer's side of the DirectLink interface.
	BgpAsn *int `json:"bgpAsn,omitempty"`

	// BgpKey The BGP authentication key.
	BgpKey *string `json:"bgpKey,omitempty"`

	// ClientPrivateIp The IP on the customer's side of the DirectLink interface.
	ClientPrivateIp *string `json:"clientPrivateIp,omitempty"`

	// DirectLinkId The ID of the DirectLink.
	DirectLinkId *string `json:"directLinkId,omitempty"`

	// DirectLinkInterfaceName The name of the DirectLink interface.
	DirectLinkInterfaceName *string `json:"directLinkInterfaceName,omitempty"`

	// Id The ID of the DirectLink interface.
	Id *string `json:"id,omitempty"`

	// InterfaceType The type of the DirectLink interface (always `private`).
	InterfaceType *string `json:"interfaceType,omitempty"`

	// Location The datacenter where the DirectLink interface is located.
	Location *string `json:"location,omitempty"`

	// Mtu The maximum transmission unit (MTU) of the DirectLink interface, in bytes (always `1500`).
	Mtu *int `json:"mtu,omitempty"`

	// NumspotPrivateIp The IP on the NumSpot side of the DirectLink interface.
	NumspotPrivateIp *string `json:"numspotPrivateIp,omitempty"`

	// State The state of the DirectLink interface (`pending` \| `available` \| `deleting` \| `deleted` \| `confirming` \| `rejected` \| `expired`).
	State *string `json:"state,omitempty"`

	// VirtualGatewayId The ID of the target virtual gateway.
	VirtualGatewayId *string `json:"virtualGatewayId,omitempty"`

	// Vlan The VLAN number associated with the DirectLink interface.
	Vlan *int `json:"vlan,omitempty"`
}

// Error For HTTP errors, we implement the https://datatracker.ietf.org/doc/html/rfc9457
type Error struct {
	// Detail Human-readable explanation specific to this occurrence of the problem.
	Detail   *string `json:"detail,omitempty"`
	Instance *Url    `json:"instance,omitempty"`

	// Title Human-readable summary of the problem type.
	Title string `json:"title"`

	// Type Documentation URL for the domain error
	Type ErrorDocumentationUrl `json:"type"`
}

// ErrorDocumentationUrl Documentation URL for the domain error
type ErrorDocumentationUrl string

// FlexibleGpu Information about the flexible GPU (fGPU).
type FlexibleGpu struct {
	// AvailabilityZoneName The Subregion where the fGPU is located.
	AvailabilityZoneName *string `json:"availabilityZoneName,omitempty"`

	// DeleteOnVmDeletion If true, the fGPU is deleted when the VM is terminated.
	DeleteOnVmDeletion *bool `json:"deleteOnVmDeletion,omitempty"`

	// Generation The compatible processor generation.
	Generation *string `json:"generation,omitempty"`

	// Id The ID of the fGPU.
	Id *string `json:"id,omitempty"`

	// ModelName The model of fGPU.
	ModelName *string `json:"modelName,omitempty"`

	// State The state of the fGPU (`allocated` \| `attaching` \| `attached` \| `detaching`).
	State *string `json:"state,omitempty"`

	// VmId The ID of the VM the fGPU is attached to, if any.
	VmId *string `json:"vmId,omitempty"`
}

// FlexibleGpuCatalog Information about the flexible GPU (fGPU) that is available in the public catalog.
type FlexibleGpuCatalog struct {
	// Generations The generations of VMs that the fGPU is compatible with.
	Generations *[]string `json:"generations,omitempty"`

	// MaxCpu The maximum number of VM vCores that the fGPU is compatible with.
	MaxCpu *int `json:"maxCpu,omitempty"`

	// MaxRam The maximum amount of VM memory that the fGPU is compatible with.
	MaxRam *int `json:"maxRam,omitempty"`

	// ModelName The model of fGPU.
	ModelName *string `json:"modelName,omitempty"`

	// VRam The amount of video RAM (VRAM) of the fGPU.
	VRam *int `json:"vRam,omitempty"`
}

// HealthCheck Information about the health check configuration.
type HealthCheck struct {
	// CheckInterval The number of seconds between two requests (between `5` and `600` both included).
	CheckInterval int `json:"checkInterval"`

	// HealthyThreshold The number of consecutive successful requests before considering the VM as healthy (between `2` and `10` both included).
	HealthyThreshold int `json:"healthyThreshold"`

	// Path If you use the HTTP or HTTPS protocols, the request URL path.
	Path *string `json:"path,omitempty"`

	// Port The port number (between `1` and `65535`, both included).
	Port int `json:"port"`

	// Protocol The protocol for the URL of the VM (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
	Protocol string `json:"protocol"`

	// Timeout The maximum waiting time for a response before considering the VM as unhealthy, in seconds (between `2` and `60` both included).
	Timeout int `json:"timeout"`

	// UnhealthyThreshold The number of consecutive failed requests before considering the VM as unhealthy (between `2` and `10` both included).
	UnhealthyThreshold int `json:"unhealthyThreshold"`
}

// Image Information about the OMI.
type Image struct {
	// Access Permissions for the resource.
	Access *Access `json:"access,omitempty"`

	// Architecture The architecture of the OMI.
	Architecture *string `json:"architecture,omitempty"`

	// BlockDeviceMappings One or more block device mappings.
	BlockDeviceMappings *[]BlockDeviceMappingImage `json:"blockDeviceMappings,omitempty"`

	// CreationDate The date and time of creation of the OMI, in ISO 8601 date-time format.
	CreationDate *time.Time `json:"creationDate,omitempty"`

	// Description The description of the OMI.
	Description *string `json:"description,omitempty"`

	// Id The ID of the OMI.
	Id *string `json:"id,omitempty"`

	// Name The name of the OMI.
	Name *string `json:"name,omitempty"`

	// ProductCodes The product codes associated with the OMI.
	ProductCodes *[]string `json:"productCodes,omitempty"`

	// RootDeviceName The name of the root device.
	RootDeviceName *string `json:"rootDeviceName,omitempty"`

	// RootDeviceType The type of root device used by the OMI (always `bsu`).
	RootDeviceType *string `json:"rootDeviceType,omitempty"`

	// State The state of the OMI (`pending` \| `available` \| `failed`).
	State *string `json:"state,omitempty"`

	// StateComment Information about the change of state.
	StateComment *StateComment `json:"stateComment,omitempty"`

	// Tags One or more tags associated with the OMI.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// Type The type of the OMI.
	Type *string `json:"type,omitempty"`
}

// InternetGateway Information about the Internet service.
type InternetGateway struct {
	// Id The ID of the Internet service.
	Id *string `json:"id,omitempty"`

	// State The state of the attachment of the Internet service to the Net (always `available`).
	State *string `json:"state,omitempty"`

	// Tags One or more tags associated with the Internet service.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// VpcId The ID of the Net attached to the Internet service.
	VpcId *string `json:"vpcId,omitempty"`
}

// Keypair Information about the keypair.
type Keypair struct {
	// Fingerprint The MD5 public key fingerprint as specified in section 4 of RFC 4716.
	Fingerprint *string `json:"fingerprint,omitempty"`

	// Name The name of the keypair.
	Name *string `json:"name,omitempty"`

	// Type The type of the keypair (`ssh-rsa`, `ssh-ed25519`, `ecdsa-sha2-nistp256`, `ecdsa-sha2-nistp384`, or `ecdsa-sha2-nistp521`).
	Type *string `json:"type,omitempty"`
}

// LinkFlexibleGpu defines model for LinkFlexibleGpu.
type LinkFlexibleGpu struct {
	// VmId The ID of the VM you want to attach the fGPU to.
	VmId string `json:"vmId"`
}

// LinkInternetGateway defines model for LinkInternetGateway.
type LinkInternetGateway struct {
	// VpcId The ID of the Net to which you want to attach the Internet service.
	VpcId string `json:"vpcId"`
}

// LinkLoadBalancerBackendMachines defines model for LinkLoadBalancerBackendMachines.
type LinkLoadBalancerBackendMachines struct {
	// BackendIps  One or more public IPs of back-end VMs.
	BackendIps *[]string `json:"backendIps,omitempty"`

	// BackendVmIds  One or more IDs of back-end VMs.
	BackendVmIds *[]string `json:"backendVmIds,omitempty"`
}

// LinkNic Information about the NIC attachment.
type LinkNic struct {
	// DeleteOnVmDeletion If true, the NIC is deleted when the VM is terminated.
	DeleteOnVmDeletion *bool `json:"deleteOnVmDeletion,omitempty"`

	// DeviceNumber The device index for the NIC attachment (between `1` and `7`, both included).
	DeviceNumber *int `json:"deviceNumber,omitempty"`

	// Id The ID of the NIC to attach.
	Id *string `json:"id,omitempty"`

	// State The state of the attachment (`attaching` \| `attached` \| `detaching` \| `detached`).
	State *string `json:"state,omitempty"`

	// VmId The ID of the VM.
	VmId *string `json:"vmId,omitempty"`
}

// LinkNicLight Information about the network interface card (NIC).
type LinkNicLight struct {
	// DeleteOnVmDeletion If true, the NIC is deleted when the VM is terminated.
	DeleteOnVmDeletion *bool `json:"deleteOnVmDeletion,omitempty"`

	// DeviceNumber The device index for the NIC attachment (between `1` and `7`, both included).
	DeviceNumber *int `json:"deviceNumber,omitempty"`

	// LinkNicId The ID of the NIC to attach.
	LinkNicId *string `json:"linkNicId,omitempty"`

	// State The state of the attachment (`attaching` \| `attached` \| `detaching` \| `detached`).
	State *string `json:"state,omitempty"`
}

// LinkNicToUpdate Information about the NIC attachment. If you are modifying the `DeleteOnVmDeletion` attribute, you must specify the ID of the NIC attachment.
type LinkNicToUpdate struct {
	// DeleteOnVmDeletion If true, the NIC is deleted when the VM is terminated. If false, the NIC is detached from the VM.
	DeleteOnVmDeletion *bool `json:"deleteOnVmDeletion,omitempty"`

	// LinkNicId The ID of the NIC attachment.
	LinkNicId *string `json:"linkNicId,omitempty"`
}

// LinkPrivateIps defines model for LinkPrivateIps.
type LinkPrivateIps struct {
	// AllowRelink If true, allows an IP that is already assigned to another NIC in the same Subnet to be assigned to the NIC you specified.
	AllowRelink *bool `json:"allowRelink,omitempty"`

	// PrivateIps The secondary private IP or IPs you want to assign to the NIC within the IP range of the Subnet.
	PrivateIps *[]string `json:"privateIps,omitempty"`

	// SecondaryPrivateIpCount The number of secondary private IPs to assign to the NIC.
	SecondaryPrivateIpCount *int `json:"secondaryPrivateIpCount,omitempty"`
}

// LinkPublicIp Information about the public IP association.
type LinkPublicIp struct {
	// Id (Required in a Net) The ID representing the association of the public IP with the VM or the NIC.
	Id *string `json:"id,omitempty"`

	// PublicDnsName The name of the public DNS.
	PublicDnsName *string `json:"publicDnsName,omitempty"`

	// PublicIp The public IP associated with the NIC.
	PublicIp *string `json:"publicIp,omitempty"`

	// PublicIpId The allocation ID of the public IP.
	PublicIpId *string `json:"publicIpId,omitempty"`
}

// LinkPublicIpLightForVm Information about the public IP associated with the NIC.
type LinkPublicIpLightForVm struct {
	// PublicDnsName The name of the public DNS.
	PublicDnsName *string `json:"publicDnsName,omitempty"`

	// PublicIp The public IP associated with the NIC.
	PublicIp *string `json:"publicIp,omitempty"`
}

// LinkRouteTable One or more associations between the route table and the Subnets.
type LinkRouteTable struct {
	// Id The ID of the association between the route table and the Subnet.
	Id *string `json:"id,omitempty"`

	// Main If true, the route table is the main one.
	Main *bool `json:"main,omitempty"`

	// RouteTableId The ID of the route table.
	RouteTableId *string `json:"routeTableId,omitempty"`

	// SubnetId The ID of the Subnet.
	SubnetId *string `json:"subnetId,omitempty"`

	// VpcId The ID of the Net.
	VpcId *string `json:"vpcId,omitempty"`
}

// LinkVirtualGatewayToVpc defines model for LinkVirtualGatewayToVpc.
type LinkVirtualGatewayToVpc struct {
	// VpcToVirtualGatewayLink Information about the attachment.
	VpcToVirtualGatewayLink *VpcToVirtualGatewayLink `json:"vpcToVirtualGatewayLink,omitempty"`
}

// LinkVolume defines model for LinkVolume.
type LinkVolume struct {
	// DeviceName The name of the device. For a root device, you must use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, and the second `X` is a letter between `a` and `z`).
	DeviceName string `json:"deviceName"`

	// VmId The ID of the VM you want to attach the volume to.
	VmId string `json:"vmId"`
}

// LinkedVolume Information about volume attachment.
type LinkedVolume struct {
	// DeleteOnVmDeletion If true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.
	DeleteOnVmDeletion *bool `json:"deleteOnVmDeletion,omitempty"`

	// DeviceName The name of the device.
	DeviceName *string `json:"deviceName,omitempty"`

	// Id The ID of the volume.
	Id *string `json:"id,omitempty"`

	// State The state of the attachment of the volume (`attaching` \| `detaching` \| `attached` \| `detached`).
	State *string `json:"state,omitempty"`

	// VmId The ID of the VM.
	VmId *string `json:"vmId,omitempty"`
}

// Listener Information about the listener.
type Listener struct {
	// BackendPort The port on which the back-end VM is listening (between `1` and `65535`, both included).
	BackendPort *int `json:"backendPort,omitempty"`

	// BackendProtocol The protocol for routing traffic to back-end VMs (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
	BackendProtocol *string `json:"backendProtocol,omitempty"`

	// LoadBalancerPort The port on which the load balancer is listening (between `1` and `65535`, both included).
	LoadBalancerPort *int `json:"loadBalancerPort,omitempty"`

	// LoadBalancerProtocol The routing protocol (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
	LoadBalancerProtocol *string `json:"loadBalancerProtocol,omitempty"`

	// PolicyNames The names of the policies. If there are no policies enabled, the list is empty.
	PolicyNames *[]string `json:"policyNames,omitempty"`

	// ServerCertificateId The NumSpot Resource Name of the server certificate.
	ServerCertificateId *string `json:"serverCertificateId,omitempty"`
}

// ListenerForCreation Information about the listener to create.
type ListenerForCreation struct {
	// BackendPort The port on which the back-end VM is listening (between `1` and `65535`, both included).
	BackendPort int `json:"backendPort"`

	// BackendProtocol The protocol for routing traffic to back-end VMs (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
	BackendProtocol *string `json:"backendProtocol,omitempty"`

	// LoadBalancerPort The port on which the load balancer is listening (between `1` and `65535`, both included).
	LoadBalancerPort int `json:"loadBalancerPort"`

	// LoadBalancerProtocol The routing protocol (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
	LoadBalancerProtocol string `json:"loadBalancerProtocol"`
}

// ListenerRule Information about the listener rule.
type ListenerRule struct {
	// Action The type of action for the rule (always `forward`).
	Action *string `json:"action,omitempty"`

	// HostNamePattern A host-name pattern for the rule, with a maximum length of 128 characters. This host-name pattern supports maximum three wildcards, and must not contain any special characters except [-.?].
	HostNamePattern *string `json:"hostNamePattern,omitempty"`

	// Id The ID of the listener rule.
	Id *int `json:"id,omitempty"`

	// ListenerId The ID of the listener.
	ListenerId *int `json:"listenerId,omitempty"`

	// Name A human-readable name for the listener rule.
	Name *string `json:"name,omitempty"`

	// PathPattern A path pattern for the rule, with a maximum length of 128 characters. This path pattern supports maximum three wildcards, and must not contain any special characters except [_-.$/~&quot;'@:+?].
	PathPattern *string `json:"pathPattern,omitempty"`

	// Priority The priority level of the listener rule, between `1` and `19999` both included. Each rule must have a unique priority level. Otherwise, an error is returned.
	Priority *int `json:"priority,omitempty"`

	// VmIds The IDs of the backend VMs.
	VmIds *[]string `json:"vmIds,omitempty"`
}

// ListenerRuleForCreation Information about the listener rule.
type ListenerRuleForCreation struct {
	// Action The type of action for the rule (always `forward`).
	Action *string `json:"action,omitempty"`

	// HostNamePattern A host-name pattern for the rule, with a maximum length of 128 characters. This host-name pattern supports maximum three wildcards, and must not contain any special characters except [-.?].
	HostNamePattern *string `json:"hostNamePattern,omitempty"`

	// ListenerRuleName A human-readable name for the listener rule.
	ListenerRuleName string `json:"listenerRuleName"`

	// PathPattern A path pattern for the rule, with a maximum length of 128 characters. This path pattern supports maximum three wildcards, and must not contain any special characters except [_-.$/~&quot;'@:+?].
	PathPattern *string `json:"pathPattern,omitempty"`

	// Priority The priority level of the listener rule, between `1` and `19999` both included. Each rule must have a unique priority level. Otherwise, an error is returned.
	Priority int `json:"priority"`
}

// LoadBalancer Information about the load balancer.
type LoadBalancer struct {
	// ApplicationStickyCookiePolicies The stickiness policies defined for the load balancer.
	ApplicationStickyCookiePolicies *[]ApplicationStickyCookiePolicy `json:"applicationStickyCookiePolicies,omitempty"`

	// AvailabilityZoneNames The ID of the Subregion in which the load balancer was created.
	AvailabilityZoneNames *[]string `json:"availabilityZoneNames,omitempty"`

	// BackendIps One or more public IPs of back-end VMs.
	BackendIps *[]string `json:"backendIps,omitempty"`

	// BackendVmIds One or more IDs of back-end VMs for the load balancer.
	BackendVmIds *[]string `json:"backendVmIds,omitempty"`

	// DnsName The DNS name of the load balancer.
	DnsName *string `json:"dnsName,omitempty"`

	// HealthCheck Information about the health check configuration.
	HealthCheck *HealthCheck `json:"healthCheck,omitempty"`

	// Listeners The listeners for the load balancer.
	Listeners *[]Listener `json:"listeners,omitempty"`

	// Name The name of the load balancer.
	Name *string `json:"name,omitempty"`

	// PublicIp (internet-facing only) The public IP associated with the load balancer.
	PublicIp *string `json:"publicIp,omitempty"`

	// SecuredCookies Whether secure cookies are enabled for the load balancer.
	SecuredCookies *bool `json:"securedCookies,omitempty"`

	// SecurityGroups One or more IDs of security groups for the load balancers. Valid only for load balancers in a Net.
	SecurityGroups *[]string `json:"securityGroups,omitempty"`

	// SourceSecurityGroup Information about the source security group of the load balancer, which you can use as part of your inbound rules for your registered VMs.<br />
	// To only allow traffic from load balancers, add a security group rule that specifies this source security group as the inbound source.
	SourceSecurityGroup *SourceSecurityGroup `json:"sourceSecurityGroup,omitempty"`

	// StickyCookiePolicies The policies defined for the load balancer.
	StickyCookiePolicies *[]LoadBalancerStickyCookiePolicy `json:"stickyCookiePolicies,omitempty"`

	// Subnets The ID of the Subnet in which the load balancer was created.
	Subnets *[]string `json:"subnets,omitempty"`

	// Tags One or more tags associated with the load balancer.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// Type The type of load balancer. Valid only for load balancers in a Net.<br />
	// If `LoadBalancerType` is `internet-facing`, the load balancer has a public DNS name that resolves to a public IP.<br />
	// If `LoadBalancerType` is `internal`, the load balancer has a public DNS name that resolves to a private IP.
	Type *string `json:"type,omitempty"`

	// VpcId The ID of the Net for the load balancer.
	VpcId *string `json:"vpcId,omitempty"`
}

// LoadBalancerLight Information about the load balancer.
type LoadBalancerLight struct {
	// LoadBalancerName The name of the load balancer to which the listener is attached.
	LoadBalancerName string `json:"loadBalancerName"`

	// LoadBalancerPort The port of load balancer on which the load balancer is listening (between `1` and `65535` both included).
	LoadBalancerPort int `json:"loadBalancerPort"`
}

// LoadBalancerStickyCookiePolicy Information about the stickiness policy.
type LoadBalancerStickyCookiePolicy struct {
	// CookieExpirationPeriod The time period, in seconds, after which the cookie should be considered stale.<br />
	// If `1`, the stickiness session lasts for the duration of the browser session.
	CookieExpirationPeriod *int `json:"cookieExpirationPeriod,omitempty"`

	// PolicyName The name of the stickiness policy.
	PolicyName *string `json:"policyName,omitempty"`
}

// LoadBalancerTag Information about the load balancer tag.
type LoadBalancerTag struct {
	// Key The key of the tag.
	Key *string `json:"key,omitempty"`

	// Name The name of the load balancer.
	Name *string `json:"name,omitempty"`

	// Value The value of the tag.
	Value *string `json:"value,omitempty"`
}

// Location Information about the DirectLink location.
type Location struct {
	// Code The location code, to be set as the `Location` parameter of the *CreateDirectLink* method when creating a DirectLink.
	Code *string `json:"code,omitempty"`

	// Name The name and description of the location, corresponding to a datacenter.
	Name *string `json:"name,omitempty"`
}

// MaintenanceEvent Information about the maintenance event.
type MaintenanceEvent struct {
	// Code The code of the event (`system-reboot` \| `system-maintenance`).
	Code *string `json:"code,omitempty"`

	// Description The description of the event.
	Description *string `json:"description,omitempty"`

	// NotAfter The latest scheduled end time for the event.
	NotAfter *openapi_types.Date `json:"notAfter,omitempty"`

	// NotBefore The earliest scheduled start time for the event.
	NotBefore *openapi_types.Date `json:"notBefore,omitempty"`
}

// NatGateway Information about the NAT service.
type NatGateway struct {
	// Id The ID of the NAT service.
	Id *string `json:"id,omitempty"`

	// PublicIps Information about the public IP or IPs associated with the NAT service.
	PublicIps *[]PublicIpLight `json:"publicIps,omitempty"`

	// State The state of the NAT service (`pending` \| `available` \| `deleting` \| `deleted`).
	State *string `json:"state,omitempty"`

	// SubnetId The ID of the Subnet in which the NAT service is.
	SubnetId *string `json:"subnetId,omitempty"`

	// Tags One or more tags associated with the NAT service.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// VpcId The ID of the Net in which the NAT service is.
	VpcId *string `json:"vpcId,omitempty"`
}

// Nic Information about the NIC.
type Nic struct {
	// AvailabilityZoneName The Subregion in which the NIC is located.
	AvailabilityZoneName *string `json:"availabilityZoneName,omitempty"`

	// Description The description of the NIC.
	Description *string `json:"description,omitempty"`

	// Id The ID of the NIC.
	Id *string `json:"id,omitempty"`

	// IsSourceDestChecked (Net only) If true, the source/destination check is enabled. If false, it is disabled. This value must be false for a NAT VM to perform network address translation (NAT) in a Net.
	IsSourceDestChecked *bool `json:"isSourceDestChecked,omitempty"`

	// LinkNic Information about the NIC attachment.
	LinkNic *LinkNic `json:"linkNic,omitempty"`

	// LinkPublicIp Information about the public IP association.
	LinkPublicIp *LinkPublicIp `json:"linkPublicIp,omitempty"`

	// MacAddress The Media Access Control (MAC) address of the NIC.
	MacAddress *string `json:"macAddress,omitempty"`

	// PrivateDnsName The name of the private DNS.
	PrivateDnsName *string `json:"privateDnsName,omitempty"`

	// PrivateIps The private IPs of the NIC.
	PrivateIps *[]PrivateIp `json:"privateIps,omitempty"`

	// SecurityGroups One or more IDs of security groups for the NIC.
	SecurityGroups *[]SecurityGroupLight `json:"securityGroups,omitempty"`

	// State The state of the NIC (`available` \| `attaching` \| `in-use` \| `detaching`).
	State *string `json:"state,omitempty"`

	// SubnetId The ID of the Subnet.
	SubnetId *string `json:"subnetId,omitempty"`

	// Tags One or more tags associated with the NIC.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// VpcId The ID of the Net for the NIC.
	VpcId *string `json:"vpcId,omitempty"`
}

// NicForVmCreation Information about the network interface card (NIC) when creating a virtual machine (VM).
type NicForVmCreation struct {
	// DeleteOnVmDeletion If true, the NIC is deleted when the VM is terminated. You can specify this parameter only for a new NIC. To modify this value for an existing NIC, see [UpdateNic](#updatenic).
	DeleteOnVmDeletion *bool `json:"deleteOnVmDeletion,omitempty"`

	// Description The description of the NIC, if you are creating a NIC when creating the VM.
	Description *string `json:"description,omitempty"`

	// DeviceNumber The index of the VM device for the NIC attachment (between `0` and `7`, both included). This parameter is required if you create a NIC when creating the VM.
	DeviceNumber *int `json:"deviceNumber,omitempty"`

	// NicId The ID of the NIC, if you are attaching an existing NIC when creating a VM.
	NicId *string `json:"nicId,omitempty"`

	// PrivateIps One or more private IPs to assign to the NIC, if you create a NIC when creating a VM. Only one private IP can be the primary private IP.
	PrivateIps *[]PrivateIpLight `json:"privateIps,omitempty"`

	// SecondaryPrivateIpCount The number of secondary private IPs, if you create a NIC when creating a VM. This parameter cannot be specified if you specified more than one private IP in the `PrivateIps` parameter.
	SecondaryPrivateIpCount *int `json:"secondaryPrivateIpCount,omitempty"`

	// SecurityGroupIds One or more IDs of security groups for the NIC, if you create a NIC when creating a VM.
	SecurityGroupIds *[]string `json:"securityGroupIds,omitempty"`

	// SubnetId The ID of the Subnet for the NIC, if you create a NIC when creating a VM. This parameter is required if you create a NIC when creating the VM.
	SubnetId *string `json:"subnetId,omitempty"`
}

// NicLight Information about the network interface card (NIC).
type NicLight struct {
	// Description The description of the NIC.
	Description *string `json:"description,omitempty"`

	// IsSourceDestChecked (Net only) If true, the source/destination check is enabled. If false, it is disabled. This value must be false for a NAT VM to perform network address translation (NAT) in a Net.
	IsSourceDestChecked *bool `json:"isSourceDestChecked,omitempty"`

	// LinkNic Information about the network interface card (NIC).
	LinkNic *LinkNicLight `json:"linkNic,omitempty"`

	// LinkPublicIp Information about the public IP associated with the NIC.
	LinkPublicIp *LinkPublicIpLightForVm `json:"linkPublicIp,omitempty"`

	// MacAddress The Media Access Control (MAC) address of the NIC.
	MacAddress *string `json:"macAddress,omitempty"`

	// NicId The ID of the NIC.
	NicId *string `json:"nicId,omitempty"`

	// PrivateDnsName The name of the private DNS.
	PrivateDnsName *string `json:"privateDnsName,omitempty"`

	// PrivateIps The private IP or IPs of the NIC.
	PrivateIps *[]PrivateIpLightForVm `json:"privateIps,omitempty"`

	// SecurityGroups One or more IDs of security groups for the NIC.
	SecurityGroups *[]SecurityGroupLight `json:"securityGroups,omitempty"`

	// State The state of the NIC (`available` \| `attaching` \| `in-use` \| `detaching`).
	State *string `json:"state,omitempty"`

	// SubnetId The ID of the Subnet for the NIC.
	SubnetId *string `json:"subnetId,omitempty"`

	// VpcId The ID of the Net for the NIC.
	VpcId *string `json:"vpcId,omitempty"`
}

// Phase1Options Information about Phase 1 of the Internet Key Exchange (IKE) negotiation. When Phase 1 finishes successfully, peers proceed to Phase 2 negotiations.
type Phase1Options struct {
	// DpdTimeoutAction The action to carry out after a Dead Peer Detection (DPD) timeout occurs.
	DpdTimeoutAction *string `json:"dpdTimeoutAction,omitempty"`

	// DpdTimeoutSeconds The maximum waiting time for a Dead Peer Detection (DPD) response before considering the peer as dead, in seconds.
	DpdTimeoutSeconds *int `json:"dpdTimeoutSeconds,omitempty"`

	// IkeVersions The Internet Key Exchange (IKE) versions allowed for the VPN tunnel.
	IkeVersions *[]string `json:"ikeVersions,omitempty"`

	// Phase1DhGroupNumbers The Diffie-Hellman (DH) group numbers allowed for the VPN tunnel for phase 1.
	Phase1DhGroupNumbers *[]int `json:"phase1DhGroupNumbers,omitempty"`

	// Phase1EncryptionAlgorithms The encryption algorithms allowed for the VPN tunnel for phase 1.
	Phase1EncryptionAlgorithms *[]string `json:"phase1EncryptionAlgorithms,omitempty"`

	// Phase1IntegrityAlgorithms The integrity algorithms allowed for the VPN tunnel for phase 1.
	Phase1IntegrityAlgorithms *[]string `json:"phase1IntegrityAlgorithms,omitempty"`

	// Phase1LifetimeSeconds The lifetime for phase 1 of the IKE negotiation process, in seconds.
	Phase1LifetimeSeconds *int `json:"phase1LifetimeSeconds,omitempty"`

	// ReplayWindowSize The number of packets in an IKE replay window.
	ReplayWindowSize *int `json:"replayWindowSize,omitempty"`

	// StartupAction The action to carry out when establishing tunnels for a VPN connection.
	StartupAction *string `json:"startupAction,omitempty"`
}

// Phase2Options Information about Phase 2 of the Internet Key Exchange (IKE) negotiation.
type Phase2Options struct {
	// Phase2DhGroupNumbers The Diffie-Hellman (DH) group numbers allowed for the VPN tunnel for phase 2.
	Phase2DhGroupNumbers *[]int `json:"phase2DhGroupNumbers,omitempty"`

	// Phase2EncryptionAlgorithms The encryption algorithms allowed for the VPN tunnel for phase 2.
	Phase2EncryptionAlgorithms *[]string `json:"phase2EncryptionAlgorithms,omitempty"`

	// Phase2IntegrityAlgorithms The integrity algorithms allowed for the VPN tunnel for phase 2.
	Phase2IntegrityAlgorithms *[]string `json:"phase2IntegrityAlgorithms,omitempty"`

	// Phase2LifetimeSeconds The lifetime for phase 2 of the Internet Key Exchange (IKE) negociation process, in seconds.
	Phase2LifetimeSeconds *int `json:"phase2LifetimeSeconds,omitempty"`

	// PreSharedKey The pre-shared key to establish the initial authentication between the client gateway and the virtual gateway. This key can contain any character except line breaks and double quotes (&quot;).
	PreSharedKey *string `json:"preSharedKey,omitempty"`
}

// Phase2OptionsToUpdate Information about Phase 2 of the Internet Key Exchange (IKE) negotiation.
type Phase2OptionsToUpdate struct {
	// PreSharedKey The pre-shared key to establish the initial authentication between the client gateway and the virtual gateway. This key can contain any character except line breaks and double quotes (&quot;).
	PreSharedKey *string `json:"preSharedKey,omitempty"`
}

// Placement Information about the placement of the VM.
type Placement struct {
	// AvailabilityZoneName The name of the Subregion. If you specify this parameter, you must not specify the `Nics` parameter.
	AvailabilityZoneName *string `json:"availabilityZoneName,omitempty"`

	// Tenancy The tenancy of the VM (`default`, `dedicated`, or a dedicated group ID).
	Tenancy *string `json:"tenancy,omitempty"`
}

// PrivateIp Information about the private IP.
type PrivateIp struct {
	// IsPrimary If true, the IP is the primary private IP of the NIC.
	IsPrimary *bool `json:"isPrimary,omitempty"`

	// LinkPublicIp Information about the public IP association.
	LinkPublicIp *LinkPublicIp `json:"linkPublicIp,omitempty"`

	// PrivateDnsName The name of the private DNS.
	PrivateDnsName *string `json:"privateDnsName,omitempty"`

	// PrivateIp The private IP of the NIC.
	PrivateIp *string `json:"privateIp,omitempty"`
}

// PrivateIpLight Information about the private IP.
type PrivateIpLight struct {
	// IsPrimary If true, the IP is the primary private IP of the NIC.
	IsPrimary *bool `json:"isPrimary,omitempty"`

	// PrivateIp The private IP of the NIC.
	PrivateIp *string `json:"privateIp,omitempty"`
}

// PrivateIpLightForVm Information about the private IP of the NIC.
type PrivateIpLightForVm struct {
	// IsPrimary If true, the IP is the primary private IP of the NIC.
	IsPrimary *bool `json:"isPrimary,omitempty"`

	// LinkPublicIp Information about the public IP associated with the NIC.
	LinkPublicIp *LinkPublicIpLightForVm `json:"linkPublicIp,omitempty"`

	// PrivateDnsName The name of the private DNS.
	PrivateDnsName *string `json:"privateDnsName,omitempty"`

	// PrivateIp The private IP.
	PrivateIp *string `json:"privateIp,omitempty"`
}

// ProductType Information about the product type.
type ProductType struct {
	// Description The description of the product type.
	Description *string `json:"description,omitempty"`

	// Id The ID of the product type.
	Id *string `json:"id,omitempty"`

	// Vendor The vendor of the product type.
	Vendor *string `json:"vendor,omitempty"`
}

// PublicIp Information about the public IP.
type PublicIp struct {
	// Id The allocation ID of the public IP.
	Id *string `json:"id,omitempty"`

	// LinkPublicIpId (Required in a Net) The ID representing the association of the public IP with the VM or the NIC.
	LinkPublicIpId *string `json:"linkPublicIpId,omitempty"`

	// NicId The ID of the NIC the public IP is associated with (if any).
	NicId *string `json:"nicId,omitempty"`

	// PrivateIp The private IP associated with the public IP.
	PrivateIp *string `json:"privateIp,omitempty"`

	// PublicIp The public IP.
	PublicIp *string `json:"publicIp,omitempty"`

	// Tags One or more tags associated with the public IP.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// VmId The ID of the VM the public IP is associated with (if any).
	VmId *string `json:"vmId,omitempty"`
}

// PublicIpLight Information about the public IP.
type PublicIpLight struct {
	// PublicIp The public IP associated with the NAT service.
	PublicIp *string `json:"publicIp,omitempty"`

	// PublicIpId The allocation ID of the public IP associated with the NAT service.
	PublicIpId *string `json:"publicIpId,omitempty"`
}

// ReadAdminPassword defines model for ReadAdminPassword.
type ReadAdminPassword struct {
	// AdminPassword The password of the VM. After the first boot, returns an empty string.
	AdminPassword *string `json:"adminPassword,omitempty"`

	// VmId The ID of the VM.
	VmId *string `json:"vmId,omitempty"`
}

// ReadClientGateways defines model for ReadClientGateways.
type ReadClientGateways struct {
	// Items Information about one or more client gateways.
	Items *[]ClientGateway `json:"items,omitempty"`
}

// ReadConsoleOutput defines model for ReadConsoleOutput.
type ReadConsoleOutput struct {
	// ConsoleOutput The Base64-encoded output of the console. If a command line tool is used, the output is decoded by the tool.
	ConsoleOutput *string `json:"consoleOutput,omitempty"`

	// VmId The ID of the VM.
	VmId *string `json:"vmId,omitempty"`
}

// ReadDhcpOptions defines model for ReadDhcpOptions.
type ReadDhcpOptions struct {
	// Items Information about one or more DHCP options sets.
	Items *[]DhcpOptionsSet `json:"items,omitempty"`
}

// ReadDirectLinkInterfaces defines model for ReadDirectLinkInterfaces.
type ReadDirectLinkInterfaces struct {
	// Items Information about one or more DirectLink interfaces.
	Items *[]DirectLinkInterfaces `json:"items,omitempty"`
}

// ReadDirectLinks defines model for ReadDirectLinks.
type ReadDirectLinks struct {
	// Items Information about one or more DirectLinks.
	Items *[]DirectLink `json:"items,omitempty"`
}

// ReadFlexibleGpuCatalog defines model for ReadFlexibleGpuCatalog.
type ReadFlexibleGpuCatalog struct {
	// Items Information about one or more fGPUs available in the public catalog.
	Items *[]FlexibleGpuCatalog `json:"items,omitempty"`
}

// ReadFlexibleGpus defines model for ReadFlexibleGpus.
type ReadFlexibleGpus struct {
	// Items Information about one or more fGPUs.
	Items *[]FlexibleGpu `json:"items,omitempty"`
}

// ReadImages defines model for ReadImages.
type ReadImages struct {
	// Items Information about one or more OMIs.
	Items *[]Image `json:"items,omitempty"`
}

// ReadInternetGateways defines model for ReadInternetGateways.
type ReadInternetGateways struct {
	// Items Information about one or more Internet services.
	Items *[]InternetGateway `json:"items,omitempty"`
}

// ReadKeypairs defines model for ReadKeypairs.
type ReadKeypairs struct {
	// Items Information about one or more keypairs.
	Items *[]Keypair `json:"items,omitempty"`
}

// ReadKeypairsById Information about the keypair.
type ReadKeypairsById struct {
	// Fingerprint The MD5 public key fingerprint as specified in section 4 of RFC 4716.
	Fingerprint *string `json:"fingerprint,omitempty"`

	// Name The name of the keypair.
	Name *string `json:"name,omitempty"`

	// Type The type of the keypair (`ssh-rsa`, `ssh-ed25519`, `ecdsa-sha2-nistp256`, `ecdsa-sha2-nistp384`, or `ecdsa-sha2-nistp521`).
	Type *string `json:"type,omitempty"`
}

// ReadListenerRules defines model for ReadListenerRules.
type ReadListenerRules struct {
	// Items The list of the rules to describe.
	Items *[]ListenerRule `json:"items,omitempty"`
}

// ReadLoadBalancerTags defines model for ReadLoadBalancerTags.
type ReadLoadBalancerTags struct {
	// Items Information about one or more load balancer tags.
	Items *[]LoadBalancerTag `json:"items,omitempty"`
}

// ReadLoadBalancers defines model for ReadLoadBalancers.
type ReadLoadBalancers struct {
	// Items Information about one or more load balancers.
	Items *[]LoadBalancer `json:"items,omitempty"`
}

// ReadLocations defines model for ReadLocations.
type ReadLocations struct {
	// Items Information about one or more locations.
	Items *[]Location `json:"items,omitempty"`
}

// ReadNatGateway defines model for ReadNatGateway.
type ReadNatGateway struct {
	// Items Information about one or more NAT services.
	Items *[]NatGateway `json:"items,omitempty"`
}

// ReadNics defines model for ReadNics.
type ReadNics struct {
	// Items Information about one or more NICs.
	Items *[]Nic `json:"items,omitempty"`
}

// ReadProductTypes defines model for ReadProductTypes.
type ReadProductTypes struct {
	// Items Information about one or more product types.
	Items *[]ProductType `json:"items,omitempty"`
}

// ReadProductTypesById Information about the product type.
type ReadProductTypesById struct {
	// Description The description of the product type.
	Description *string `json:"description,omitempty"`

	// Id The ID of the product type.
	Id *string `json:"id,omitempty"`

	// Vendor The vendor of the product type.
	Vendor *string `json:"vendor,omitempty"`
}

// ReadPublicIpRanges defines model for ReadPublicIpRanges.
type ReadPublicIpRanges struct {
	// Items The list of public IPv4 addresses used in the Region, in CIDR notation.
	Items *[]string `json:"items,omitempty"`
}

// ReadPublicIps defines model for ReadPublicIps.
type ReadPublicIps struct {
	// Items Information about one or more public IPs.
	Items *[]PublicIp `json:"items,omitempty"`
}

// ReadRouteTables defines model for ReadRouteTables.
type ReadRouteTables struct {
	// Items Information about one or more route tables.
	Items *[]RouteTable `json:"items,omitempty"`
}

// ReadSecurityGroups defines model for ReadSecurityGroups.
type ReadSecurityGroups struct {
	// Items Information about one or more security groups.
	Items *[]SecurityGroup `json:"items,omitempty"`
}

// ReadSnapshots defines model for ReadSnapshots.
type ReadSnapshots struct {
	// Items Information about one or more snapshots and their permissions.
	Items *[]Snapshot `json:"items,omitempty"`
}

// ReadSubnets defines model for ReadSubnets.
type ReadSubnets struct {
	// Items Information about one or more Subnets.
	Items *[]Subnet `json:"items,omitempty"`
}

// ReadTags defines model for ReadTags.
type ReadTags struct {
	// Items Information about one or more tags.
	Items *[]Tag `json:"items,omitempty"`
}

// ReadVirtualGateways defines model for ReadVirtualGateways.
type ReadVirtualGateways struct {
	// Items Information about one or more virtual gateways.
	Items *[]VirtualGateway `json:"items,omitempty"`
}

// ReadVms defines model for ReadVms.
type ReadVms struct {
	// Items Information about one or more VMs.
	Items *[]Vm `json:"items,omitempty"`
}

// ReadVmsHealth defines model for ReadVmsHealth.
type ReadVmsHealth struct {
	// BackendVmHealth Information about the health of one or more back-end VMs.
	BackendVmHealth *[]BackendVmHealth `json:"backendVmHealth,omitempty"`
}

// ReadVmsState defines model for ReadVmsState.
type ReadVmsState struct {
	// Items Information about one or more VM states.
	Items *[]VmStates `json:"items,omitempty"`
}

// ReadVolumes defines model for ReadVolumes.
type ReadVolumes struct {
	// Items Information about one or more volumes.
	Items *[]Volume `json:"items,omitempty"`
}

// ReadVpcAccessPoints defines model for ReadVpcAccessPoints.
type ReadVpcAccessPoints struct {
	// Items One or more Net access points.
	Items *[]VpcAccessPoint `json:"items,omitempty"`
}

// ReadVpcPeerings defines model for ReadVpcPeerings.
type ReadVpcPeerings struct {
	// Items Information about one or more Net peerings.
	Items *[]VpcPeering `json:"items,omitempty"`
}

// ReadVpcs defines model for ReadVpcs.
type ReadVpcs struct {
	// Items Information about the described Nets.
	Items *[]Vpc `json:"items,omitempty"`
}

// ReadVpnConnections defines model for ReadVpnConnections.
type ReadVpnConnections struct {
	// Items Information about one or more VPN connections.
	Items *[]VpnConnection `json:"items,omitempty"`
}

// ResourceLoadBalancerTag Information about the tag.
type ResourceLoadBalancerTag struct {
	// Key The key of the tag, with a minimum of 1 character.
	Key *string `json:"key,omitempty"`
}

// ResourceTag Information about the tag.
type ResourceTag struct {
	// Key The key of the tag, with a minimum of 1 character.
	Key string `json:"key"`

	// Value The value of the tag, between 0 and 255 characters.
	Value string `json:"value"`
}

// Route Information about the route.
type Route struct {
	// CreationMethod The method used to create the route.
	CreationMethod *string `json:"creationMethod,omitempty"`

	// DestinationIpRange The IP range used for the destination match, in CIDR notation (for example, `10.0.0.0/24`).
	DestinationIpRange *string `json:"destinationIpRange,omitempty"`

	// DestinationServiceId The ID of the NumSpot service.
	DestinationServiceId *string `json:"destinationServiceId,omitempty"`

	// GatewayId The ID of the Internet service or virtual gateway attached to the Net.
	GatewayId *string `json:"gatewayId,omitempty"`

	// NatGatewayId The ID of a NAT service attached to the Net.
	NatGatewayId *string `json:"natGatewayId,omitempty"`

	// NicId The ID of the NIC.
	NicId *string `json:"nicId,omitempty"`

	// State The state of a route in the route table (always `active`).
	State *string `json:"state,omitempty"`

	// VmAccountId The account ID of the owner of the VM.
	VmAccountId *string `json:"vmAccountId,omitempty"`

	// VmId The ID of a VM specified in a route in the table.
	VmId *string `json:"vmId,omitempty"`

	// VpcAccessPointId The ID of the Net access point.
	VpcAccessPointId *string `json:"vpcAccessPointId,omitempty"`

	// VpcPeeringId The ID of the Net peering.
	VpcPeeringId *string `json:"vpcPeeringId,omitempty"`
}

// RouteLight Information about the route.
type RouteLight struct {
	// DestinationIpRange The IP range used for the destination match, in CIDR notation (for example, `10.0.0.0/24`).
	DestinationIpRange *string `json:"destinationIpRange,omitempty"`

	// RouteType The type of route (always `static`).
	RouteType *string `json:"routeType,omitempty"`

	// State The current state of the static route (`pending` \| `available` \| `deleting` \| `deleted`).
	State *string `json:"state,omitempty"`
}

// RoutePropagatingVirtualGateway Information about the route propagating virtual gateway.
type RoutePropagatingVirtualGateway struct {
	// VirtualGatewayId The ID of the virtual gateway.
	VirtualGatewayId *string `json:"virtualGatewayId,omitempty"`
}

// RouteTable Information about the route table.
type RouteTable struct {
	// Id The ID of the route table.
	Id *string `json:"id,omitempty"`

	// LinkRouteTables One or more associations between the route table and Subnets.
	LinkRouteTables *[]LinkRouteTable `json:"linkRouteTables,omitempty"`

	// RoutePropagatingVirtualGateways Information about virtual gateways propagating routes.
	RoutePropagatingVirtualGateways *[]RoutePropagatingVirtualGateway `json:"routePropagatingVirtualGateways,omitempty"`

	// Routes One or more routes in the route table.
	Routes *[]Route `json:"routes,omitempty"`

	// Tags One or more tags associated with the route table.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// VpcId The ID of the Net for the route table.
	VpcId *string `json:"vpcId,omitempty"`
}

// SecurityGroup Information about the security group.
type SecurityGroup struct {
	// Description The description of the security group.
	Description *string `json:"description,omitempty"`

	// Id The ID of the security group.
	Id *string `json:"id,omitempty"`

	// InboundRules The inbound rules associated with the security group.
	InboundRules *[]SecurityGroupRule `json:"inboundRules,omitempty"`

	// Name The name of the security group.
	Name *string `json:"name,omitempty"`

	// OutboundRules The outbound rules associated with the security group.
	OutboundRules *[]SecurityGroupRule `json:"outboundRules,omitempty"`

	// Tags One or more tags associated with the security group.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// VpcId The ID of the Net for the security group.
	VpcId *string `json:"vpcId,omitempty"`
}

// SecurityGroupLight Information about the security group.
type SecurityGroupLight struct {
	// SecurityGroupId The ID of the security group.
	SecurityGroupId *string `json:"securityGroupId,omitempty"`

	// SecurityGroupName The name of the security group.
	SecurityGroupName *string `json:"securityGroupName,omitempty"`
}

// SecurityGroupRule Information about the security group rule.
type SecurityGroupRule struct {
	// FromPortRange The beginning of the port range for the TCP and UDP protocols, or an ICMP type number.
	FromPortRange *int `json:"fromPortRange,omitempty"`

	// IpProtocol The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all protocols). By default, `-1`. In a Net, this can also be an IP protocol number. For more information, see the [IANA.org website](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
	IpProtocol *string `json:"ipProtocol,omitempty"`

	// IpRanges One or more IP ranges for the security group rules, in CIDR notation (for example, `10.0.0.0/16`).
	IpRanges *[]string `json:"ipRanges,omitempty"`

	// SecurityGroupsMembers Information about one or more source or destination security groups.
	SecurityGroupsMembers *[]SecurityGroupsMember `json:"securityGroupsMembers,omitempty"`

	// ServiceIds One or more service IDs to allow traffic from a Net to access the corresponding NumSpot services.
	ServiceIds *[]string `json:"serviceIds,omitempty"`

	// ToPortRange The end of the port range for the TCP and UDP protocols, or an ICMP code number.
	ToPortRange *int `json:"toPortRange,omitempty"`
}

// SecurityGroupsMember Information about a source or destination security group.
type SecurityGroupsMember struct {
	// SecurityGroupId The ID of a source or destination security group that you want to link to the security group of the rule.
	SecurityGroupId *string `json:"securityGroupId,omitempty"`

	// SecurityGroupName (Public Cloud only) The name of a source or destination security group that you want to link to the security group of the rule.
	SecurityGroupName *string `json:"securityGroupName,omitempty"`
}

// Snapshot Information about the snapshot.
type Snapshot struct {
	// Access Permissions for the resource.
	Access *Access `json:"access,omitempty"`

	// CreationDate The date and time of creation of the snapshot.
	CreationDate *time.Time `json:"creationDate,omitempty"`

	// Description The description of the snapshot.
	Description *string `json:"description,omitempty"`

	// Id The ID of the snapshot.
	Id *string `json:"id,omitempty"`

	// Progress The progress of the snapshot, as a percentage.
	Progress *int `json:"progress,omitempty"`

	// State The state of the snapshot (`in-queue` \| `completed` \| `error`).
	State *string `json:"state,omitempty"`

	// Tags One or more tags associated with the snapshot.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// VolumeId The ID of the volume used to create the snapshot.
	VolumeId *string `json:"volumeId,omitempty"`

	// VolumeSize The size of the volume used to create the snapshot, in gibibytes (GiB).
	VolumeSize *int `json:"volumeSize,omitempty"`
}

// SourceSecurityGroup Information about the source security group of the load balancer, which you can use as part of your inbound rules for your registered VMs.<br />
// To only allow traffic from load balancers, add a security group rule that specifies this source security group as the inbound source.
type SourceSecurityGroup struct {
	// SecurityGroupAccountId The account ID of the owner of the security group.
	SecurityGroupAccountId *string `json:"securityGroupAccountId,omitempty"`

	// SecurityGroupName The name of the security group.
	SecurityGroupName *string `json:"securityGroupName,omitempty"`
}

// SourceVpc Information about the source Net.
type SourceVpc struct {
	// IpRange The IP range for the source Net, in CIDR notation (for example, `10.0.0.0/16`).
	IpRange *string `json:"ipRange,omitempty"`

	// VpcId The ID of the source Net.
	VpcId *string `json:"vpcId,omitempty"`
}

// StateComment Information about the change of state.
type StateComment struct {
	// StateCode The code of the change of state.
	StateCode *string `json:"stateCode,omitempty"`

	// StateMessage A message explaining the change of state.
	StateMessage *string `json:"stateMessage,omitempty"`
}

// StopVm defines model for StopVm.
type StopVm struct {
	// ForceStop Forces the VM to stop.
	ForceStop *bool `json:"forceStop,omitempty"`
}

// Subnet Information about the Subnet.
type Subnet struct {
	// AvailabilityZoneName The name of the Subregion in which the Subnet is located.
	AvailabilityZoneName *string `json:"availabilityZoneName,omitempty"`

	// AvailableIpsCount The number of available IPs in the Subnets.
	AvailableIpsCount *int `json:"availableIpsCount,omitempty"`

	// Id The ID of the Subnet.
	Id *string `json:"id,omitempty"`

	// IpRange The IP range in the Subnet, in CIDR notation (for example, `10.0.0.0/16`).
	IpRange *string `json:"ipRange,omitempty"`

	// MapPublicIpOnLaunch If true, a public IP is assigned to the network interface cards (NICs) created in the specified Subnet.
	MapPublicIpOnLaunch *bool `json:"mapPublicIpOnLaunch,omitempty"`

	// State The state of the Subnet (`pending` \| `available` \| `deleted`).
	State *string `json:"state,omitempty"`

	// Tags One or more tags associated with the Subnet.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// VpcId The ID of the Net in which the Subnet is.
	VpcId *string `json:"vpcId,omitempty"`
}

// Tag Information about the tag.
type Tag struct {
	// Key The key of the tag, with a minimum of 1 character.
	Key *string `json:"key,omitempty"`

	// ResourceId The ID of the resource.
	ResourceId *string `json:"resourceId,omitempty"`

	// ResourceType The type of the resource.
	ResourceType *string `json:"resourceType,omitempty"`

	// Value The value of the tag, between 0 and 255 characters.
	Value *string `json:"value,omitempty"`
}

// UnlinkInternetGateway defines model for UnlinkInternetGateway.
type UnlinkInternetGateway struct {
	// VpcId The ID of the Net from which you want to detach the Internet service.
	VpcId string `json:"vpcId"`
}

// UnlinkLoadBalancerBackendMachines defines model for UnlinkLoadBalancerBackendMachines.
type UnlinkLoadBalancerBackendMachines struct {
	// BackendIps  One or more public IPs of back-end VMs.
	BackendIps *[]string `json:"backendIps,omitempty"`

	// BackendVmIds  One or more IDs of back-end VMs.
	BackendVmIds *[]string `json:"backendVmIds,omitempty"`
}

// UnlinkNic defines model for UnlinkNic.
type UnlinkNic struct {
	// LinkNicId The ID of the attachment operation.
	LinkNicId string `json:"linkNicId"`
}

// UnlinkPrivateIps defines model for UnlinkPrivateIps.
type UnlinkPrivateIps struct {
	// PrivateIps One or more secondary private IPs you want to unassign from the NIC.
	PrivateIps []string `json:"privateIps"`
}

// UnlinkPublicIp defines model for UnlinkPublicIp.
type UnlinkPublicIp struct {
	// LinkPublicIpId The ID representing the association of the public IP with the VM or the NIC. This parameter is required unless you use the `PublicIp` parameter.
	LinkPublicIpId *string `json:"linkPublicIpId,omitempty"`
}

// UnlinkRouteTable defines model for UnlinkRouteTable.
type UnlinkRouteTable struct {
	// LinkRouteTableId The ID of the association between the route table and the Subnet.
	LinkRouteTableId string `json:"linkRouteTableId"`
}

// UnlinkVirtualGatewayToVpc defines model for UnlinkVirtualGatewayToVpc.
type UnlinkVirtualGatewayToVpc struct {
	// VpcId The ID of the Net from which you want to detach the virtual gateway.
	VpcId string `json:"vpcId"`
}

// UnlinkVolume defines model for UnlinkVolume.
type UnlinkVolume struct {
	// ForceUnlink Forces the detachment of the volume in case of previous failure. Important: This action may damage your data or file systems.
	ForceUnlink *bool `json:"forceUnlink,omitempty"`
}

// UpdateDirectLinkInterface defines model for UpdateDirectLinkInterface.
type UpdateDirectLinkInterface struct {
	// Mtu The maximum transmission unit (MTU) of the DirectLink interface, in bytes (always `1500`).
	Mtu UpdateDirectLinkInterfaceMtu `json:"mtu"`
}

// UpdateDirectLinkInterfaceMtu The maximum transmission unit (MTU) of the DirectLink interface, in bytes (always `1500`).
type UpdateDirectLinkInterfaceMtu int

// UpdateFlexibleGpu defines model for UpdateFlexibleGpu.
type UpdateFlexibleGpu struct {
	// DeleteOnVmDeletion If true, the fGPU is deleted when the VM is terminated.
	DeleteOnVmDeletion *bool `json:"deleteOnVmDeletion,omitempty"`
}

// UpdateImage defines model for UpdateImage.
type UpdateImage struct {
	// AccessCreation Information about the permissions for the resource.<br />
	// Specify either the `Additions` or the `Removals` parameter.
	AccessCreation AccessCreation `json:"accessCreation"`
}

// UpdateListenerRule defines model for UpdateListenerRule.
type UpdateListenerRule struct {
	// HostPattern A host-name pattern for the rule, with a maximum length of 128 characters. This host-name pattern supports maximum three wildcards, and must not contain any special characters except [-.?].
	HostPattern *string `json:"hostPattern"`

	// PathPattern A path pattern for the rule, with a maximum length of 128 characters. This path pattern supports maximum three wildcards, and must not contain any special characters except [_-.$/~&quot;'@:+?].
	PathPattern *string `json:"pathPattern"`
}

// UpdateLoadBalancer defines model for UpdateLoadBalancer.
type UpdateLoadBalancer struct {
	// HealthCheck Information about the health check configuration.
	HealthCheck *HealthCheck `json:"healthCheck,omitempty"`

	// LoadBalancerPort The port on which the load balancer is listening (between `1` and `65535`, both included). This parameter is required if you want to update the server certificate.
	LoadBalancerPort *int `json:"loadBalancerPort,omitempty"`

	// PolicyNames The name of the policy you want to enable for the listener.
	PolicyNames *[]string `json:"policyNames,omitempty"`

	// PublicIp (internet-facing only) The public IP you want to associate with the load balancer. The former public IP of the load balancer is then disassociated. If you specify an empty string and the former public IP belonged to you, it is disassociated and replaced by a public IP owned by NumSpot.
	PublicIp *string `json:"publicIp,omitempty"`

	// SecuredCookies If true, secure cookies are enabled for the load balancer.
	SecuredCookies *bool `json:"securedCookies,omitempty"`

	// SecurityGroups (Net only) One or more IDs of security groups you want to assign to the load balancer. You need to specify the already assigned security groups that you want to keep along with the new ones you are assigning. If the list is empty, the default security group of the Net is assigned to the load balancer.
	SecurityGroups *[]string `json:"securityGroups,omitempty"`
}

// UpdateNic defines model for UpdateNic.
type UpdateNic struct {
	// Description A new description for the NIC.
	Description *string `json:"description,omitempty"`

	// LinkNic Information about the NIC attachment. If you are modifying the `DeleteOnVmDeletion` attribute, you must specify the ID of the NIC attachment.
	LinkNic *LinkNicToUpdate `json:"linkNic,omitempty"`

	// SecurityGroupIds One or more IDs of security groups for the NIC.<br />
	// You must specify at least one group, even if you use the default security group in the Net.
	SecurityGroupIds *[]string `json:"securityGroupIds,omitempty"`
}

// UpdateRoute defines model for UpdateRoute.
type UpdateRoute struct {
	// DestinationIpRange The IP range used for the destination match, in CIDR notation (for example, `10.0.0.0/24`).
	DestinationIpRange string `json:"destinationIpRange"`

	// GatewayId The ID of an Internet service or virtual gateway attached to your Net.
	GatewayId *string `json:"gatewayId,omitempty"`

	// NatGatewayId The ID of a NAT service.
	NatGatewayId *string `json:"natGatewayId,omitempty"`

	// NicId The ID of a network interface card (NIC).
	NicId *string `json:"nicId,omitempty"`

	// VmId The ID of a NAT VM in your Net.
	VmId *string `json:"vmId,omitempty"`

	// VpcPeeringId The ID of a Net peering.
	VpcPeeringId *string `json:"vpcPeeringId,omitempty"`
}

// UpdateRouteTableRoutePropagation defines model for UpdateRouteTableRoutePropagation.
type UpdateRouteTableRoutePropagation struct {
	// Enable If true, a virtual gateway can propagate routes to a specified route table of a Net. If false, the propagation is disabled.
	Enable bool `json:"enable"`

	// VirtualGatewayId The ID of the virtual gateway.
	VirtualGatewayId string `json:"virtualGatewayId"`
}

// UpdateSubnet defines model for UpdateSubnet.
type UpdateSubnet struct {
	// MapPublicIpOnLaunch If true, a public IP is assigned to the network interface cards (NICs) created in the specified Subnet.
	MapPublicIpOnLaunch bool `json:"mapPublicIpOnLaunch"`
}

// UpdateVm defines model for UpdateVm.
type UpdateVm struct {
	// BlockDeviceMappings One or more block device mappings of the VM.
	BlockDeviceMappings *[]BlockDeviceMappingVmUpdate `json:"blockDeviceMappings,omitempty"`

	// BsuOptimized This parameter is not available. It is present in our API for the sake of historical compatibility with AWS.
	BsuOptimized *bool `json:"bsuOptimized,omitempty"`

	// DeletionProtection If true, you cannot delete the VM unless you change this parameter back to false.
	DeletionProtection *bool `json:"deletionProtection,omitempty"`

	// IsSourceDestChecked (Net only) If true, the source/destination check is enabled. If false, it is disabled. This value must be false for a NAT VM to perform network address translation (NAT) in a Net.
	IsSourceDestChecked *bool `json:"isSourceDestChecked,omitempty"`

	// KeypairName The name of a keypair you want to associate with the VM.<br />
	// When you replace the keypair of a VM with another one, the metadata of the VM is modified to reflect the new public key, but the replacement is still not effective in the operating system of the VM. To complete the replacement and effectively apply the new keypair, you need to perform other actions inside the VM.
	KeypairName *string `json:"keypairName,omitempty"`

	// NestedVirtualization (dedicated tenancy only) If true, nested virtualization is enabled. If false, it is disabled.
	NestedVirtualization *bool `json:"nestedVirtualization,omitempty"`

	// Performance The performance of the VM (`medium` \| `high` \|  `highest`).
	Performance *UpdateVmPerformance `json:"performance,omitempty"`

	// SecurityGroupIds One or more IDs of security groups for the VM.
	SecurityGroupIds *[]string `json:"securityGroupIds,omitempty"`

	// Type The type of VM.
	Type *string `json:"type,omitempty"`

	// UserData The Base64-encoded MIME user data, limited to 500 kibibytes (KiB).
	UserData *string `json:"userData,omitempty"`

	// VmInitiatedShutdownBehavior The VM behavior when you stop it. If set to `stop`, the VM stops. If set to `restart`, the VM stops then automatically restarts. If set to `terminate`, the VM stops and is terminated.
	VmInitiatedShutdownBehavior *string `json:"vmInitiatedShutdownBehavior,omitempty"`
}

// UpdateVmPerformance The performance of the VM (`medium` \| `high` \|  `highest`).
type UpdateVmPerformance string

// UpdateVolume defines model for UpdateVolume.
type UpdateVolume struct {
	// Iops **Cold volume**: the new number of I/O operations per second (IOPS). This parameter can be specified only if you update an `io1` volume or if you change the type of the volume for an `io1`. This modification is instantaneous. <br />
	// **Hot volume**: the new number of I/O operations per second (IOPS). This parameter can be specified only if you update an `io1` volume. This modification is not instantaneous. <br /><br />
	//  The maximum number of IOPS allowed for `io1` volumes is `13000` with a maximum performance ratio of 300 IOPS per gibibyte.
	Iops *int `json:"iops,omitempty"`

	// Size **Cold volume**: the new size of the volume, in gibibytes (GiB). This value must be equal to or greater than the current size of the volume. This modification is not instantaneous. <br />
	// **Hot volume**: you cannot change the size of a hot volume.
	Size *int `json:"size,omitempty"`

	// VolumeType **Cold volume**: the new type of the volume (`standard` \ | `io1` \| `gp2`). This modification is instantaneous. If you update to an `io1` volume, you must also specify the `Iops` parameter.<br />
	//  **Hot volume**: you cannot change the type of a hot volume.
	VolumeType *string `json:"volumeType,omitempty"`
}

// UpdateVpc defines model for UpdateVpc.
type UpdateVpc struct {
	// DhcpOptionsSetId The ID of the DHCP options set (or `default` if you want to associate the default one).
	DhcpOptionsSetId string `json:"dhcpOptionsSetId"`
}

// UpdateVpcAccessPoint defines model for UpdateVpcAccessPoint.
type UpdateVpcAccessPoint struct {
	// AddRouteTableIds One or more IDs of route tables to associate with the specified Net access point.
	AddRouteTableIds *[]string `json:"addRouteTableIds,omitempty"`

	// RemoveRouteTableIds One or more IDs of route tables to disassociate from the specified Net access point.
	RemoveRouteTableIds *[]string `json:"removeRouteTableIds,omitempty"`
}

// UpdateVpnConnection defines model for UpdateVpnConnection.
type UpdateVpnConnection struct {
	// ClientGatewayId The ID of the client gateway.
	ClientGatewayId *string `json:"clientGatewayId,omitempty"`

	// VirtualGatewayId The ID of the virtual gateway.
	VirtualGatewayId *string `json:"virtualGatewayId,omitempty"`

	// VpnOptions Information about the VPN options.
	VpnOptions *VpnOptionsToUpdate `json:"vpnOptions,omitempty"`
}

// Url defines model for Url.
type Url = string

// VgwTelemetry Information about the current state of a VPN tunnel.
type VgwTelemetry struct {
	// AcceptedRouteCount The number of routes accepted through BGP (Border Gateway Protocol) route exchanges.
	AcceptedRouteCount *int `json:"acceptedRouteCount,omitempty"`

	// LastStateChangeDate The date and time (UTC) of the latest state update.
	LastStateChangeDate *time.Time `json:"lastStateChangeDate,omitempty"`

	// OutsideIpAddress The IP on the NumSpot side of the tunnel.
	OutsideIpAddress *string `json:"outsideIpAddress,omitempty"`

	// State The state of the IPSEC tunnel (`UP` \| `DOWN`).
	State *string `json:"state,omitempty"`

	// StateDescription A description of the current state of the tunnel.
	StateDescription *string `json:"stateDescription,omitempty"`
}

// VirtualGateway Information about the virtual gateway.
type VirtualGateway struct {
	// ConnectionType The type of VPN connection supported by the virtual gateway (only `ipsec.1` is supported).
	ConnectionType *string `json:"connectionType,omitempty"`

	// Id The ID of the virtual gateway.
	Id *string `json:"id,omitempty"`

	// State The state of the virtual gateway (`pending` \| `available` \| `deleting` \| `deleted`).
	State *string `json:"state,omitempty"`

	// Tags One or more tags associated with the virtual gateway.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// VpcToVirtualGatewayLinks The Net to which the virtual gateway is attached.
	VpcToVirtualGatewayLinks *[]VpcToVirtualGatewayLink `json:"vpcToVirtualGatewayLinks,omitempty"`
}

// Vm Information about the VM.
type Vm struct {
	// Architecture The architecture of the VM (`i386` \| `x86_64`).
	Architecture *string `json:"architecture,omitempty"`

	// BlockDeviceMappings The block device mapping of the VM.
	BlockDeviceMappings *[]BlockDeviceMappingCreated `json:"blockDeviceMappings,omitempty"`

	// BsuOptimized This parameter is not available. It is present in our API for the sake of historical compatibility with AWS.
	BsuOptimized *bool `json:"bsuOptimized,omitempty"`

	// ClientToken The idempotency token provided when launching the VM.
	ClientToken *string `json:"clientToken,omitempty"`

	// CreationDate The date and time of creation of the VM.
	CreationDate *time.Time `json:"creationDate,omitempty"`

	// DeletionProtection If true, you cannot delete the VM unless you change this parameter back to false.
	DeletionProtection *bool `json:"deletionProtection,omitempty"`

	// Hypervisor The hypervisor type of the VMs (`ovm` \| `xen`).
	Hypervisor *string `json:"hypervisor,omitempty"`

	// Id The ID of the VM.
	Id *string `json:"id,omitempty"`

	// ImageId The ID of the OMI used to create the VM.
	ImageId *string `json:"imageId,omitempty"`

	// InitiatedShutdownBehavior The VM behavior when you stop it. If set to `stop`, the VM stops. If set to `restart`, the VM stops then automatically restarts. If set to `terminate`, the VM stops and is deleted.
	InitiatedShutdownBehavior *string `json:"initiatedShutdownBehavior,omitempty"`

	// IsSourceDestChecked (Net only) If true, the source/destination check is enabled. If false, it is disabled. This value must be false for a NAT VM to perform network address translation (NAT) in a Net.
	IsSourceDestChecked *bool `json:"isSourceDestChecked,omitempty"`

	// KeypairName The name of the keypair used when launching the VM.
	KeypairName *string `json:"keypairName,omitempty"`

	// LaunchNumber The number for the VM when launching a group of several VMs (for example, `0`, `1`, `2`, and so on).
	LaunchNumber *int `json:"launchNumber,omitempty"`

	// NestedVirtualization If true, nested virtualization is enabled. If false, it is disabled.
	NestedVirtualization *bool `json:"nestedVirtualization,omitempty"`

	// Nics (Net only) The network interface cards (NICs) the VMs are attached to.
	Nics *[]NicLight `json:"nics,omitempty"`

	// OsFamily Indicates the operating system (OS) of the VM.
	OsFamily *string `json:"osFamily,omitempty"`

	// Performance The performance of the VM (`medium` \| `high` \|  `highest`).
	Performance *string `json:"performance,omitempty"`

	// Placement Information about the placement of the VM.
	Placement *Placement `json:"placement,omitempty"`

	// PrivateDnsName The name of the private DNS.
	PrivateDnsName *string `json:"privateDnsName,omitempty"`

	// PrivateIp The primary private IP of the VM.
	PrivateIp *string `json:"privateIp,omitempty"`

	// ProductCodes The product codes associated with the OMI used to create the VM.
	ProductCodes *[]string `json:"productCodes,omitempty"`

	// PublicDnsName The name of the public DNS.
	PublicDnsName *string `json:"publicDnsName,omitempty"`

	// PublicIp The public IP of the VM.
	PublicIp *string `json:"publicIp,omitempty"`

	// ReservationId The reservation ID of the VM.
	ReservationId *string `json:"reservationId,omitempty"`

	// RootDeviceName The name of the root device for the VM (for example, `/dev/sda1`).
	RootDeviceName *string `json:"rootDeviceName,omitempty"`

	// RootDeviceType The type of root device used by the VM (always `bsu`).
	RootDeviceType *string `json:"rootDeviceType,omitempty"`

	// SecurityGroups One or more security groups associated with the VM.
	SecurityGroups *[]SecurityGroupLight `json:"securityGroups,omitempty"`

	// State The state of the VM (`pending` \| `running` \| `stopping` \| `stopped` \| `shutting-down` \| `terminated` \| `quarantine`).
	State *string `json:"state,omitempty"`

	// StateReason The reason explaining the current state of the VM.
	StateReason *string `json:"stateReason,omitempty"`

	// SubnetId The ID of the Subnet for the VM.
	SubnetId *string `json:"subnetId,omitempty"`

	// Tags One or more tags associated with the VM.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// Type The type of VM.
	Type *string `json:"type,omitempty"`

	// UserData The Base64-encoded MIME user data.
	UserData *string `json:"userData,omitempty"`

	// VpcId The ID of the Net in which the VM is running.
	VpcId *string `json:"vpcId,omitempty"`
}

// VmState Information about the state of the VM.
type VmState struct {
	// CurrentState The current state of the VM (`InService` \| `OutOfService` \| `Unknown`).
	CurrentState *string `json:"currentState,omitempty"`

	// Id The ID of the VM.
	Id *string `json:"id,omitempty"`

	// PreviousState The previous state of the VM (`InService` \| `OutOfService` \| `Unknown`).
	PreviousState *string `json:"previousState,omitempty"`
}

// VmStates Information about the states of the VMs.
type VmStates struct {
	// AvailabilityZoneName The name of the Subregion of the VM.
	AvailabilityZoneName *string `json:"availabilityZoneName,omitempty"`

	// Id The ID of the VM.
	Id *string `json:"id,omitempty"`

	// MaintenanceEvents One or more scheduled events associated with the VM.
	MaintenanceEvents *[]MaintenanceEvent `json:"maintenanceEvents,omitempty"`

	// VmState The state of the VM (`pending` \| `running` \| `stopping` \| `stopped` \| `shutting-down` \| `terminated` \| `quarantine`).
	VmState *string `json:"vmState,omitempty"`
}

// Volume Information about the volume.
type Volume struct {
	// AvailabilityZoneName The Subregion in which the volume was created.
	AvailabilityZoneName *string `json:"availabilityZoneName,omitempty"`

	// CreationDate The date and time of creation of the volume.
	CreationDate *time.Time `json:"creationDate,omitempty"`

	// Id The ID of the volume.
	Id *string `json:"id,omitempty"`

	// Iops The number of I/O operations per second (IOPS):<br />
	// - For `io1` volumes, the number of provisioned IOPS<br />
	// - For `gp2` volumes, the baseline performance of the volume
	Iops *int `json:"iops,omitempty"`

	// LinkedVolumes Information about your volume attachment.
	LinkedVolumes *[]LinkedVolume `json:"linkedVolumes,omitempty"`

	// Size The size of the volume, in gibibytes (GiB).
	Size *int `json:"size,omitempty"`

	// SnapshotId The snapshot from which the volume was created.
	SnapshotId *string `json:"snapshotId,omitempty"`

	// State The state of the volume (`creating` \| `available` \| `in-use` \| `updating` \| `deleting` \| `error`).
	State *string `json:"state,omitempty"`

	// Tags One or more tags associated with the volume.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// Type The type of the volume (`standard` \| `gp2` \| `io1`).
	Type *string `json:"type,omitempty"`
}

// Vpc Information about the Net.
type Vpc struct {
	// DhcpOptionsSetId The ID of the DHCP options set (or `default` if you want to associate the default one).
	DhcpOptionsSetId *string `json:"dhcpOptionsSetId,omitempty"`

	// Id The ID of the Net.
	Id *string `json:"id,omitempty"`

	// IpRange The IP range for the Net, in CIDR notation (for example, `10.0.0.0/16`).
	IpRange *string `json:"ipRange,omitempty"`

	// State The state of the Net (`pending` \| `available` \| `deleting`).
	State *string `json:"state,omitempty"`

	// Tags One or more tags associated with the Net.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// Tenancy The VM tenancy in a Net.
	Tenancy *string `json:"tenancy,omitempty"`
}

// VpcAccessPoint Information about the Net access point.
type VpcAccessPoint struct {
	// Id The ID of the Net access point.
	Id *string `json:"id,omitempty"`

	// RouteTableIds The ID of the route tables associated with the Net access point.
	RouteTableIds *[]string `json:"routeTableIds,omitempty"`

	// ServiceName The name of the service with which the Net access point is associated.
	ServiceName *string `json:"serviceName,omitempty"`

	// State The state of the Net access point (`pending` \| `available` \| `deleting` \| `deleted`).
	State *string `json:"state,omitempty"`

	// Tags One or more tags associated with the Net access point.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// VpcId The ID of the Net with which the Net access point is associated.
	VpcId *string `json:"vpcId,omitempty"`
}

// VpcPeering Information about the Net peering.
type VpcPeering struct {
	// AccepterVpc Information about the accepter Net.
	AccepterVpc *AccepterVpc `json:"accepterVpc,omitempty"`

	// ExpirationDate The date and time at which the Net peerings expire.
	ExpirationDate *time.Time `json:"expirationDate"`

	// Id The ID of the Net peering.
	Id *string `json:"id,omitempty"`

	// SourceVpc Information about the source Net.
	SourceVpc *SourceVpc `json:"sourceVpc,omitempty"`

	// State Information about the state of the Net peering.
	State *VpcPeeringState `json:"state,omitempty"`

	// Tags One or more tags associated with the Net peering.
	Tags *[]ResourceTag `json:"tags,omitempty"`
}

// VpcPeeringState Information about the state of the Net peering.
type VpcPeeringState struct {
	// Message Additional information about the state of the Net peering.
	Message *string `json:"message,omitempty"`

	// Name The state of the Net peering (`pending-acceptance` \| `active` \| `rejected` \| `failed` \| `expired` \| `deleted`).
	Name *string `json:"name,omitempty"`
}

// VpcToVirtualGatewayLink Information about the attachment.
type VpcToVirtualGatewayLink struct {
	// State The state of the attachment (`attaching` \| `attached` \| `detaching` \| `detached`).
	State *string `json:"state,omitempty"`

	// VpcId The ID of the Net to which the virtual gateway is attached.
	VpcId *string `json:"vpcId,omitempty"`
}

// VpnConnection Information about a VPN connection.
type VpnConnection struct {
	// ClientGatewayConfiguration Example configuration for the client gateway.
	ClientGatewayConfiguration *string `json:"clientGatewayConfiguration,omitempty"`

	// ClientGatewayId The ID of the client gateway used on the client end of the connection.
	ClientGatewayId *string `json:"clientGatewayId,omitempty"`

	// ConnectionType The type of VPN connection (always `ipsec.1`).
	ConnectionType *string `json:"connectionType,omitempty"`

	// Id The ID of the VPN connection.
	Id *string `json:"id,omitempty"`

	// Routes Information about one or more static routes associated with the VPN connection, if any.
	Routes *[]RouteLight `json:"routes,omitempty"`

	// State The state of the VPN connection (`pending` \| `available` \| `deleting` \| `deleted`).
	State *string `json:"state,omitempty"`

	// StaticRoutesOnly If false, the VPN connection uses dynamic routing with Border Gateway Protocol (BGP). If true, routing is controlled using static routes. For more information about how to create and delete static routes, see [CreateVpnConnectionRoute](#createvpnconnectionroute) and [DeleteVpnConnectionRoute](#deletevpnconnectionroute).
	StaticRoutesOnly *bool `json:"staticRoutesOnly,omitempty"`

	// Tags One or more tags associated with the VPN connection.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// VgwTelemetries Information about the current state of one or more of the VPN tunnels.
	VgwTelemetries *[]VgwTelemetry `json:"vgwTelemetries,omitempty"`

	// VirtualGatewayId The ID of the virtual gateway used on the NumSpot end of the connection.
	VirtualGatewayId *string `json:"virtualGatewayId,omitempty"`

	// VpnOptions Information about the VPN options.
	VpnOptions *VpnOptions `json:"vpnOptions,omitempty"`
}

// VpnOptions Information about the VPN options.
type VpnOptions struct {
	// Phase1Options Information about Phase 1 of the Internet Key Exchange (IKE) negotiation. When Phase 1 finishes successfully, peers proceed to Phase 2 negotiations.
	Phase1Options *Phase1Options `json:"phase1Options,omitempty"`

	// Phase2Options Information about Phase 2 of the Internet Key Exchange (IKE) negotiation.
	Phase2Options *Phase2Options `json:"phase2Options,omitempty"`

	// TunnelInsideIpRange The range of inside IPs for the tunnel. This must be a /30 CIDR block from the 169.254.254.0/24 range.
	TunnelInsideIpRange *string `json:"tunnelInsideIpRange,omitempty"`
}

// VpnOptionsToUpdate Information about the VPN options.
type VpnOptionsToUpdate struct {
	// Phase2Options Information about Phase 2 of the Internet Key Exchange (IKE) negotiation.
	Phase2Options *Phase2OptionsToUpdate `json:"phase2Options,omitempty"`

	// TunnelInsideIpRange The range of inside IPs for the tunnel. This must be a /30 CIDR block from the 169.254.254.0/24 range.
	TunnelInsideIpRange *string `json:"tunnelInsideIpRange,omitempty"`
}

// SpaceId defines model for SpaceId.
type SpaceId = openapi_types.UUID

// AcceptVpcPeeringResponseSchema defines model for AcceptVpcPeeringResponse.
type AcceptVpcPeeringResponseSchema = AcceptVpcPeering

// CreateClientGatewayResponseSchema Information about the client gateway.
type CreateClientGatewayResponseSchema = ClientGateway

// CreateDhcpOptionsResponseSchema Information about the DHCP options set.
type CreateDhcpOptionsResponseSchema = DhcpOptionsSet

// CreateDirectLinkInterfaceResponseSchema Information about the DirectLink interfaces.
type CreateDirectLinkInterfaceResponseSchema = DirectLinkInterfaces

// CreateDirectLinkResponseSchema Information about the DirectLink.
type CreateDirectLinkResponseSchema = DirectLink

// CreateFlexibleGpuResponseSchema Information about the flexible GPU (fGPU).
type CreateFlexibleGpuResponseSchema = FlexibleGpu

// CreateImageResponseSchema Information about the OMI.
type CreateImageResponseSchema = Image

// CreateInternetGatewayResponseSchema Information about the Internet service.
type CreateInternetGatewayResponseSchema = InternetGateway

// CreateKeypairResponseSchema Information about the created keypair.
type CreateKeypairResponseSchema = CreateKeypair

// CreateListenerRuleResponseSchema Information about the listener rule.
type CreateListenerRuleResponseSchema = ListenerRule

// CreateLoadBalancerListenersResponseSchema Information about the load balancer.
type CreateLoadBalancerListenersResponseSchema = LoadBalancer

// CreateLoadBalancerPolicyResponseSchema Information about the load balancer.
type CreateLoadBalancerPolicyResponseSchema = LoadBalancer

// CreateLoadBalancerResponseSchema Information about the load balancer.
type CreateLoadBalancerResponseSchema = LoadBalancer

// CreateNatGatewayResponseSchema Information about the NAT service.
type CreateNatGatewayResponseSchema = NatGateway

// CreateNicResponseSchema Information about the NIC.
type CreateNicResponseSchema = Nic

// CreatePublicIpResponseSchema Information about the public IP.
type CreatePublicIpResponseSchema = PublicIp

// CreateRouteResponseSchema Information about the route table.
type CreateRouteResponseSchema = RouteTable

// CreateRouteTableResponseSchema Information about the route table.
type CreateRouteTableResponseSchema = RouteTable

// CreateSecurityGroupResponseSchema Information about the security group.
type CreateSecurityGroupResponseSchema = SecurityGroup

// CreateSecurityGroupRuleResponseSchema Information about the security group.
type CreateSecurityGroupRuleResponseSchema = SecurityGroup

// CreateSnapshotResponseSchema Information about the snapshot.
type CreateSnapshotResponseSchema = Snapshot

// CreateSubnetResponseSchema Information about the Subnet.
type CreateSubnetResponseSchema = Subnet

// CreateVirtualGatewayResponseSchema Information about the virtual gateway.
type CreateVirtualGatewayResponseSchema = VirtualGateway

// CreateVmsResponseSchema Information about the VM.
type CreateVmsResponseSchema = Vm

// CreateVolumeResponseSchema Information about the volume.
type CreateVolumeResponseSchema = Volume

// CreateVpcAccessPointResponseSchema Information about the Net access point.
type CreateVpcAccessPointResponseSchema = VpcAccessPoint

// CreateVpcPeeringResponseSchema Information about the Net peering.
type CreateVpcPeeringResponseSchema = VpcPeering

// CreateVpcResponseSchema Information about the Net.
type CreateVpcResponseSchema = Vpc

// CreateVpnConnectionResponseSchema Information about a VPN connection.
type CreateVpnConnectionResponseSchema = VpnConnection

// LinkNicResponseSchema defines model for LinkNicResponse.
type LinkNicResponseSchema struct {
	// LinkNicId The ID of the NIC attachment.
	LinkNicId *string `json:"linkNicId,omitempty"`
}

// LinkPublicIpResponseSchema defines model for LinkPublicIpResponse.
type LinkPublicIpResponseSchema struct {
	// LinkPublicIpId (Net only) The ID representing the association of the public IP with the VM or the NIC.
	LinkPublicIpId *string `json:"linkPublicIpId,omitempty"`
}

// LinkRouteTableResponseSchema defines model for LinkRouteTableResponse.
type LinkRouteTableResponseSchema struct {
	// LinkRouteTableId The ID of the association between the route table and the Subnet.
	LinkRouteTableId *string `json:"linkRouteTableId,omitempty"`
}

// LinkVirtualGatewayToVpcResponseSchema defines model for LinkVirtualGatewayToVpcResponse.
type LinkVirtualGatewayToVpcResponseSchema = LinkVirtualGatewayToVpc

// ReadAdminPasswordResponseSchema defines model for ReadAdminPasswordResponse.
type ReadAdminPasswordResponseSchema = ReadAdminPassword

// ReadClientGatewaysByIdResponseSchema Information about the client gateway.
type ReadClientGatewaysByIdResponseSchema = ClientGateway

// ReadClientGatewaysResponseSchema defines model for ReadClientGatewaysResponse.
type ReadClientGatewaysResponseSchema = ReadClientGateways

// ReadConsoleOutputResponseSchema defines model for ReadConsoleOutputResponse.
type ReadConsoleOutputResponseSchema = ReadConsoleOutput

// ReadDhcpOptionsByIdResponseSchema Information about the DHCP options set.
type ReadDhcpOptionsByIdResponseSchema = DhcpOptionsSet

// ReadDhcpOptionsResponseSchema defines model for ReadDhcpOptionsResponse.
type ReadDhcpOptionsResponseSchema = ReadDhcpOptions

// ReadDirectLinkInterfacesByIdResponseSchema Information about the DirectLink interfaces.
type ReadDirectLinkInterfacesByIdResponseSchema = DirectLinkInterfaces

// ReadDirectLinkInterfacesResponseSchema defines model for ReadDirectLinkInterfacesResponse.
type ReadDirectLinkInterfacesResponseSchema = ReadDirectLinkInterfaces

// ReadDirectLinksByIdResponseSchema Information about the DirectLink.
type ReadDirectLinksByIdResponseSchema = DirectLink

// ReadDirectLinksResponseSchema defines model for ReadDirectLinksResponse.
type ReadDirectLinksResponseSchema = ReadDirectLinks

// ReadFlexibleGpuCatalogResponseSchema defines model for ReadFlexibleGpuCatalogResponse.
type ReadFlexibleGpuCatalogResponseSchema = ReadFlexibleGpuCatalog

// ReadFlexibleGpusByIdResponseSchema Information about the flexible GPU (fGPU).
type ReadFlexibleGpusByIdResponseSchema = FlexibleGpu

// ReadFlexibleGpusResponseSchema defines model for ReadFlexibleGpusResponse.
type ReadFlexibleGpusResponseSchema = ReadFlexibleGpus

// ReadImagesByIdResponseSchema Information about the OMI.
type ReadImagesByIdResponseSchema = Image

// ReadImagesResponseSchema defines model for ReadImagesResponse.
type ReadImagesResponseSchema = ReadImages

// ReadInternetGatewaysByIdResponseSchema Information about the Internet service.
type ReadInternetGatewaysByIdResponseSchema = InternetGateway

// ReadInternetGatewaysResponseSchema defines model for ReadInternetGatewaysResponse.
type ReadInternetGatewaysResponseSchema = ReadInternetGateways

// ReadKeypairsByIdResponseSchema Information about the keypair.
type ReadKeypairsByIdResponseSchema = ReadKeypairsById

// ReadKeypairsResponseSchema defines model for ReadKeypairsResponse.
type ReadKeypairsResponseSchema = ReadKeypairs

// ReadListenerRulesByIdResponseSchema Information about the listener rule.
type ReadListenerRulesByIdResponseSchema = ListenerRule

// ReadListenerRulesResponseSchema defines model for ReadListenerRulesResponse.
type ReadListenerRulesResponseSchema = ReadListenerRules

// ReadLoadBalancerTagsResponseSchema defines model for ReadLoadBalancerTagsResponse.
type ReadLoadBalancerTagsResponseSchema = ReadLoadBalancerTags

// ReadLoadBalancersByIdResponseSchema Information about the load balancer.
type ReadLoadBalancersByIdResponseSchema = LoadBalancer

// ReadLoadBalancersResponseSchema defines model for ReadLoadBalancersResponse.
type ReadLoadBalancersResponseSchema = ReadLoadBalancers

// ReadLocationsResponseSchema defines model for ReadLocationsResponse.
type ReadLocationsResponseSchema = ReadLocations

// ReadNatGatewayByIdResponseSchema Information about the NAT service.
type ReadNatGatewayByIdResponseSchema = NatGateway

// ReadNatGatewayResponseSchema defines model for ReadNatGatewayResponse.
type ReadNatGatewayResponseSchema = ReadNatGateway

// ReadNicsByIdResponseSchema Information about the NIC.
type ReadNicsByIdResponseSchema = Nic

// ReadNicsResponseSchema defines model for ReadNicsResponse.
type ReadNicsResponseSchema = ReadNics

// ReadProductTypesByIdResponseSchema Information about the product type.
type ReadProductTypesByIdResponseSchema = ReadProductTypesById

// ReadProductTypesResponseSchema defines model for ReadProductTypesResponse.
type ReadProductTypesResponseSchema = ReadProductTypes

// ReadPublicIpRangesResponseSchema defines model for ReadPublicIpRangesResponse.
type ReadPublicIpRangesResponseSchema = ReadPublicIpRanges

// ReadPublicIpsByIdResponseSchema Information about the public IP.
type ReadPublicIpsByIdResponseSchema = PublicIp

// ReadPublicIpsResponseSchema defines model for ReadPublicIpsResponse.
type ReadPublicIpsResponseSchema = ReadPublicIps

// ReadRouteTablesByIdResponseSchema Information about the route table.
type ReadRouteTablesByIdResponseSchema = RouteTable

// ReadRouteTablesResponseSchema defines model for ReadRouteTablesResponse.
type ReadRouteTablesResponseSchema = ReadRouteTables

// ReadSecurityGroupsByIdResponseSchema Information about the security group.
type ReadSecurityGroupsByIdResponseSchema = SecurityGroup

// ReadSecurityGroupsResponseSchema defines model for ReadSecurityGroupsResponse.
type ReadSecurityGroupsResponseSchema = ReadSecurityGroups

// ReadSnapshotsByIdResponseSchema Information about the snapshot.
type ReadSnapshotsByIdResponseSchema = Snapshot

// ReadSnapshotsResponseSchema defines model for ReadSnapshotsResponse.
type ReadSnapshotsResponseSchema = ReadSnapshots

// ReadSubnetsByIdResponseSchema Information about the Subnet.
type ReadSubnetsByIdResponseSchema = Subnet

// ReadSubnetsResponseSchema defines model for ReadSubnetsResponse.
type ReadSubnetsResponseSchema = ReadSubnets

// ReadTagsResponseSchema defines model for ReadTagsResponse.
type ReadTagsResponseSchema = ReadTags

// ReadVirtualGatewaysByIdResponseSchema Information about the virtual gateway.
type ReadVirtualGatewaysByIdResponseSchema = VirtualGateway

// ReadVirtualGatewaysResponseSchema defines model for ReadVirtualGatewaysResponse.
type ReadVirtualGatewaysResponseSchema = ReadVirtualGateways

// ReadVmsByIdResponseSchema Information about the VM.
type ReadVmsByIdResponseSchema = Vm

// ReadVmsHealthResponseSchema defines model for ReadVmsHealthResponse.
type ReadVmsHealthResponseSchema = ReadVmsHealth

// ReadVmsResponseSchema defines model for ReadVmsResponse.
type ReadVmsResponseSchema = ReadVms

// ReadVmsStateResponseSchema defines model for ReadVmsStateResponse.
type ReadVmsStateResponseSchema = ReadVmsState

// ReadVolumesByIdResponseSchema Information about the volume.
type ReadVolumesByIdResponseSchema = Volume

// ReadVolumesResponseSchema defines model for ReadVolumesResponse.
type ReadVolumesResponseSchema = ReadVolumes

// ReadVpcAccessPointsByIdResponseSchema Information about the Net access point.
type ReadVpcAccessPointsByIdResponseSchema = VpcAccessPoint

// ReadVpcAccessPointsResponseSchema defines model for ReadVpcAccessPointsResponse.
type ReadVpcAccessPointsResponseSchema = ReadVpcAccessPoints

// ReadVpcPeeringsByIdResponseSchema Information about the Net peering.
type ReadVpcPeeringsByIdResponseSchema = VpcPeering

// ReadVpcPeeringsResponseSchema defines model for ReadVpcPeeringsResponse.
type ReadVpcPeeringsResponseSchema = ReadVpcPeerings

// ReadVpcsByIdResponseSchema Information about the Net.
type ReadVpcsByIdResponseSchema = Vpc

// ReadVpcsResponseSchema defines model for ReadVpcsResponse.
type ReadVpcsResponseSchema = ReadVpcs

// ReadVpnConnectionsByIdResponseSchema Information about a VPN connection.
type ReadVpnConnectionsByIdResponseSchema = VpnConnection

// ReadVpnConnectionsResponseSchema defines model for ReadVpnConnectionsResponse.
type ReadVpnConnectionsResponseSchema = ReadVpnConnections

// StartVmResponseSchema Information about the state of the VM.
type StartVmResponseSchema = VmState

// StopVmResponseSchema Information about the state of the VM.
type StopVmResponseSchema = VmState

// UpdateDirectLinkInterfaceResponseSchema Information about the DirectLink interfaces.
type UpdateDirectLinkInterfaceResponseSchema = DirectLinkInterfaces

// UpdateFlexibleGpuResponseSchema Information about the flexible GPU (fGPU).
type UpdateFlexibleGpuResponseSchema = FlexibleGpu

// UpdateImageResponseSchema Information about the OMI.
type UpdateImageResponseSchema = Image

// UpdateListenerRuleResponseSchema Information about the listener rule.
type UpdateListenerRuleResponseSchema = ListenerRule

// UpdateLoadBalancerResponseSchema Information about the load balancer.
type UpdateLoadBalancerResponseSchema = LoadBalancer

// UpdateNicResponseSchema Information about the NIC.
type UpdateNicResponseSchema = Nic

// UpdateRouteResponseSchema Information about the route table.
type UpdateRouteResponseSchema = RouteTable

// UpdateRouteTableRoutePropagationResponseSchema Information about the route table.
type UpdateRouteTableRoutePropagationResponseSchema = RouteTable

// UpdateSubnetResponseSchema Information about the Subnet.
type UpdateSubnetResponseSchema = Subnet

// UpdateVmResponseSchema Information about the VM.
type UpdateVmResponseSchema = Vm

// UpdateVolumeResponseSchema Information about the volume.
type UpdateVolumeResponseSchema = Volume

// UpdateVpcAccessPointResponseSchema Information about the Net access point.
type UpdateVpcAccessPointResponseSchema = VpcAccessPoint

// UpdateVpcResponseSchema Information about the Net.
type UpdateVpcResponseSchema = Vpc

// UpdateVpnConnectionResponseSchema Information about a VPN connection.
type UpdateVpnConnectionResponseSchema = VpnConnection

// CreateClientGatewayRequest defines model for CreateClientGatewayRequest.
type CreateClientGatewayRequest = CreateClientGateway

// CreateDhcpOptionsRequest defines model for CreateDhcpOptionsRequest.
type CreateDhcpOptionsRequest = CreateDhcpOptions

// CreateDirectLinkInterfaceRequest defines model for CreateDirectLinkInterfaceRequest.
type CreateDirectLinkInterfaceRequest = CreateDirectLinkInterface

// CreateDirectLinkRequest defines model for CreateDirectLinkRequest.
type CreateDirectLinkRequest = CreateDirectLink

// CreateFlexibleGpuRequest defines model for CreateFlexibleGpuRequest.
type CreateFlexibleGpuRequest = CreateFlexibleGpu

// CreateImageRequest defines model for CreateImageRequest.
type CreateImageRequest = CreateImage

// CreateKeypairRequest defines model for CreateKeypairRequest.
type CreateKeypairRequest struct {
	// Name A unique name for the keypair, with a maximum length of 255 [ASCII printable characters](https://en.wikipedia.org/wiki/ASCII#Printable_characters).
	Name string `json:"name"`

	// PublicKey The public key to import in your account, if you are importing an existing keypair. This value must be Base64-encoded.
	PublicKey *string `json:"publicKey,omitempty"`
}

// CreateListenerRuleRequest defines model for CreateListenerRuleRequest.
type CreateListenerRuleRequest = CreateListenerRule

// CreateLoadBalancerListenersRequest defines model for CreateLoadBalancerListenersRequest.
type CreateLoadBalancerListenersRequest = CreateLoadBalancerListeners

// CreateLoadBalancerPolicyRequest defines model for CreateLoadBalancerPolicyRequest.
type CreateLoadBalancerPolicyRequest = CreateLoadBalancerPolicy

// CreateLoadBalancerRequest defines model for CreateLoadBalancerRequest.
type CreateLoadBalancerRequest = CreateLoadBalancer

// CreateLoadBalancerTagsRequest defines model for CreateLoadBalancerTagsRequest.
type CreateLoadBalancerTagsRequest = CreateLoadBalancerTags

// CreateNatGatewayRequest defines model for CreateNatGatewayRequest.
type CreateNatGatewayRequest = CreateNatGateway

// CreateNicRequest defines model for CreateNicRequest.
type CreateNicRequest = CreateNic

// CreateRouteRequest defines model for CreateRouteRequest.
type CreateRouteRequest = CreateRoute

// CreateRouteTableRequest defines model for CreateRouteTableRequest.
type CreateRouteTableRequest = CreateRouteTable

// CreateSecurityGroupRequest defines model for CreateSecurityGroupRequest.
type CreateSecurityGroupRequest = CreateSecurityGroup

// CreateSecurityGroupRuleRequest defines model for CreateSecurityGroupRuleRequest.
type CreateSecurityGroupRuleRequest = CreateSecurityGroupRule

// CreateSnapshotRequest defines model for CreateSnapshotRequest.
type CreateSnapshotRequest = CreateSnapshot

// CreateSubnetRequest defines model for CreateSubnetRequest.
type CreateSubnetRequest = CreateSubnet

// CreateTagsRequest defines model for CreateTagsRequest.
type CreateTagsRequest = CreateTags

// CreateVirtualGatewayRequest defines model for CreateVirtualGatewayRequest.
type CreateVirtualGatewayRequest = CreateVirtualGateway

// CreateVmsRequest defines model for CreateVmsRequest.
type CreateVmsRequest = CreateVms

// CreateVolumeRequest defines model for CreateVolumeRequest.
type CreateVolumeRequest = CreateVolume

// CreateVpcAccessPointRequest defines model for CreateVpcAccessPointRequest.
type CreateVpcAccessPointRequest = CreateVpcAccessPoint

// CreateVpcPeeringRequest defines model for CreateVpcPeeringRequest.
type CreateVpcPeeringRequest = CreateVpcPeering

// CreateVpcRequest defines model for CreateVpcRequest.
type CreateVpcRequest = CreateVpc

// CreateVpnConnectionRequest defines model for CreateVpnConnectionRequest.
type CreateVpnConnectionRequest = CreateVpnConnection

// CreateVpnConnectionRouteRequest defines model for CreateVpnConnectionRouteRequest.
type CreateVpnConnectionRouteRequest = CreateVpnConnectionRoute

// DeleteLoadBalancerListenersRequest defines model for DeleteLoadBalancerListenersRequest.
type DeleteLoadBalancerListenersRequest = DeleteLoadBalancerListeners

// DeleteLoadBalancerPolicyRequest defines model for DeleteLoadBalancerPolicyRequest.
type DeleteLoadBalancerPolicyRequest = DeleteLoadBalancerPolicy

// DeleteLoadBalancerTagsRequest defines model for DeleteLoadBalancerTagsRequest.
type DeleteLoadBalancerTagsRequest = DeleteLoadBalancerTags

// DeleteRouteRequest defines model for DeleteRouteRequest.
type DeleteRouteRequest = DeleteRoute

// DeleteSecurityGroupRuleRequest defines model for DeleteSecurityGroupRuleRequest.
type DeleteSecurityGroupRuleRequest = DeleteSecurityGroupRule

// DeleteTagsRequest defines model for DeleteTagsRequest.
type DeleteTagsRequest = DeleteTags

// DeleteVpnConnectionRouteRequest defines model for DeleteVpnConnectionRouteRequest.
type DeleteVpnConnectionRouteRequest = DeleteVpnConnectionRoute

// LinkFlexibleGpuRequest defines model for LinkFlexibleGpuRequest.
type LinkFlexibleGpuRequest = LinkFlexibleGpu

// LinkInternetGatewayRequest defines model for LinkInternetGatewayRequest.
type LinkInternetGatewayRequest = LinkInternetGateway

// LinkLoadBalancerBackendMachinesRequest defines model for LinkLoadBalancerBackendMachinesRequest.
type LinkLoadBalancerBackendMachinesRequest = LinkLoadBalancerBackendMachines

// LinkNicRequest defines model for LinkNicRequest.
type LinkNicRequest struct {
	// DeviceNumber The index of the VM device for the NIC attachment (between `1` and `7`, both included).
	DeviceNumber int `json:"deviceNumber"`

	// VmId The ID of the VM to which you want to attach the NIC.
	VmId string `json:"vmId"`
}

// LinkPrivateIpsRequest defines model for LinkPrivateIpsRequest.
type LinkPrivateIpsRequest = LinkPrivateIps

// LinkPublicIpRequest defines model for LinkPublicIpRequest.
type LinkPublicIpRequest struct {
	// AllowRelink If true, allows the public IP to be associated with the VM or NIC that you specify even if it is already associated with another VM or NIC. If false, prevents the public IP from being associated with the VM or NIC that you specify if it is already associated with another VM or NIC. (By default, true in the public Cloud, false in a Net.)
	AllowRelink *bool `json:"allowRelink,omitempty"`

	// NicId (Net only) The ID of the NIC. This parameter is required if the VM has more than one NIC attached. Otherwise, you need to specify the `VmId` parameter instead. You cannot specify both parameters at the same time.
	NicId *string `json:"nicId,omitempty"`

	// PrivateIp (Net only) The primary or secondary private IP of the specified NIC. By default, the primary private IP.
	PrivateIp *string `json:"privateIp,omitempty"`

	// VmId The ID of the VM.<br />
	// - In the public Cloud, this parameter is required.<br />
	// - In a Net, this parameter is required if the VM has only one NIC. Otherwise, you need to specify the `NicId` parameter instead. You cannot specify both parameters at the same time.
	VmId *string `json:"vmId,omitempty"`
}

// LinkRouteTableRequest defines model for LinkRouteTableRequest.
type LinkRouteTableRequest struct {
	// SubnetId The ID of the Subnet.
	SubnetId string `json:"subnetId"`
}

// LinkVirtualGatewayToVpcRequest defines model for LinkVirtualGatewayToVpcRequest.
type LinkVirtualGatewayToVpcRequest struct {
	// VpcId The ID of the Net to which you want to attach the virtual gateway.
	VpcId string `json:"vpcId"`
}

// LinkVolumeRequest defines model for LinkVolumeRequest.
type LinkVolumeRequest = LinkVolume

// ReadLoadBalancerTagsRequest defines model for ReadLoadBalancerTagsRequest.
type ReadLoadBalancerTagsRequest struct {
	// Names One or more load balancer names.
	Names []string `json:"names"`
}

// ReadVmsHealthRequest defines model for ReadVmsHealthRequest.
type ReadVmsHealthRequest struct {
	// BackendVmIds One or more IDs of back-end VMs.
	BackendVmIds *[]string `json:"backendVmIds,omitempty"`
}

// StopVmRequest defines model for StopVmRequest.
type StopVmRequest = StopVm

// UnlinkInternetGatewayRequest defines model for UnlinkInternetGatewayRequest.
type UnlinkInternetGatewayRequest = UnlinkInternetGateway

// UnlinkLoadBalancerBackendMachinesRequest defines model for UnlinkLoadBalancerBackendMachinesRequest.
type UnlinkLoadBalancerBackendMachinesRequest = UnlinkLoadBalancerBackendMachines

// UnlinkNicRequest defines model for UnlinkNicRequest.
type UnlinkNicRequest = UnlinkNic

// UnlinkPrivateIpsRequest defines model for UnlinkPrivateIpsRequest.
type UnlinkPrivateIpsRequest = UnlinkPrivateIps

// UnlinkPublicIpRequest defines model for UnlinkPublicIpRequest.
type UnlinkPublicIpRequest = UnlinkPublicIp

// UnlinkRouteTableRequest defines model for UnlinkRouteTableRequest.
type UnlinkRouteTableRequest = UnlinkRouteTable

// UnlinkVirtualGatewayToVpcRequest defines model for UnlinkVirtualGatewayToVpcRequest.
type UnlinkVirtualGatewayToVpcRequest = UnlinkVirtualGatewayToVpc

// UnlinkVolumeRequest defines model for UnlinkVolumeRequest.
type UnlinkVolumeRequest = UnlinkVolume

// UpdateDirectLinkInterfaceRequest defines model for UpdateDirectLinkInterfaceRequest.
type UpdateDirectLinkInterfaceRequest = UpdateDirectLinkInterface

// UpdateFlexibleGpuRequest defines model for UpdateFlexibleGpuRequest.
type UpdateFlexibleGpuRequest = UpdateFlexibleGpu

// UpdateImageRequest defines model for UpdateImageRequest.
type UpdateImageRequest = UpdateImage

// UpdateListenerRuleRequest defines model for UpdateListenerRuleRequest.
type UpdateListenerRuleRequest = UpdateListenerRule

// UpdateLoadBalancerRequest defines model for UpdateLoadBalancerRequest.
type UpdateLoadBalancerRequest = UpdateLoadBalancer

// UpdateNicRequest defines model for UpdateNicRequest.
type UpdateNicRequest = UpdateNic

// UpdateRouteRequest defines model for UpdateRouteRequest.
type UpdateRouteRequest = UpdateRoute

// UpdateRouteTableRoutePropagationRequest defines model for UpdateRouteTableRoutePropagationRequest.
type UpdateRouteTableRoutePropagationRequest = UpdateRouteTableRoutePropagation

// UpdateSubnetRequest defines model for UpdateSubnetRequest.
type UpdateSubnetRequest = UpdateSubnet

// UpdateVmRequest defines model for UpdateVmRequest.
type UpdateVmRequest = UpdateVm

// UpdateVolumeRequest defines model for UpdateVolumeRequest.
type UpdateVolumeRequest = UpdateVolume

// UpdateVpcAccessPointRequest defines model for UpdateVpcAccessPointRequest.
type UpdateVpcAccessPointRequest = UpdateVpcAccessPoint

// UpdateVpcRequest defines model for UpdateVpcRequest.
type UpdateVpcRequest = UpdateVpc

// UpdateVpnConnectionRequest defines model for UpdateVpnConnectionRequest.
type UpdateVpnConnectionRequest = UpdateVpnConnection

// ReadClientGatewaysParams defines parameters for ReadClientGateways.
type ReadClientGatewaysParams struct {
	// BgpAsns The Border Gateway Protocol (BGP) Autonomous System Numbers (ASNs) of the connections.
	BgpAsns *[]int `form:"bgpAsns,omitempty" json:"bgpAsns,omitempty"`

	// ConnectionTypes The types of communication tunnels used by the client gateways (only `ipsec.1` is supported).
	ConnectionTypes *[]string `form:"connectionTypes,omitempty" json:"connectionTypes,omitempty"`

	// PublicIps The public IPv4 addresses of the client gateways.
	PublicIps *[]string `form:"publicIps,omitempty" json:"publicIps,omitempty"`

	// States The states of the client gateways (`pending` \| `available` \| `deleting` \| `deleted`).
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// TagKeys The keys of the tags associated with the client gateways.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the client gateways.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the client gateways, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// Ids The IDs of the client gateways.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`
}

// ReadDhcpOptionsParams defines parameters for ReadDhcpOptions.
type ReadDhcpOptionsParams struct {
	// Default If true, lists all default DHCP options set. If false, lists all non-default DHCP options set.
	Default *bool `form:"default,omitempty" json:"default,omitempty"`

	// DomainNameServers The IPs of the domain name servers used for the DHCP options sets.
	DomainNameServers *[]string `form:"domainNameServers,omitempty" json:"domainNameServers,omitempty"`

	// DomainNames The domain names used for the DHCP options sets.
	DomainNames *[]string `form:"domainNames,omitempty" json:"domainNames,omitempty"`

	// LogServers The IPs of the log servers used for the DHCP options sets.
	LogServers *[]string `form:"logServers,omitempty" json:"logServers,omitempty"`

	// NtpServers The IPs of the Network Time Protocol (NTP) servers used for the DHCP options sets.
	NtpServers *[]string `form:"ntpServers,omitempty" json:"ntpServers,omitempty"`

	// TagKeys The keys of the tags associated with the DHCP options sets.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the DHCP options sets.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the DHCP options sets, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// Ids The IDs of the DHCP options sets.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`
}

// ReadDirectLinkInterfacesParams defines parameters for ReadDirectLinkInterfaces.
type ReadDirectLinkInterfacesParams struct {
	// DirectLinkIds The IDs of the DirectLinks.
	DirectLinkIds *[]string `form:"directLinkIds,omitempty" json:"directLinkIds,omitempty"`

	// Ids The IDs of the DirectLink interfaces.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`
}

// ReadDirectLinksParams defines parameters for ReadDirectLinks.
type ReadDirectLinksParams struct {
	// Ids The IDs of the DirectLinks.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`
}

// ReadFlexibleGpusParams defines parameters for ReadFlexibleGpus.
type ReadFlexibleGpusParams struct {
	// DeleteOnVmDeletion Indicates whether the fGPU is deleted when terminating the VM.
	DeleteOnVmDeletion *bool `form:"deleteOnVmDeletion,omitempty" json:"deleteOnVmDeletion,omitempty"`

	// Generations The processor generations that the fGPUs are compatible with.
	Generations *[]string `form:"generations,omitempty" json:"generations,omitempty"`

	// ModelNames One or more models of fGPUs.
	ModelNames *[]string `form:"modelNames,omitempty" json:"modelNames,omitempty"`

	// States The states of the fGPUs (`allocated` \| `attaching` \| `attached` \| `detaching`).
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// VmIds One or more IDs of VMs.
	VmIds *[]string `form:"vmIds,omitempty" json:"vmIds,omitempty"`

	// AvailabilityZoneNames The Subregions where the fGPUs are located.
	AvailabilityZoneNames *[]string `form:"availabilityZoneNames,omitempty" json:"availabilityZoneNames,omitempty"`

	// Ids One or more IDs of fGPUs.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`
}

// ReadImagesParams defines parameters for ReadImages.
type ReadImagesParams struct {
	// AccountAliases The account aliases of the owners of the OMIs.
	AccountAliases *[]string `form:"accountAliases,omitempty" json:"accountAliases,omitempty"`

	// AccountIds The account IDs of the owners of the OMIs. By default, all the OMIs for which you have launch permissions are described.
	AccountIds *[]string `form:"accountIds,omitempty" json:"accountIds,omitempty"`

	// Architectures The architectures of the OMIs (`i386` \| `x86_64`).
	Architectures *[]string `form:"architectures,omitempty" json:"architectures,omitempty"`

	// BlockDeviceMappingDeleteOnVmDeletion Whether the volumes are deleted or not when terminating the VM.
	BlockDeviceMappingDeleteOnVmDeletion *bool `form:"blockDeviceMappingDeleteOnVmDeletion,omitempty" json:"blockDeviceMappingDeleteOnVmDeletion,omitempty"`

	// BlockDeviceMappingDeviceNames The device names for the volumes.
	BlockDeviceMappingDeviceNames *[]string `form:"blockDeviceMappingDeviceNames,omitempty" json:"blockDeviceMappingDeviceNames,omitempty"`

	// BlockDeviceMappingSnapshotIds The IDs of the snapshots used to create the volumes.
	BlockDeviceMappingSnapshotIds *[]string `form:"blockDeviceMappingSnapshotIds,omitempty" json:"blockDeviceMappingSnapshotIds,omitempty"`

	// BlockDeviceMappingVolumeSizes The sizes of the volumes, in gibibytes (GiB).
	BlockDeviceMappingVolumeSizes *[]int `form:"blockDeviceMappingVolumeSizes,omitempty" json:"blockDeviceMappingVolumeSizes,omitempty"`

	// BlockDeviceMappingVolumeTypes The types of volumes (`standard` \| `gp2` \| `io1`).
	BlockDeviceMappingVolumeTypes *[]string `form:"blockDeviceMappingVolumeTypes,omitempty" json:"blockDeviceMappingVolumeTypes,omitempty"`

	// Descriptions The descriptions of the OMIs, provided when they were created.
	Descriptions *[]string `form:"descriptions,omitempty" json:"descriptions,omitempty"`

	// FileLocations The locations of the buckets where the OMI files are stored.
	FileLocations *[]string `form:"fileLocations,omitempty" json:"fileLocations,omitempty"`

	// Hypervisors The hypervisor type of the OMI (always `xen`).
	Hypervisors *[]string `form:"hypervisors,omitempty" json:"hypervisors,omitempty"`

	// ImageNames The names of the OMIs, provided when they were created.
	ImageNames *[]string `form:"imageNames,omitempty" json:"imageNames,omitempty"`

	// ProductCodeNames The names of the product codes associated with the OMI.
	ProductCodeNames *[]string `form:"productCodeNames,omitempty" json:"productCodeNames,omitempty"`

	// ProductCodes The product codes associated with the OMI.
	ProductCodes *[]string `form:"productCodes,omitempty" json:"productCodes,omitempty"`

	// RootDeviceNames The name of the root device. This value must be /dev/sda1.
	RootDeviceNames *[]string `form:"rootDeviceNames,omitempty" json:"rootDeviceNames,omitempty"`

	// RootDeviceTypes The types of root device used by the OMIs (`bsu` or `ebs`).
	RootDeviceTypes *[]string `form:"rootDeviceTypes,omitempty" json:"rootDeviceTypes,omitempty"`

	// States The states of the OMIs (`pending` \| `available` \| `failed`).
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// TagKeys The keys of the tags associated with the OMIs.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the OMIs.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the OMIs, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// VirtualizationTypes The virtualization types (always `hvm`).
	VirtualizationTypes *[]string `form:"virtualizationTypes,omitempty" json:"virtualizationTypes,omitempty"`

	// Ids The IDs of the OMIs.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`

	// IsPublic If true, lists all public OMIs. If false, lists all private OMIs.
	IsPublic *bool `form:"isPublic,omitempty" json:"isPublic,omitempty"`
}

// ReadInternetGatewaysParams defines parameters for ReadInternetGateways.
type ReadInternetGatewaysParams struct {
	// LinkStates The current states of the attachments between the Internet services and the Nets (only `available`, if the Internet gateway is attached to a Net).
	LinkStates *[]string `form:"linkStates,omitempty" json:"linkStates,omitempty"`

	// TagKeys The keys of the tags associated with the Internet services.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the Internet services.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the Internet services, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// LinkVpcIds The IDs of the Nets the Internet services are attached to.
	LinkVpcIds *[]string `form:"linkVpcIds,omitempty" json:"linkVpcIds,omitempty"`

	// Ids The IDs of the Internet services.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`
}

// ReadKeypairsParams defines parameters for ReadKeypairs.
type ReadKeypairsParams struct {
	// KeypairFingerprints The fingerprints of the keypairs.
	KeypairFingerprints *[]string `form:"keypairFingerprints,omitempty" json:"keypairFingerprints,omitempty"`

	// KeypairNames The names of the keypairs.
	KeypairNames *[]string `form:"keypairNames,omitempty" json:"keypairNames,omitempty"`

	// KeypairTypes The types of the keypairs (`ssh-rsa`, `ssh-ed25519`, `ecdsa-sha2-nistp256`, `ecdsa-sha2-nistp384`, or `ecdsa-sha2-nistp521`).
	KeypairTypes *[]string `form:"keypairTypes,omitempty" json:"keypairTypes,omitempty"`
}

// CreateKeypairJSONBody defines parameters for CreateKeypair.
type CreateKeypairJSONBody struct {
	// Name A unique name for the keypair, with a maximum length of 255 [ASCII printable characters](https://en.wikipedia.org/wiki/ASCII#Printable_characters).
	Name string `json:"name"`

	// PublicKey The public key to import in your account, if you are importing an existing keypair. This value must be Base64-encoded.
	PublicKey *string `json:"publicKey,omitempty"`
}

// ReadListenerRulesParams defines parameters for ReadListenerRules.
type ReadListenerRulesParams struct {
	// ListenerRuleNames The names of the listener rules.
	ListenerRuleNames *[]string `form:"listenerRuleNames,omitempty" json:"listenerRuleNames,omitempty"`
}

// ReadLoadBalancersParams defines parameters for ReadLoadBalancers.
type ReadLoadBalancersParams struct {
	// LoadBalancerNames The names of the load balancers.
	LoadBalancerNames *[]string `form:"loadBalancerNames,omitempty" json:"loadBalancerNames,omitempty"`
}

// ReadVmsHealthJSONBody defines parameters for ReadVmsHealth.
type ReadVmsHealthJSONBody struct {
	// BackendVmIds One or more IDs of back-end VMs.
	BackendVmIds *[]string `json:"backendVmIds,omitempty"`
}

// ReadLoadBalancerTagsJSONBody defines parameters for ReadLoadBalancerTags.
type ReadLoadBalancerTagsJSONBody struct {
	// Names One or more load balancer names.
	Names []string `json:"names"`
}

// ReadNatGatewayParams defines parameters for ReadNatGateway.
type ReadNatGatewayParams struct {
	// States The states of the NAT services (`pending` \| `available` \| `deleting` \| `deleted`).
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// SubnetIds The IDs of the Subnets in which the NAT services are.
	SubnetIds *[]string `form:"subnetIds,omitempty" json:"subnetIds,omitempty"`

	// TagKeys The keys of the tags associated with the NAT services.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the NAT services.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the NAT services, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// Ids The IDs of the NAT services.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`

	// VpcIds The IDs of the Nets in which the NAT services are.
	VpcIds *[]string `form:"vpcIds,omitempty" json:"vpcIds,omitempty"`
}

// ReadNicsParams defines parameters for ReadNics.
type ReadNicsParams struct {
	// Descriptions The descriptions of the NICs.
	Descriptions *[]string `form:"descriptions,omitempty" json:"descriptions,omitempty"`

	// IsSourceDestCheck Whether the source/destination checking is enabled (true) or disabled (false).
	IsSourceDestCheck *bool `form:"isSourceDestCheck,omitempty" json:"isSourceDestCheck,omitempty"`

	// LinkNicDeleteOnVmDeletion Whether the NICs are deleted when the VMs they are attached to are terminated.
	LinkNicDeleteOnVmDeletion *bool `form:"linkNicDeleteOnVmDeletion,omitempty" json:"linkNicDeleteOnVmDeletion,omitempty"`

	// LinkNicDeviceNumbers The device numbers the NICs are attached to.
	LinkNicDeviceNumbers *[]int `form:"linkNicDeviceNumbers,omitempty" json:"linkNicDeviceNumbers,omitempty"`

	// LinkNicLinkNicIds The attachment IDs of the NICs.
	LinkNicLinkNicIds *[]string `form:"linkNicLinkNicIds,omitempty" json:"linkNicLinkNicIds,omitempty"`

	// LinkNicStates The states of the attachments.
	LinkNicStates *[]string `form:"linkNicStates,omitempty" json:"linkNicStates,omitempty"`

	// LinkNicVmAccountIds The account IDs of the owners of the VMs the NICs are attached to.
	LinkNicVmAccountIds *[]string `form:"linkNicVmAccountIds,omitempty" json:"linkNicVmAccountIds,omitempty"`

	// LinkNicVmIds The IDs of the VMs the NICs are attached to.
	LinkNicVmIds *[]string `form:"linkNicVmIds,omitempty" json:"linkNicVmIds,omitempty"`

	// LinkPublicIpAccountIds The account IDs of the owners of the public IPs associated with the NICs.
	LinkPublicIpAccountIds *[]string `form:"linkPublicIpAccountIds,omitempty" json:"linkPublicIpAccountIds,omitempty"`

	// LinkPublicIpLinkPublicIpIds The association IDs returned when the public IPs were associated with the NICs.
	LinkPublicIpLinkPublicIpIds *[]string `form:"linkPublicIpLinkPublicIpIds,omitempty" json:"linkPublicIpLinkPublicIpIds,omitempty"`

	// LinkPublicIpPublicIpIds The allocation IDs returned when the public IPs were allocated to their accounts.
	LinkPublicIpPublicIpIds *[]string `form:"linkPublicIpPublicIpIds,omitempty" json:"linkPublicIpPublicIpIds,omitempty"`

	// LinkPublicIpPublicIps The public IPs associated with the NICs.
	LinkPublicIpPublicIps *[]string `form:"linkPublicIpPublicIps,omitempty" json:"linkPublicIpPublicIps,omitempty"`

	// MacAddresses The Media Access Control (MAC) addresses of the NICs.
	MacAddresses *[]string `form:"macAddresses,omitempty" json:"macAddresses,omitempty"`

	// PrivateDnsNames The private DNS names associated with the primary private IPs.
	PrivateDnsNames *[]string `form:"privateDnsNames,omitempty" json:"privateDnsNames,omitempty"`

	// PrivateIpsLinkPublicIpPublicIps The public IPs associated with the private IPs.
	PrivateIpsLinkPublicIpPublicIps *[]string `form:"privateIpsLinkPublicIpPublicIps,omitempty" json:"privateIpsLinkPublicIpPublicIps,omitempty"`

	// PrivateIpsPrimaryIp Whether the private IP is the primary IP associated with the NIC.
	PrivateIpsPrimaryIp *bool `form:"privateIpsPrimaryIp,omitempty" json:"privateIpsPrimaryIp,omitempty"`

	// PrivateIpsPrivateIps The private IPs of the NICs.
	PrivateIpsPrivateIps *[]string `form:"privateIpsPrivateIps,omitempty" json:"privateIpsPrivateIps,omitempty"`

	// SecurityGroupIds The IDs of the security groups associated with the NICs.
	SecurityGroupIds *[]string `form:"securityGroupIds,omitempty" json:"securityGroupIds,omitempty"`

	// SecurityGroupNames The names of the security groups associated with the NICs.
	SecurityGroupNames *[]string `form:"securityGroupNames,omitempty" json:"securityGroupNames,omitempty"`

	// States The states of the NICs.
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// SubnetIds The IDs of the Subnets for the NICs.
	SubnetIds *[]string `form:"subnetIds,omitempty" json:"subnetIds,omitempty"`

	// TagKeys The keys of the tags associated with the NICs.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the NICs.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the NICs, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// VpcIds The IDs of the Nets where the NICs are located.
	VpcIds *[]string `form:"vpcIds,omitempty" json:"vpcIds,omitempty"`

	// Ids The IDs of the NICs.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`

	// AvailabilityZoneNames The Subregions where the NICs are located.
	AvailabilityZoneNames *[]string `form:"availabilityZoneNames,omitempty" json:"availabilityZoneNames,omitempty"`
}

// LinkNicJSONBody defines parameters for LinkNic.
type LinkNicJSONBody struct {
	// DeviceNumber The index of the VM device for the NIC attachment (between `1` and `7`, both included).
	DeviceNumber int `json:"deviceNumber"`

	// VmId The ID of the VM to which you want to attach the NIC.
	VmId string `json:"vmId"`
}

// ReadProductTypesParams defines parameters for ReadProductTypes.
type ReadProductTypesParams struct {
	// Ids The IDs of the product types.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`
}

// ReadPublicIpsParams defines parameters for ReadPublicIps.
type ReadPublicIpsParams struct {
	// LinkPublicIpIds The IDs representing the associations of public IPs with VMs or NICs.
	LinkPublicIpIds *[]string `form:"linkPublicIpIds,omitempty" json:"linkPublicIpIds,omitempty"`

	// NicIds The IDs of the NICs.
	NicIds *[]string `form:"nicIds,omitempty" json:"nicIds,omitempty"`

	// PrivateIps The private IPs associated with the public IPs.
	PrivateIps *[]string `form:"privateIps,omitempty" json:"privateIps,omitempty"`

	// TagKeys The keys of the tags associated with the public IPs.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the public IPs.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the public IPs, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// VmIds The IDs of the VMs.
	VmIds *[]string `form:"vmIds,omitempty" json:"vmIds,omitempty"`

	// Ids The IDs of the public IPs.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`
}

// LinkPublicIpJSONBody defines parameters for LinkPublicIp.
type LinkPublicIpJSONBody struct {
	// AllowRelink If true, allows the public IP to be associated with the VM or NIC that you specify even if it is already associated with another VM or NIC. If false, prevents the public IP from being associated with the VM or NIC that you specify if it is already associated with another VM or NIC. (By default, true in the public Cloud, false in a Net.)
	AllowRelink *bool `json:"allowRelink,omitempty"`

	// NicId (Net only) The ID of the NIC. This parameter is required if the VM has more than one NIC attached. Otherwise, you need to specify the `VmId` parameter instead. You cannot specify both parameters at the same time.
	NicId *string `json:"nicId,omitempty"`

	// PrivateIp (Net only) The primary or secondary private IP of the specified NIC. By default, the primary private IP.
	PrivateIp *string `json:"privateIp,omitempty"`

	// VmId The ID of the VM.<br />
	// - In the public Cloud, this parameter is required.<br />
	// - In a Net, this parameter is required if the VM has only one NIC. Otherwise, you need to specify the `NicId` parameter instead. You cannot specify both parameters at the same time.
	VmId *string `json:"vmId,omitempty"`
}

// ReadRouteTablesParams defines parameters for ReadRouteTables.
type ReadRouteTablesParams struct {
	// LinkRouteTableIds The IDs of the route tables involved in the associations.
	LinkRouteTableIds *[]string `form:"linkRouteTableIds,omitempty" json:"linkRouteTableIds,omitempty"`

	// LinkRouteTableLinkRouteTableIds The IDs of the associations between the route tables and the Subnets.
	LinkRouteTableLinkRouteTableIds *[]string `form:"linkRouteTableLinkRouteTableIds,omitempty" json:"linkRouteTableLinkRouteTableIds,omitempty"`

	// LinkRouteTableMain If true, the route tables are the main ones for their Nets.
	LinkRouteTableMain *bool `form:"linkRouteTableMain,omitempty" json:"linkRouteTableMain,omitempty"`

	// LinkSubnetIds The IDs of the Subnets involved in the associations.
	LinkSubnetIds *[]string `form:"linkSubnetIds,omitempty" json:"linkSubnetIds,omitempty"`

	// RouteCreationMethods The methods used to create a route.
	RouteCreationMethods *[]string `form:"routeCreationMethods,omitempty" json:"routeCreationMethods,omitempty"`

	// RouteDestinationIpRanges The IP ranges specified in routes in the tables.
	RouteDestinationIpRanges *[]string `form:"routeDestinationIpRanges,omitempty" json:"routeDestinationIpRanges,omitempty"`

	// RouteDestinationServiceIds The service IDs specified in routes in the tables.
	RouteDestinationServiceIds *[]string `form:"routeDestinationServiceIds,omitempty" json:"routeDestinationServiceIds,omitempty"`

	// RouteGatewayIds The IDs of the gateways specified in routes in the tables.
	RouteGatewayIds *[]string `form:"routeGatewayIds,omitempty" json:"routeGatewayIds,omitempty"`

	// RouteStates The states of routes in the route tables (always `active`).
	RouteStates *[]string `form:"routeStates,omitempty" json:"routeStates,omitempty"`

	// RouteVmIds The IDs of the VMs specified in routes in the tables.
	RouteVmIds *[]string `form:"routeVmIds,omitempty" json:"routeVmIds,omitempty"`

	// TagKeys The keys of the tags associated with the route tables.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the route tables.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the route tables, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// VpcIds The IDs of the Nets for the route tables.
	VpcIds *[]string `form:"vpcIds,omitempty" json:"vpcIds,omitempty"`

	// RouteNatGatewayIds The IDs of the NAT services specified in routes in the tables.
	RouteNatGatewayIds *[]string `form:"routeNatGatewayIds,omitempty" json:"routeNatGatewayIds,omitempty"`

	// RouteVpcPeeringIds The IDs of the Net peerings specified in routes in the tables.
	RouteVpcPeeringIds *[]string `form:"routeVpcPeeringIds,omitempty" json:"routeVpcPeeringIds,omitempty"`

	// Ids The IDs of the route tables.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`
}

// LinkRouteTableJSONBody defines parameters for LinkRouteTable.
type LinkRouteTableJSONBody struct {
	// SubnetId The ID of the Subnet.
	SubnetId string `json:"subnetId"`
}

// ReadSecurityGroupsParams defines parameters for ReadSecurityGroups.
type ReadSecurityGroupsParams struct {
	// Descriptions The descriptions of the security groups.
	Descriptions *[]string `form:"descriptions,omitempty" json:"descriptions,omitempty"`

	// InboundRuleAccountIds The account IDs that have been granted permissions.
	InboundRuleAccountIds *[]string `form:"inboundRuleAccountIds,omitempty" json:"inboundRuleAccountIds,omitempty"`

	// InboundRuleFromPortRanges The beginnings of the port ranges for the TCP and UDP protocols, or the ICMP type numbers.
	InboundRuleFromPortRanges *[]int `form:"inboundRuleFromPortRanges,omitempty" json:"inboundRuleFromPortRanges,omitempty"`

	// InboundRuleIpRanges The IP ranges that have been granted permissions, in CIDR notation (for example, `10.0.0.0/24`).
	InboundRuleIpRanges *[]string `form:"inboundRuleIpRanges,omitempty" json:"inboundRuleIpRanges,omitempty"`

	// InboundRuleProtocols The IP protocols for the permissions (`tcp` \| `udp` \| `icmp`, or a protocol number, or `-1` for all protocols).
	InboundRuleProtocols *[]string `form:"inboundRuleProtocols,omitempty" json:"inboundRuleProtocols,omitempty"`

	// InboundRuleSecurityGroupIds The IDs of the security groups that have been granted permissions.
	InboundRuleSecurityGroupIds *[]string `form:"inboundRuleSecurityGroupIds,omitempty" json:"inboundRuleSecurityGroupIds,omitempty"`

	// InboundRuleSecurityGroupNames The names of the security groups that have been granted permissions.
	InboundRuleSecurityGroupNames *[]string `form:"inboundRuleSecurityGroupNames,omitempty" json:"inboundRuleSecurityGroupNames,omitempty"`

	// InboundRuleToPortRanges The ends of the port ranges for the TCP and UDP protocols, or the ICMP code numbers.
	InboundRuleToPortRanges *[]int `form:"inboundRuleToPortRanges,omitempty" json:"inboundRuleToPortRanges,omitempty"`

	// OutboundRuleAccountIds The account IDs that have been granted permissions.
	OutboundRuleAccountIds *[]string `form:"outboundRuleAccountIds,omitempty" json:"outboundRuleAccountIds,omitempty"`

	// OutboundRuleFromPortRanges The beginnings of the port ranges for the TCP and UDP protocols, or the ICMP type numbers.
	OutboundRuleFromPortRanges *[]int `form:"outboundRuleFromPortRanges,omitempty" json:"outboundRuleFromPortRanges,omitempty"`

	// OutboundRuleIpRanges The IP ranges that have been granted permissions, in CIDR notation (for example, `10.0.0.0/24`).
	OutboundRuleIpRanges *[]string `form:"outboundRuleIpRanges,omitempty" json:"outboundRuleIpRanges,omitempty"`

	// OutboundRuleProtocols The IP protocols for the permissions (`tcp` \| `udp` \| `icmp`, or a protocol number, or `-1` for all protocols).
	OutboundRuleProtocols *[]string `form:"outboundRuleProtocols,omitempty" json:"outboundRuleProtocols,omitempty"`

	// OutboundRuleSecurityGroupIds The IDs of the security groups that have been granted permissions.
	OutboundRuleSecurityGroupIds *[]string `form:"outboundRuleSecurityGroupIds,omitempty" json:"outboundRuleSecurityGroupIds,omitempty"`

	// OutboundRuleSecurityGroupNames The names of the security groups that have been granted permissions.
	OutboundRuleSecurityGroupNames *[]string `form:"outboundRuleSecurityGroupNames,omitempty" json:"outboundRuleSecurityGroupNames,omitempty"`

	// OutboundRuleToPortRanges The ends of the port ranges for the TCP and UDP protocols, or the ICMP code numbers.
	OutboundRuleToPortRanges *[]int `form:"outboundRuleToPortRanges,omitempty" json:"outboundRuleToPortRanges,omitempty"`

	// SecurityGroupIds The IDs of the security groups.
	SecurityGroupIds *[]string `form:"securityGroupIds,omitempty" json:"securityGroupIds,omitempty"`

	// SecurityGroupNames The names of the security groups.
	SecurityGroupNames *[]string `form:"securityGroupNames,omitempty" json:"securityGroupNames,omitempty"`

	// TagKeys The keys of the tags associated with the security groups.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the security groups.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the security groups, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// VpcIds The IDs of the Nets specified when the security groups were created.
	VpcIds *[]string `form:"vpcIds,omitempty" json:"vpcIds,omitempty"`
}

// ReadSnapshotsParams defines parameters for ReadSnapshots.
type ReadSnapshotsParams struct {
	// Descriptions The descriptions of the snapshots.
	Descriptions *[]string `form:"descriptions,omitempty" json:"descriptions,omitempty"`

	// FromCreationDate The beginning of the time period, in ISO 8601 date-time format (for example, `2020-06-14T00:00:00.000Z`).
	FromCreationDate *string `form:"fromCreationDate,omitempty" json:"fromCreationDate,omitempty"`

	// Progresses The progresses of the snapshots, as a percentage.
	Progresses *[]int `form:"progresses,omitempty" json:"progresses,omitempty"`

	// States The states of the snapshots (`in-queue` \| `completed` \| `error`).
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// TagKeys The keys of the tags associated with the snapshots.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the snapshots.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the snapshots, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// ToCreationDate The end of the time period, in ISO 8601 date-time format (for example, `2020-06-30T00:00:00.000Z`).
	ToCreationDate *string `form:"toCreationDate,omitempty" json:"toCreationDate,omitempty"`

	// VolumeIds The IDs of the volumes used to create the snapshots.
	VolumeIds *[]string `form:"volumeIds,omitempty" json:"volumeIds,omitempty"`

	// VolumeSizes The sizes of the volumes used to create the snapshots, in gibibytes (GiB).
	VolumeSizes *[]int `form:"volumeSizes,omitempty" json:"volumeSizes,omitempty"`

	// IsPublic If true, lists all public volumes. If false, lists all private volumes.
	IsPublic *bool `form:"isPublic,omitempty" json:"isPublic,omitempty"`

	// Ids The IDs of the snapshots.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`
}

// ReadSubnetsParams defines parameters for ReadSubnets.
type ReadSubnetsParams struct {
	// AvailableIpsCounts The number of available IPs.
	AvailableIpsCounts *[]int `form:"availableIpsCounts,omitempty" json:"availableIpsCounts,omitempty"`

	// IpRanges The IP ranges in the Subnets, in CIDR notation (for example, `10.0.0.0/16`).
	IpRanges *[]string `form:"ipRanges,omitempty" json:"ipRanges,omitempty"`

	// States The states of the Subnets (`pending` \| `available` \| `deleted`).
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// TagKeys The keys of the tags associated with the Subnets.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the Subnets.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the Subnets, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// VpcIds The IDs of the Nets in which the Subnets are.
	VpcIds *[]string `form:"vpcIds,omitempty" json:"vpcIds,omitempty"`

	// Ids The IDs of the Subnets.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`

	// AvailabilityZoneNames The names of the Subregions in which the Subnets are located.
	AvailabilityZoneNames *[]string `form:"availabilityZoneNames,omitempty" json:"availabilityZoneNames,omitempty"`
}

// ReadTagsParams defines parameters for ReadTags.
type ReadTagsParams struct {
	// Keys The keys of the tags that are assigned to the resources. You can use this filter alongside the `Values` filter. In that case, you filter the resources corresponding to each tag, regardless of the other filter.
	Keys *[]string `form:"keys,omitempty" json:"keys,omitempty"`

	// ResourceIds The IDs of the resources with which the tags are associated.
	ResourceIds *[]string `form:"resourceIds,omitempty" json:"resourceIds,omitempty"`

	// ResourceTypes The resource type (`vm` \| `image` \| `volume` \| `snapshot` \| `public-ip` \| `security-group` \| `route-table` \| `nic` \| `net` \| `subnet` \| `net-peering` \| `net-access-point` \| `nat-service` \| `internet-service` \| `client-gateway` \| `virtual-gateway` \| `vpn-connection` \| `dhcp-options` \| `task`).
	ResourceTypes *[]string `form:"resourceTypes,omitempty" json:"resourceTypes,omitempty"`

	// Values The values of the tags that are assigned to the resources. You can use this filter alongside the `TagKeys` filter. In that case, you filter the resources corresponding to each tag, regardless of the other filter.
	Values *[]string `form:"values,omitempty" json:"values,omitempty"`
}

// ReadVirtualGatewaysParams defines parameters for ReadVirtualGateways.
type ReadVirtualGatewaysParams struct {
	// ConnectionTypes The types of the virtual gateways (only `ipsec.1` is supported).
	ConnectionTypes *[]string `form:"connectionTypes,omitempty" json:"connectionTypes,omitempty"`

	// LinkStates The current states of the attachments between the virtual gateways and the Nets (`attaching` \| `attached` \| `detaching` \| `detached`).
	LinkStates *[]string `form:"linkStates,omitempty" json:"linkStates,omitempty"`

	// States The states of the virtual gateways (`pending` \| `available` \| `deleting` \| `deleted`).
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// TagKeys The keys of the tags associated with the virtual gateways.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the virtual gateways.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the virtual gateways, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// LinkVpcIds The IDs of the Nets the virtual gateways are attached to.
	LinkVpcIds *[]string `form:"linkVpcIds,omitempty" json:"linkVpcIds,omitempty"`

	// Ids The IDs of the virtual gateways.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`
}

// LinkVirtualGatewayToVpcJSONBody defines parameters for LinkVirtualGatewayToVpc.
type LinkVirtualGatewayToVpcJSONBody struct {
	// VpcId The ID of the Net to which you want to attach the virtual gateway.
	VpcId string `json:"vpcId"`
}

// ReadVmsParams defines parameters for ReadVms.
type ReadVmsParams struct {
	// Architectures The architectures of the VMs (`i386` \| `x86_64`).
	Architectures *[]string `form:"architectures,omitempty" json:"architectures,omitempty"`

	// BlockDeviceMappingDeleteOnVmDeletion Whether the BSU volumes are deleted when terminating the VMs.
	BlockDeviceMappingDeleteOnVmDeletion *bool `form:"blockDeviceMappingDeleteOnVmDeletion,omitempty" json:"blockDeviceMappingDeleteOnVmDeletion,omitempty"`

	// BlockDeviceMappingDeviceNames The device names for the BSU volumes (in the format `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX`).
	BlockDeviceMappingDeviceNames *[]string `form:"blockDeviceMappingDeviceNames,omitempty" json:"blockDeviceMappingDeviceNames,omitempty"`

	// BlockDeviceMappingLinkDates The link dates for the BSU volumes mapped to the VMs (for example, `2016-01-23T18:45:30.000Z`).
	BlockDeviceMappingLinkDates *[]ReadVmsParams_BlockDeviceMappingLinkDates_Item `form:"blockDeviceMappingLinkDates,omitempty" json:"blockDeviceMappingLinkDates,omitempty"`

	// BlockDeviceMappingStates The states for the BSU volumes (`attaching` \| `attached` \| `detaching` \| `detached`).
	BlockDeviceMappingStates *[]string `form:"blockDeviceMappingStates,omitempty" json:"blockDeviceMappingStates,omitempty"`

	// BlockDeviceMappingVolumeIds The volume IDs of the BSU volumes.
	BlockDeviceMappingVolumeIds *[]string `form:"blockDeviceMappingVolumeIds,omitempty" json:"blockDeviceMappingVolumeIds,omitempty"`

	// ClientTokens The idempotency tokens provided when launching the VMs.
	ClientTokens *[]string `form:"clientTokens,omitempty" json:"clientTokens,omitempty"`

	// CreationDates The dates when the VMs were launched.
	CreationDates *[]ReadVmsParams_CreationDates_Item `form:"creationDates,omitempty" json:"creationDates,omitempty"`

	// ImageIds The IDs of the OMIs used to launch the VMs.
	ImageIds *[]string `form:"imageIds,omitempty" json:"imageIds,omitempty"`

	// IsSourceDestChecked Whether the source/destination checking is enabled (true) or disabled (false).
	IsSourceDestChecked *bool `form:"isSourceDestChecked,omitempty" json:"isSourceDestChecked,omitempty"`

	// KeypairNames The names of the keypairs used when launching the VMs.
	KeypairNames *[]string `form:"keypairNames,omitempty" json:"keypairNames,omitempty"`

	// LaunchNumbers The numbers for the VMs when launching a group of several VMs (for example, `0`, `1`, `2`, and so on).
	LaunchNumbers *[]int `form:"launchNumbers,omitempty" json:"launchNumbers,omitempty"`

	// Lifecycles Whether the VMs are Spot Instances (spot).
	Lifecycles *[]string `form:"lifecycles,omitempty" json:"lifecycles,omitempty"`

	// NicAccountIds The IDs of the NICs.
	NicAccountIds *[]string `form:"nicAccountIds,omitempty" json:"nicAccountIds,omitempty"`

	// NicDescriptions The descriptions of the NICs.
	NicDescriptions *[]string `form:"nicDescriptions,omitempty" json:"nicDescriptions,omitempty"`

	// NicIsSourceDestChecked Whether the source/destination checking is enabled (true) or disabled (false).
	NicIsSourceDestChecked *bool `form:"nicIsSourceDestChecked,omitempty" json:"nicIsSourceDestChecked,omitempty"`

	// NicLinkNicDeleteOnVmDeletion Whether the NICs are deleted when the VMs they are attached to are deleted.
	NicLinkNicDeleteOnVmDeletion *bool `form:"nicLinkNicDeleteOnVmDeletion,omitempty" json:"nicLinkNicDeleteOnVmDeletion,omitempty"`

	// NicLinkNicDeviceNumbers The device numbers the NICs are attached to.
	NicLinkNicDeviceNumbers *[]int `form:"nicLinkNicDeviceNumbers,omitempty" json:"nicLinkNicDeviceNumbers,omitempty"`

	// NicLinkNicLinkNicDates The dates and time when the NICs were attached to the VMs.
	NicLinkNicLinkNicDates *[]ReadVmsParams_NicLinkNicLinkNicDates_Item `form:"nicLinkNicLinkNicDates,omitempty" json:"nicLinkNicLinkNicDates,omitempty"`

	// NicLinkNicLinkNicIds The IDs of the NIC attachments.
	NicLinkNicLinkNicIds *[]string `form:"nicLinkNicLinkNicIds,omitempty" json:"nicLinkNicLinkNicIds,omitempty"`

	// NicLinkNicStates The states of the attachments.
	NicLinkNicStates *[]string `form:"nicLinkNicStates,omitempty" json:"nicLinkNicStates,omitempty"`

	// NicLinkNicVmAccountIds The account IDs of the owners of the VMs the NICs are attached to.
	NicLinkNicVmAccountIds *[]string `form:"nicLinkNicVmAccountIds,omitempty" json:"nicLinkNicVmAccountIds,omitempty"`

	// NicLinkNicVmIds The IDs of the VMs the NICs are attached to.
	NicLinkNicVmIds *[]string `form:"nicLinkNicVmIds,omitempty" json:"nicLinkNicVmIds,omitempty"`

	// NicLinkPublicIpAccountIds The account IDs of the owners of the public IPs associated with the NICs.
	NicLinkPublicIpAccountIds *[]string `form:"nicLinkPublicIpAccountIds,omitempty" json:"nicLinkPublicIpAccountIds,omitempty"`

	// NicLinkPublicIpLinkPublicIpIds The association IDs returned when the public IPs were associated with the NICs.
	NicLinkPublicIpLinkPublicIpIds *[]string `form:"nicLinkPublicIpLinkPublicIpIds,omitempty" json:"nicLinkPublicIpLinkPublicIpIds,omitempty"`

	// NicLinkPublicIpPublicIpIds The allocation IDs returned when the public IPs were allocated to their accounts.
	NicLinkPublicIpPublicIpIds *[]string `form:"nicLinkPublicIpPublicIpIds,omitempty" json:"nicLinkPublicIpPublicIpIds,omitempty"`

	// NicLinkPublicIpPublicIps The public IPs associated with the NICs.
	NicLinkPublicIpPublicIps *[]string `form:"nicLinkPublicIpPublicIps,omitempty" json:"nicLinkPublicIpPublicIps,omitempty"`

	// NicMacAddresses The Media Access Control (MAC) addresses of the NICs.
	NicMacAddresses *[]string `form:"nicMacAddresses,omitempty" json:"nicMacAddresses,omitempty"`

	// NicNicIds The IDs of the NICs.
	NicNicIds *[]string `form:"nicNicIds,omitempty" json:"nicNicIds,omitempty"`

	// NicPrivateIpsLinkPublicIpAccountIds The account IDs of the owner of the public IPs associated with the private IPs.
	NicPrivateIpsLinkPublicIpAccountIds *[]string `form:"nicPrivateIpsLinkPublicIpAccountIds,omitempty" json:"nicPrivateIpsLinkPublicIpAccountIds,omitempty"`

	// NicPrivateIpsLinkPublicIpIds The public IPs associated with the private IPs.
	NicPrivateIpsLinkPublicIpIds *[]string `form:"nicPrivateIpsLinkPublicIpIds,omitempty" json:"nicPrivateIpsLinkPublicIpIds,omitempty"`

	// NicPrivateIpsPrimaryIp Whether the private IPs are the primary IPs associated with the NICs.
	NicPrivateIpsPrimaryIp *bool `form:"nicPrivateIpsPrimaryIp,omitempty" json:"nicPrivateIpsPrimaryIp,omitempty"`

	// NicPrivateIpsPrivateIps The private IPs of the NICs.
	NicPrivateIpsPrivateIps *[]string `form:"nicPrivateIpsPrivateIps,omitempty" json:"nicPrivateIpsPrivateIps,omitempty"`

	// NicSecurityGroupIds The IDs of the security groups associated with the NICs.
	NicSecurityGroupIds *[]string `form:"nicSecurityGroupIds,omitempty" json:"nicSecurityGroupIds,omitempty"`

	// NicSecurityGroupNames The names of the security groups associated with the NICs.
	NicSecurityGroupNames *[]string `form:"nicSecurityGroupNames,omitempty" json:"nicSecurityGroupNames,omitempty"`

	// NicStates The states of the NICs (`available` \| `in-use`).
	NicStates *[]string `form:"nicStates,omitempty" json:"nicStates,omitempty"`

	// NicSubnetIds The IDs of the Subnets for the NICs.
	NicSubnetIds *[]string `form:"nicSubnetIds,omitempty" json:"nicSubnetIds,omitempty"`

	// Platforms The platforms. Use windows if you have Windows VMs. Otherwise, leave this filter blank.
	Platforms *[]string `form:"platforms,omitempty" json:"platforms,omitempty"`

	// PrivateIps The private IPs of the VMs.
	PrivateIps *[]string `form:"privateIps,omitempty" json:"privateIps,omitempty"`

	// ProductCodes The product codes associated with the OMI used to create the VMs.
	ProductCodes *[]string `form:"productCodes,omitempty" json:"productCodes,omitempty"`

	// PublicIps The public IPs of the VMs.
	PublicIps *[]string `form:"publicIps,omitempty" json:"publicIps,omitempty"`

	// ReservationIds The IDs of the reservation of the VMs, created every time you launch VMs. These reservation IDs can be associated with several VMs when you lauch a group of VMs using the same launch request.
	ReservationIds *[]string `form:"reservationIds,omitempty" json:"reservationIds,omitempty"`

	// RootDeviceNames The names of the root devices for the VMs (for example, `/dev/sda1`)
	RootDeviceNames *[]string `form:"rootDeviceNames,omitempty" json:"rootDeviceNames,omitempty"`

	// RootDeviceTypes The root devices types used by the VMs (always `ebs`)
	RootDeviceTypes *[]string `form:"rootDeviceTypes,omitempty" json:"rootDeviceTypes,omitempty"`

	// SecurityGroupIds The IDs of the security groups for the VMs (only in the public Cloud).
	SecurityGroupIds *[]string `form:"securityGroupIds,omitempty" json:"securityGroupIds,omitempty"`

	// SecurityGroupNames The names of the security groups for the VMs (only in the public Cloud).
	SecurityGroupNames *[]string `form:"securityGroupNames,omitempty" json:"securityGroupNames,omitempty"`

	// StateReasonCodes The reason codes for the state changes.
	StateReasonCodes *[]int `form:"stateReasonCodes,omitempty" json:"stateReasonCodes,omitempty"`

	// StateReasonMessages The messages describing the state changes.
	StateReasonMessages *[]string `form:"stateReasonMessages,omitempty" json:"stateReasonMessages,omitempty"`

	// StateReasons The reasons explaining the current states of the VMs. This filter is like the `StateReasonCodes` one.
	StateReasons *[]string `form:"stateReasons,omitempty" json:"stateReasons,omitempty"`

	// SubnetIds The IDs of the Subnets for the VMs.
	SubnetIds *[]string `form:"subnetIds,omitempty" json:"subnetIds,omitempty"`

	// TagKeys The keys of the tags associated with the VMs.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the VMs.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the VMs, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// Tenancies The tenancies of the VMs (`dedicated` \| `default` \| `host`).
	Tenancies *[]string `form:"tenancies,omitempty" json:"tenancies,omitempty"`

	// VmSecurityGroupIds The IDs of the security groups for the VMs.
	VmSecurityGroupIds *[]string `form:"vmSecurityGroupIds,omitempty" json:"vmSecurityGroupIds,omitempty"`

	// VmSecurityGroupNames The names of the security group for the VMs.
	VmSecurityGroupNames *[]string `form:"vmSecurityGroupNames,omitempty" json:"vmSecurityGroupNames,omitempty"`

	// VmStateCodes The state codes of the VMs: `-1` (quarantine), `0` (pending), `16` (running), `32` (shutting-down), `48` (terminated), `64` (stopping), and `80` (stopped).
	VmStateCodes *[]int `form:"vmStateCodes,omitempty" json:"vmStateCodes,omitempty"`

	// VmStateNames The state names of the VMs (`pending` \| `running` \| `stopping` \| `stopped` \| `shutting-down` \| `terminated` \| `quarantine`).
	VmStateNames *[]string `form:"vmStateNames,omitempty" json:"vmStateNames,omitempty"`

	// Types The NumSpot VM types.
	Types *[]string `form:"types,omitempty" json:"types,omitempty"`

	// VpcIds The IDs of the Nets in which the VMs are running.
	VpcIds *[]string `form:"vpcIds,omitempty" json:"vpcIds,omitempty"`

	// NicVpcIds The IDs of the Nets where the NICs are located.
	NicVpcIds *[]string `form:"nicVpcIds,omitempty" json:"nicVpcIds,omitempty"`

	// NicAvailabilityZoneNames The Subregions where the NICs are located.
	NicAvailabilityZoneNames *[]string `form:"nicAvailabilityZoneNames,omitempty" json:"nicAvailabilityZoneNames,omitempty"`

	// AvailabilityZoneNames The names of the Subregions of the VMs.
	AvailabilityZoneNames *[]string `form:"availabilityZoneNames,omitempty" json:"availabilityZoneNames,omitempty"`

	// Ids One or more IDs of VMs.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`
}

// ReadVmsParamsBlockDeviceMappingLinkDates0 defines parameters for ReadVms.
type ReadVmsParamsBlockDeviceMappingLinkDates0 = openapi_types.Date

// ReadVmsParamsBlockDeviceMappingLinkDates1 defines parameters for ReadVms.
type ReadVmsParamsBlockDeviceMappingLinkDates1 = time.Time

// ReadVmsParams_BlockDeviceMappingLinkDates_Item defines parameters for ReadVms.
type ReadVmsParams_BlockDeviceMappingLinkDates_Item struct {
	union json.RawMessage
}

// ReadVmsParamsCreationDates0 defines parameters for ReadVms.
type ReadVmsParamsCreationDates0 = openapi_types.Date

// ReadVmsParamsCreationDates1 defines parameters for ReadVms.
type ReadVmsParamsCreationDates1 = time.Time

// ReadVmsParams_CreationDates_Item defines parameters for ReadVms.
type ReadVmsParams_CreationDates_Item struct {
	union json.RawMessage
}

// ReadVmsParamsNicLinkNicLinkNicDates0 defines parameters for ReadVms.
type ReadVmsParamsNicLinkNicLinkNicDates0 = openapi_types.Date

// ReadVmsParamsNicLinkNicLinkNicDates1 defines parameters for ReadVms.
type ReadVmsParamsNicLinkNicLinkNicDates1 = time.Time

// ReadVmsParams_NicLinkNicLinkNicDates_Item defines parameters for ReadVms.
type ReadVmsParams_NicLinkNicLinkNicDates_Item struct {
	union json.RawMessage
}

// ReadVmsStateParams defines parameters for ReadVmsState.
type ReadVmsStateParams struct {
	// MaintenanceEventCodes The code for the scheduled event (`system-reboot` \| `system-maintenance`).
	MaintenanceEventCodes *[]string `form:"maintenanceEventCodes,omitempty" json:"maintenanceEventCodes,omitempty"`

	// MaintenanceEventDescriptions The description of the scheduled event.
	MaintenanceEventDescriptions *[]string `form:"maintenanceEventDescriptions,omitempty" json:"maintenanceEventDescriptions,omitempty"`

	// MaintenanceEventsNotAfter The latest time the event can end.
	MaintenanceEventsNotAfter *[]openapi_types.Date `form:"maintenanceEventsNotAfter,omitempty" json:"maintenanceEventsNotAfter,omitempty"`

	// MaintenanceEventsNotBefore The earliest time the event can start.
	MaintenanceEventsNotBefore *[]openapi_types.Date `form:"maintenanceEventsNotBefore,omitempty" json:"maintenanceEventsNotBefore,omitempty"`

	// VmStates The states of the VMs (`pending` \| `running` \| `stopping` \| `stopped` \| `shutting-down` \| `terminated` \| `quarantine`).
	VmStates *[]string `form:"vmStates,omitempty" json:"vmStates,omitempty"`

	// AvailabilityZoneNames The names of the Subregions of the VMs.
	AvailabilityZoneNames *[]string `form:"availabilityZoneNames,omitempty" json:"availabilityZoneNames,omitempty"`

	// Ids One or more IDs of VMs.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`
}

// ReadVolumesParams defines parameters for ReadVolumes.
type ReadVolumesParams struct {
	// CreationDates The dates and times of creation of the volumes, in ISO 8601 date-time format (for example, `2020-06-30T00:00:00.000Z`).
	CreationDates *[]time.Time `form:"creationDates,omitempty" json:"creationDates,omitempty"`

	// LinkVolumeDeleteOnVmDeletion Whether the volumes are deleted or not when terminating the VMs.
	LinkVolumeDeleteOnVmDeletion *bool `form:"linkVolumeDeleteOnVmDeletion,omitempty" json:"linkVolumeDeleteOnVmDeletion,omitempty"`

	// LinkVolumeDeviceNames The VM device names.
	LinkVolumeDeviceNames *[]string `form:"linkVolumeDeviceNames,omitempty" json:"linkVolumeDeviceNames,omitempty"`

	// LinkVolumeLinkDates The dates and times of creation of the volumes, in ISO 8601 date-time format (for example, `2020-06-30T00:00:00.000Z`).
	LinkVolumeLinkDates *[]time.Time `form:"linkVolumeLinkDates,omitempty" json:"linkVolumeLinkDates,omitempty"`

	// LinkVolumeLinkStates The attachment states of the volumes (`attaching` \| `detaching` \| `attached` \| `detached`).
	LinkVolumeLinkStates *[]string `form:"linkVolumeLinkStates,omitempty" json:"linkVolumeLinkStates,omitempty"`

	// LinkVolumeVmIds One or more IDs of VMs.
	LinkVolumeVmIds *[]string `form:"linkVolumeVmIds,omitempty" json:"linkVolumeVmIds,omitempty"`

	// SnapshotIds The snapshots from which the volumes were created.
	SnapshotIds *[]string `form:"snapshotIds,omitempty" json:"snapshotIds,omitempty"`

	// TagKeys The keys of the tags associated with the volumes.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the volumes.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the volumes, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// VolumeSizes The sizes of the volumes, in gibibytes (GiB).
	VolumeSizes *[]int `form:"volumeSizes,omitempty" json:"volumeSizes,omitempty"`

	// VolumeStates The states of the volumes (`creating` \| `available` \| `in-use` \| `updating` \| `deleting` \| `error`).
	VolumeStates *[]string `form:"volumeStates,omitempty" json:"volumeStates,omitempty"`

	// VolumeTypes The types of the volumes (`standard` \| `gp2` \| `io1`).
	VolumeTypes *[]string `form:"volumeTypes,omitempty" json:"volumeTypes,omitempty"`

	// AvailabilityZoneNames The names of the Subregions in which the volumes were created.
	AvailabilityZoneNames *[]string `form:"availabilityZoneNames,omitempty" json:"availabilityZoneNames,omitempty"`

	// Ids The IDs of the volumes.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`
}

// ReadVpcAccessPointsParams defines parameters for ReadVpcAccessPoints.
type ReadVpcAccessPointsParams struct {
	// ServiceNames The names of the services. For more information, see [ReadNetAccessPointServices](#readnetaccesspointservices).
	ServiceNames *[]string `form:"serviceNames,omitempty" json:"serviceNames,omitempty"`

	// States The states of the Net access points (`pending` \| `available` \| `deleting` \| `deleted`).
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// TagKeys The keys of the tags associated with the Net access points.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the Net access points.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the Net access points, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// Ids The IDs of the Net access points.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`

	// VpcIds The IDs of the Nets.
	VpcIds *[]string `form:"vpcIds,omitempty" json:"vpcIds,omitempty"`
}

// ReadVpcPeeringsParams defines parameters for ReadVpcPeerings.
type ReadVpcPeeringsParams struct {
	// ExpirationDates The dates and times at which the Net peerings expire, in ISO 8601 date-time format (for example, `2020-06-14T00:00:00.000Z`).
	ExpirationDates *[]time.Time `form:"expirationDates,omitempty" json:"expirationDates,omitempty"`

	// StateMessages Additional information about the states of the Net peerings.
	StateMessages *[]string `form:"stateMessages,omitempty" json:"stateMessages,omitempty"`

	// StateNames The states of the Net peerings (`pending-acceptance` \| `active` \| `rejected` \| `failed` \| `expired` \| `deleted`).
	StateNames *[]string `form:"stateNames,omitempty" json:"stateNames,omitempty"`

	// TagKeys The keys of the tags associated with the Net peerings.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the Net peerings.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the Net peerings, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// AccepterVpcAccountIds The account IDs of the owners of the peer Nets.
	AccepterVpcAccountIds *[]string `form:"accepterVpcAccountIds,omitempty" json:"accepterVpcAccountIds,omitempty"`

	// AccepterVpcIpRanges The IP ranges of the peer Nets, in CIDR notation (for example, `10.0.0.0/24`).
	AccepterVpcIpRanges *[]string `form:"accepterVpcIpRanges,omitempty" json:"accepterVpcIpRanges,omitempty"`

	// AccepterVpcVpcIds The IDs of the peer Nets.
	AccepterVpcVpcIds *[]string `form:"accepterVpcVpcIds,omitempty" json:"accepterVpcVpcIds,omitempty"`

	// Ids The IDs of the Net peerings.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`

	// SourceVpcAccountIds The account IDs of the owners of the peer Nets.
	SourceVpcAccountIds *[]string `form:"sourceVpcAccountIds,omitempty" json:"sourceVpcAccountIds,omitempty"`

	// SourceVpcIpRanges The IP ranges of the peer Nets.
	SourceVpcIpRanges *[]string `form:"sourceVpcIpRanges,omitempty" json:"sourceVpcIpRanges,omitempty"`

	// SourceVpcVpcIds The IDs of the peer Nets.
	SourceVpcVpcIds *[]string `form:"sourceVpcVpcIds,omitempty" json:"sourceVpcVpcIds,omitempty"`
}

// ReadVpcsParams defines parameters for ReadVpcs.
type ReadVpcsParams struct {
	// DhcpOptionsSetIds The IDs of the DHCP options sets.
	DhcpOptionsSetIds *[]string `form:"dhcpOptionsSetIds,omitempty" json:"dhcpOptionsSetIds,omitempty"`

	// IpRanges The IP ranges for the Nets, in CIDR notation (for example, `10.0.0.0/16`).
	IpRanges *[]string `form:"ipRanges,omitempty" json:"ipRanges,omitempty"`

	// IsDefault If true, the Net used is the default one.
	IsDefault *bool `form:"isDefault,omitempty" json:"isDefault,omitempty"`

	// States The states of the Nets (`pending` \| `available` \| `deleting`).
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// TagKeys The keys of the tags associated with the Nets.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the Nets.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the Nets, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// Ids The IDs of the Nets.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`
}

// ReadVpnConnectionsParams defines parameters for ReadVpnConnections.
type ReadVpnConnectionsParams struct {
	// BgpAsns The Border Gateway Protocol (BGP) Autonomous System Numbers (ASNs) of the connections.
	BgpAsns *[]int `form:"bgpAsns,omitempty" json:"bgpAsns,omitempty"`

	// ClientGatewayIds The IDs of the client gateways.
	ClientGatewayIds *[]string `form:"clientGatewayIds,omitempty" json:"clientGatewayIds,omitempty"`

	// ConnectionTypes The types of the VPN connections (only `ipsec.1` is supported).
	ConnectionTypes *[]string `form:"connectionTypes,omitempty" json:"connectionTypes,omitempty"`

	// RouteDestinationIpRanges The destination IP ranges.
	RouteDestinationIpRanges *[]string `form:"routeDestinationIpRanges,omitempty" json:"routeDestinationIpRanges,omitempty"`

	// States The states of the VPN connections (`pending` \| `available` \| `deleting` \| `deleted`).
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// StaticRoutesOnly If false, the VPN connection uses dynamic routing with Border Gateway Protocol (BGP). If true, routing is controlled using static routes. For more information about how to create and delete static routes, see [CreateVpnConnectionRoute](#createvpnconnectionroute) and [DeleteVpnConnectionRoute](#deletevpnconnectionroute).
	StaticRoutesOnly *bool `form:"staticRoutesOnly,omitempty" json:"staticRoutesOnly,omitempty"`

	// TagKeys The keys of the tags associated with the VPN connections.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the VPN connections.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the VPN connections, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// VirtualGatewayIds The IDs of the virtual gateways.
	VirtualGatewayIds *[]string `form:"virtualGatewayIds,omitempty" json:"virtualGatewayIds,omitempty"`

	// Ids The IDs of the VPN connections.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`
}

// DeleteLoadBalancerTagsJSONRequestBody defines body for DeleteLoadBalancerTags for application/json ContentType.
type DeleteLoadBalancerTagsJSONRequestBody = DeleteLoadBalancerTags

// CreateLoadBalancerTagsJSONRequestBody defines body for CreateLoadBalancerTags for application/json ContentType.
type CreateLoadBalancerTagsJSONRequestBody = CreateLoadBalancerTags

// DeleteTagsJSONRequestBody defines body for DeleteTags for application/json ContentType.
type DeleteTagsJSONRequestBody = DeleteTags

// CreateTagsJSONRequestBody defines body for CreateTags for application/json ContentType.
type CreateTagsJSONRequestBody = CreateTags

// CreateClientGatewayJSONRequestBody defines body for CreateClientGateway for application/json ContentType.
type CreateClientGatewayJSONRequestBody = CreateClientGateway

// CreateDhcpOptionsJSONRequestBody defines body for CreateDhcpOptions for application/json ContentType.
type CreateDhcpOptionsJSONRequestBody = CreateDhcpOptions

// CreateDirectLinkInterfaceJSONRequestBody defines body for CreateDirectLinkInterface for application/json ContentType.
type CreateDirectLinkInterfaceJSONRequestBody = CreateDirectLinkInterface

// UpdateDirectLinkInterfaceJSONRequestBody defines body for UpdateDirectLinkInterface for application/json ContentType.
type UpdateDirectLinkInterfaceJSONRequestBody = UpdateDirectLinkInterface

// CreateDirectLinkJSONRequestBody defines body for CreateDirectLink for application/json ContentType.
type CreateDirectLinkJSONRequestBody = CreateDirectLink

// CreateFlexibleGpuJSONRequestBody defines body for CreateFlexibleGpu for application/json ContentType.
type CreateFlexibleGpuJSONRequestBody = CreateFlexibleGpu

// UpdateFlexibleGpuJSONRequestBody defines body for UpdateFlexibleGpu for application/json ContentType.
type UpdateFlexibleGpuJSONRequestBody = UpdateFlexibleGpu

// LinkFlexibleGpuJSONRequestBody defines body for LinkFlexibleGpu for application/json ContentType.
type LinkFlexibleGpuJSONRequestBody = LinkFlexibleGpu

// CreateImageJSONRequestBody defines body for CreateImage for application/json ContentType.
type CreateImageJSONRequestBody = CreateImage

// UpdateImageJSONRequestBody defines body for UpdateImage for application/json ContentType.
type UpdateImageJSONRequestBody = UpdateImage

// LinkInternetGatewayJSONRequestBody defines body for LinkInternetGateway for application/json ContentType.
type LinkInternetGatewayJSONRequestBody = LinkInternetGateway

// UnlinkInternetGatewayJSONRequestBody defines body for UnlinkInternetGateway for application/json ContentType.
type UnlinkInternetGatewayJSONRequestBody = UnlinkInternetGateway

// CreateKeypairJSONRequestBody defines body for CreateKeypair for application/json ContentType.
type CreateKeypairJSONRequestBody CreateKeypairJSONBody

// CreateListenerRuleJSONRequestBody defines body for CreateListenerRule for application/json ContentType.
type CreateListenerRuleJSONRequestBody = CreateListenerRule

// UpdateListenerRuleJSONRequestBody defines body for UpdateListenerRule for application/json ContentType.
type UpdateListenerRuleJSONRequestBody = UpdateListenerRule

// CreateLoadBalancerJSONRequestBody defines body for CreateLoadBalancer for application/json ContentType.
type CreateLoadBalancerJSONRequestBody = CreateLoadBalancer

// UpdateLoadBalancerJSONRequestBody defines body for UpdateLoadBalancer for application/json ContentType.
type UpdateLoadBalancerJSONRequestBody = UpdateLoadBalancer

// LinkLoadBalancerBackendMachinesJSONRequestBody defines body for LinkLoadBalancerBackendMachines for application/json ContentType.
type LinkLoadBalancerBackendMachinesJSONRequestBody = LinkLoadBalancerBackendMachines

// UnlinkLoadBalancerBackendMachinesJSONRequestBody defines body for UnlinkLoadBalancerBackendMachines for application/json ContentType.
type UnlinkLoadBalancerBackendMachinesJSONRequestBody = UnlinkLoadBalancerBackendMachines

// DeleteLoadBalancerListenersJSONRequestBody defines body for DeleteLoadBalancerListeners for application/json ContentType.
type DeleteLoadBalancerListenersJSONRequestBody = DeleteLoadBalancerListeners

// CreateLoadBalancerListenersJSONRequestBody defines body for CreateLoadBalancerListeners for application/json ContentType.
type CreateLoadBalancerListenersJSONRequestBody = CreateLoadBalancerListeners

// DeleteLoadBalancerPolicyJSONRequestBody defines body for DeleteLoadBalancerPolicy for application/json ContentType.
type DeleteLoadBalancerPolicyJSONRequestBody = DeleteLoadBalancerPolicy

// CreateLoadBalancerPolicyJSONRequestBody defines body for CreateLoadBalancerPolicy for application/json ContentType.
type CreateLoadBalancerPolicyJSONRequestBody = CreateLoadBalancerPolicy

// ReadVmsHealthJSONRequestBody defines body for ReadVmsHealth for application/json ContentType.
type ReadVmsHealthJSONRequestBody ReadVmsHealthJSONBody

// ReadLoadBalancerTagsJSONRequestBody defines body for ReadLoadBalancerTags for application/json ContentType.
type ReadLoadBalancerTagsJSONRequestBody ReadLoadBalancerTagsJSONBody

// CreateNatGatewayJSONRequestBody defines body for CreateNatGateway for application/json ContentType.
type CreateNatGatewayJSONRequestBody = CreateNatGateway

// CreateNicJSONRequestBody defines body for CreateNic for application/json ContentType.
type CreateNicJSONRequestBody = CreateNic

// UpdateNicJSONRequestBody defines body for UpdateNic for application/json ContentType.
type UpdateNicJSONRequestBody = UpdateNic

// LinkPrivateIpsJSONRequestBody defines body for LinkPrivateIps for application/json ContentType.
type LinkPrivateIpsJSONRequestBody = LinkPrivateIps

// UnlinkPrivateIpsJSONRequestBody defines body for UnlinkPrivateIps for application/json ContentType.
type UnlinkPrivateIpsJSONRequestBody = UnlinkPrivateIps

// LinkNicJSONRequestBody defines body for LinkNic for application/json ContentType.
type LinkNicJSONRequestBody LinkNicJSONBody

// UnlinkNicJSONRequestBody defines body for UnlinkNic for application/json ContentType.
type UnlinkNicJSONRequestBody = UnlinkNic

// LinkPublicIpJSONRequestBody defines body for LinkPublicIp for application/json ContentType.
type LinkPublicIpJSONRequestBody LinkPublicIpJSONBody

// UnlinkPublicIpJSONRequestBody defines body for UnlinkPublicIp for application/json ContentType.
type UnlinkPublicIpJSONRequestBody = UnlinkPublicIp

// CreateRouteTableJSONRequestBody defines body for CreateRouteTable for application/json ContentType.
type CreateRouteTableJSONRequestBody = CreateRouteTable

// UpdateRouteTableRoutePropagationJSONRequestBody defines body for UpdateRouteTableRoutePropagation for application/json ContentType.
type UpdateRouteTableRoutePropagationJSONRequestBody = UpdateRouteTableRoutePropagation

// DeleteRouteJSONRequestBody defines body for DeleteRoute for application/json ContentType.
type DeleteRouteJSONRequestBody = DeleteRoute

// CreateRouteJSONRequestBody defines body for CreateRoute for application/json ContentType.
type CreateRouteJSONRequestBody = CreateRoute

// UpdateRouteJSONRequestBody defines body for UpdateRoute for application/json ContentType.
type UpdateRouteJSONRequestBody = UpdateRoute

// LinkRouteTableJSONRequestBody defines body for LinkRouteTable for application/json ContentType.
type LinkRouteTableJSONRequestBody LinkRouteTableJSONBody

// UnlinkRouteTableJSONRequestBody defines body for UnlinkRouteTable for application/json ContentType.
type UnlinkRouteTableJSONRequestBody = UnlinkRouteTable

// CreateSecurityGroupJSONRequestBody defines body for CreateSecurityGroup for application/json ContentType.
type CreateSecurityGroupJSONRequestBody = CreateSecurityGroup

// DeleteSecurityGroupRuleJSONRequestBody defines body for DeleteSecurityGroupRule for application/json ContentType.
type DeleteSecurityGroupRuleJSONRequestBody = DeleteSecurityGroupRule

// CreateSecurityGroupRuleJSONRequestBody defines body for CreateSecurityGroupRule for application/json ContentType.
type CreateSecurityGroupRuleJSONRequestBody = CreateSecurityGroupRule

// CreateSnapshotJSONRequestBody defines body for CreateSnapshot for application/json ContentType.
type CreateSnapshotJSONRequestBody = CreateSnapshot

// CreateSubnetJSONRequestBody defines body for CreateSubnet for application/json ContentType.
type CreateSubnetJSONRequestBody = CreateSubnet

// UpdateSubnetJSONRequestBody defines body for UpdateSubnet for application/json ContentType.
type UpdateSubnetJSONRequestBody = UpdateSubnet

// CreateVirtualGatewayJSONRequestBody defines body for CreateVirtualGateway for application/json ContentType.
type CreateVirtualGatewayJSONRequestBody = CreateVirtualGateway

// LinkVirtualGatewayToVpcJSONRequestBody defines body for LinkVirtualGatewayToVpc for application/json ContentType.
type LinkVirtualGatewayToVpcJSONRequestBody LinkVirtualGatewayToVpcJSONBody

// UnlinkVirtualGatewayToVpcJSONRequestBody defines body for UnlinkVirtualGatewayToVpc for application/json ContentType.
type UnlinkVirtualGatewayToVpcJSONRequestBody = UnlinkVirtualGatewayToVpc

// CreateVmsJSONRequestBody defines body for CreateVms for application/json ContentType.
type CreateVmsJSONRequestBody = CreateVms

// UpdateVmJSONRequestBody defines body for UpdateVm for application/json ContentType.
type UpdateVmJSONRequestBody = UpdateVm

// StopVmJSONRequestBody defines body for StopVm for application/json ContentType.
type StopVmJSONRequestBody = StopVm

// CreateVolumeJSONRequestBody defines body for CreateVolume for application/json ContentType.
type CreateVolumeJSONRequestBody = CreateVolume

// UpdateVolumeJSONRequestBody defines body for UpdateVolume for application/json ContentType.
type UpdateVolumeJSONRequestBody = UpdateVolume

// LinkVolumeJSONRequestBody defines body for LinkVolume for application/json ContentType.
type LinkVolumeJSONRequestBody = LinkVolume

// UnlinkVolumeJSONRequestBody defines body for UnlinkVolume for application/json ContentType.
type UnlinkVolumeJSONRequestBody = UnlinkVolume

// CreateVpcAccessPointJSONRequestBody defines body for CreateVpcAccessPoint for application/json ContentType.
type CreateVpcAccessPointJSONRequestBody = CreateVpcAccessPoint

// UpdateVpcAccessPointJSONRequestBody defines body for UpdateVpcAccessPoint for application/json ContentType.
type UpdateVpcAccessPointJSONRequestBody = UpdateVpcAccessPoint

// CreateVpcPeeringJSONRequestBody defines body for CreateVpcPeering for application/json ContentType.
type CreateVpcPeeringJSONRequestBody = CreateVpcPeering

// CreateVpcJSONRequestBody defines body for CreateVpc for application/json ContentType.
type CreateVpcJSONRequestBody = CreateVpc

// UpdateVpcJSONRequestBody defines body for UpdateVpc for application/json ContentType.
type UpdateVpcJSONRequestBody = UpdateVpc

// CreateVpnConnectionJSONRequestBody defines body for CreateVpnConnection for application/json ContentType.
type CreateVpnConnectionJSONRequestBody = CreateVpnConnection

// UpdateVpnConnectionJSONRequestBody defines body for UpdateVpnConnection for application/json ContentType.
type UpdateVpnConnectionJSONRequestBody = UpdateVpnConnection

// DeleteVpnConnectionRouteJSONRequestBody defines body for DeleteVpnConnectionRoute for application/json ContentType.
type DeleteVpnConnectionRouteJSONRequestBody = DeleteVpnConnectionRoute

// CreateVpnConnectionRouteJSONRequestBody defines body for CreateVpnConnectionRoute for application/json ContentType.
type CreateVpnConnectionRouteJSONRequestBody = CreateVpnConnectionRoute

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// DeleteLoadBalancerTagsWithBody request with any body
	DeleteLoadBalancerTagsWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteLoadBalancerTags(ctx context.Context, spaceId SpaceId, body DeleteLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLoadBalancerTagsWithBody request with any body
	CreateLoadBalancerTagsWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLoadBalancerTags(ctx context.Context, spaceId SpaceId, body CreateLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTagsWithBody request with any body
	DeleteTagsWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteTags(ctx context.Context, spaceId SpaceId, body DeleteTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTagsWithBody request with any body
	CreateTagsWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTags(ctx context.Context, spaceId SpaceId, body CreateTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadClientGateways request
	ReadClientGateways(ctx context.Context, spaceId SpaceId, params *ReadClientGatewaysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateClientGatewayWithBody request with any body
	CreateClientGatewayWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateClientGateway(ctx context.Context, spaceId SpaceId, body CreateClientGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteClientGateway request
	DeleteClientGateway(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadClientGatewaysById request
	ReadClientGatewaysById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadDhcpOptions request
	ReadDhcpOptions(ctx context.Context, spaceId SpaceId, params *ReadDhcpOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDhcpOptionsWithBody request with any body
	CreateDhcpOptionsWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDhcpOptions(ctx context.Context, spaceId SpaceId, body CreateDhcpOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDhcpOptions request
	DeleteDhcpOptions(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadDhcpOptionsById request
	ReadDhcpOptionsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadDirectLinkInterfaces request
	ReadDirectLinkInterfaces(ctx context.Context, spaceId SpaceId, params *ReadDirectLinkInterfacesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDirectLinkInterfaceWithBody request with any body
	CreateDirectLinkInterfaceWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDirectLinkInterface(ctx context.Context, spaceId SpaceId, body CreateDirectLinkInterfaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDirectLinkInterface request
	DeleteDirectLinkInterface(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadDirectLinkInterfacesById request
	ReadDirectLinkInterfacesById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDirectLinkInterfaceWithBody request with any body
	UpdateDirectLinkInterfaceWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDirectLinkInterface(ctx context.Context, spaceId SpaceId, id string, body UpdateDirectLinkInterfaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadDirectLinks request
	ReadDirectLinks(ctx context.Context, spaceId SpaceId, params *ReadDirectLinksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDirectLinkWithBody request with any body
	CreateDirectLinkWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDirectLink(ctx context.Context, spaceId SpaceId, body CreateDirectLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDirectLink request
	DeleteDirectLink(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadDirectLinksById request
	ReadDirectLinksById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadFlexibleGpuCatalog request
	ReadFlexibleGpuCatalog(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadFlexibleGpus request
	ReadFlexibleGpus(ctx context.Context, spaceId SpaceId, params *ReadFlexibleGpusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFlexibleGpuWithBody request with any body
	CreateFlexibleGpuWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFlexibleGpu(ctx context.Context, spaceId SpaceId, body CreateFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFlexibleGpu request
	DeleteFlexibleGpu(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadFlexibleGpusById request
	ReadFlexibleGpusById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateFlexibleGpuWithBody request with any body
	UpdateFlexibleGpuWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateFlexibleGpu(ctx context.Context, spaceId SpaceId, id string, body UpdateFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkFlexibleGpuWithBody request with any body
	LinkFlexibleGpuWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkFlexibleGpu(ctx context.Context, spaceId SpaceId, id string, body LinkFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkFlexibleGpu request
	UnlinkFlexibleGpu(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadImages request
	ReadImages(ctx context.Context, spaceId SpaceId, params *ReadImagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateImageWithBody request with any body
	CreateImageWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateImage(ctx context.Context, spaceId SpaceId, body CreateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteImage request
	DeleteImage(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadImagesById request
	ReadImagesById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateImageWithBody request with any body
	UpdateImageWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateImage(ctx context.Context, spaceId SpaceId, id string, body UpdateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadInternetGateways request
	ReadInternetGateways(ctx context.Context, spaceId SpaceId, params *ReadInternetGatewaysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateInternetGateway request
	CreateInternetGateway(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteInternetGateway request
	DeleteInternetGateway(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadInternetGatewaysById request
	ReadInternetGatewaysById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkInternetGatewayWithBody request with any body
	LinkInternetGatewayWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkInternetGateway(ctx context.Context, spaceId SpaceId, id string, body LinkInternetGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkInternetGatewayWithBody request with any body
	UnlinkInternetGatewayWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnlinkInternetGateway(ctx context.Context, spaceId SpaceId, id string, body UnlinkInternetGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadKeypairs request
	ReadKeypairs(ctx context.Context, spaceId SpaceId, params *ReadKeypairsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateKeypairWithBody request with any body
	CreateKeypairWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateKeypair(ctx context.Context, spaceId SpaceId, body CreateKeypairJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteKeypair request
	DeleteKeypair(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadKeypairsById request
	ReadKeypairsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadListenerRules request
	ReadListenerRules(ctx context.Context, spaceId SpaceId, params *ReadListenerRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateListenerRuleWithBody request with any body
	CreateListenerRuleWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateListenerRule(ctx context.Context, spaceId SpaceId, body CreateListenerRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteListenerRule request
	DeleteListenerRule(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadListenerRulesById request
	ReadListenerRulesById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateListenerRuleWithBody request with any body
	UpdateListenerRuleWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateListenerRule(ctx context.Context, spaceId SpaceId, id string, body UpdateListenerRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadLoadBalancers request
	ReadLoadBalancers(ctx context.Context, spaceId SpaceId, params *ReadLoadBalancersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLoadBalancerWithBody request with any body
	CreateLoadBalancerWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLoadBalancer(ctx context.Context, spaceId SpaceId, body CreateLoadBalancerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLoadBalancer request
	DeleteLoadBalancer(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadLoadBalancersById request
	ReadLoadBalancersById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateLoadBalancerWithBody request with any body
	UpdateLoadBalancerWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateLoadBalancer(ctx context.Context, spaceId SpaceId, id string, body UpdateLoadBalancerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkLoadBalancerBackendMachinesWithBody request with any body
	LinkLoadBalancerBackendMachinesWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkLoadBalancerBackendMachines(ctx context.Context, spaceId SpaceId, id string, body LinkLoadBalancerBackendMachinesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkLoadBalancerBackendMachinesWithBody request with any body
	UnlinkLoadBalancerBackendMachinesWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnlinkLoadBalancerBackendMachines(ctx context.Context, spaceId SpaceId, id string, body UnlinkLoadBalancerBackendMachinesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLoadBalancerListenersWithBody request with any body
	DeleteLoadBalancerListenersWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteLoadBalancerListeners(ctx context.Context, spaceId SpaceId, id string, body DeleteLoadBalancerListenersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLoadBalancerListenersWithBody request with any body
	CreateLoadBalancerListenersWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLoadBalancerListeners(ctx context.Context, spaceId SpaceId, id string, body CreateLoadBalancerListenersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLoadBalancerPolicyWithBody request with any body
	DeleteLoadBalancerPolicyWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteLoadBalancerPolicy(ctx context.Context, spaceId SpaceId, id string, body DeleteLoadBalancerPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLoadBalancerPolicyWithBody request with any body
	CreateLoadBalancerPolicyWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLoadBalancerPolicy(ctx context.Context, spaceId SpaceId, id string, body CreateLoadBalancerPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVmsHealthWithBody request with any body
	ReadVmsHealthWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReadVmsHealth(ctx context.Context, spaceId SpaceId, id string, body ReadVmsHealthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadLoadBalancerTagsWithBody request with any body
	ReadLoadBalancerTagsWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReadLoadBalancerTags(ctx context.Context, spaceId SpaceId, body ReadLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadLocations request
	ReadLocations(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadNatGateway request
	ReadNatGateway(ctx context.Context, spaceId SpaceId, params *ReadNatGatewayParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNatGatewayWithBody request with any body
	CreateNatGatewayWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNatGateway(ctx context.Context, spaceId SpaceId, body CreateNatGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNatGateway request
	DeleteNatGateway(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadNatGatewayById request
	ReadNatGatewayById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadNics request
	ReadNics(ctx context.Context, spaceId SpaceId, params *ReadNicsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNicWithBody request with any body
	CreateNicWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNic(ctx context.Context, spaceId SpaceId, body CreateNicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNic request
	DeleteNic(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadNicsById request
	ReadNicsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateNicWithBody request with any body
	UpdateNicWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateNic(ctx context.Context, spaceId SpaceId, id string, body UpdateNicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkPrivateIpsWithBody request with any body
	LinkPrivateIpsWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkPrivateIps(ctx context.Context, spaceId SpaceId, id string, body LinkPrivateIpsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkPrivateIpsWithBody request with any body
	UnlinkPrivateIpsWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnlinkPrivateIps(ctx context.Context, spaceId SpaceId, id string, body UnlinkPrivateIpsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkNicWithBody request with any body
	LinkNicWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkNic(ctx context.Context, spaceId SpaceId, id string, body LinkNicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkNicWithBody request with any body
	UnlinkNicWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnlinkNic(ctx context.Context, spaceId SpaceId, id string, body UnlinkNicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadProductTypes request
	ReadProductTypes(ctx context.Context, spaceId SpaceId, params *ReadProductTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadProductTypesById request
	ReadProductTypesById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadPublicIpRanges request
	ReadPublicIpRanges(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadPublicIps request
	ReadPublicIps(ctx context.Context, spaceId SpaceId, params *ReadPublicIpsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePublicIp request
	CreatePublicIp(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePublicIp request
	DeletePublicIp(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadPublicIpsById request
	ReadPublicIpsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkPublicIpWithBody request with any body
	LinkPublicIpWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkPublicIp(ctx context.Context, spaceId SpaceId, id string, body LinkPublicIpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkPublicIpWithBody request with any body
	UnlinkPublicIpWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnlinkPublicIp(ctx context.Context, spaceId SpaceId, id string, body UnlinkPublicIpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadRouteTables request
	ReadRouteTables(ctx context.Context, spaceId SpaceId, params *ReadRouteTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRouteTableWithBody request with any body
	CreateRouteTableWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRouteTable(ctx context.Context, spaceId SpaceId, body CreateRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRouteTable request
	DeleteRouteTable(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadRouteTablesById request
	ReadRouteTablesById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRouteTableRoutePropagationWithBody request with any body
	UpdateRouteTableRoutePropagationWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRouteTableRoutePropagation(ctx context.Context, spaceId SpaceId, id string, body UpdateRouteTableRoutePropagationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRouteWithBody request with any body
	DeleteRouteWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteRoute(ctx context.Context, spaceId SpaceId, id string, body DeleteRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRouteWithBody request with any body
	CreateRouteWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRoute(ctx context.Context, spaceId SpaceId, id string, body CreateRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRouteWithBody request with any body
	UpdateRouteWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRoute(ctx context.Context, spaceId SpaceId, id string, body UpdateRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkRouteTableWithBody request with any body
	LinkRouteTableWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkRouteTable(ctx context.Context, spaceId SpaceId, id string, body LinkRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkRouteTableWithBody request with any body
	UnlinkRouteTableWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnlinkRouteTable(ctx context.Context, spaceId SpaceId, id string, body UnlinkRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadSecurityGroups request
	ReadSecurityGroups(ctx context.Context, spaceId SpaceId, params *ReadSecurityGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSecurityGroupWithBody request with any body
	CreateSecurityGroupWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSecurityGroup(ctx context.Context, spaceId SpaceId, body CreateSecurityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSecurityGroup request
	DeleteSecurityGroup(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadSecurityGroupsById request
	ReadSecurityGroupsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSecurityGroupRuleWithBody request with any body
	DeleteSecurityGroupRuleWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteSecurityGroupRule(ctx context.Context, spaceId SpaceId, id string, body DeleteSecurityGroupRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSecurityGroupRuleWithBody request with any body
	CreateSecurityGroupRuleWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSecurityGroupRule(ctx context.Context, spaceId SpaceId, id string, body CreateSecurityGroupRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadSnapshots request
	ReadSnapshots(ctx context.Context, spaceId SpaceId, params *ReadSnapshotsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSnapshotWithBody request with any body
	CreateSnapshotWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSnapshot(ctx context.Context, spaceId SpaceId, body CreateSnapshotJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSnapshot request
	DeleteSnapshot(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadSnapshotsById request
	ReadSnapshotsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadSubnets request
	ReadSubnets(ctx context.Context, spaceId SpaceId, params *ReadSubnetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSubnetWithBody request with any body
	CreateSubnetWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSubnet(ctx context.Context, spaceId SpaceId, body CreateSubnetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSubnet request
	DeleteSubnet(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadSubnetsById request
	ReadSubnetsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSubnetWithBody request with any body
	UpdateSubnetWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSubnet(ctx context.Context, spaceId SpaceId, id string, body UpdateSubnetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadTags request
	ReadTags(ctx context.Context, spaceId SpaceId, params *ReadTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVirtualGateways request
	ReadVirtualGateways(ctx context.Context, spaceId SpaceId, params *ReadVirtualGatewaysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVirtualGatewayWithBody request with any body
	CreateVirtualGatewayWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVirtualGateway(ctx context.Context, spaceId SpaceId, body CreateVirtualGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVirtualGateway request
	DeleteVirtualGateway(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVirtualGatewaysById request
	ReadVirtualGatewaysById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkVirtualGatewayToVpcWithBody request with any body
	LinkVirtualGatewayToVpcWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkVirtualGatewayToVpc(ctx context.Context, spaceId SpaceId, id string, body LinkVirtualGatewayToVpcJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkVirtualGatewayToVpcWithBody request with any body
	UnlinkVirtualGatewayToVpcWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnlinkVirtualGatewayToVpc(ctx context.Context, spaceId SpaceId, id string, body UnlinkVirtualGatewayToVpcJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVms request
	ReadVms(ctx context.Context, spaceId SpaceId, params *ReadVmsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVmsWithBody request with any body
	CreateVmsWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVms(ctx context.Context, spaceId SpaceId, body CreateVmsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVmsState request
	ReadVmsState(ctx context.Context, spaceId SpaceId, params *ReadVmsStateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVms request
	DeleteVms(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVmsById request
	ReadVmsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVmWithBody request with any body
	UpdateVmWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVm(ctx context.Context, spaceId SpaceId, id string, body UpdateVmJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadAdminPassword request
	ReadAdminPassword(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadConsoleOutput request
	ReadConsoleOutput(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RebootVm request
	RebootVm(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartVm request
	StartVm(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StopVmWithBody request with any body
	StopVmWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StopVm(ctx context.Context, spaceId SpaceId, id string, body StopVmJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVolumes request
	ReadVolumes(ctx context.Context, spaceId SpaceId, params *ReadVolumesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVolumeWithBody request with any body
	CreateVolumeWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVolume(ctx context.Context, spaceId SpaceId, body CreateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVolume request
	DeleteVolume(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVolumesById request
	ReadVolumesById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVolumeWithBody request with any body
	UpdateVolumeWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVolume(ctx context.Context, spaceId SpaceId, id string, body UpdateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkVolumeWithBody request with any body
	LinkVolumeWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkVolume(ctx context.Context, spaceId SpaceId, id string, body LinkVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkVolumeWithBody request with any body
	UnlinkVolumeWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnlinkVolume(ctx context.Context, spaceId SpaceId, id string, body UnlinkVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVpcAccessPoints request
	ReadVpcAccessPoints(ctx context.Context, spaceId SpaceId, params *ReadVpcAccessPointsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVpcAccessPointWithBody request with any body
	CreateVpcAccessPointWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVpcAccessPoint(ctx context.Context, spaceId SpaceId, body CreateVpcAccessPointJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVpcAccessPoint request
	DeleteVpcAccessPoint(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVpcAccessPointsById request
	ReadVpcAccessPointsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVpcAccessPointWithBody request with any body
	UpdateVpcAccessPointWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVpcAccessPoint(ctx context.Context, spaceId SpaceId, id string, body UpdateVpcAccessPointJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVpcPeerings request
	ReadVpcPeerings(ctx context.Context, spaceId SpaceId, params *ReadVpcPeeringsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVpcPeeringWithBody request with any body
	CreateVpcPeeringWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVpcPeering(ctx context.Context, spaceId SpaceId, body CreateVpcPeeringJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVpcPeering request
	DeleteVpcPeering(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVpcPeeringsById request
	ReadVpcPeeringsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AcceptVpcPeering request
	AcceptVpcPeering(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RejectVpcPeering request
	RejectVpcPeering(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVpcs request
	ReadVpcs(ctx context.Context, spaceId SpaceId, params *ReadVpcsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVpcWithBody request with any body
	CreateVpcWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVpc(ctx context.Context, spaceId SpaceId, body CreateVpcJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVpc request
	DeleteVpc(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVpcsById request
	ReadVpcsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVpcWithBody request with any body
	UpdateVpcWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVpc(ctx context.Context, spaceId SpaceId, id string, body UpdateVpcJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVpnConnections request
	ReadVpnConnections(ctx context.Context, spaceId SpaceId, params *ReadVpnConnectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVpnConnectionWithBody request with any body
	CreateVpnConnectionWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVpnConnection(ctx context.Context, spaceId SpaceId, body CreateVpnConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVpnConnection request
	DeleteVpnConnection(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVpnConnectionsById request
	ReadVpnConnectionsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVpnConnectionWithBody request with any body
	UpdateVpnConnectionWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVpnConnection(ctx context.Context, spaceId SpaceId, id string, body UpdateVpnConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVpnConnectionRouteWithBody request with any body
	DeleteVpnConnectionRouteWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteVpnConnectionRoute(ctx context.Context, spaceId SpaceId, id string, body DeleteVpnConnectionRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVpnConnectionRouteWithBody request with any body
	CreateVpnConnectionRouteWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVpnConnectionRoute(ctx context.Context, spaceId SpaceId, id string, body CreateVpnConnectionRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) DeleteLoadBalancerTagsWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLoadBalancerTagsRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLoadBalancerTags(ctx context.Context, spaceId SpaceId, body DeleteLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLoadBalancerTagsRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLoadBalancerTagsWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLoadBalancerTagsRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLoadBalancerTags(ctx context.Context, spaceId SpaceId, body CreateLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLoadBalancerTagsRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTagsWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTagsRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTags(ctx context.Context, spaceId SpaceId, body DeleteTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTagsRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTagsWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTagsRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTags(ctx context.Context, spaceId SpaceId, body CreateTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTagsRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadClientGateways(ctx context.Context, spaceId SpaceId, params *ReadClientGatewaysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadClientGatewaysRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClientGatewayWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientGatewayRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClientGateway(ctx context.Context, spaceId SpaceId, body CreateClientGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientGatewayRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteClientGateway(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClientGatewayRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadClientGatewaysById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadClientGatewaysByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadDhcpOptions(ctx context.Context, spaceId SpaceId, params *ReadDhcpOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadDhcpOptionsRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDhcpOptionsWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDhcpOptionsRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDhcpOptions(ctx context.Context, spaceId SpaceId, body CreateDhcpOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDhcpOptionsRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDhcpOptions(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDhcpOptionsRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadDhcpOptionsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadDhcpOptionsByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadDirectLinkInterfaces(ctx context.Context, spaceId SpaceId, params *ReadDirectLinkInterfacesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadDirectLinkInterfacesRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDirectLinkInterfaceWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDirectLinkInterfaceRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDirectLinkInterface(ctx context.Context, spaceId SpaceId, body CreateDirectLinkInterfaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDirectLinkInterfaceRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDirectLinkInterface(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDirectLinkInterfaceRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadDirectLinkInterfacesById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadDirectLinkInterfacesByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDirectLinkInterfaceWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDirectLinkInterfaceRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDirectLinkInterface(ctx context.Context, spaceId SpaceId, id string, body UpdateDirectLinkInterfaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDirectLinkInterfaceRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadDirectLinks(ctx context.Context, spaceId SpaceId, params *ReadDirectLinksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadDirectLinksRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDirectLinkWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDirectLinkRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDirectLink(ctx context.Context, spaceId SpaceId, body CreateDirectLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDirectLinkRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDirectLink(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDirectLinkRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadDirectLinksById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadDirectLinksByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadFlexibleGpuCatalog(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadFlexibleGpuCatalogRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadFlexibleGpus(ctx context.Context, spaceId SpaceId, params *ReadFlexibleGpusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadFlexibleGpusRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFlexibleGpuWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFlexibleGpuRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFlexibleGpu(ctx context.Context, spaceId SpaceId, body CreateFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFlexibleGpuRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFlexibleGpu(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFlexibleGpuRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadFlexibleGpusById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadFlexibleGpusByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFlexibleGpuWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFlexibleGpuRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFlexibleGpu(ctx context.Context, spaceId SpaceId, id string, body UpdateFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFlexibleGpuRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkFlexibleGpuWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkFlexibleGpuRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkFlexibleGpu(ctx context.Context, spaceId SpaceId, id string, body LinkFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkFlexibleGpuRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkFlexibleGpu(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkFlexibleGpuRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadImages(ctx context.Context, spaceId SpaceId, params *ReadImagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadImagesRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateImageWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateImageRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateImage(ctx context.Context, spaceId SpaceId, body CreateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateImageRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteImage(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteImageRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadImagesById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadImagesByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateImageWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateImageRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateImage(ctx context.Context, spaceId SpaceId, id string, body UpdateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateImageRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadInternetGateways(ctx context.Context, spaceId SpaceId, params *ReadInternetGatewaysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadInternetGatewaysRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateInternetGateway(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateInternetGatewayRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteInternetGateway(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteInternetGatewayRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadInternetGatewaysById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadInternetGatewaysByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkInternetGatewayWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkInternetGatewayRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkInternetGateway(ctx context.Context, spaceId SpaceId, id string, body LinkInternetGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkInternetGatewayRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkInternetGatewayWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkInternetGatewayRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkInternetGateway(ctx context.Context, spaceId SpaceId, id string, body UnlinkInternetGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkInternetGatewayRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadKeypairs(ctx context.Context, spaceId SpaceId, params *ReadKeypairsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadKeypairsRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKeypairWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeypairRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKeypair(ctx context.Context, spaceId SpaceId, body CreateKeypairJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeypairRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteKeypair(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteKeypairRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadKeypairsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadKeypairsByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadListenerRules(ctx context.Context, spaceId SpaceId, params *ReadListenerRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadListenerRulesRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateListenerRuleWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateListenerRuleRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateListenerRule(ctx context.Context, spaceId SpaceId, body CreateListenerRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateListenerRuleRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteListenerRule(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteListenerRuleRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadListenerRulesById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadListenerRulesByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateListenerRuleWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateListenerRuleRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateListenerRule(ctx context.Context, spaceId SpaceId, id string, body UpdateListenerRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateListenerRuleRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadLoadBalancers(ctx context.Context, spaceId SpaceId, params *ReadLoadBalancersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadLoadBalancersRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLoadBalancerWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLoadBalancerRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLoadBalancer(ctx context.Context, spaceId SpaceId, body CreateLoadBalancerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLoadBalancerRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLoadBalancer(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLoadBalancerRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadLoadBalancersById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadLoadBalancersByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLoadBalancerWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLoadBalancerRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLoadBalancer(ctx context.Context, spaceId SpaceId, id string, body UpdateLoadBalancerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLoadBalancerRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkLoadBalancerBackendMachinesWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkLoadBalancerBackendMachinesRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkLoadBalancerBackendMachines(ctx context.Context, spaceId SpaceId, id string, body LinkLoadBalancerBackendMachinesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkLoadBalancerBackendMachinesRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkLoadBalancerBackendMachinesWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkLoadBalancerBackendMachinesRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkLoadBalancerBackendMachines(ctx context.Context, spaceId SpaceId, id string, body UnlinkLoadBalancerBackendMachinesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkLoadBalancerBackendMachinesRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLoadBalancerListenersWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLoadBalancerListenersRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLoadBalancerListeners(ctx context.Context, spaceId SpaceId, id string, body DeleteLoadBalancerListenersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLoadBalancerListenersRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLoadBalancerListenersWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLoadBalancerListenersRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLoadBalancerListeners(ctx context.Context, spaceId SpaceId, id string, body CreateLoadBalancerListenersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLoadBalancerListenersRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLoadBalancerPolicyWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLoadBalancerPolicyRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLoadBalancerPolicy(ctx context.Context, spaceId SpaceId, id string, body DeleteLoadBalancerPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLoadBalancerPolicyRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLoadBalancerPolicyWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLoadBalancerPolicyRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLoadBalancerPolicy(ctx context.Context, spaceId SpaceId, id string, body CreateLoadBalancerPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLoadBalancerPolicyRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVmsHealthWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVmsHealthRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVmsHealth(ctx context.Context, spaceId SpaceId, id string, body ReadVmsHealthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVmsHealthRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadLoadBalancerTagsWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadLoadBalancerTagsRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadLoadBalancerTags(ctx context.Context, spaceId SpaceId, body ReadLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadLoadBalancerTagsRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadLocations(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadLocationsRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadNatGateway(ctx context.Context, spaceId SpaceId, params *ReadNatGatewayParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadNatGatewayRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNatGatewayWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNatGatewayRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNatGateway(ctx context.Context, spaceId SpaceId, body CreateNatGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNatGatewayRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNatGateway(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNatGatewayRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadNatGatewayById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadNatGatewayByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadNics(ctx context.Context, spaceId SpaceId, params *ReadNicsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadNicsRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNicWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNicRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNic(ctx context.Context, spaceId SpaceId, body CreateNicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNicRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNic(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNicRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadNicsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadNicsByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNicWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNicRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNic(ctx context.Context, spaceId SpaceId, id string, body UpdateNicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNicRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkPrivateIpsWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkPrivateIpsRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkPrivateIps(ctx context.Context, spaceId SpaceId, id string, body LinkPrivateIpsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkPrivateIpsRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkPrivateIpsWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkPrivateIpsRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkPrivateIps(ctx context.Context, spaceId SpaceId, id string, body UnlinkPrivateIpsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkPrivateIpsRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkNicWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkNicRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkNic(ctx context.Context, spaceId SpaceId, id string, body LinkNicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkNicRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkNicWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkNicRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkNic(ctx context.Context, spaceId SpaceId, id string, body UnlinkNicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkNicRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadProductTypes(ctx context.Context, spaceId SpaceId, params *ReadProductTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadProductTypesRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadProductTypesById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadProductTypesByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadPublicIpRanges(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadPublicIpRangesRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadPublicIps(ctx context.Context, spaceId SpaceId, params *ReadPublicIpsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadPublicIpsRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePublicIp(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePublicIpRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePublicIp(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePublicIpRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadPublicIpsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadPublicIpsByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkPublicIpWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkPublicIpRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkPublicIp(ctx context.Context, spaceId SpaceId, id string, body LinkPublicIpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkPublicIpRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkPublicIpWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkPublicIpRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkPublicIp(ctx context.Context, spaceId SpaceId, id string, body UnlinkPublicIpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkPublicIpRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadRouteTables(ctx context.Context, spaceId SpaceId, params *ReadRouteTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadRouteTablesRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRouteTableWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRouteTableRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRouteTable(ctx context.Context, spaceId SpaceId, body CreateRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRouteTableRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRouteTable(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRouteTableRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadRouteTablesById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadRouteTablesByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRouteTableRoutePropagationWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRouteTableRoutePropagationRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRouteTableRoutePropagation(ctx context.Context, spaceId SpaceId, id string, body UpdateRouteTableRoutePropagationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRouteTableRoutePropagationRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRouteWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRouteRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRoute(ctx context.Context, spaceId SpaceId, id string, body DeleteRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRouteRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRouteWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRouteRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRoute(ctx context.Context, spaceId SpaceId, id string, body CreateRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRouteRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRouteWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRouteRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRoute(ctx context.Context, spaceId SpaceId, id string, body UpdateRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRouteRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkRouteTableWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkRouteTableRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkRouteTable(ctx context.Context, spaceId SpaceId, id string, body LinkRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkRouteTableRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkRouteTableWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkRouteTableRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkRouteTable(ctx context.Context, spaceId SpaceId, id string, body UnlinkRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkRouteTableRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadSecurityGroups(ctx context.Context, spaceId SpaceId, params *ReadSecurityGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadSecurityGroupsRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSecurityGroupWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSecurityGroupRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSecurityGroup(ctx context.Context, spaceId SpaceId, body CreateSecurityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSecurityGroupRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSecurityGroup(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSecurityGroupRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadSecurityGroupsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadSecurityGroupsByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSecurityGroupRuleWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSecurityGroupRuleRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSecurityGroupRule(ctx context.Context, spaceId SpaceId, id string, body DeleteSecurityGroupRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSecurityGroupRuleRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSecurityGroupRuleWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSecurityGroupRuleRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSecurityGroupRule(ctx context.Context, spaceId SpaceId, id string, body CreateSecurityGroupRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSecurityGroupRuleRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadSnapshots(ctx context.Context, spaceId SpaceId, params *ReadSnapshotsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadSnapshotsRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSnapshotWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSnapshotRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSnapshot(ctx context.Context, spaceId SpaceId, body CreateSnapshotJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSnapshotRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSnapshot(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSnapshotRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadSnapshotsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadSnapshotsByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadSubnets(ctx context.Context, spaceId SpaceId, params *ReadSubnetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadSubnetsRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSubnetWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSubnetRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSubnet(ctx context.Context, spaceId SpaceId, body CreateSubnetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSubnetRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSubnet(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSubnetRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadSubnetsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadSubnetsByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSubnetWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSubnetRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSubnet(ctx context.Context, spaceId SpaceId, id string, body UpdateSubnetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSubnetRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadTags(ctx context.Context, spaceId SpaceId, params *ReadTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadTagsRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVirtualGateways(ctx context.Context, spaceId SpaceId, params *ReadVirtualGatewaysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVirtualGatewaysRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVirtualGatewayWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVirtualGatewayRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVirtualGateway(ctx context.Context, spaceId SpaceId, body CreateVirtualGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVirtualGatewayRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVirtualGateway(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVirtualGatewayRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVirtualGatewaysById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVirtualGatewaysByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkVirtualGatewayToVpcWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkVirtualGatewayToVpcRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkVirtualGatewayToVpc(ctx context.Context, spaceId SpaceId, id string, body LinkVirtualGatewayToVpcJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkVirtualGatewayToVpcRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkVirtualGatewayToVpcWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkVirtualGatewayToVpcRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkVirtualGatewayToVpc(ctx context.Context, spaceId SpaceId, id string, body UnlinkVirtualGatewayToVpcJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkVirtualGatewayToVpcRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVms(ctx context.Context, spaceId SpaceId, params *ReadVmsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVmsRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVmsWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVmsRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVms(ctx context.Context, spaceId SpaceId, body CreateVmsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVmsRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVmsState(ctx context.Context, spaceId SpaceId, params *ReadVmsStateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVmsStateRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVms(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVmsRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVmsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVmsByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVmWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVmRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVm(ctx context.Context, spaceId SpaceId, id string, body UpdateVmJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVmRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadAdminPassword(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadAdminPasswordRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadConsoleOutput(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadConsoleOutputRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RebootVm(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRebootVmRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartVm(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartVmRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopVmWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopVmRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopVm(ctx context.Context, spaceId SpaceId, id string, body StopVmJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopVmRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVolumes(ctx context.Context, spaceId SpaceId, params *ReadVolumesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVolumesRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVolumeWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVolumeRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVolume(ctx context.Context, spaceId SpaceId, body CreateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVolumeRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVolume(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVolumeRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVolumesById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVolumesByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVolumeWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVolumeRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVolume(ctx context.Context, spaceId SpaceId, id string, body UpdateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVolumeRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkVolumeWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkVolumeRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkVolume(ctx context.Context, spaceId SpaceId, id string, body LinkVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkVolumeRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkVolumeWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkVolumeRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkVolume(ctx context.Context, spaceId SpaceId, id string, body UnlinkVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkVolumeRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVpcAccessPoints(ctx context.Context, spaceId SpaceId, params *ReadVpcAccessPointsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVpcAccessPointsRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVpcAccessPointWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVpcAccessPointRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVpcAccessPoint(ctx context.Context, spaceId SpaceId, body CreateVpcAccessPointJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVpcAccessPointRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVpcAccessPoint(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVpcAccessPointRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVpcAccessPointsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVpcAccessPointsByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVpcAccessPointWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVpcAccessPointRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVpcAccessPoint(ctx context.Context, spaceId SpaceId, id string, body UpdateVpcAccessPointJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVpcAccessPointRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVpcPeerings(ctx context.Context, spaceId SpaceId, params *ReadVpcPeeringsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVpcPeeringsRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVpcPeeringWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVpcPeeringRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVpcPeering(ctx context.Context, spaceId SpaceId, body CreateVpcPeeringJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVpcPeeringRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVpcPeering(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVpcPeeringRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVpcPeeringsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVpcPeeringsByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AcceptVpcPeering(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcceptVpcPeeringRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RejectVpcPeering(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRejectVpcPeeringRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVpcs(ctx context.Context, spaceId SpaceId, params *ReadVpcsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVpcsRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVpcWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVpcRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVpc(ctx context.Context, spaceId SpaceId, body CreateVpcJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVpcRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVpc(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVpcRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVpcsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVpcsByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVpcWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVpcRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVpc(ctx context.Context, spaceId SpaceId, id string, body UpdateVpcJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVpcRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVpnConnections(ctx context.Context, spaceId SpaceId, params *ReadVpnConnectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVpnConnectionsRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVpnConnectionWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVpnConnectionRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVpnConnection(ctx context.Context, spaceId SpaceId, body CreateVpnConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVpnConnectionRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVpnConnection(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVpnConnectionRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVpnConnectionsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVpnConnectionsByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVpnConnectionWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVpnConnectionRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVpnConnection(ctx context.Context, spaceId SpaceId, id string, body UpdateVpnConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVpnConnectionRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVpnConnectionRouteWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVpnConnectionRouteRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVpnConnectionRoute(ctx context.Context, spaceId SpaceId, id string, body DeleteVpnConnectionRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVpnConnectionRouteRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVpnConnectionRouteWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVpnConnectionRouteRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVpnConnectionRoute(ctx context.Context, spaceId SpaceId, id string, body CreateVpnConnectionRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVpnConnectionRouteRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewDeleteLoadBalancerTagsRequest calls the generic DeleteLoadBalancerTags builder with application/json body
func NewDeleteLoadBalancerTagsRequest(server string, spaceId SpaceId, body DeleteLoadBalancerTagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteLoadBalancerTagsRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewDeleteLoadBalancerTagsRequestWithBody generates requests for DeleteLoadBalancerTags with any type of body
func NewDeleteLoadBalancerTagsRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/bulk/loadBalancersTags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateLoadBalancerTagsRequest calls the generic CreateLoadBalancerTags builder with application/json body
func NewCreateLoadBalancerTagsRequest(server string, spaceId SpaceId, body CreateLoadBalancerTagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLoadBalancerTagsRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateLoadBalancerTagsRequestWithBody generates requests for CreateLoadBalancerTags with any type of body
func NewCreateLoadBalancerTagsRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/bulk/loadBalancersTags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTagsRequest calls the generic DeleteTags builder with application/json body
func NewDeleteTagsRequest(server string, spaceId SpaceId, body DeleteTagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteTagsRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewDeleteTagsRequestWithBody generates requests for DeleteTags with any type of body
func NewDeleteTagsRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/bulk/tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateTagsRequest calls the generic CreateTags builder with application/json body
func NewCreateTagsRequest(server string, spaceId SpaceId, body CreateTagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTagsRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateTagsRequestWithBody generates requests for CreateTags with any type of body
func NewCreateTagsRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/bulk/tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadClientGatewaysRequest generates requests for ReadClientGateways
func NewReadClientGatewaysRequest(server string, spaceId SpaceId, params *ReadClientGatewaysParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/clientGateways", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BgpAsns != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bgpAsns", runtime.ParamLocationQuery, *params.BgpAsns); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ConnectionTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "connectionTypes", runtime.ParamLocationQuery, *params.ConnectionTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PublicIps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "publicIps", runtime.ParamLocationQuery, *params.PublicIps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateClientGatewayRequest calls the generic CreateClientGateway builder with application/json body
func NewCreateClientGatewayRequest(server string, spaceId SpaceId, body CreateClientGatewayJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateClientGatewayRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateClientGatewayRequestWithBody generates requests for CreateClientGateway with any type of body
func NewCreateClientGatewayRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/clientGateways", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteClientGatewayRequest generates requests for DeleteClientGateway
func NewDeleteClientGatewayRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/clientGateways/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadClientGatewaysByIdRequest generates requests for ReadClientGatewaysById
func NewReadClientGatewaysByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/clientGateways/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadDhcpOptionsRequest generates requests for ReadDhcpOptions
func NewReadDhcpOptionsRequest(server string, spaceId SpaceId, params *ReadDhcpOptionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/dhcpOptions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Default != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "default", runtime.ParamLocationQuery, *params.Default); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DomainNameServers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domainNameServers", runtime.ParamLocationQuery, *params.DomainNameServers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DomainNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domainNames", runtime.ParamLocationQuery, *params.DomainNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LogServers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "logServers", runtime.ParamLocationQuery, *params.LogServers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NtpServers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ntpServers", runtime.ParamLocationQuery, *params.NtpServers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDhcpOptionsRequest calls the generic CreateDhcpOptions builder with application/json body
func NewCreateDhcpOptionsRequest(server string, spaceId SpaceId, body CreateDhcpOptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDhcpOptionsRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateDhcpOptionsRequestWithBody generates requests for CreateDhcpOptions with any type of body
func NewCreateDhcpOptionsRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/dhcpOptions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDhcpOptionsRequest generates requests for DeleteDhcpOptions
func NewDeleteDhcpOptionsRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/dhcpOptions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadDhcpOptionsByIdRequest generates requests for ReadDhcpOptionsById
func NewReadDhcpOptionsByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/dhcpOptions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadDirectLinkInterfacesRequest generates requests for ReadDirectLinkInterfaces
func NewReadDirectLinkInterfacesRequest(server string, spaceId SpaceId, params *ReadDirectLinkInterfacesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/directLinkInterfaces", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DirectLinkIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "directLinkIds", runtime.ParamLocationQuery, *params.DirectLinkIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDirectLinkInterfaceRequest calls the generic CreateDirectLinkInterface builder with application/json body
func NewCreateDirectLinkInterfaceRequest(server string, spaceId SpaceId, body CreateDirectLinkInterfaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDirectLinkInterfaceRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateDirectLinkInterfaceRequestWithBody generates requests for CreateDirectLinkInterface with any type of body
func NewCreateDirectLinkInterfaceRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/directLinkInterfaces", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDirectLinkInterfaceRequest generates requests for DeleteDirectLinkInterface
func NewDeleteDirectLinkInterfaceRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/directLinkInterfaces/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadDirectLinkInterfacesByIdRequest generates requests for ReadDirectLinkInterfacesById
func NewReadDirectLinkInterfacesByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/directLinkInterfaces/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDirectLinkInterfaceRequest calls the generic UpdateDirectLinkInterface builder with application/json body
func NewUpdateDirectLinkInterfaceRequest(server string, spaceId SpaceId, id string, body UpdateDirectLinkInterfaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDirectLinkInterfaceRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateDirectLinkInterfaceRequestWithBody generates requests for UpdateDirectLinkInterface with any type of body
func NewUpdateDirectLinkInterfaceRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/directLinkInterfaces/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadDirectLinksRequest generates requests for ReadDirectLinks
func NewReadDirectLinksRequest(server string, spaceId SpaceId, params *ReadDirectLinksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/directLinks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDirectLinkRequest calls the generic CreateDirectLink builder with application/json body
func NewCreateDirectLinkRequest(server string, spaceId SpaceId, body CreateDirectLinkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDirectLinkRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateDirectLinkRequestWithBody generates requests for CreateDirectLink with any type of body
func NewCreateDirectLinkRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/directLinks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDirectLinkRequest generates requests for DeleteDirectLink
func NewDeleteDirectLinkRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/directLinks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadDirectLinksByIdRequest generates requests for ReadDirectLinksById
func NewReadDirectLinksByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/directLinks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadFlexibleGpuCatalogRequest generates requests for ReadFlexibleGpuCatalog
func NewReadFlexibleGpuCatalogRequest(server string, spaceId SpaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/flexibleGpuCatalogs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadFlexibleGpusRequest generates requests for ReadFlexibleGpus
func NewReadFlexibleGpusRequest(server string, spaceId SpaceId, params *ReadFlexibleGpusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/flexibleGpus", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DeleteOnVmDeletion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleteOnVmDeletion", runtime.ParamLocationQuery, *params.DeleteOnVmDeletion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Generations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "generations", runtime.ParamLocationQuery, *params.Generations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModelNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modelNames", runtime.ParamLocationQuery, *params.ModelNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VmIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vmIds", runtime.ParamLocationQuery, *params.VmIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AvailabilityZoneNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "availabilityZoneNames", runtime.ParamLocationQuery, *params.AvailabilityZoneNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFlexibleGpuRequest calls the generic CreateFlexibleGpu builder with application/json body
func NewCreateFlexibleGpuRequest(server string, spaceId SpaceId, body CreateFlexibleGpuJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFlexibleGpuRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateFlexibleGpuRequestWithBody generates requests for CreateFlexibleGpu with any type of body
func NewCreateFlexibleGpuRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/flexibleGpus", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFlexibleGpuRequest generates requests for DeleteFlexibleGpu
func NewDeleteFlexibleGpuRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/flexibleGpus/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadFlexibleGpusByIdRequest generates requests for ReadFlexibleGpusById
func NewReadFlexibleGpusByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/flexibleGpus/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateFlexibleGpuRequest calls the generic UpdateFlexibleGpu builder with application/json body
func NewUpdateFlexibleGpuRequest(server string, spaceId SpaceId, id string, body UpdateFlexibleGpuJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateFlexibleGpuRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateFlexibleGpuRequestWithBody generates requests for UpdateFlexibleGpu with any type of body
func NewUpdateFlexibleGpuRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/flexibleGpus/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLinkFlexibleGpuRequest calls the generic LinkFlexibleGpu builder with application/json body
func NewLinkFlexibleGpuRequest(server string, spaceId SpaceId, id string, body LinkFlexibleGpuJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkFlexibleGpuRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewLinkFlexibleGpuRequestWithBody generates requests for LinkFlexibleGpu with any type of body
func NewLinkFlexibleGpuRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/flexibleGpus/%s/vms/link", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnlinkFlexibleGpuRequest generates requests for UnlinkFlexibleGpu
func NewUnlinkFlexibleGpuRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/flexibleGpus/%s/vms/unlink", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadImagesRequest generates requests for ReadImages
func NewReadImagesRequest(server string, spaceId SpaceId, params *ReadImagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/images", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AccountAliases != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accountAliases", runtime.ParamLocationQuery, *params.AccountAliases); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AccountIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accountIds", runtime.ParamLocationQuery, *params.AccountIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Architectures != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "architectures", runtime.ParamLocationQuery, *params.Architectures); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BlockDeviceMappingDeleteOnVmDeletion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blockDeviceMappingDeleteOnVmDeletion", runtime.ParamLocationQuery, *params.BlockDeviceMappingDeleteOnVmDeletion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BlockDeviceMappingDeviceNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blockDeviceMappingDeviceNames", runtime.ParamLocationQuery, *params.BlockDeviceMappingDeviceNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BlockDeviceMappingSnapshotIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blockDeviceMappingSnapshotIds", runtime.ParamLocationQuery, *params.BlockDeviceMappingSnapshotIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BlockDeviceMappingVolumeSizes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blockDeviceMappingVolumeSizes", runtime.ParamLocationQuery, *params.BlockDeviceMappingVolumeSizes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BlockDeviceMappingVolumeTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blockDeviceMappingVolumeTypes", runtime.ParamLocationQuery, *params.BlockDeviceMappingVolumeTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Descriptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "descriptions", runtime.ParamLocationQuery, *params.Descriptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FileLocations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fileLocations", runtime.ParamLocationQuery, *params.FileLocations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Hypervisors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hypervisors", runtime.ParamLocationQuery, *params.Hypervisors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageNames", runtime.ParamLocationQuery, *params.ImageNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductCodeNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "productCodeNames", runtime.ParamLocationQuery, *params.ProductCodeNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductCodes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "productCodes", runtime.ParamLocationQuery, *params.ProductCodes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RootDeviceNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rootDeviceNames", runtime.ParamLocationQuery, *params.RootDeviceNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RootDeviceTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rootDeviceTypes", runtime.ParamLocationQuery, *params.RootDeviceTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VirtualizationTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "virtualizationTypes", runtime.ParamLocationQuery, *params.VirtualizationTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsPublic != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isPublic", runtime.ParamLocationQuery, *params.IsPublic); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateImageRequest calls the generic CreateImage builder with application/json body
func NewCreateImageRequest(server string, spaceId SpaceId, body CreateImageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateImageRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateImageRequestWithBody generates requests for CreateImage with any type of body
func NewCreateImageRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/images", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteImageRequest generates requests for DeleteImage
func NewDeleteImageRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/images/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadImagesByIdRequest generates requests for ReadImagesById
func NewReadImagesByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/images/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateImageRequest calls the generic UpdateImage builder with application/json body
func NewUpdateImageRequest(server string, spaceId SpaceId, id string, body UpdateImageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateImageRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateImageRequestWithBody generates requests for UpdateImage with any type of body
func NewUpdateImageRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/images/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadInternetGatewaysRequest generates requests for ReadInternetGateways
func NewReadInternetGatewaysRequest(server string, spaceId SpaceId, params *ReadInternetGatewaysParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/internetGateways", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LinkStates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkStates", runtime.ParamLocationQuery, *params.LinkStates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkVpcIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkVpcIds", runtime.ParamLocationQuery, *params.LinkVpcIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateInternetGatewayRequest generates requests for CreateInternetGateway
func NewCreateInternetGatewayRequest(server string, spaceId SpaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/internetGateways", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteInternetGatewayRequest generates requests for DeleteInternetGateway
func NewDeleteInternetGatewayRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/internetGateways/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadInternetGatewaysByIdRequest generates requests for ReadInternetGatewaysById
func NewReadInternetGatewaysByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/internetGateways/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLinkInternetGatewayRequest calls the generic LinkInternetGateway builder with application/json body
func NewLinkInternetGatewayRequest(server string, spaceId SpaceId, id string, body LinkInternetGatewayJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkInternetGatewayRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewLinkInternetGatewayRequestWithBody generates requests for LinkInternetGateway with any type of body
func NewLinkInternetGatewayRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/internetGateways/%s/vpcs/link", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnlinkInternetGatewayRequest calls the generic UnlinkInternetGateway builder with application/json body
func NewUnlinkInternetGatewayRequest(server string, spaceId SpaceId, id string, body UnlinkInternetGatewayJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnlinkInternetGatewayRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUnlinkInternetGatewayRequestWithBody generates requests for UnlinkInternetGateway with any type of body
func NewUnlinkInternetGatewayRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/internetGateways/%s/vpcs/unlink", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadKeypairsRequest generates requests for ReadKeypairs
func NewReadKeypairsRequest(server string, spaceId SpaceId, params *ReadKeypairsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/keypairs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.KeypairFingerprints != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keypairFingerprints", runtime.ParamLocationQuery, *params.KeypairFingerprints); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.KeypairNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keypairNames", runtime.ParamLocationQuery, *params.KeypairNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.KeypairTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keypairTypes", runtime.ParamLocationQuery, *params.KeypairTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateKeypairRequest calls the generic CreateKeypair builder with application/json body
func NewCreateKeypairRequest(server string, spaceId SpaceId, body CreateKeypairJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateKeypairRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateKeypairRequestWithBody generates requests for CreateKeypair with any type of body
func NewCreateKeypairRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/keypairs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteKeypairRequest generates requests for DeleteKeypair
func NewDeleteKeypairRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/keypairs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadKeypairsByIdRequest generates requests for ReadKeypairsById
func NewReadKeypairsByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/keypairs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadListenerRulesRequest generates requests for ReadListenerRules
func NewReadListenerRulesRequest(server string, spaceId SpaceId, params *ReadListenerRulesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/listenerRules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ListenerRuleNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "listenerRuleNames", runtime.ParamLocationQuery, *params.ListenerRuleNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateListenerRuleRequest calls the generic CreateListenerRule builder with application/json body
func NewCreateListenerRuleRequest(server string, spaceId SpaceId, body CreateListenerRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateListenerRuleRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateListenerRuleRequestWithBody generates requests for CreateListenerRule with any type of body
func NewCreateListenerRuleRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/listenerRules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteListenerRuleRequest generates requests for DeleteListenerRule
func NewDeleteListenerRuleRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/listenerRules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadListenerRulesByIdRequest generates requests for ReadListenerRulesById
func NewReadListenerRulesByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/listenerRules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateListenerRuleRequest calls the generic UpdateListenerRule builder with application/json body
func NewUpdateListenerRuleRequest(server string, spaceId SpaceId, id string, body UpdateListenerRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateListenerRuleRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateListenerRuleRequestWithBody generates requests for UpdateListenerRule with any type of body
func NewUpdateListenerRuleRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/listenerRules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadLoadBalancersRequest generates requests for ReadLoadBalancers
func NewReadLoadBalancersRequest(server string, spaceId SpaceId, params *ReadLoadBalancersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/loadBalancers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LoadBalancerNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "loadBalancerNames", runtime.ParamLocationQuery, *params.LoadBalancerNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateLoadBalancerRequest calls the generic CreateLoadBalancer builder with application/json body
func NewCreateLoadBalancerRequest(server string, spaceId SpaceId, body CreateLoadBalancerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLoadBalancerRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateLoadBalancerRequestWithBody generates requests for CreateLoadBalancer with any type of body
func NewCreateLoadBalancerRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/loadBalancers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLoadBalancerRequest generates requests for DeleteLoadBalancer
func NewDeleteLoadBalancerRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/loadBalancers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadLoadBalancersByIdRequest generates requests for ReadLoadBalancersById
func NewReadLoadBalancersByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/loadBalancers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateLoadBalancerRequest calls the generic UpdateLoadBalancer builder with application/json body
func NewUpdateLoadBalancerRequest(server string, spaceId SpaceId, id string, body UpdateLoadBalancerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateLoadBalancerRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateLoadBalancerRequestWithBody generates requests for UpdateLoadBalancer with any type of body
func NewUpdateLoadBalancerRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/loadBalancers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLinkLoadBalancerBackendMachinesRequest calls the generic LinkLoadBalancerBackendMachines builder with application/json body
func NewLinkLoadBalancerBackendMachinesRequest(server string, spaceId SpaceId, id string, body LinkLoadBalancerBackendMachinesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkLoadBalancerBackendMachinesRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewLinkLoadBalancerBackendMachinesRequestWithBody generates requests for LinkLoadBalancerBackendMachines with any type of body
func NewLinkLoadBalancerBackendMachinesRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/loadBalancers/%s/backendMachines/link", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnlinkLoadBalancerBackendMachinesRequest calls the generic UnlinkLoadBalancerBackendMachines builder with application/json body
func NewUnlinkLoadBalancerBackendMachinesRequest(server string, spaceId SpaceId, id string, body UnlinkLoadBalancerBackendMachinesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnlinkLoadBalancerBackendMachinesRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUnlinkLoadBalancerBackendMachinesRequestWithBody generates requests for UnlinkLoadBalancerBackendMachines with any type of body
func NewUnlinkLoadBalancerBackendMachinesRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/loadBalancers/%s/backendMachines/unlink", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLoadBalancerListenersRequest calls the generic DeleteLoadBalancerListeners builder with application/json body
func NewDeleteLoadBalancerListenersRequest(server string, spaceId SpaceId, id string, body DeleteLoadBalancerListenersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteLoadBalancerListenersRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewDeleteLoadBalancerListenersRequestWithBody generates requests for DeleteLoadBalancerListeners with any type of body
func NewDeleteLoadBalancerListenersRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/loadBalancers/%s/listeners", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateLoadBalancerListenersRequest calls the generic CreateLoadBalancerListeners builder with application/json body
func NewCreateLoadBalancerListenersRequest(server string, spaceId SpaceId, id string, body CreateLoadBalancerListenersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLoadBalancerListenersRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewCreateLoadBalancerListenersRequestWithBody generates requests for CreateLoadBalancerListeners with any type of body
func NewCreateLoadBalancerListenersRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/loadBalancers/%s/listeners", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLoadBalancerPolicyRequest calls the generic DeleteLoadBalancerPolicy builder with application/json body
func NewDeleteLoadBalancerPolicyRequest(server string, spaceId SpaceId, id string, body DeleteLoadBalancerPolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteLoadBalancerPolicyRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewDeleteLoadBalancerPolicyRequestWithBody generates requests for DeleteLoadBalancerPolicy with any type of body
func NewDeleteLoadBalancerPolicyRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/loadBalancers/%s/policies", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateLoadBalancerPolicyRequest calls the generic CreateLoadBalancerPolicy builder with application/json body
func NewCreateLoadBalancerPolicyRequest(server string, spaceId SpaceId, id string, body CreateLoadBalancerPolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLoadBalancerPolicyRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewCreateLoadBalancerPolicyRequestWithBody generates requests for CreateLoadBalancerPolicy with any type of body
func NewCreateLoadBalancerPolicyRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/loadBalancers/%s/policies", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadVmsHealthRequest calls the generic ReadVmsHealth builder with application/json body
func NewReadVmsHealthRequest(server string, spaceId SpaceId, id string, body ReadVmsHealthJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReadVmsHealthRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewReadVmsHealthRequestWithBody generates requests for ReadVmsHealth with any type of body
func NewReadVmsHealthRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/loadBalancers/%s/vmsHealth", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadLoadBalancerTagsRequest calls the generic ReadLoadBalancerTags builder with application/json body
func NewReadLoadBalancerTagsRequest(server string, spaceId SpaceId, body ReadLoadBalancerTagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReadLoadBalancerTagsRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewReadLoadBalancerTagsRequestWithBody generates requests for ReadLoadBalancerTags with any type of body
func NewReadLoadBalancerTagsRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/loadBalancersTags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadLocationsRequest generates requests for ReadLocations
func NewReadLocationsRequest(server string, spaceId SpaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/locations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadNatGatewayRequest generates requests for ReadNatGateway
func NewReadNatGatewayRequest(server string, spaceId SpaceId, params *ReadNatGatewayParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/natGateways", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubnetIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subnetIds", runtime.ParamLocationQuery, *params.SubnetIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VpcIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vpcIds", runtime.ParamLocationQuery, *params.VpcIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNatGatewayRequest calls the generic CreateNatGateway builder with application/json body
func NewCreateNatGatewayRequest(server string, spaceId SpaceId, body CreateNatGatewayJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNatGatewayRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateNatGatewayRequestWithBody generates requests for CreateNatGateway with any type of body
func NewCreateNatGatewayRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/natGateways", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteNatGatewayRequest generates requests for DeleteNatGateway
func NewDeleteNatGatewayRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/natGateways/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadNatGatewayByIdRequest generates requests for ReadNatGatewayById
func NewReadNatGatewayByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/natGateways/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadNicsRequest generates requests for ReadNics
func NewReadNicsRequest(server string, spaceId SpaceId, params *ReadNicsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/nics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Descriptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "descriptions", runtime.ParamLocationQuery, *params.Descriptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsSourceDestCheck != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isSourceDestCheck", runtime.ParamLocationQuery, *params.IsSourceDestCheck); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkNicDeleteOnVmDeletion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkNicDeleteOnVmDeletion", runtime.ParamLocationQuery, *params.LinkNicDeleteOnVmDeletion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkNicDeviceNumbers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkNicDeviceNumbers", runtime.ParamLocationQuery, *params.LinkNicDeviceNumbers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkNicLinkNicIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkNicLinkNicIds", runtime.ParamLocationQuery, *params.LinkNicLinkNicIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkNicStates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkNicStates", runtime.ParamLocationQuery, *params.LinkNicStates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkNicVmAccountIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkNicVmAccountIds", runtime.ParamLocationQuery, *params.LinkNicVmAccountIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkNicVmIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkNicVmIds", runtime.ParamLocationQuery, *params.LinkNicVmIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkPublicIpAccountIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkPublicIpAccountIds", runtime.ParamLocationQuery, *params.LinkPublicIpAccountIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkPublicIpLinkPublicIpIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkPublicIpLinkPublicIpIds", runtime.ParamLocationQuery, *params.LinkPublicIpLinkPublicIpIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkPublicIpPublicIpIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkPublicIpPublicIpIds", runtime.ParamLocationQuery, *params.LinkPublicIpPublicIpIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkPublicIpPublicIps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkPublicIpPublicIps", runtime.ParamLocationQuery, *params.LinkPublicIpPublicIps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MacAddresses != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "macAddresses", runtime.ParamLocationQuery, *params.MacAddresses); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrivateDnsNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "privateDnsNames", runtime.ParamLocationQuery, *params.PrivateDnsNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrivateIpsLinkPublicIpPublicIps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "privateIpsLinkPublicIpPublicIps", runtime.ParamLocationQuery, *params.PrivateIpsLinkPublicIpPublicIps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrivateIpsPrimaryIp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "privateIpsPrimaryIp", runtime.ParamLocationQuery, *params.PrivateIpsPrimaryIp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrivateIpsPrivateIps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "privateIpsPrivateIps", runtime.ParamLocationQuery, *params.PrivateIpsPrivateIps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SecurityGroupIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "securityGroupIds", runtime.ParamLocationQuery, *params.SecurityGroupIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SecurityGroupNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "securityGroupNames", runtime.ParamLocationQuery, *params.SecurityGroupNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubnetIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subnetIds", runtime.ParamLocationQuery, *params.SubnetIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VpcIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vpcIds", runtime.ParamLocationQuery, *params.VpcIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AvailabilityZoneNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "availabilityZoneNames", runtime.ParamLocationQuery, *params.AvailabilityZoneNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNicRequest calls the generic CreateNic builder with application/json body
func NewCreateNicRequest(server string, spaceId SpaceId, body CreateNicJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNicRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateNicRequestWithBody generates requests for CreateNic with any type of body
func NewCreateNicRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/nics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteNicRequest generates requests for DeleteNic
func NewDeleteNicRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/nics/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadNicsByIdRequest generates requests for ReadNicsById
func NewReadNicsByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/nics/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateNicRequest calls the generic UpdateNic builder with application/json body
func NewUpdateNicRequest(server string, spaceId SpaceId, id string, body UpdateNicJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateNicRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateNicRequestWithBody generates requests for UpdateNic with any type of body
func NewUpdateNicRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/nics/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLinkPrivateIpsRequest calls the generic LinkPrivateIps builder with application/json body
func NewLinkPrivateIpsRequest(server string, spaceId SpaceId, id string, body LinkPrivateIpsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkPrivateIpsRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewLinkPrivateIpsRequestWithBody generates requests for LinkPrivateIps with any type of body
func NewLinkPrivateIpsRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/nics/%s/privateIps/link", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnlinkPrivateIpsRequest calls the generic UnlinkPrivateIps builder with application/json body
func NewUnlinkPrivateIpsRequest(server string, spaceId SpaceId, id string, body UnlinkPrivateIpsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnlinkPrivateIpsRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUnlinkPrivateIpsRequestWithBody generates requests for UnlinkPrivateIps with any type of body
func NewUnlinkPrivateIpsRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/nics/%s/privateIps/unlink", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLinkNicRequest calls the generic LinkNic builder with application/json body
func NewLinkNicRequest(server string, spaceId SpaceId, id string, body LinkNicJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkNicRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewLinkNicRequestWithBody generates requests for LinkNic with any type of body
func NewLinkNicRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/nics/%s/vms/link", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnlinkNicRequest calls the generic UnlinkNic builder with application/json body
func NewUnlinkNicRequest(server string, spaceId SpaceId, id string, body UnlinkNicJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnlinkNicRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUnlinkNicRequestWithBody generates requests for UnlinkNic with any type of body
func NewUnlinkNicRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/nics/%s/vms/unlink", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadProductTypesRequest generates requests for ReadProductTypes
func NewReadProductTypesRequest(server string, spaceId SpaceId, params *ReadProductTypesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/productTypes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadProductTypesByIdRequest generates requests for ReadProductTypesById
func NewReadProductTypesByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/productTypes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadPublicIpRangesRequest generates requests for ReadPublicIpRanges
func NewReadPublicIpRangesRequest(server string, spaceId SpaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/publicIpRanges", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadPublicIpsRequest generates requests for ReadPublicIps
func NewReadPublicIpsRequest(server string, spaceId SpaceId, params *ReadPublicIpsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/publicIps", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LinkPublicIpIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkPublicIpIds", runtime.ParamLocationQuery, *params.LinkPublicIpIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicIds", runtime.ParamLocationQuery, *params.NicIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrivateIps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "privateIps", runtime.ParamLocationQuery, *params.PrivateIps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VmIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vmIds", runtime.ParamLocationQuery, *params.VmIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePublicIpRequest generates requests for CreatePublicIp
func NewCreatePublicIpRequest(server string, spaceId SpaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/publicIps", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeletePublicIpRequest generates requests for DeletePublicIp
func NewDeletePublicIpRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/publicIps/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadPublicIpsByIdRequest generates requests for ReadPublicIpsById
func NewReadPublicIpsByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/publicIps/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLinkPublicIpRequest calls the generic LinkPublicIp builder with application/json body
func NewLinkPublicIpRequest(server string, spaceId SpaceId, id string, body LinkPublicIpJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkPublicIpRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewLinkPublicIpRequestWithBody generates requests for LinkPublicIp with any type of body
func NewLinkPublicIpRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/publicIps/%s/link", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnlinkPublicIpRequest calls the generic UnlinkPublicIp builder with application/json body
func NewUnlinkPublicIpRequest(server string, spaceId SpaceId, id string, body UnlinkPublicIpJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnlinkPublicIpRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUnlinkPublicIpRequestWithBody generates requests for UnlinkPublicIp with any type of body
func NewUnlinkPublicIpRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/publicIps/%s/unlink", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadRouteTablesRequest generates requests for ReadRouteTables
func NewReadRouteTablesRequest(server string, spaceId SpaceId, params *ReadRouteTablesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/routeTables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LinkRouteTableIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkRouteTableIds", runtime.ParamLocationQuery, *params.LinkRouteTableIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkRouteTableLinkRouteTableIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkRouteTableLinkRouteTableIds", runtime.ParamLocationQuery, *params.LinkRouteTableLinkRouteTableIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkRouteTableMain != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkRouteTableMain", runtime.ParamLocationQuery, *params.LinkRouteTableMain); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkSubnetIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkSubnetIds", runtime.ParamLocationQuery, *params.LinkSubnetIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RouteCreationMethods != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "routeCreationMethods", runtime.ParamLocationQuery, *params.RouteCreationMethods); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RouteDestinationIpRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "routeDestinationIpRanges", runtime.ParamLocationQuery, *params.RouteDestinationIpRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RouteDestinationServiceIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "routeDestinationServiceIds", runtime.ParamLocationQuery, *params.RouteDestinationServiceIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RouteGatewayIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "routeGatewayIds", runtime.ParamLocationQuery, *params.RouteGatewayIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RouteStates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "routeStates", runtime.ParamLocationQuery, *params.RouteStates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RouteVmIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "routeVmIds", runtime.ParamLocationQuery, *params.RouteVmIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VpcIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vpcIds", runtime.ParamLocationQuery, *params.VpcIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RouteNatGatewayIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "routeNatGatewayIds", runtime.ParamLocationQuery, *params.RouteNatGatewayIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RouteVpcPeeringIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "routeVpcPeeringIds", runtime.ParamLocationQuery, *params.RouteVpcPeeringIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRouteTableRequest calls the generic CreateRouteTable builder with application/json body
func NewCreateRouteTableRequest(server string, spaceId SpaceId, body CreateRouteTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRouteTableRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateRouteTableRequestWithBody generates requests for CreateRouteTable with any type of body
func NewCreateRouteTableRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/routeTables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRouteTableRequest generates requests for DeleteRouteTable
func NewDeleteRouteTableRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/routeTables/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadRouteTablesByIdRequest generates requests for ReadRouteTablesById
func NewReadRouteTablesByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/routeTables/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRouteTableRoutePropagationRequest calls the generic UpdateRouteTableRoutePropagation builder with application/json body
func NewUpdateRouteTableRoutePropagationRequest(server string, spaceId SpaceId, id string, body UpdateRouteTableRoutePropagationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRouteTableRoutePropagationRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateRouteTableRoutePropagationRequestWithBody generates requests for UpdateRouteTableRoutePropagation with any type of body
func NewUpdateRouteTableRoutePropagationRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/routeTables/%s/routePropagation", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRouteRequest calls the generic DeleteRoute builder with application/json body
func NewDeleteRouteRequest(server string, spaceId SpaceId, id string, body DeleteRouteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteRouteRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewDeleteRouteRequestWithBody generates requests for DeleteRoute with any type of body
func NewDeleteRouteRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/routeTables/%s/routes", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateRouteRequest calls the generic CreateRoute builder with application/json body
func NewCreateRouteRequest(server string, spaceId SpaceId, id string, body CreateRouteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRouteRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewCreateRouteRequestWithBody generates requests for CreateRoute with any type of body
func NewCreateRouteRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/routeTables/%s/routes", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateRouteRequest calls the generic UpdateRoute builder with application/json body
func NewUpdateRouteRequest(server string, spaceId SpaceId, id string, body UpdateRouteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRouteRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateRouteRequestWithBody generates requests for UpdateRoute with any type of body
func NewUpdateRouteRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/routeTables/%s/routes", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLinkRouteTableRequest calls the generic LinkRouteTable builder with application/json body
func NewLinkRouteTableRequest(server string, spaceId SpaceId, id string, body LinkRouteTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkRouteTableRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewLinkRouteTableRequestWithBody generates requests for LinkRouteTable with any type of body
func NewLinkRouteTableRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/routeTables/%s/subnets/link", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnlinkRouteTableRequest calls the generic UnlinkRouteTable builder with application/json body
func NewUnlinkRouteTableRequest(server string, spaceId SpaceId, id string, body UnlinkRouteTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnlinkRouteTableRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUnlinkRouteTableRequestWithBody generates requests for UnlinkRouteTable with any type of body
func NewUnlinkRouteTableRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/routeTables/%s/subnets/unlink", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadSecurityGroupsRequest generates requests for ReadSecurityGroups
func NewReadSecurityGroupsRequest(server string, spaceId SpaceId, params *ReadSecurityGroupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/securityGroups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Descriptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "descriptions", runtime.ParamLocationQuery, *params.Descriptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InboundRuleAccountIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inboundRuleAccountIds", runtime.ParamLocationQuery, *params.InboundRuleAccountIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InboundRuleFromPortRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inboundRuleFromPortRanges", runtime.ParamLocationQuery, *params.InboundRuleFromPortRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InboundRuleIpRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inboundRuleIpRanges", runtime.ParamLocationQuery, *params.InboundRuleIpRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InboundRuleProtocols != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inboundRuleProtocols", runtime.ParamLocationQuery, *params.InboundRuleProtocols); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InboundRuleSecurityGroupIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inboundRuleSecurityGroupIds", runtime.ParamLocationQuery, *params.InboundRuleSecurityGroupIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InboundRuleSecurityGroupNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inboundRuleSecurityGroupNames", runtime.ParamLocationQuery, *params.InboundRuleSecurityGroupNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InboundRuleToPortRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inboundRuleToPortRanges", runtime.ParamLocationQuery, *params.InboundRuleToPortRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OutboundRuleAccountIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outboundRuleAccountIds", runtime.ParamLocationQuery, *params.OutboundRuleAccountIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OutboundRuleFromPortRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outboundRuleFromPortRanges", runtime.ParamLocationQuery, *params.OutboundRuleFromPortRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OutboundRuleIpRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outboundRuleIpRanges", runtime.ParamLocationQuery, *params.OutboundRuleIpRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OutboundRuleProtocols != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outboundRuleProtocols", runtime.ParamLocationQuery, *params.OutboundRuleProtocols); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OutboundRuleSecurityGroupIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outboundRuleSecurityGroupIds", runtime.ParamLocationQuery, *params.OutboundRuleSecurityGroupIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OutboundRuleSecurityGroupNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outboundRuleSecurityGroupNames", runtime.ParamLocationQuery, *params.OutboundRuleSecurityGroupNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OutboundRuleToPortRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outboundRuleToPortRanges", runtime.ParamLocationQuery, *params.OutboundRuleToPortRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SecurityGroupIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "securityGroupIds", runtime.ParamLocationQuery, *params.SecurityGroupIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SecurityGroupNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "securityGroupNames", runtime.ParamLocationQuery, *params.SecurityGroupNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VpcIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vpcIds", runtime.ParamLocationQuery, *params.VpcIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSecurityGroupRequest calls the generic CreateSecurityGroup builder with application/json body
func NewCreateSecurityGroupRequest(server string, spaceId SpaceId, body CreateSecurityGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSecurityGroupRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateSecurityGroupRequestWithBody generates requests for CreateSecurityGroup with any type of body
func NewCreateSecurityGroupRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/securityGroups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSecurityGroupRequest generates requests for DeleteSecurityGroup
func NewDeleteSecurityGroupRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/securityGroups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadSecurityGroupsByIdRequest generates requests for ReadSecurityGroupsById
func NewReadSecurityGroupsByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/securityGroups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteSecurityGroupRuleRequest calls the generic DeleteSecurityGroupRule builder with application/json body
func NewDeleteSecurityGroupRuleRequest(server string, spaceId SpaceId, id string, body DeleteSecurityGroupRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteSecurityGroupRuleRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewDeleteSecurityGroupRuleRequestWithBody generates requests for DeleteSecurityGroupRule with any type of body
func NewDeleteSecurityGroupRuleRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/securityGroups/%s/rules", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateSecurityGroupRuleRequest calls the generic CreateSecurityGroupRule builder with application/json body
func NewCreateSecurityGroupRuleRequest(server string, spaceId SpaceId, id string, body CreateSecurityGroupRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSecurityGroupRuleRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewCreateSecurityGroupRuleRequestWithBody generates requests for CreateSecurityGroupRule with any type of body
func NewCreateSecurityGroupRuleRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/securityGroups/%s/rules", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadSnapshotsRequest generates requests for ReadSnapshots
func NewReadSnapshotsRequest(server string, spaceId SpaceId, params *ReadSnapshotsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/snapshots", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Descriptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "descriptions", runtime.ParamLocationQuery, *params.Descriptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FromCreationDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromCreationDate", runtime.ParamLocationQuery, *params.FromCreationDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Progresses != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "progresses", runtime.ParamLocationQuery, *params.Progresses); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToCreationDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toCreationDate", runtime.ParamLocationQuery, *params.ToCreationDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VolumeIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "volumeIds", runtime.ParamLocationQuery, *params.VolumeIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VolumeSizes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "volumeSizes", runtime.ParamLocationQuery, *params.VolumeSizes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsPublic != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isPublic", runtime.ParamLocationQuery, *params.IsPublic); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSnapshotRequest calls the generic CreateSnapshot builder with application/json body
func NewCreateSnapshotRequest(server string, spaceId SpaceId, body CreateSnapshotJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSnapshotRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateSnapshotRequestWithBody generates requests for CreateSnapshot with any type of body
func NewCreateSnapshotRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/snapshots", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSnapshotRequest generates requests for DeleteSnapshot
func NewDeleteSnapshotRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/snapshots/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadSnapshotsByIdRequest generates requests for ReadSnapshotsById
func NewReadSnapshotsByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/snapshots/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadSubnetsRequest generates requests for ReadSubnets
func NewReadSubnetsRequest(server string, spaceId SpaceId, params *ReadSubnetsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/subnets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AvailableIpsCounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "availableIpsCounts", runtime.ParamLocationQuery, *params.AvailableIpsCounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IpRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ipRanges", runtime.ParamLocationQuery, *params.IpRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VpcIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vpcIds", runtime.ParamLocationQuery, *params.VpcIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AvailabilityZoneNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "availabilityZoneNames", runtime.ParamLocationQuery, *params.AvailabilityZoneNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSubnetRequest calls the generic CreateSubnet builder with application/json body
func NewCreateSubnetRequest(server string, spaceId SpaceId, body CreateSubnetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSubnetRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateSubnetRequestWithBody generates requests for CreateSubnet with any type of body
func NewCreateSubnetRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/subnets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSubnetRequest generates requests for DeleteSubnet
func NewDeleteSubnetRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/subnets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadSubnetsByIdRequest generates requests for ReadSubnetsById
func NewReadSubnetsByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/subnets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSubnetRequest calls the generic UpdateSubnet builder with application/json body
func NewUpdateSubnetRequest(server string, spaceId SpaceId, id string, body UpdateSubnetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSubnetRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateSubnetRequestWithBody generates requests for UpdateSubnet with any type of body
func NewUpdateSubnetRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/subnets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadTagsRequest generates requests for ReadTags
func NewReadTagsRequest(server string, spaceId SpaceId, params *ReadTagsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Keys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keys", runtime.ParamLocationQuery, *params.Keys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResourceIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resourceIds", runtime.ParamLocationQuery, *params.ResourceIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResourceTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resourceTypes", runtime.ParamLocationQuery, *params.ResourceTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Values != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "values", runtime.ParamLocationQuery, *params.Values); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadVirtualGatewaysRequest generates requests for ReadVirtualGateways
func NewReadVirtualGatewaysRequest(server string, spaceId SpaceId, params *ReadVirtualGatewaysParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/virtualGateways", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ConnectionTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "connectionTypes", runtime.ParamLocationQuery, *params.ConnectionTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkStates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkStates", runtime.ParamLocationQuery, *params.LinkStates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkVpcIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkVpcIds", runtime.ParamLocationQuery, *params.LinkVpcIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVirtualGatewayRequest calls the generic CreateVirtualGateway builder with application/json body
func NewCreateVirtualGatewayRequest(server string, spaceId SpaceId, body CreateVirtualGatewayJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVirtualGatewayRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateVirtualGatewayRequestWithBody generates requests for CreateVirtualGateway with any type of body
func NewCreateVirtualGatewayRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/virtualGateways", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVirtualGatewayRequest generates requests for DeleteVirtualGateway
func NewDeleteVirtualGatewayRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/virtualGateways/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadVirtualGatewaysByIdRequest generates requests for ReadVirtualGatewaysById
func NewReadVirtualGatewaysByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/virtualGateways/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLinkVirtualGatewayToVpcRequest calls the generic LinkVirtualGatewayToVpc builder with application/json body
func NewLinkVirtualGatewayToVpcRequest(server string, spaceId SpaceId, id string, body LinkVirtualGatewayToVpcJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkVirtualGatewayToVpcRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewLinkVirtualGatewayToVpcRequestWithBody generates requests for LinkVirtualGatewayToVpc with any type of body
func NewLinkVirtualGatewayToVpcRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/virtualGateways/%s/vpcs/link", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnlinkVirtualGatewayToVpcRequest calls the generic UnlinkVirtualGatewayToVpc builder with application/json body
func NewUnlinkVirtualGatewayToVpcRequest(server string, spaceId SpaceId, id string, body UnlinkVirtualGatewayToVpcJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnlinkVirtualGatewayToVpcRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUnlinkVirtualGatewayToVpcRequestWithBody generates requests for UnlinkVirtualGatewayToVpc with any type of body
func NewUnlinkVirtualGatewayToVpcRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/virtualGateways/%s/vpcs/unlink", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadVmsRequest generates requests for ReadVms
func NewReadVmsRequest(server string, spaceId SpaceId, params *ReadVmsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vms", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Architectures != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "architectures", runtime.ParamLocationQuery, *params.Architectures); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BlockDeviceMappingDeleteOnVmDeletion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blockDeviceMappingDeleteOnVmDeletion", runtime.ParamLocationQuery, *params.BlockDeviceMappingDeleteOnVmDeletion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BlockDeviceMappingDeviceNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blockDeviceMappingDeviceNames", runtime.ParamLocationQuery, *params.BlockDeviceMappingDeviceNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BlockDeviceMappingLinkDates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blockDeviceMappingLinkDates", runtime.ParamLocationQuery, *params.BlockDeviceMappingLinkDates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BlockDeviceMappingStates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blockDeviceMappingStates", runtime.ParamLocationQuery, *params.BlockDeviceMappingStates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BlockDeviceMappingVolumeIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blockDeviceMappingVolumeIds", runtime.ParamLocationQuery, *params.BlockDeviceMappingVolumeIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClientTokens != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "clientTokens", runtime.ParamLocationQuery, *params.ClientTokens); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreationDates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "creationDates", runtime.ParamLocationQuery, *params.CreationDates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageIds", runtime.ParamLocationQuery, *params.ImageIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsSourceDestChecked != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isSourceDestChecked", runtime.ParamLocationQuery, *params.IsSourceDestChecked); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.KeypairNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keypairNames", runtime.ParamLocationQuery, *params.KeypairNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LaunchNumbers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "launchNumbers", runtime.ParamLocationQuery, *params.LaunchNumbers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Lifecycles != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lifecycles", runtime.ParamLocationQuery, *params.Lifecycles); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicAccountIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicAccountIds", runtime.ParamLocationQuery, *params.NicAccountIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicDescriptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicDescriptions", runtime.ParamLocationQuery, *params.NicDescriptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicIsSourceDestChecked != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicIsSourceDestChecked", runtime.ParamLocationQuery, *params.NicIsSourceDestChecked); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicLinkNicDeleteOnVmDeletion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicLinkNicDeleteOnVmDeletion", runtime.ParamLocationQuery, *params.NicLinkNicDeleteOnVmDeletion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicLinkNicDeviceNumbers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicLinkNicDeviceNumbers", runtime.ParamLocationQuery, *params.NicLinkNicDeviceNumbers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicLinkNicLinkNicDates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicLinkNicLinkNicDates", runtime.ParamLocationQuery, *params.NicLinkNicLinkNicDates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicLinkNicLinkNicIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicLinkNicLinkNicIds", runtime.ParamLocationQuery, *params.NicLinkNicLinkNicIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicLinkNicStates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicLinkNicStates", runtime.ParamLocationQuery, *params.NicLinkNicStates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicLinkNicVmAccountIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicLinkNicVmAccountIds", runtime.ParamLocationQuery, *params.NicLinkNicVmAccountIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicLinkNicVmIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicLinkNicVmIds", runtime.ParamLocationQuery, *params.NicLinkNicVmIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicLinkPublicIpAccountIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicLinkPublicIpAccountIds", runtime.ParamLocationQuery, *params.NicLinkPublicIpAccountIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicLinkPublicIpLinkPublicIpIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicLinkPublicIpLinkPublicIpIds", runtime.ParamLocationQuery, *params.NicLinkPublicIpLinkPublicIpIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicLinkPublicIpPublicIpIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicLinkPublicIpPublicIpIds", runtime.ParamLocationQuery, *params.NicLinkPublicIpPublicIpIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicLinkPublicIpPublicIps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicLinkPublicIpPublicIps", runtime.ParamLocationQuery, *params.NicLinkPublicIpPublicIps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicMacAddresses != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicMacAddresses", runtime.ParamLocationQuery, *params.NicMacAddresses); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicNicIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicNicIds", runtime.ParamLocationQuery, *params.NicNicIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicPrivateIpsLinkPublicIpAccountIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicPrivateIpsLinkPublicIpAccountIds", runtime.ParamLocationQuery, *params.NicPrivateIpsLinkPublicIpAccountIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicPrivateIpsLinkPublicIpIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicPrivateIpsLinkPublicIpIds", runtime.ParamLocationQuery, *params.NicPrivateIpsLinkPublicIpIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicPrivateIpsPrimaryIp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicPrivateIpsPrimaryIp", runtime.ParamLocationQuery, *params.NicPrivateIpsPrimaryIp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicPrivateIpsPrivateIps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicPrivateIpsPrivateIps", runtime.ParamLocationQuery, *params.NicPrivateIpsPrivateIps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicSecurityGroupIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicSecurityGroupIds", runtime.ParamLocationQuery, *params.NicSecurityGroupIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicSecurityGroupNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicSecurityGroupNames", runtime.ParamLocationQuery, *params.NicSecurityGroupNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicStates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicStates", runtime.ParamLocationQuery, *params.NicStates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicSubnetIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicSubnetIds", runtime.ParamLocationQuery, *params.NicSubnetIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Platforms != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "platforms", runtime.ParamLocationQuery, *params.Platforms); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrivateIps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "privateIps", runtime.ParamLocationQuery, *params.PrivateIps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductCodes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "productCodes", runtime.ParamLocationQuery, *params.ProductCodes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PublicIps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "publicIps", runtime.ParamLocationQuery, *params.PublicIps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReservationIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reservationIds", runtime.ParamLocationQuery, *params.ReservationIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RootDeviceNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rootDeviceNames", runtime.ParamLocationQuery, *params.RootDeviceNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RootDeviceTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rootDeviceTypes", runtime.ParamLocationQuery, *params.RootDeviceTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SecurityGroupIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "securityGroupIds", runtime.ParamLocationQuery, *params.SecurityGroupIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SecurityGroupNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "securityGroupNames", runtime.ParamLocationQuery, *params.SecurityGroupNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StateReasonCodes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stateReasonCodes", runtime.ParamLocationQuery, *params.StateReasonCodes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StateReasonMessages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stateReasonMessages", runtime.ParamLocationQuery, *params.StateReasonMessages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StateReasons != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stateReasons", runtime.ParamLocationQuery, *params.StateReasons); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubnetIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subnetIds", runtime.ParamLocationQuery, *params.SubnetIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tenancies != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tenancies", runtime.ParamLocationQuery, *params.Tenancies); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VmSecurityGroupIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vmSecurityGroupIds", runtime.ParamLocationQuery, *params.VmSecurityGroupIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VmSecurityGroupNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vmSecurityGroupNames", runtime.ParamLocationQuery, *params.VmSecurityGroupNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VmStateCodes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vmStateCodes", runtime.ParamLocationQuery, *params.VmStateCodes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VmStateNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vmStateNames", runtime.ParamLocationQuery, *params.VmStateNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Types != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "types", runtime.ParamLocationQuery, *params.Types); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VpcIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vpcIds", runtime.ParamLocationQuery, *params.VpcIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicVpcIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicVpcIds", runtime.ParamLocationQuery, *params.NicVpcIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicAvailabilityZoneNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicAvailabilityZoneNames", runtime.ParamLocationQuery, *params.NicAvailabilityZoneNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AvailabilityZoneNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "availabilityZoneNames", runtime.ParamLocationQuery, *params.AvailabilityZoneNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVmsRequest calls the generic CreateVms builder with application/json body
func NewCreateVmsRequest(server string, spaceId SpaceId, body CreateVmsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVmsRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateVmsRequestWithBody generates requests for CreateVms with any type of body
func NewCreateVmsRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vms", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadVmsStateRequest generates requests for ReadVmsState
func NewReadVmsStateRequest(server string, spaceId SpaceId, params *ReadVmsStateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vms/states", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MaintenanceEventCodes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maintenanceEventCodes", runtime.ParamLocationQuery, *params.MaintenanceEventCodes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaintenanceEventDescriptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maintenanceEventDescriptions", runtime.ParamLocationQuery, *params.MaintenanceEventDescriptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaintenanceEventsNotAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maintenanceEventsNotAfter", runtime.ParamLocationQuery, *params.MaintenanceEventsNotAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaintenanceEventsNotBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maintenanceEventsNotBefore", runtime.ParamLocationQuery, *params.MaintenanceEventsNotBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VmStates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vmStates", runtime.ParamLocationQuery, *params.VmStates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AvailabilityZoneNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "availabilityZoneNames", runtime.ParamLocationQuery, *params.AvailabilityZoneNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteVmsRequest generates requests for DeleteVms
func NewDeleteVmsRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vms/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadVmsByIdRequest generates requests for ReadVmsById
func NewReadVmsByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vms/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVmRequest calls the generic UpdateVm builder with application/json body
func NewUpdateVmRequest(server string, spaceId SpaceId, id string, body UpdateVmJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVmRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateVmRequestWithBody generates requests for UpdateVm with any type of body
func NewUpdateVmRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vms/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadAdminPasswordRequest generates requests for ReadAdminPassword
func NewReadAdminPasswordRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vms/%s/adminPasswords", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadConsoleOutputRequest generates requests for ReadConsoleOutput
func NewReadConsoleOutputRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vms/%s/consoleOutputs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRebootVmRequest generates requests for RebootVm
func NewRebootVmRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vms/%s/reboot", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartVmRequest generates requests for StartVm
func NewStartVmRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vms/%s/start", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStopVmRequest calls the generic StopVm builder with application/json body
func NewStopVmRequest(server string, spaceId SpaceId, id string, body StopVmJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStopVmRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewStopVmRequestWithBody generates requests for StopVm with any type of body
func NewStopVmRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vms/%s/stop", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadVolumesRequest generates requests for ReadVolumes
func NewReadVolumesRequest(server string, spaceId SpaceId, params *ReadVolumesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/volumes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreationDates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "creationDates", runtime.ParamLocationQuery, *params.CreationDates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkVolumeDeleteOnVmDeletion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkVolumeDeleteOnVmDeletion", runtime.ParamLocationQuery, *params.LinkVolumeDeleteOnVmDeletion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkVolumeDeviceNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkVolumeDeviceNames", runtime.ParamLocationQuery, *params.LinkVolumeDeviceNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkVolumeLinkDates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkVolumeLinkDates", runtime.ParamLocationQuery, *params.LinkVolumeLinkDates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkVolumeLinkStates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkVolumeLinkStates", runtime.ParamLocationQuery, *params.LinkVolumeLinkStates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkVolumeVmIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkVolumeVmIds", runtime.ParamLocationQuery, *params.LinkVolumeVmIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SnapshotIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "snapshotIds", runtime.ParamLocationQuery, *params.SnapshotIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VolumeSizes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "volumeSizes", runtime.ParamLocationQuery, *params.VolumeSizes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VolumeStates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "volumeStates", runtime.ParamLocationQuery, *params.VolumeStates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VolumeTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "volumeTypes", runtime.ParamLocationQuery, *params.VolumeTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AvailabilityZoneNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "availabilityZoneNames", runtime.ParamLocationQuery, *params.AvailabilityZoneNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVolumeRequest calls the generic CreateVolume builder with application/json body
func NewCreateVolumeRequest(server string, spaceId SpaceId, body CreateVolumeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVolumeRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateVolumeRequestWithBody generates requests for CreateVolume with any type of body
func NewCreateVolumeRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/volumes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVolumeRequest generates requests for DeleteVolume
func NewDeleteVolumeRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/volumes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadVolumesByIdRequest generates requests for ReadVolumesById
func NewReadVolumesByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/volumes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVolumeRequest calls the generic UpdateVolume builder with application/json body
func NewUpdateVolumeRequest(server string, spaceId SpaceId, id string, body UpdateVolumeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVolumeRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateVolumeRequestWithBody generates requests for UpdateVolume with any type of body
func NewUpdateVolumeRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/volumes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLinkVolumeRequest calls the generic LinkVolume builder with application/json body
func NewLinkVolumeRequest(server string, spaceId SpaceId, id string, body LinkVolumeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkVolumeRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewLinkVolumeRequestWithBody generates requests for LinkVolume with any type of body
func NewLinkVolumeRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/volumes/%s/vms/link", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnlinkVolumeRequest calls the generic UnlinkVolume builder with application/json body
func NewUnlinkVolumeRequest(server string, spaceId SpaceId, id string, body UnlinkVolumeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnlinkVolumeRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUnlinkVolumeRequestWithBody generates requests for UnlinkVolume with any type of body
func NewUnlinkVolumeRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/volumes/%s/vms/unlink", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadVpcAccessPointsRequest generates requests for ReadVpcAccessPoints
func NewReadVpcAccessPointsRequest(server string, spaceId SpaceId, params *ReadVpcAccessPointsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpcAccessPoints", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ServiceNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "serviceNames", runtime.ParamLocationQuery, *params.ServiceNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VpcIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vpcIds", runtime.ParamLocationQuery, *params.VpcIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVpcAccessPointRequest calls the generic CreateVpcAccessPoint builder with application/json body
func NewCreateVpcAccessPointRequest(server string, spaceId SpaceId, body CreateVpcAccessPointJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVpcAccessPointRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateVpcAccessPointRequestWithBody generates requests for CreateVpcAccessPoint with any type of body
func NewCreateVpcAccessPointRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpcAccessPoints", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVpcAccessPointRequest generates requests for DeleteVpcAccessPoint
func NewDeleteVpcAccessPointRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpcAccessPoints/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadVpcAccessPointsByIdRequest generates requests for ReadVpcAccessPointsById
func NewReadVpcAccessPointsByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpcAccessPoints/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVpcAccessPointRequest calls the generic UpdateVpcAccessPoint builder with application/json body
func NewUpdateVpcAccessPointRequest(server string, spaceId SpaceId, id string, body UpdateVpcAccessPointJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVpcAccessPointRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateVpcAccessPointRequestWithBody generates requests for UpdateVpcAccessPoint with any type of body
func NewUpdateVpcAccessPointRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpcAccessPoints/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadVpcPeeringsRequest generates requests for ReadVpcPeerings
func NewReadVpcPeeringsRequest(server string, spaceId SpaceId, params *ReadVpcPeeringsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpcPeerings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExpirationDates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expirationDates", runtime.ParamLocationQuery, *params.ExpirationDates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StateMessages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stateMessages", runtime.ParamLocationQuery, *params.StateMessages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StateNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stateNames", runtime.ParamLocationQuery, *params.StateNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AccepterVpcAccountIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accepterVpcAccountIds", runtime.ParamLocationQuery, *params.AccepterVpcAccountIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AccepterVpcIpRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accepterVpcIpRanges", runtime.ParamLocationQuery, *params.AccepterVpcIpRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AccepterVpcVpcIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accepterVpcVpcIds", runtime.ParamLocationQuery, *params.AccepterVpcVpcIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SourceVpcAccountIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sourceVpcAccountIds", runtime.ParamLocationQuery, *params.SourceVpcAccountIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SourceVpcIpRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sourceVpcIpRanges", runtime.ParamLocationQuery, *params.SourceVpcIpRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SourceVpcVpcIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sourceVpcVpcIds", runtime.ParamLocationQuery, *params.SourceVpcVpcIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVpcPeeringRequest calls the generic CreateVpcPeering builder with application/json body
func NewCreateVpcPeeringRequest(server string, spaceId SpaceId, body CreateVpcPeeringJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVpcPeeringRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateVpcPeeringRequestWithBody generates requests for CreateVpcPeering with any type of body
func NewCreateVpcPeeringRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpcPeerings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVpcPeeringRequest generates requests for DeleteVpcPeering
func NewDeleteVpcPeeringRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpcPeerings/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadVpcPeeringsByIdRequest generates requests for ReadVpcPeeringsById
func NewReadVpcPeeringsByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpcPeerings/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAcceptVpcPeeringRequest generates requests for AcceptVpcPeering
func NewAcceptVpcPeeringRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpcPeerings/%s/accept", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRejectVpcPeeringRequest generates requests for RejectVpcPeering
func NewRejectVpcPeeringRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpcPeerings/%s/reject", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadVpcsRequest generates requests for ReadVpcs
func NewReadVpcsRequest(server string, spaceId SpaceId, params *ReadVpcsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpcs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DhcpOptionsSetIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dhcpOptionsSetIds", runtime.ParamLocationQuery, *params.DhcpOptionsSetIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IpRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ipRanges", runtime.ParamLocationQuery, *params.IpRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsDefault != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isDefault", runtime.ParamLocationQuery, *params.IsDefault); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVpcRequest calls the generic CreateVpc builder with application/json body
func NewCreateVpcRequest(server string, spaceId SpaceId, body CreateVpcJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVpcRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateVpcRequestWithBody generates requests for CreateVpc with any type of body
func NewCreateVpcRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpcs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVpcRequest generates requests for DeleteVpc
func NewDeleteVpcRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpcs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadVpcsByIdRequest generates requests for ReadVpcsById
func NewReadVpcsByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpcs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVpcRequest calls the generic UpdateVpc builder with application/json body
func NewUpdateVpcRequest(server string, spaceId SpaceId, id string, body UpdateVpcJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVpcRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateVpcRequestWithBody generates requests for UpdateVpc with any type of body
func NewUpdateVpcRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpcs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadVpnConnectionsRequest generates requests for ReadVpnConnections
func NewReadVpnConnectionsRequest(server string, spaceId SpaceId, params *ReadVpnConnectionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpnConnections", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BgpAsns != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bgpAsns", runtime.ParamLocationQuery, *params.BgpAsns); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClientGatewayIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "clientGatewayIds", runtime.ParamLocationQuery, *params.ClientGatewayIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ConnectionTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "connectionTypes", runtime.ParamLocationQuery, *params.ConnectionTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RouteDestinationIpRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "routeDestinationIpRanges", runtime.ParamLocationQuery, *params.RouteDestinationIpRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StaticRoutesOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "staticRoutesOnly", runtime.ParamLocationQuery, *params.StaticRoutesOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VirtualGatewayIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "virtualGatewayIds", runtime.ParamLocationQuery, *params.VirtualGatewayIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVpnConnectionRequest calls the generic CreateVpnConnection builder with application/json body
func NewCreateVpnConnectionRequest(server string, spaceId SpaceId, body CreateVpnConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVpnConnectionRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateVpnConnectionRequestWithBody generates requests for CreateVpnConnection with any type of body
func NewCreateVpnConnectionRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpnConnections", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVpnConnectionRequest generates requests for DeleteVpnConnection
func NewDeleteVpnConnectionRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpnConnections/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadVpnConnectionsByIdRequest generates requests for ReadVpnConnectionsById
func NewReadVpnConnectionsByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpnConnections/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVpnConnectionRequest calls the generic UpdateVpnConnection builder with application/json body
func NewUpdateVpnConnectionRequest(server string, spaceId SpaceId, id string, body UpdateVpnConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVpnConnectionRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateVpnConnectionRequestWithBody generates requests for UpdateVpnConnection with any type of body
func NewUpdateVpnConnectionRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpnConnections/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVpnConnectionRouteRequest calls the generic DeleteVpnConnectionRoute builder with application/json body
func NewDeleteVpnConnectionRouteRequest(server string, spaceId SpaceId, id string, body DeleteVpnConnectionRouteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteVpnConnectionRouteRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewDeleteVpnConnectionRouteRequestWithBody generates requests for DeleteVpnConnectionRoute with any type of body
func NewDeleteVpnConnectionRouteRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpnConnections/%s/routes", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateVpnConnectionRouteRequest calls the generic CreateVpnConnectionRoute builder with application/json body
func NewCreateVpnConnectionRouteRequest(server string, spaceId SpaceId, id string, body CreateVpnConnectionRouteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVpnConnectionRouteRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewCreateVpnConnectionRouteRequestWithBody generates requests for CreateVpnConnectionRoute with any type of body
func NewCreateVpnConnectionRouteRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpnConnections/%s/routes", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// DeleteLoadBalancerTagsWithBodyWithResponse request with any body
	DeleteLoadBalancerTagsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerTagsResponse, error)

	DeleteLoadBalancerTagsWithResponse(ctx context.Context, spaceId SpaceId, body DeleteLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerTagsResponse, error)

	// CreateLoadBalancerTagsWithBodyWithResponse request with any body
	CreateLoadBalancerTagsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLoadBalancerTagsResponse, error)

	CreateLoadBalancerTagsWithResponse(ctx context.Context, spaceId SpaceId, body CreateLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLoadBalancerTagsResponse, error)

	// DeleteTagsWithBodyWithResponse request with any body
	DeleteTagsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteTagsResponse, error)

	DeleteTagsWithResponse(ctx context.Context, spaceId SpaceId, body DeleteTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteTagsResponse, error)

	// CreateTagsWithBodyWithResponse request with any body
	CreateTagsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTagsResponse, error)

	CreateTagsWithResponse(ctx context.Context, spaceId SpaceId, body CreateTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTagsResponse, error)

	// ReadClientGatewaysWithResponse request
	ReadClientGatewaysWithResponse(ctx context.Context, spaceId SpaceId, params *ReadClientGatewaysParams, reqEditors ...RequestEditorFn) (*ReadClientGatewaysResponse, error)

	// CreateClientGatewayWithBodyWithResponse request with any body
	CreateClientGatewayWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientGatewayResponse, error)

	CreateClientGatewayWithResponse(ctx context.Context, spaceId SpaceId, body CreateClientGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientGatewayResponse, error)

	// DeleteClientGatewayWithResponse request
	DeleteClientGatewayWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteClientGatewayResponse, error)

	// ReadClientGatewaysByIdWithResponse request
	ReadClientGatewaysByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadClientGatewaysByIdResponse, error)

	// ReadDhcpOptionsWithResponse request
	ReadDhcpOptionsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadDhcpOptionsParams, reqEditors ...RequestEditorFn) (*ReadDhcpOptionsResponse, error)

	// CreateDhcpOptionsWithBodyWithResponse request with any body
	CreateDhcpOptionsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDhcpOptionsResponse, error)

	CreateDhcpOptionsWithResponse(ctx context.Context, spaceId SpaceId, body CreateDhcpOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDhcpOptionsResponse, error)

	// DeleteDhcpOptionsWithResponse request
	DeleteDhcpOptionsWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteDhcpOptionsResponse, error)

	// ReadDhcpOptionsByIdWithResponse request
	ReadDhcpOptionsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadDhcpOptionsByIdResponse, error)

	// ReadDirectLinkInterfacesWithResponse request
	ReadDirectLinkInterfacesWithResponse(ctx context.Context, spaceId SpaceId, params *ReadDirectLinkInterfacesParams, reqEditors ...RequestEditorFn) (*ReadDirectLinkInterfacesResponse, error)

	// CreateDirectLinkInterfaceWithBodyWithResponse request with any body
	CreateDirectLinkInterfaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDirectLinkInterfaceResponse, error)

	CreateDirectLinkInterfaceWithResponse(ctx context.Context, spaceId SpaceId, body CreateDirectLinkInterfaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDirectLinkInterfaceResponse, error)

	// DeleteDirectLinkInterfaceWithResponse request
	DeleteDirectLinkInterfaceWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteDirectLinkInterfaceResponse, error)

	// ReadDirectLinkInterfacesByIdWithResponse request
	ReadDirectLinkInterfacesByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadDirectLinkInterfacesByIdResponse, error)

	// UpdateDirectLinkInterfaceWithBodyWithResponse request with any body
	UpdateDirectLinkInterfaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDirectLinkInterfaceResponse, error)

	UpdateDirectLinkInterfaceWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateDirectLinkInterfaceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDirectLinkInterfaceResponse, error)

	// ReadDirectLinksWithResponse request
	ReadDirectLinksWithResponse(ctx context.Context, spaceId SpaceId, params *ReadDirectLinksParams, reqEditors ...RequestEditorFn) (*ReadDirectLinksResponse, error)

	// CreateDirectLinkWithBodyWithResponse request with any body
	CreateDirectLinkWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDirectLinkResponse, error)

	CreateDirectLinkWithResponse(ctx context.Context, spaceId SpaceId, body CreateDirectLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDirectLinkResponse, error)

	// DeleteDirectLinkWithResponse request
	DeleteDirectLinkWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteDirectLinkResponse, error)

	// ReadDirectLinksByIdWithResponse request
	ReadDirectLinksByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadDirectLinksByIdResponse, error)

	// ReadFlexibleGpuCatalogWithResponse request
	ReadFlexibleGpuCatalogWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*ReadFlexibleGpuCatalogResponse, error)

	// ReadFlexibleGpusWithResponse request
	ReadFlexibleGpusWithResponse(ctx context.Context, spaceId SpaceId, params *ReadFlexibleGpusParams, reqEditors ...RequestEditorFn) (*ReadFlexibleGpusResponse, error)

	// CreateFlexibleGpuWithBodyWithResponse request with any body
	CreateFlexibleGpuWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFlexibleGpuResponse, error)

	CreateFlexibleGpuWithResponse(ctx context.Context, spaceId SpaceId, body CreateFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFlexibleGpuResponse, error)

	// DeleteFlexibleGpuWithResponse request
	DeleteFlexibleGpuWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteFlexibleGpuResponse, error)

	// ReadFlexibleGpusByIdWithResponse request
	ReadFlexibleGpusByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadFlexibleGpusByIdResponse, error)

	// UpdateFlexibleGpuWithBodyWithResponse request with any body
	UpdateFlexibleGpuWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFlexibleGpuResponse, error)

	UpdateFlexibleGpuWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFlexibleGpuResponse, error)

	// LinkFlexibleGpuWithBodyWithResponse request with any body
	LinkFlexibleGpuWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkFlexibleGpuResponse, error)

	LinkFlexibleGpuWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkFlexibleGpuResponse, error)

	// UnlinkFlexibleGpuWithResponse request
	UnlinkFlexibleGpuWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*UnlinkFlexibleGpuResponse, error)

	// ReadImagesWithResponse request
	ReadImagesWithResponse(ctx context.Context, spaceId SpaceId, params *ReadImagesParams, reqEditors ...RequestEditorFn) (*ReadImagesResponse, error)

	// CreateImageWithBodyWithResponse request with any body
	CreateImageWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateImageResponse, error)

	CreateImageWithResponse(ctx context.Context, spaceId SpaceId, body CreateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateImageResponse, error)

	// DeleteImageWithResponse request
	DeleteImageWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteImageResponse, error)

	// ReadImagesByIdWithResponse request
	ReadImagesByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadImagesByIdResponse, error)

	// UpdateImageWithBodyWithResponse request with any body
	UpdateImageWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateImageResponse, error)

	UpdateImageWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateImageResponse, error)

	// ReadInternetGatewaysWithResponse request
	ReadInternetGatewaysWithResponse(ctx context.Context, spaceId SpaceId, params *ReadInternetGatewaysParams, reqEditors ...RequestEditorFn) (*ReadInternetGatewaysResponse, error)

	// CreateInternetGatewayWithResponse request
	CreateInternetGatewayWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*CreateInternetGatewayResponse, error)

	// DeleteInternetGatewayWithResponse request
	DeleteInternetGatewayWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteInternetGatewayResponse, error)

	// ReadInternetGatewaysByIdWithResponse request
	ReadInternetGatewaysByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadInternetGatewaysByIdResponse, error)

	// LinkInternetGatewayWithBodyWithResponse request with any body
	LinkInternetGatewayWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkInternetGatewayResponse, error)

	LinkInternetGatewayWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkInternetGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkInternetGatewayResponse, error)

	// UnlinkInternetGatewayWithBodyWithResponse request with any body
	UnlinkInternetGatewayWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkInternetGatewayResponse, error)

	UnlinkInternetGatewayWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkInternetGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkInternetGatewayResponse, error)

	// ReadKeypairsWithResponse request
	ReadKeypairsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadKeypairsParams, reqEditors ...RequestEditorFn) (*ReadKeypairsResponse, error)

	// CreateKeypairWithBodyWithResponse request with any body
	CreateKeypairWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeypairResponse, error)

	CreateKeypairWithResponse(ctx context.Context, spaceId SpaceId, body CreateKeypairJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeypairResponse, error)

	// DeleteKeypairWithResponse request
	DeleteKeypairWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteKeypairResponse, error)

	// ReadKeypairsByIdWithResponse request
	ReadKeypairsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadKeypairsByIdResponse, error)

	// ReadListenerRulesWithResponse request
	ReadListenerRulesWithResponse(ctx context.Context, spaceId SpaceId, params *ReadListenerRulesParams, reqEditors ...RequestEditorFn) (*ReadListenerRulesResponse, error)

	// CreateListenerRuleWithBodyWithResponse request with any body
	CreateListenerRuleWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateListenerRuleResponse, error)

	CreateListenerRuleWithResponse(ctx context.Context, spaceId SpaceId, body CreateListenerRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateListenerRuleResponse, error)

	// DeleteListenerRuleWithResponse request
	DeleteListenerRuleWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteListenerRuleResponse, error)

	// ReadListenerRulesByIdWithResponse request
	ReadListenerRulesByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadListenerRulesByIdResponse, error)

	// UpdateListenerRuleWithBodyWithResponse request with any body
	UpdateListenerRuleWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateListenerRuleResponse, error)

	UpdateListenerRuleWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateListenerRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateListenerRuleResponse, error)

	// ReadLoadBalancersWithResponse request
	ReadLoadBalancersWithResponse(ctx context.Context, spaceId SpaceId, params *ReadLoadBalancersParams, reqEditors ...RequestEditorFn) (*ReadLoadBalancersResponse, error)

	// CreateLoadBalancerWithBodyWithResponse request with any body
	CreateLoadBalancerWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLoadBalancerResponse, error)

	CreateLoadBalancerWithResponse(ctx context.Context, spaceId SpaceId, body CreateLoadBalancerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLoadBalancerResponse, error)

	// DeleteLoadBalancerWithResponse request
	DeleteLoadBalancerWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerResponse, error)

	// ReadLoadBalancersByIdWithResponse request
	ReadLoadBalancersByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadLoadBalancersByIdResponse, error)

	// UpdateLoadBalancerWithBodyWithResponse request with any body
	UpdateLoadBalancerWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLoadBalancerResponse, error)

	UpdateLoadBalancerWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateLoadBalancerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLoadBalancerResponse, error)

	// LinkLoadBalancerBackendMachinesWithBodyWithResponse request with any body
	LinkLoadBalancerBackendMachinesWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkLoadBalancerBackendMachinesResponse, error)

	LinkLoadBalancerBackendMachinesWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkLoadBalancerBackendMachinesJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkLoadBalancerBackendMachinesResponse, error)

	// UnlinkLoadBalancerBackendMachinesWithBodyWithResponse request with any body
	UnlinkLoadBalancerBackendMachinesWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkLoadBalancerBackendMachinesResponse, error)

	UnlinkLoadBalancerBackendMachinesWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkLoadBalancerBackendMachinesJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkLoadBalancerBackendMachinesResponse, error)

	// DeleteLoadBalancerListenersWithBodyWithResponse request with any body
	DeleteLoadBalancerListenersWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerListenersResponse, error)

	DeleteLoadBalancerListenersWithResponse(ctx context.Context, spaceId SpaceId, id string, body DeleteLoadBalancerListenersJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerListenersResponse, error)

	// CreateLoadBalancerListenersWithBodyWithResponse request with any body
	CreateLoadBalancerListenersWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLoadBalancerListenersResponse, error)

	CreateLoadBalancerListenersWithResponse(ctx context.Context, spaceId SpaceId, id string, body CreateLoadBalancerListenersJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLoadBalancerListenersResponse, error)

	// DeleteLoadBalancerPolicyWithBodyWithResponse request with any body
	DeleteLoadBalancerPolicyWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerPolicyResponse, error)

	DeleteLoadBalancerPolicyWithResponse(ctx context.Context, spaceId SpaceId, id string, body DeleteLoadBalancerPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerPolicyResponse, error)

	// CreateLoadBalancerPolicyWithBodyWithResponse request with any body
	CreateLoadBalancerPolicyWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLoadBalancerPolicyResponse, error)

	CreateLoadBalancerPolicyWithResponse(ctx context.Context, spaceId SpaceId, id string, body CreateLoadBalancerPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLoadBalancerPolicyResponse, error)

	// ReadVmsHealthWithBodyWithResponse request with any body
	ReadVmsHealthWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReadVmsHealthResponse, error)

	ReadVmsHealthWithResponse(ctx context.Context, spaceId SpaceId, id string, body ReadVmsHealthJSONRequestBody, reqEditors ...RequestEditorFn) (*ReadVmsHealthResponse, error)

	// ReadLoadBalancerTagsWithBodyWithResponse request with any body
	ReadLoadBalancerTagsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReadLoadBalancerTagsResponse, error)

	ReadLoadBalancerTagsWithResponse(ctx context.Context, spaceId SpaceId, body ReadLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReadLoadBalancerTagsResponse, error)

	// ReadLocationsWithResponse request
	ReadLocationsWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*ReadLocationsResponse, error)

	// ReadNatGatewayWithResponse request
	ReadNatGatewayWithResponse(ctx context.Context, spaceId SpaceId, params *ReadNatGatewayParams, reqEditors ...RequestEditorFn) (*ReadNatGatewayResponse, error)

	// CreateNatGatewayWithBodyWithResponse request with any body
	CreateNatGatewayWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNatGatewayResponse, error)

	CreateNatGatewayWithResponse(ctx context.Context, spaceId SpaceId, body CreateNatGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNatGatewayResponse, error)

	// DeleteNatGatewayWithResponse request
	DeleteNatGatewayWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteNatGatewayResponse, error)

	// ReadNatGatewayByIdWithResponse request
	ReadNatGatewayByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadNatGatewayByIdResponse, error)

	// ReadNicsWithResponse request
	ReadNicsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadNicsParams, reqEditors ...RequestEditorFn) (*ReadNicsResponse, error)

	// CreateNicWithBodyWithResponse request with any body
	CreateNicWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNicResponse, error)

	CreateNicWithResponse(ctx context.Context, spaceId SpaceId, body CreateNicJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNicResponse, error)

	// DeleteNicWithResponse request
	DeleteNicWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteNicResponse, error)

	// ReadNicsByIdWithResponse request
	ReadNicsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadNicsByIdResponse, error)

	// UpdateNicWithBodyWithResponse request with any body
	UpdateNicWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNicResponse, error)

	UpdateNicWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateNicJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNicResponse, error)

	// LinkPrivateIpsWithBodyWithResponse request with any body
	LinkPrivateIpsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkPrivateIpsResponse, error)

	LinkPrivateIpsWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkPrivateIpsJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkPrivateIpsResponse, error)

	// UnlinkPrivateIpsWithBodyWithResponse request with any body
	UnlinkPrivateIpsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkPrivateIpsResponse, error)

	UnlinkPrivateIpsWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkPrivateIpsJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkPrivateIpsResponse, error)

	// LinkNicWithBodyWithResponse request with any body
	LinkNicWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkNicResponse, error)

	LinkNicWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkNicJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkNicResponse, error)

	// UnlinkNicWithBodyWithResponse request with any body
	UnlinkNicWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkNicResponse, error)

	UnlinkNicWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkNicJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkNicResponse, error)

	// ReadProductTypesWithResponse request
	ReadProductTypesWithResponse(ctx context.Context, spaceId SpaceId, params *ReadProductTypesParams, reqEditors ...RequestEditorFn) (*ReadProductTypesResponse, error)

	// ReadProductTypesByIdWithResponse request
	ReadProductTypesByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadProductTypesByIdResponse, error)

	// ReadPublicIpRangesWithResponse request
	ReadPublicIpRangesWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*ReadPublicIpRangesResponse, error)

	// ReadPublicIpsWithResponse request
	ReadPublicIpsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadPublicIpsParams, reqEditors ...RequestEditorFn) (*ReadPublicIpsResponse, error)

	// CreatePublicIpWithResponse request
	CreatePublicIpWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*CreatePublicIpResponse, error)

	// DeletePublicIpWithResponse request
	DeletePublicIpWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeletePublicIpResponse, error)

	// ReadPublicIpsByIdWithResponse request
	ReadPublicIpsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadPublicIpsByIdResponse, error)

	// LinkPublicIpWithBodyWithResponse request with any body
	LinkPublicIpWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkPublicIpResponse, error)

	LinkPublicIpWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkPublicIpJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkPublicIpResponse, error)

	// UnlinkPublicIpWithBodyWithResponse request with any body
	UnlinkPublicIpWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkPublicIpResponse, error)

	UnlinkPublicIpWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkPublicIpJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkPublicIpResponse, error)

	// ReadRouteTablesWithResponse request
	ReadRouteTablesWithResponse(ctx context.Context, spaceId SpaceId, params *ReadRouteTablesParams, reqEditors ...RequestEditorFn) (*ReadRouteTablesResponse, error)

	// CreateRouteTableWithBodyWithResponse request with any body
	CreateRouteTableWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRouteTableResponse, error)

	CreateRouteTableWithResponse(ctx context.Context, spaceId SpaceId, body CreateRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRouteTableResponse, error)

	// DeleteRouteTableWithResponse request
	DeleteRouteTableWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteRouteTableResponse, error)

	// ReadRouteTablesByIdWithResponse request
	ReadRouteTablesByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadRouteTablesByIdResponse, error)

	// UpdateRouteTableRoutePropagationWithBodyWithResponse request with any body
	UpdateRouteTableRoutePropagationWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRouteTableRoutePropagationResponse, error)

	UpdateRouteTableRoutePropagationWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateRouteTableRoutePropagationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRouteTableRoutePropagationResponse, error)

	// DeleteRouteWithBodyWithResponse request with any body
	DeleteRouteWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteRouteResponse, error)

	DeleteRouteWithResponse(ctx context.Context, spaceId SpaceId, id string, body DeleteRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteRouteResponse, error)

	// CreateRouteWithBodyWithResponse request with any body
	CreateRouteWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRouteResponse, error)

	CreateRouteWithResponse(ctx context.Context, spaceId SpaceId, id string, body CreateRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRouteResponse, error)

	// UpdateRouteWithBodyWithResponse request with any body
	UpdateRouteWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRouteResponse, error)

	UpdateRouteWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRouteResponse, error)

	// LinkRouteTableWithBodyWithResponse request with any body
	LinkRouteTableWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkRouteTableResponse, error)

	LinkRouteTableWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkRouteTableResponse, error)

	// UnlinkRouteTableWithBodyWithResponse request with any body
	UnlinkRouteTableWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkRouteTableResponse, error)

	UnlinkRouteTableWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkRouteTableResponse, error)

	// ReadSecurityGroupsWithResponse request
	ReadSecurityGroupsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadSecurityGroupsParams, reqEditors ...RequestEditorFn) (*ReadSecurityGroupsResponse, error)

	// CreateSecurityGroupWithBodyWithResponse request with any body
	CreateSecurityGroupWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSecurityGroupResponse, error)

	CreateSecurityGroupWithResponse(ctx context.Context, spaceId SpaceId, body CreateSecurityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSecurityGroupResponse, error)

	// DeleteSecurityGroupWithResponse request
	DeleteSecurityGroupWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteSecurityGroupResponse, error)

	// ReadSecurityGroupsByIdWithResponse request
	ReadSecurityGroupsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadSecurityGroupsByIdResponse, error)

	// DeleteSecurityGroupRuleWithBodyWithResponse request with any body
	DeleteSecurityGroupRuleWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteSecurityGroupRuleResponse, error)

	DeleteSecurityGroupRuleWithResponse(ctx context.Context, spaceId SpaceId, id string, body DeleteSecurityGroupRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteSecurityGroupRuleResponse, error)

	// CreateSecurityGroupRuleWithBodyWithResponse request with any body
	CreateSecurityGroupRuleWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSecurityGroupRuleResponse, error)

	CreateSecurityGroupRuleWithResponse(ctx context.Context, spaceId SpaceId, id string, body CreateSecurityGroupRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSecurityGroupRuleResponse, error)

	// ReadSnapshotsWithResponse request
	ReadSnapshotsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadSnapshotsParams, reqEditors ...RequestEditorFn) (*ReadSnapshotsResponse, error)

	// CreateSnapshotWithBodyWithResponse request with any body
	CreateSnapshotWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSnapshotResponse, error)

	CreateSnapshotWithResponse(ctx context.Context, spaceId SpaceId, body CreateSnapshotJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSnapshotResponse, error)

	// DeleteSnapshotWithResponse request
	DeleteSnapshotWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteSnapshotResponse, error)

	// ReadSnapshotsByIdWithResponse request
	ReadSnapshotsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadSnapshotsByIdResponse, error)

	// ReadSubnetsWithResponse request
	ReadSubnetsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadSubnetsParams, reqEditors ...RequestEditorFn) (*ReadSubnetsResponse, error)

	// CreateSubnetWithBodyWithResponse request with any body
	CreateSubnetWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSubnetResponse, error)

	CreateSubnetWithResponse(ctx context.Context, spaceId SpaceId, body CreateSubnetJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSubnetResponse, error)

	// DeleteSubnetWithResponse request
	DeleteSubnetWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteSubnetResponse, error)

	// ReadSubnetsByIdWithResponse request
	ReadSubnetsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadSubnetsByIdResponse, error)

	// UpdateSubnetWithBodyWithResponse request with any body
	UpdateSubnetWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSubnetResponse, error)

	UpdateSubnetWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateSubnetJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSubnetResponse, error)

	// ReadTagsWithResponse request
	ReadTagsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadTagsParams, reqEditors ...RequestEditorFn) (*ReadTagsResponse, error)

	// ReadVirtualGatewaysWithResponse request
	ReadVirtualGatewaysWithResponse(ctx context.Context, spaceId SpaceId, params *ReadVirtualGatewaysParams, reqEditors ...RequestEditorFn) (*ReadVirtualGatewaysResponse, error)

	// CreateVirtualGatewayWithBodyWithResponse request with any body
	CreateVirtualGatewayWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVirtualGatewayResponse, error)

	CreateVirtualGatewayWithResponse(ctx context.Context, spaceId SpaceId, body CreateVirtualGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVirtualGatewayResponse, error)

	// DeleteVirtualGatewayWithResponse request
	DeleteVirtualGatewayWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteVirtualGatewayResponse, error)

	// ReadVirtualGatewaysByIdWithResponse request
	ReadVirtualGatewaysByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadVirtualGatewaysByIdResponse, error)

	// LinkVirtualGatewayToVpcWithBodyWithResponse request with any body
	LinkVirtualGatewayToVpcWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkVirtualGatewayToVpcResponse, error)

	LinkVirtualGatewayToVpcWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkVirtualGatewayToVpcJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkVirtualGatewayToVpcResponse, error)

	// UnlinkVirtualGatewayToVpcWithBodyWithResponse request with any body
	UnlinkVirtualGatewayToVpcWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkVirtualGatewayToVpcResponse, error)

	UnlinkVirtualGatewayToVpcWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkVirtualGatewayToVpcJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkVirtualGatewayToVpcResponse, error)

	// ReadVmsWithResponse request
	ReadVmsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadVmsParams, reqEditors ...RequestEditorFn) (*ReadVmsResponse, error)

	// CreateVmsWithBodyWithResponse request with any body
	CreateVmsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVmsResponse, error)

	CreateVmsWithResponse(ctx context.Context, spaceId SpaceId, body CreateVmsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVmsResponse, error)

	// ReadVmsStateWithResponse request
	ReadVmsStateWithResponse(ctx context.Context, spaceId SpaceId, params *ReadVmsStateParams, reqEditors ...RequestEditorFn) (*ReadVmsStateResponse, error)

	// DeleteVmsWithResponse request
	DeleteVmsWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteVmsResponse, error)

	// ReadVmsByIdWithResponse request
	ReadVmsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadVmsByIdResponse, error)

	// UpdateVmWithBodyWithResponse request with any body
	UpdateVmWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVmResponse, error)

	UpdateVmWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateVmJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVmResponse, error)

	// ReadAdminPasswordWithResponse request
	ReadAdminPasswordWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadAdminPasswordResponse, error)

	// ReadConsoleOutputWithResponse request
	ReadConsoleOutputWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadConsoleOutputResponse, error)

	// RebootVmWithResponse request
	RebootVmWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*RebootVmResponse, error)

	// StartVmWithResponse request
	StartVmWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*StartVmResponse, error)

	// StopVmWithBodyWithResponse request with any body
	StopVmWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StopVmResponse, error)

	StopVmWithResponse(ctx context.Context, spaceId SpaceId, id string, body StopVmJSONRequestBody, reqEditors ...RequestEditorFn) (*StopVmResponse, error)

	// ReadVolumesWithResponse request
	ReadVolumesWithResponse(ctx context.Context, spaceId SpaceId, params *ReadVolumesParams, reqEditors ...RequestEditorFn) (*ReadVolumesResponse, error)

	// CreateVolumeWithBodyWithResponse request with any body
	CreateVolumeWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVolumeResponse, error)

	CreateVolumeWithResponse(ctx context.Context, spaceId SpaceId, body CreateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVolumeResponse, error)

	// DeleteVolumeWithResponse request
	DeleteVolumeWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteVolumeResponse, error)

	// ReadVolumesByIdWithResponse request
	ReadVolumesByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadVolumesByIdResponse, error)

	// UpdateVolumeWithBodyWithResponse request with any body
	UpdateVolumeWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVolumeResponse, error)

	UpdateVolumeWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVolumeResponse, error)

	// LinkVolumeWithBodyWithResponse request with any body
	LinkVolumeWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkVolumeResponse, error)

	LinkVolumeWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkVolumeResponse, error)

	// UnlinkVolumeWithBodyWithResponse request with any body
	UnlinkVolumeWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkVolumeResponse, error)

	UnlinkVolumeWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkVolumeResponse, error)

	// ReadVpcAccessPointsWithResponse request
	ReadVpcAccessPointsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadVpcAccessPointsParams, reqEditors ...RequestEditorFn) (*ReadVpcAccessPointsResponse, error)

	// CreateVpcAccessPointWithBodyWithResponse request with any body
	CreateVpcAccessPointWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVpcAccessPointResponse, error)

	CreateVpcAccessPointWithResponse(ctx context.Context, spaceId SpaceId, body CreateVpcAccessPointJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVpcAccessPointResponse, error)

	// DeleteVpcAccessPointWithResponse request
	DeleteVpcAccessPointWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteVpcAccessPointResponse, error)

	// ReadVpcAccessPointsByIdWithResponse request
	ReadVpcAccessPointsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadVpcAccessPointsByIdResponse, error)

	// UpdateVpcAccessPointWithBodyWithResponse request with any body
	UpdateVpcAccessPointWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVpcAccessPointResponse, error)

	UpdateVpcAccessPointWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateVpcAccessPointJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVpcAccessPointResponse, error)

	// ReadVpcPeeringsWithResponse request
	ReadVpcPeeringsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadVpcPeeringsParams, reqEditors ...RequestEditorFn) (*ReadVpcPeeringsResponse, error)

	// CreateVpcPeeringWithBodyWithResponse request with any body
	CreateVpcPeeringWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVpcPeeringResponse, error)

	CreateVpcPeeringWithResponse(ctx context.Context, spaceId SpaceId, body CreateVpcPeeringJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVpcPeeringResponse, error)

	// DeleteVpcPeeringWithResponse request
	DeleteVpcPeeringWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteVpcPeeringResponse, error)

	// ReadVpcPeeringsByIdWithResponse request
	ReadVpcPeeringsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadVpcPeeringsByIdResponse, error)

	// AcceptVpcPeeringWithResponse request
	AcceptVpcPeeringWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*AcceptVpcPeeringResponse, error)

	// RejectVpcPeeringWithResponse request
	RejectVpcPeeringWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*RejectVpcPeeringResponse, error)

	// ReadVpcsWithResponse request
	ReadVpcsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadVpcsParams, reqEditors ...RequestEditorFn) (*ReadVpcsResponse, error)

	// CreateVpcWithBodyWithResponse request with any body
	CreateVpcWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVpcResponse, error)

	CreateVpcWithResponse(ctx context.Context, spaceId SpaceId, body CreateVpcJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVpcResponse, error)

	// DeleteVpcWithResponse request
	DeleteVpcWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteVpcResponse, error)

	// ReadVpcsByIdWithResponse request
	ReadVpcsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadVpcsByIdResponse, error)

	// UpdateVpcWithBodyWithResponse request with any body
	UpdateVpcWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVpcResponse, error)

	UpdateVpcWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateVpcJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVpcResponse, error)

	// ReadVpnConnectionsWithResponse request
	ReadVpnConnectionsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadVpnConnectionsParams, reqEditors ...RequestEditorFn) (*ReadVpnConnectionsResponse, error)

	// CreateVpnConnectionWithBodyWithResponse request with any body
	CreateVpnConnectionWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVpnConnectionResponse, error)

	CreateVpnConnectionWithResponse(ctx context.Context, spaceId SpaceId, body CreateVpnConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVpnConnectionResponse, error)

	// DeleteVpnConnectionWithResponse request
	DeleteVpnConnectionWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteVpnConnectionResponse, error)

	// ReadVpnConnectionsByIdWithResponse request
	ReadVpnConnectionsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadVpnConnectionsByIdResponse, error)

	// UpdateVpnConnectionWithBodyWithResponse request with any body
	UpdateVpnConnectionWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVpnConnectionResponse, error)

	UpdateVpnConnectionWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateVpnConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVpnConnectionResponse, error)

	// DeleteVpnConnectionRouteWithBodyWithResponse request with any body
	DeleteVpnConnectionRouteWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteVpnConnectionRouteResponse, error)

	DeleteVpnConnectionRouteWithResponse(ctx context.Context, spaceId SpaceId, id string, body DeleteVpnConnectionRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteVpnConnectionRouteResponse, error)

	// CreateVpnConnectionRouteWithBodyWithResponse request with any body
	CreateVpnConnectionRouteWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVpnConnectionRouteResponse, error)

	CreateVpnConnectionRouteWithResponse(ctx context.Context, spaceId SpaceId, id string, body CreateVpnConnectionRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVpnConnectionRouteResponse, error)
}

type DeleteLoadBalancerTagsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteLoadBalancerTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLoadBalancerTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLoadBalancerTagsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateLoadBalancerTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLoadBalancerTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTagsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTagsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadClientGatewaysResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadClientGatewaysResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadClientGatewaysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadClientGatewaysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClientGatewayResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateClientGatewayResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateClientGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClientGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClientGatewayResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteClientGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClientGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadClientGatewaysByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadClientGatewaysByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadClientGatewaysByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadClientGatewaysByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadDhcpOptionsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadDhcpOptionsResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadDhcpOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadDhcpOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDhcpOptionsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateDhcpOptionsResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateDhcpOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDhcpOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDhcpOptionsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteDhcpOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDhcpOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadDhcpOptionsByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadDhcpOptionsByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadDhcpOptionsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadDhcpOptionsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadDirectLinkInterfacesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadDirectLinkInterfacesResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadDirectLinkInterfacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadDirectLinkInterfacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDirectLinkInterfaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateDirectLinkInterfaceResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateDirectLinkInterfaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDirectLinkInterfaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDirectLinkInterfaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteDirectLinkInterfaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDirectLinkInterfaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadDirectLinkInterfacesByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadDirectLinkInterfacesByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadDirectLinkInterfacesByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadDirectLinkInterfacesByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDirectLinkInterfaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateDirectLinkInterfaceResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateDirectLinkInterfaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDirectLinkInterfaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadDirectLinksResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadDirectLinksResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadDirectLinksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadDirectLinksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDirectLinkResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateDirectLinkResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateDirectLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDirectLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDirectLinkResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteDirectLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDirectLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadDirectLinksByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadDirectLinksByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadDirectLinksByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadDirectLinksByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadFlexibleGpuCatalogResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadFlexibleGpuCatalogResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadFlexibleGpuCatalogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadFlexibleGpuCatalogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadFlexibleGpusResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadFlexibleGpusResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadFlexibleGpusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadFlexibleGpusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFlexibleGpuResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateFlexibleGpuResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateFlexibleGpuResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFlexibleGpuResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFlexibleGpuResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteFlexibleGpuResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFlexibleGpuResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadFlexibleGpusByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadFlexibleGpusByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadFlexibleGpusByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadFlexibleGpusByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateFlexibleGpuResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateFlexibleGpuResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateFlexibleGpuResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFlexibleGpuResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkFlexibleGpuResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r LinkFlexibleGpuResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkFlexibleGpuResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkFlexibleGpuResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UnlinkFlexibleGpuResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkFlexibleGpuResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadImagesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadImagesResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadImagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadImagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateImageResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateImageResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteImageResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadImagesByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadImagesByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadImagesByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadImagesByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateImageResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateImageResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadInternetGatewaysResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadInternetGatewaysResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadInternetGatewaysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadInternetGatewaysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateInternetGatewayResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateInternetGatewayResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateInternetGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateInternetGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteInternetGatewayResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteInternetGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteInternetGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadInternetGatewaysByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadInternetGatewaysByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadInternetGatewaysByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadInternetGatewaysByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkInternetGatewayResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r LinkInternetGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkInternetGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkInternetGatewayResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UnlinkInternetGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkInternetGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadKeypairsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadKeypairsResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadKeypairsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadKeypairsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateKeypairResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateKeypairResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateKeypairResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateKeypairResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteKeypairResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteKeypairResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteKeypairResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadKeypairsByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadKeypairsByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadKeypairsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadKeypairsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadListenerRulesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadListenerRulesResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadListenerRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadListenerRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateListenerRuleResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateListenerRuleResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateListenerRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateListenerRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteListenerRuleResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteListenerRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteListenerRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadListenerRulesByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadListenerRulesByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadListenerRulesByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadListenerRulesByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateListenerRuleResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateListenerRuleResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateListenerRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateListenerRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadLoadBalancersResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadLoadBalancersResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadLoadBalancersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadLoadBalancersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLoadBalancerResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateLoadBalancerResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateLoadBalancerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLoadBalancerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLoadBalancerResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteLoadBalancerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLoadBalancerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadLoadBalancersByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadLoadBalancersByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadLoadBalancersByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadLoadBalancersByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateLoadBalancerResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateLoadBalancerResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateLoadBalancerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateLoadBalancerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkLoadBalancerBackendMachinesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r LinkLoadBalancerBackendMachinesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkLoadBalancerBackendMachinesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkLoadBalancerBackendMachinesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UnlinkLoadBalancerBackendMachinesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkLoadBalancerBackendMachinesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLoadBalancerListenersResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteLoadBalancerListenersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLoadBalancerListenersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLoadBalancerListenersResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateLoadBalancerListenersResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateLoadBalancerListenersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLoadBalancerListenersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLoadBalancerPolicyResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteLoadBalancerPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLoadBalancerPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLoadBalancerPolicyResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateLoadBalancerPolicyResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateLoadBalancerPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLoadBalancerPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVmsHealthResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadVmsHealthResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadVmsHealthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVmsHealthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadLoadBalancerTagsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadLoadBalancerTagsResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadLoadBalancerTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadLoadBalancerTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadLocationsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadLocationsResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadLocationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadLocationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadNatGatewayResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadNatGatewayResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadNatGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadNatGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNatGatewayResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateNatGatewayResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateNatGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNatGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNatGatewayResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteNatGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNatGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadNatGatewayByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadNatGatewayByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadNatGatewayByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadNatGatewayByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadNicsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadNicsResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadNicsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadNicsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNicResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateNicResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateNicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNicResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteNicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadNicsByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadNicsByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadNicsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadNicsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateNicResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateNicResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateNicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateNicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkPrivateIpsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r LinkPrivateIpsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkPrivateIpsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkPrivateIpsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UnlinkPrivateIpsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkPrivateIpsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkNicResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *LinkNicResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r LinkNicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkNicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkNicResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UnlinkNicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkNicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadProductTypesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadProductTypesResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadProductTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadProductTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadProductTypesByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadProductTypesByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadProductTypesByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadProductTypesByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadPublicIpRangesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadPublicIpRangesResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadPublicIpRangesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadPublicIpRangesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadPublicIpsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadPublicIpsResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadPublicIpsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadPublicIpsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePublicIpResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreatePublicIpResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreatePublicIpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePublicIpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePublicIpResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeletePublicIpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePublicIpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadPublicIpsByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadPublicIpsByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadPublicIpsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadPublicIpsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkPublicIpResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *LinkPublicIpResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r LinkPublicIpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkPublicIpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkPublicIpResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UnlinkPublicIpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkPublicIpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadRouteTablesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadRouteTablesResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadRouteTablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadRouteTablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRouteTableResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateRouteTableResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateRouteTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRouteTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRouteTableResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteRouteTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRouteTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadRouteTablesByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadRouteTablesByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadRouteTablesByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadRouteTablesByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRouteTableRoutePropagationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateRouteTableRoutePropagationResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateRouteTableRoutePropagationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRouteTableRoutePropagationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRouteResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteRouteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRouteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRouteResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateRouteResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateRouteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRouteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRouteResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateRouteResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateRouteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRouteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkRouteTableResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *LinkRouteTableResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r LinkRouteTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkRouteTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkRouteTableResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UnlinkRouteTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkRouteTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadSecurityGroupsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadSecurityGroupsResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadSecurityGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadSecurityGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSecurityGroupResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateSecurityGroupResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateSecurityGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSecurityGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSecurityGroupResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSecurityGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSecurityGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadSecurityGroupsByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadSecurityGroupsByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadSecurityGroupsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadSecurityGroupsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSecurityGroupRuleResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSecurityGroupRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSecurityGroupRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSecurityGroupRuleResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateSecurityGroupRuleResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateSecurityGroupRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSecurityGroupRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadSnapshotsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadSnapshotsResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadSnapshotsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadSnapshotsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSnapshotResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateSnapshotResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateSnapshotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSnapshotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSnapshotResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSnapshotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSnapshotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadSnapshotsByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadSnapshotsByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadSnapshotsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadSnapshotsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadSubnetsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadSubnetsResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadSubnetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadSubnetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSubnetResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateSubnetResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateSubnetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSubnetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSubnetResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSubnetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSubnetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadSubnetsByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadSubnetsByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadSubnetsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadSubnetsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSubnetResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateSubnetResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateSubnetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSubnetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadTagsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadTagsResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVirtualGatewaysResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadVirtualGatewaysResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadVirtualGatewaysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVirtualGatewaysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVirtualGatewayResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateVirtualGatewayResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateVirtualGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVirtualGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVirtualGatewayResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteVirtualGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVirtualGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVirtualGatewaysByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadVirtualGatewaysByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadVirtualGatewaysByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVirtualGatewaysByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkVirtualGatewayToVpcResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *LinkVirtualGatewayToVpcResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r LinkVirtualGatewayToVpcResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkVirtualGatewayToVpcResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkVirtualGatewayToVpcResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UnlinkVirtualGatewayToVpcResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkVirtualGatewayToVpcResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVmsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadVmsResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadVmsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVmsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVmsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateVmsResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateVmsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVmsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVmsStateResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadVmsStateResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadVmsStateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVmsStateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVmsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteVmsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVmsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVmsByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadVmsByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadVmsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVmsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVmResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateVmResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateVmResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVmResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadAdminPasswordResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadAdminPasswordResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadAdminPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadAdminPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadConsoleOutputResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadConsoleOutputResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadConsoleOutputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadConsoleOutputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RebootVmResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r RebootVmResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RebootVmResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartVmResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *StartVmResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r StartVmResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartVmResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StopVmResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *StopVmResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r StopVmResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StopVmResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVolumesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadVolumesResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadVolumesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVolumesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVolumeResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateVolumeResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateVolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVolumeResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteVolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVolumesByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadVolumesByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadVolumesByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVolumesByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVolumeResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateVolumeResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateVolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkVolumeResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r LinkVolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkVolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkVolumeResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UnlinkVolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkVolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVpcAccessPointsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadVpcAccessPointsResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadVpcAccessPointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVpcAccessPointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVpcAccessPointResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateVpcAccessPointResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateVpcAccessPointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVpcAccessPointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVpcAccessPointResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteVpcAccessPointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVpcAccessPointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVpcAccessPointsByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadVpcAccessPointsByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadVpcAccessPointsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVpcAccessPointsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVpcAccessPointResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateVpcAccessPointResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateVpcAccessPointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVpcAccessPointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVpcPeeringsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadVpcPeeringsResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadVpcPeeringsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVpcPeeringsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVpcPeeringResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateVpcPeeringResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateVpcPeeringResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVpcPeeringResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVpcPeeringResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteVpcPeeringResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVpcPeeringResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVpcPeeringsByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadVpcPeeringsByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadVpcPeeringsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVpcPeeringsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AcceptVpcPeeringResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *AcceptVpcPeeringResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r AcceptVpcPeeringResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AcceptVpcPeeringResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RejectVpcPeeringResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r RejectVpcPeeringResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RejectVpcPeeringResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVpcsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadVpcsResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadVpcsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVpcsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVpcResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateVpcResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateVpcResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVpcResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVpcResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteVpcResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVpcResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVpcsByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadVpcsByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadVpcsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVpcsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVpcResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateVpcResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateVpcResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVpcResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVpnConnectionsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadVpnConnectionsResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadVpnConnectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVpnConnectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVpnConnectionResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateVpnConnectionResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateVpnConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVpnConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVpnConnectionResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteVpnConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVpnConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVpnConnectionsByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadVpnConnectionsByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadVpnConnectionsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVpnConnectionsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVpnConnectionResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateVpnConnectionResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateVpnConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVpnConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVpnConnectionRouteResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteVpnConnectionRouteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVpnConnectionRouteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVpnConnectionRouteResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateVpnConnectionRouteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVpnConnectionRouteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// DeleteLoadBalancerTagsWithBodyWithResponse request with arbitrary body returning *DeleteLoadBalancerTagsResponse
func (c *ClientWithResponses) DeleteLoadBalancerTagsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerTagsResponse, error) {
	rsp, err := c.DeleteLoadBalancerTagsWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLoadBalancerTagsResponse(rsp)
}

func (c *ClientWithResponses) DeleteLoadBalancerTagsWithResponse(ctx context.Context, spaceId SpaceId, body DeleteLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerTagsResponse, error) {
	rsp, err := c.DeleteLoadBalancerTags(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLoadBalancerTagsResponse(rsp)
}

// CreateLoadBalancerTagsWithBodyWithResponse request with arbitrary body returning *CreateLoadBalancerTagsResponse
func (c *ClientWithResponses) CreateLoadBalancerTagsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLoadBalancerTagsResponse, error) {
	rsp, err := c.CreateLoadBalancerTagsWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLoadBalancerTagsResponse(rsp)
}

func (c *ClientWithResponses) CreateLoadBalancerTagsWithResponse(ctx context.Context, spaceId SpaceId, body CreateLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLoadBalancerTagsResponse, error) {
	rsp, err := c.CreateLoadBalancerTags(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLoadBalancerTagsResponse(rsp)
}

// DeleteTagsWithBodyWithResponse request with arbitrary body returning *DeleteTagsResponse
func (c *ClientWithResponses) DeleteTagsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteTagsResponse, error) {
	rsp, err := c.DeleteTagsWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTagsResponse(rsp)
}

func (c *ClientWithResponses) DeleteTagsWithResponse(ctx context.Context, spaceId SpaceId, body DeleteTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteTagsResponse, error) {
	rsp, err := c.DeleteTags(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTagsResponse(rsp)
}

// CreateTagsWithBodyWithResponse request with arbitrary body returning *CreateTagsResponse
func (c *ClientWithResponses) CreateTagsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTagsResponse, error) {
	rsp, err := c.CreateTagsWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTagsResponse(rsp)
}

func (c *ClientWithResponses) CreateTagsWithResponse(ctx context.Context, spaceId SpaceId, body CreateTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTagsResponse, error) {
	rsp, err := c.CreateTags(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTagsResponse(rsp)
}

// ReadClientGatewaysWithResponse request returning *ReadClientGatewaysResponse
func (c *ClientWithResponses) ReadClientGatewaysWithResponse(ctx context.Context, spaceId SpaceId, params *ReadClientGatewaysParams, reqEditors ...RequestEditorFn) (*ReadClientGatewaysResponse, error) {
	rsp, err := c.ReadClientGateways(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadClientGatewaysResponse(rsp)
}

// CreateClientGatewayWithBodyWithResponse request with arbitrary body returning *CreateClientGatewayResponse
func (c *ClientWithResponses) CreateClientGatewayWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientGatewayResponse, error) {
	rsp, err := c.CreateClientGatewayWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientGatewayResponse(rsp)
}

func (c *ClientWithResponses) CreateClientGatewayWithResponse(ctx context.Context, spaceId SpaceId, body CreateClientGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientGatewayResponse, error) {
	rsp, err := c.CreateClientGateway(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientGatewayResponse(rsp)
}

// DeleteClientGatewayWithResponse request returning *DeleteClientGatewayResponse
func (c *ClientWithResponses) DeleteClientGatewayWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteClientGatewayResponse, error) {
	rsp, err := c.DeleteClientGateway(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClientGatewayResponse(rsp)
}

// ReadClientGatewaysByIdWithResponse request returning *ReadClientGatewaysByIdResponse
func (c *ClientWithResponses) ReadClientGatewaysByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadClientGatewaysByIdResponse, error) {
	rsp, err := c.ReadClientGatewaysById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadClientGatewaysByIdResponse(rsp)
}

// ReadDhcpOptionsWithResponse request returning *ReadDhcpOptionsResponse
func (c *ClientWithResponses) ReadDhcpOptionsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadDhcpOptionsParams, reqEditors ...RequestEditorFn) (*ReadDhcpOptionsResponse, error) {
	rsp, err := c.ReadDhcpOptions(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadDhcpOptionsResponse(rsp)
}

// CreateDhcpOptionsWithBodyWithResponse request with arbitrary body returning *CreateDhcpOptionsResponse
func (c *ClientWithResponses) CreateDhcpOptionsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDhcpOptionsResponse, error) {
	rsp, err := c.CreateDhcpOptionsWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDhcpOptionsResponse(rsp)
}

func (c *ClientWithResponses) CreateDhcpOptionsWithResponse(ctx context.Context, spaceId SpaceId, body CreateDhcpOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDhcpOptionsResponse, error) {
	rsp, err := c.CreateDhcpOptions(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDhcpOptionsResponse(rsp)
}

// DeleteDhcpOptionsWithResponse request returning *DeleteDhcpOptionsResponse
func (c *ClientWithResponses) DeleteDhcpOptionsWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteDhcpOptionsResponse, error) {
	rsp, err := c.DeleteDhcpOptions(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDhcpOptionsResponse(rsp)
}

// ReadDhcpOptionsByIdWithResponse request returning *ReadDhcpOptionsByIdResponse
func (c *ClientWithResponses) ReadDhcpOptionsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadDhcpOptionsByIdResponse, error) {
	rsp, err := c.ReadDhcpOptionsById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadDhcpOptionsByIdResponse(rsp)
}

// ReadDirectLinkInterfacesWithResponse request returning *ReadDirectLinkInterfacesResponse
func (c *ClientWithResponses) ReadDirectLinkInterfacesWithResponse(ctx context.Context, spaceId SpaceId, params *ReadDirectLinkInterfacesParams, reqEditors ...RequestEditorFn) (*ReadDirectLinkInterfacesResponse, error) {
	rsp, err := c.ReadDirectLinkInterfaces(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadDirectLinkInterfacesResponse(rsp)
}

// CreateDirectLinkInterfaceWithBodyWithResponse request with arbitrary body returning *CreateDirectLinkInterfaceResponse
func (c *ClientWithResponses) CreateDirectLinkInterfaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDirectLinkInterfaceResponse, error) {
	rsp, err := c.CreateDirectLinkInterfaceWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDirectLinkInterfaceResponse(rsp)
}

func (c *ClientWithResponses) CreateDirectLinkInterfaceWithResponse(ctx context.Context, spaceId SpaceId, body CreateDirectLinkInterfaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDirectLinkInterfaceResponse, error) {
	rsp, err := c.CreateDirectLinkInterface(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDirectLinkInterfaceResponse(rsp)
}

// DeleteDirectLinkInterfaceWithResponse request returning *DeleteDirectLinkInterfaceResponse
func (c *ClientWithResponses) DeleteDirectLinkInterfaceWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteDirectLinkInterfaceResponse, error) {
	rsp, err := c.DeleteDirectLinkInterface(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDirectLinkInterfaceResponse(rsp)
}

// ReadDirectLinkInterfacesByIdWithResponse request returning *ReadDirectLinkInterfacesByIdResponse
func (c *ClientWithResponses) ReadDirectLinkInterfacesByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadDirectLinkInterfacesByIdResponse, error) {
	rsp, err := c.ReadDirectLinkInterfacesById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadDirectLinkInterfacesByIdResponse(rsp)
}

// UpdateDirectLinkInterfaceWithBodyWithResponse request with arbitrary body returning *UpdateDirectLinkInterfaceResponse
func (c *ClientWithResponses) UpdateDirectLinkInterfaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDirectLinkInterfaceResponse, error) {
	rsp, err := c.UpdateDirectLinkInterfaceWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDirectLinkInterfaceResponse(rsp)
}

func (c *ClientWithResponses) UpdateDirectLinkInterfaceWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateDirectLinkInterfaceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDirectLinkInterfaceResponse, error) {
	rsp, err := c.UpdateDirectLinkInterface(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDirectLinkInterfaceResponse(rsp)
}

// ReadDirectLinksWithResponse request returning *ReadDirectLinksResponse
func (c *ClientWithResponses) ReadDirectLinksWithResponse(ctx context.Context, spaceId SpaceId, params *ReadDirectLinksParams, reqEditors ...RequestEditorFn) (*ReadDirectLinksResponse, error) {
	rsp, err := c.ReadDirectLinks(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadDirectLinksResponse(rsp)
}

// CreateDirectLinkWithBodyWithResponse request with arbitrary body returning *CreateDirectLinkResponse
func (c *ClientWithResponses) CreateDirectLinkWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDirectLinkResponse, error) {
	rsp, err := c.CreateDirectLinkWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDirectLinkResponse(rsp)
}

func (c *ClientWithResponses) CreateDirectLinkWithResponse(ctx context.Context, spaceId SpaceId, body CreateDirectLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDirectLinkResponse, error) {
	rsp, err := c.CreateDirectLink(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDirectLinkResponse(rsp)
}

// DeleteDirectLinkWithResponse request returning *DeleteDirectLinkResponse
func (c *ClientWithResponses) DeleteDirectLinkWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteDirectLinkResponse, error) {
	rsp, err := c.DeleteDirectLink(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDirectLinkResponse(rsp)
}

// ReadDirectLinksByIdWithResponse request returning *ReadDirectLinksByIdResponse
func (c *ClientWithResponses) ReadDirectLinksByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadDirectLinksByIdResponse, error) {
	rsp, err := c.ReadDirectLinksById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadDirectLinksByIdResponse(rsp)
}

// ReadFlexibleGpuCatalogWithResponse request returning *ReadFlexibleGpuCatalogResponse
func (c *ClientWithResponses) ReadFlexibleGpuCatalogWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*ReadFlexibleGpuCatalogResponse, error) {
	rsp, err := c.ReadFlexibleGpuCatalog(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadFlexibleGpuCatalogResponse(rsp)
}

// ReadFlexibleGpusWithResponse request returning *ReadFlexibleGpusResponse
func (c *ClientWithResponses) ReadFlexibleGpusWithResponse(ctx context.Context, spaceId SpaceId, params *ReadFlexibleGpusParams, reqEditors ...RequestEditorFn) (*ReadFlexibleGpusResponse, error) {
	rsp, err := c.ReadFlexibleGpus(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadFlexibleGpusResponse(rsp)
}

// CreateFlexibleGpuWithBodyWithResponse request with arbitrary body returning *CreateFlexibleGpuResponse
func (c *ClientWithResponses) CreateFlexibleGpuWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFlexibleGpuResponse, error) {
	rsp, err := c.CreateFlexibleGpuWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFlexibleGpuResponse(rsp)
}

func (c *ClientWithResponses) CreateFlexibleGpuWithResponse(ctx context.Context, spaceId SpaceId, body CreateFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFlexibleGpuResponse, error) {
	rsp, err := c.CreateFlexibleGpu(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFlexibleGpuResponse(rsp)
}

// DeleteFlexibleGpuWithResponse request returning *DeleteFlexibleGpuResponse
func (c *ClientWithResponses) DeleteFlexibleGpuWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteFlexibleGpuResponse, error) {
	rsp, err := c.DeleteFlexibleGpu(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFlexibleGpuResponse(rsp)
}

// ReadFlexibleGpusByIdWithResponse request returning *ReadFlexibleGpusByIdResponse
func (c *ClientWithResponses) ReadFlexibleGpusByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadFlexibleGpusByIdResponse, error) {
	rsp, err := c.ReadFlexibleGpusById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadFlexibleGpusByIdResponse(rsp)
}

// UpdateFlexibleGpuWithBodyWithResponse request with arbitrary body returning *UpdateFlexibleGpuResponse
func (c *ClientWithResponses) UpdateFlexibleGpuWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFlexibleGpuResponse, error) {
	rsp, err := c.UpdateFlexibleGpuWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFlexibleGpuResponse(rsp)
}

func (c *ClientWithResponses) UpdateFlexibleGpuWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFlexibleGpuResponse, error) {
	rsp, err := c.UpdateFlexibleGpu(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFlexibleGpuResponse(rsp)
}

// LinkFlexibleGpuWithBodyWithResponse request with arbitrary body returning *LinkFlexibleGpuResponse
func (c *ClientWithResponses) LinkFlexibleGpuWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkFlexibleGpuResponse, error) {
	rsp, err := c.LinkFlexibleGpuWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkFlexibleGpuResponse(rsp)
}

func (c *ClientWithResponses) LinkFlexibleGpuWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkFlexibleGpuResponse, error) {
	rsp, err := c.LinkFlexibleGpu(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkFlexibleGpuResponse(rsp)
}

// UnlinkFlexibleGpuWithResponse request returning *UnlinkFlexibleGpuResponse
func (c *ClientWithResponses) UnlinkFlexibleGpuWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*UnlinkFlexibleGpuResponse, error) {
	rsp, err := c.UnlinkFlexibleGpu(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkFlexibleGpuResponse(rsp)
}

// ReadImagesWithResponse request returning *ReadImagesResponse
func (c *ClientWithResponses) ReadImagesWithResponse(ctx context.Context, spaceId SpaceId, params *ReadImagesParams, reqEditors ...RequestEditorFn) (*ReadImagesResponse, error) {
	rsp, err := c.ReadImages(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadImagesResponse(rsp)
}

// CreateImageWithBodyWithResponse request with arbitrary body returning *CreateImageResponse
func (c *ClientWithResponses) CreateImageWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateImageResponse, error) {
	rsp, err := c.CreateImageWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateImageResponse(rsp)
}

func (c *ClientWithResponses) CreateImageWithResponse(ctx context.Context, spaceId SpaceId, body CreateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateImageResponse, error) {
	rsp, err := c.CreateImage(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateImageResponse(rsp)
}

// DeleteImageWithResponse request returning *DeleteImageResponse
func (c *ClientWithResponses) DeleteImageWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteImageResponse, error) {
	rsp, err := c.DeleteImage(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteImageResponse(rsp)
}

// ReadImagesByIdWithResponse request returning *ReadImagesByIdResponse
func (c *ClientWithResponses) ReadImagesByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadImagesByIdResponse, error) {
	rsp, err := c.ReadImagesById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadImagesByIdResponse(rsp)
}

// UpdateImageWithBodyWithResponse request with arbitrary body returning *UpdateImageResponse
func (c *ClientWithResponses) UpdateImageWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateImageResponse, error) {
	rsp, err := c.UpdateImageWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateImageResponse(rsp)
}

func (c *ClientWithResponses) UpdateImageWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateImageResponse, error) {
	rsp, err := c.UpdateImage(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateImageResponse(rsp)
}

// ReadInternetGatewaysWithResponse request returning *ReadInternetGatewaysResponse
func (c *ClientWithResponses) ReadInternetGatewaysWithResponse(ctx context.Context, spaceId SpaceId, params *ReadInternetGatewaysParams, reqEditors ...RequestEditorFn) (*ReadInternetGatewaysResponse, error) {
	rsp, err := c.ReadInternetGateways(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadInternetGatewaysResponse(rsp)
}

// CreateInternetGatewayWithResponse request returning *CreateInternetGatewayResponse
func (c *ClientWithResponses) CreateInternetGatewayWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*CreateInternetGatewayResponse, error) {
	rsp, err := c.CreateInternetGateway(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateInternetGatewayResponse(rsp)
}

// DeleteInternetGatewayWithResponse request returning *DeleteInternetGatewayResponse
func (c *ClientWithResponses) DeleteInternetGatewayWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteInternetGatewayResponse, error) {
	rsp, err := c.DeleteInternetGateway(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInternetGatewayResponse(rsp)
}

// ReadInternetGatewaysByIdWithResponse request returning *ReadInternetGatewaysByIdResponse
func (c *ClientWithResponses) ReadInternetGatewaysByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadInternetGatewaysByIdResponse, error) {
	rsp, err := c.ReadInternetGatewaysById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadInternetGatewaysByIdResponse(rsp)
}

// LinkInternetGatewayWithBodyWithResponse request with arbitrary body returning *LinkInternetGatewayResponse
func (c *ClientWithResponses) LinkInternetGatewayWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkInternetGatewayResponse, error) {
	rsp, err := c.LinkInternetGatewayWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkInternetGatewayResponse(rsp)
}

func (c *ClientWithResponses) LinkInternetGatewayWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkInternetGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkInternetGatewayResponse, error) {
	rsp, err := c.LinkInternetGateway(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkInternetGatewayResponse(rsp)
}

// UnlinkInternetGatewayWithBodyWithResponse request with arbitrary body returning *UnlinkInternetGatewayResponse
func (c *ClientWithResponses) UnlinkInternetGatewayWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkInternetGatewayResponse, error) {
	rsp, err := c.UnlinkInternetGatewayWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkInternetGatewayResponse(rsp)
}

func (c *ClientWithResponses) UnlinkInternetGatewayWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkInternetGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkInternetGatewayResponse, error) {
	rsp, err := c.UnlinkInternetGateway(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkInternetGatewayResponse(rsp)
}

// ReadKeypairsWithResponse request returning *ReadKeypairsResponse
func (c *ClientWithResponses) ReadKeypairsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadKeypairsParams, reqEditors ...RequestEditorFn) (*ReadKeypairsResponse, error) {
	rsp, err := c.ReadKeypairs(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadKeypairsResponse(rsp)
}

// CreateKeypairWithBodyWithResponse request with arbitrary body returning *CreateKeypairResponse
func (c *ClientWithResponses) CreateKeypairWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeypairResponse, error) {
	rsp, err := c.CreateKeypairWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeypairResponse(rsp)
}

func (c *ClientWithResponses) CreateKeypairWithResponse(ctx context.Context, spaceId SpaceId, body CreateKeypairJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeypairResponse, error) {
	rsp, err := c.CreateKeypair(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeypairResponse(rsp)
}

// DeleteKeypairWithResponse request returning *DeleteKeypairResponse
func (c *ClientWithResponses) DeleteKeypairWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteKeypairResponse, error) {
	rsp, err := c.DeleteKeypair(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteKeypairResponse(rsp)
}

// ReadKeypairsByIdWithResponse request returning *ReadKeypairsByIdResponse
func (c *ClientWithResponses) ReadKeypairsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadKeypairsByIdResponse, error) {
	rsp, err := c.ReadKeypairsById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadKeypairsByIdResponse(rsp)
}

// ReadListenerRulesWithResponse request returning *ReadListenerRulesResponse
func (c *ClientWithResponses) ReadListenerRulesWithResponse(ctx context.Context, spaceId SpaceId, params *ReadListenerRulesParams, reqEditors ...RequestEditorFn) (*ReadListenerRulesResponse, error) {
	rsp, err := c.ReadListenerRules(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadListenerRulesResponse(rsp)
}

// CreateListenerRuleWithBodyWithResponse request with arbitrary body returning *CreateListenerRuleResponse
func (c *ClientWithResponses) CreateListenerRuleWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateListenerRuleResponse, error) {
	rsp, err := c.CreateListenerRuleWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateListenerRuleResponse(rsp)
}

func (c *ClientWithResponses) CreateListenerRuleWithResponse(ctx context.Context, spaceId SpaceId, body CreateListenerRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateListenerRuleResponse, error) {
	rsp, err := c.CreateListenerRule(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateListenerRuleResponse(rsp)
}

// DeleteListenerRuleWithResponse request returning *DeleteListenerRuleResponse
func (c *ClientWithResponses) DeleteListenerRuleWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteListenerRuleResponse, error) {
	rsp, err := c.DeleteListenerRule(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteListenerRuleResponse(rsp)
}

// ReadListenerRulesByIdWithResponse request returning *ReadListenerRulesByIdResponse
func (c *ClientWithResponses) ReadListenerRulesByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadListenerRulesByIdResponse, error) {
	rsp, err := c.ReadListenerRulesById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadListenerRulesByIdResponse(rsp)
}

// UpdateListenerRuleWithBodyWithResponse request with arbitrary body returning *UpdateListenerRuleResponse
func (c *ClientWithResponses) UpdateListenerRuleWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateListenerRuleResponse, error) {
	rsp, err := c.UpdateListenerRuleWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateListenerRuleResponse(rsp)
}

func (c *ClientWithResponses) UpdateListenerRuleWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateListenerRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateListenerRuleResponse, error) {
	rsp, err := c.UpdateListenerRule(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateListenerRuleResponse(rsp)
}

// ReadLoadBalancersWithResponse request returning *ReadLoadBalancersResponse
func (c *ClientWithResponses) ReadLoadBalancersWithResponse(ctx context.Context, spaceId SpaceId, params *ReadLoadBalancersParams, reqEditors ...RequestEditorFn) (*ReadLoadBalancersResponse, error) {
	rsp, err := c.ReadLoadBalancers(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadLoadBalancersResponse(rsp)
}

// CreateLoadBalancerWithBodyWithResponse request with arbitrary body returning *CreateLoadBalancerResponse
func (c *ClientWithResponses) CreateLoadBalancerWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLoadBalancerResponse, error) {
	rsp, err := c.CreateLoadBalancerWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLoadBalancerResponse(rsp)
}

func (c *ClientWithResponses) CreateLoadBalancerWithResponse(ctx context.Context, spaceId SpaceId, body CreateLoadBalancerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLoadBalancerResponse, error) {
	rsp, err := c.CreateLoadBalancer(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLoadBalancerResponse(rsp)
}

// DeleteLoadBalancerWithResponse request returning *DeleteLoadBalancerResponse
func (c *ClientWithResponses) DeleteLoadBalancerWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerResponse, error) {
	rsp, err := c.DeleteLoadBalancer(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLoadBalancerResponse(rsp)
}

// ReadLoadBalancersByIdWithResponse request returning *ReadLoadBalancersByIdResponse
func (c *ClientWithResponses) ReadLoadBalancersByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadLoadBalancersByIdResponse, error) {
	rsp, err := c.ReadLoadBalancersById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadLoadBalancersByIdResponse(rsp)
}

// UpdateLoadBalancerWithBodyWithResponse request with arbitrary body returning *UpdateLoadBalancerResponse
func (c *ClientWithResponses) UpdateLoadBalancerWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLoadBalancerResponse, error) {
	rsp, err := c.UpdateLoadBalancerWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLoadBalancerResponse(rsp)
}

func (c *ClientWithResponses) UpdateLoadBalancerWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateLoadBalancerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLoadBalancerResponse, error) {
	rsp, err := c.UpdateLoadBalancer(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLoadBalancerResponse(rsp)
}

// LinkLoadBalancerBackendMachinesWithBodyWithResponse request with arbitrary body returning *LinkLoadBalancerBackendMachinesResponse
func (c *ClientWithResponses) LinkLoadBalancerBackendMachinesWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkLoadBalancerBackendMachinesResponse, error) {
	rsp, err := c.LinkLoadBalancerBackendMachinesWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkLoadBalancerBackendMachinesResponse(rsp)
}

func (c *ClientWithResponses) LinkLoadBalancerBackendMachinesWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkLoadBalancerBackendMachinesJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkLoadBalancerBackendMachinesResponse, error) {
	rsp, err := c.LinkLoadBalancerBackendMachines(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkLoadBalancerBackendMachinesResponse(rsp)
}

// UnlinkLoadBalancerBackendMachinesWithBodyWithResponse request with arbitrary body returning *UnlinkLoadBalancerBackendMachinesResponse
func (c *ClientWithResponses) UnlinkLoadBalancerBackendMachinesWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkLoadBalancerBackendMachinesResponse, error) {
	rsp, err := c.UnlinkLoadBalancerBackendMachinesWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkLoadBalancerBackendMachinesResponse(rsp)
}

func (c *ClientWithResponses) UnlinkLoadBalancerBackendMachinesWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkLoadBalancerBackendMachinesJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkLoadBalancerBackendMachinesResponse, error) {
	rsp, err := c.UnlinkLoadBalancerBackendMachines(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkLoadBalancerBackendMachinesResponse(rsp)
}

// DeleteLoadBalancerListenersWithBodyWithResponse request with arbitrary body returning *DeleteLoadBalancerListenersResponse
func (c *ClientWithResponses) DeleteLoadBalancerListenersWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerListenersResponse, error) {
	rsp, err := c.DeleteLoadBalancerListenersWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLoadBalancerListenersResponse(rsp)
}

func (c *ClientWithResponses) DeleteLoadBalancerListenersWithResponse(ctx context.Context, spaceId SpaceId, id string, body DeleteLoadBalancerListenersJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerListenersResponse, error) {
	rsp, err := c.DeleteLoadBalancerListeners(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLoadBalancerListenersResponse(rsp)
}

// CreateLoadBalancerListenersWithBodyWithResponse request with arbitrary body returning *CreateLoadBalancerListenersResponse
func (c *ClientWithResponses) CreateLoadBalancerListenersWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLoadBalancerListenersResponse, error) {
	rsp, err := c.CreateLoadBalancerListenersWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLoadBalancerListenersResponse(rsp)
}

func (c *ClientWithResponses) CreateLoadBalancerListenersWithResponse(ctx context.Context, spaceId SpaceId, id string, body CreateLoadBalancerListenersJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLoadBalancerListenersResponse, error) {
	rsp, err := c.CreateLoadBalancerListeners(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLoadBalancerListenersResponse(rsp)
}

// DeleteLoadBalancerPolicyWithBodyWithResponse request with arbitrary body returning *DeleteLoadBalancerPolicyResponse
func (c *ClientWithResponses) DeleteLoadBalancerPolicyWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerPolicyResponse, error) {
	rsp, err := c.DeleteLoadBalancerPolicyWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLoadBalancerPolicyResponse(rsp)
}

func (c *ClientWithResponses) DeleteLoadBalancerPolicyWithResponse(ctx context.Context, spaceId SpaceId, id string, body DeleteLoadBalancerPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerPolicyResponse, error) {
	rsp, err := c.DeleteLoadBalancerPolicy(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLoadBalancerPolicyResponse(rsp)
}

// CreateLoadBalancerPolicyWithBodyWithResponse request with arbitrary body returning *CreateLoadBalancerPolicyResponse
func (c *ClientWithResponses) CreateLoadBalancerPolicyWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLoadBalancerPolicyResponse, error) {
	rsp, err := c.CreateLoadBalancerPolicyWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLoadBalancerPolicyResponse(rsp)
}

func (c *ClientWithResponses) CreateLoadBalancerPolicyWithResponse(ctx context.Context, spaceId SpaceId, id string, body CreateLoadBalancerPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLoadBalancerPolicyResponse, error) {
	rsp, err := c.CreateLoadBalancerPolicy(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLoadBalancerPolicyResponse(rsp)
}

// ReadVmsHealthWithBodyWithResponse request with arbitrary body returning *ReadVmsHealthResponse
func (c *ClientWithResponses) ReadVmsHealthWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReadVmsHealthResponse, error) {
	rsp, err := c.ReadVmsHealthWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVmsHealthResponse(rsp)
}

func (c *ClientWithResponses) ReadVmsHealthWithResponse(ctx context.Context, spaceId SpaceId, id string, body ReadVmsHealthJSONRequestBody, reqEditors ...RequestEditorFn) (*ReadVmsHealthResponse, error) {
	rsp, err := c.ReadVmsHealth(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVmsHealthResponse(rsp)
}

// ReadLoadBalancerTagsWithBodyWithResponse request with arbitrary body returning *ReadLoadBalancerTagsResponse
func (c *ClientWithResponses) ReadLoadBalancerTagsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReadLoadBalancerTagsResponse, error) {
	rsp, err := c.ReadLoadBalancerTagsWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadLoadBalancerTagsResponse(rsp)
}

func (c *ClientWithResponses) ReadLoadBalancerTagsWithResponse(ctx context.Context, spaceId SpaceId, body ReadLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReadLoadBalancerTagsResponse, error) {
	rsp, err := c.ReadLoadBalancerTags(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadLoadBalancerTagsResponse(rsp)
}

// ReadLocationsWithResponse request returning *ReadLocationsResponse
func (c *ClientWithResponses) ReadLocationsWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*ReadLocationsResponse, error) {
	rsp, err := c.ReadLocations(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadLocationsResponse(rsp)
}

// ReadNatGatewayWithResponse request returning *ReadNatGatewayResponse
func (c *ClientWithResponses) ReadNatGatewayWithResponse(ctx context.Context, spaceId SpaceId, params *ReadNatGatewayParams, reqEditors ...RequestEditorFn) (*ReadNatGatewayResponse, error) {
	rsp, err := c.ReadNatGateway(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadNatGatewayResponse(rsp)
}

// CreateNatGatewayWithBodyWithResponse request with arbitrary body returning *CreateNatGatewayResponse
func (c *ClientWithResponses) CreateNatGatewayWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNatGatewayResponse, error) {
	rsp, err := c.CreateNatGatewayWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNatGatewayResponse(rsp)
}

func (c *ClientWithResponses) CreateNatGatewayWithResponse(ctx context.Context, spaceId SpaceId, body CreateNatGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNatGatewayResponse, error) {
	rsp, err := c.CreateNatGateway(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNatGatewayResponse(rsp)
}

// DeleteNatGatewayWithResponse request returning *DeleteNatGatewayResponse
func (c *ClientWithResponses) DeleteNatGatewayWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteNatGatewayResponse, error) {
	rsp, err := c.DeleteNatGateway(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNatGatewayResponse(rsp)
}

// ReadNatGatewayByIdWithResponse request returning *ReadNatGatewayByIdResponse
func (c *ClientWithResponses) ReadNatGatewayByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadNatGatewayByIdResponse, error) {
	rsp, err := c.ReadNatGatewayById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadNatGatewayByIdResponse(rsp)
}

// ReadNicsWithResponse request returning *ReadNicsResponse
func (c *ClientWithResponses) ReadNicsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadNicsParams, reqEditors ...RequestEditorFn) (*ReadNicsResponse, error) {
	rsp, err := c.ReadNics(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadNicsResponse(rsp)
}

// CreateNicWithBodyWithResponse request with arbitrary body returning *CreateNicResponse
func (c *ClientWithResponses) CreateNicWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNicResponse, error) {
	rsp, err := c.CreateNicWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNicResponse(rsp)
}

func (c *ClientWithResponses) CreateNicWithResponse(ctx context.Context, spaceId SpaceId, body CreateNicJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNicResponse, error) {
	rsp, err := c.CreateNic(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNicResponse(rsp)
}

// DeleteNicWithResponse request returning *DeleteNicResponse
func (c *ClientWithResponses) DeleteNicWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteNicResponse, error) {
	rsp, err := c.DeleteNic(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNicResponse(rsp)
}

// ReadNicsByIdWithResponse request returning *ReadNicsByIdResponse
func (c *ClientWithResponses) ReadNicsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadNicsByIdResponse, error) {
	rsp, err := c.ReadNicsById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadNicsByIdResponse(rsp)
}

// UpdateNicWithBodyWithResponse request with arbitrary body returning *UpdateNicResponse
func (c *ClientWithResponses) UpdateNicWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNicResponse, error) {
	rsp, err := c.UpdateNicWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNicResponse(rsp)
}

func (c *ClientWithResponses) UpdateNicWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateNicJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNicResponse, error) {
	rsp, err := c.UpdateNic(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNicResponse(rsp)
}

// LinkPrivateIpsWithBodyWithResponse request with arbitrary body returning *LinkPrivateIpsResponse
func (c *ClientWithResponses) LinkPrivateIpsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkPrivateIpsResponse, error) {
	rsp, err := c.LinkPrivateIpsWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkPrivateIpsResponse(rsp)
}

func (c *ClientWithResponses) LinkPrivateIpsWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkPrivateIpsJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkPrivateIpsResponse, error) {
	rsp, err := c.LinkPrivateIps(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkPrivateIpsResponse(rsp)
}

// UnlinkPrivateIpsWithBodyWithResponse request with arbitrary body returning *UnlinkPrivateIpsResponse
func (c *ClientWithResponses) UnlinkPrivateIpsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkPrivateIpsResponse, error) {
	rsp, err := c.UnlinkPrivateIpsWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkPrivateIpsResponse(rsp)
}

func (c *ClientWithResponses) UnlinkPrivateIpsWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkPrivateIpsJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkPrivateIpsResponse, error) {
	rsp, err := c.UnlinkPrivateIps(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkPrivateIpsResponse(rsp)
}

// LinkNicWithBodyWithResponse request with arbitrary body returning *LinkNicResponse
func (c *ClientWithResponses) LinkNicWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkNicResponse, error) {
	rsp, err := c.LinkNicWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkNicResponse(rsp)
}

func (c *ClientWithResponses) LinkNicWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkNicJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkNicResponse, error) {
	rsp, err := c.LinkNic(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkNicResponse(rsp)
}

// UnlinkNicWithBodyWithResponse request with arbitrary body returning *UnlinkNicResponse
func (c *ClientWithResponses) UnlinkNicWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkNicResponse, error) {
	rsp, err := c.UnlinkNicWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkNicResponse(rsp)
}

func (c *ClientWithResponses) UnlinkNicWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkNicJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkNicResponse, error) {
	rsp, err := c.UnlinkNic(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkNicResponse(rsp)
}

// ReadProductTypesWithResponse request returning *ReadProductTypesResponse
func (c *ClientWithResponses) ReadProductTypesWithResponse(ctx context.Context, spaceId SpaceId, params *ReadProductTypesParams, reqEditors ...RequestEditorFn) (*ReadProductTypesResponse, error) {
	rsp, err := c.ReadProductTypes(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadProductTypesResponse(rsp)
}

// ReadProductTypesByIdWithResponse request returning *ReadProductTypesByIdResponse
func (c *ClientWithResponses) ReadProductTypesByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadProductTypesByIdResponse, error) {
	rsp, err := c.ReadProductTypesById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadProductTypesByIdResponse(rsp)
}

// ReadPublicIpRangesWithResponse request returning *ReadPublicIpRangesResponse
func (c *ClientWithResponses) ReadPublicIpRangesWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*ReadPublicIpRangesResponse, error) {
	rsp, err := c.ReadPublicIpRanges(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadPublicIpRangesResponse(rsp)
}

// ReadPublicIpsWithResponse request returning *ReadPublicIpsResponse
func (c *ClientWithResponses) ReadPublicIpsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadPublicIpsParams, reqEditors ...RequestEditorFn) (*ReadPublicIpsResponse, error) {
	rsp, err := c.ReadPublicIps(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadPublicIpsResponse(rsp)
}

// CreatePublicIpWithResponse request returning *CreatePublicIpResponse
func (c *ClientWithResponses) CreatePublicIpWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*CreatePublicIpResponse, error) {
	rsp, err := c.CreatePublicIp(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePublicIpResponse(rsp)
}

// DeletePublicIpWithResponse request returning *DeletePublicIpResponse
func (c *ClientWithResponses) DeletePublicIpWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeletePublicIpResponse, error) {
	rsp, err := c.DeletePublicIp(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePublicIpResponse(rsp)
}

// ReadPublicIpsByIdWithResponse request returning *ReadPublicIpsByIdResponse
func (c *ClientWithResponses) ReadPublicIpsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadPublicIpsByIdResponse, error) {
	rsp, err := c.ReadPublicIpsById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadPublicIpsByIdResponse(rsp)
}

// LinkPublicIpWithBodyWithResponse request with arbitrary body returning *LinkPublicIpResponse
func (c *ClientWithResponses) LinkPublicIpWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkPublicIpResponse, error) {
	rsp, err := c.LinkPublicIpWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkPublicIpResponse(rsp)
}

func (c *ClientWithResponses) LinkPublicIpWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkPublicIpJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkPublicIpResponse, error) {
	rsp, err := c.LinkPublicIp(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkPublicIpResponse(rsp)
}

// UnlinkPublicIpWithBodyWithResponse request with arbitrary body returning *UnlinkPublicIpResponse
func (c *ClientWithResponses) UnlinkPublicIpWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkPublicIpResponse, error) {
	rsp, err := c.UnlinkPublicIpWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkPublicIpResponse(rsp)
}

func (c *ClientWithResponses) UnlinkPublicIpWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkPublicIpJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkPublicIpResponse, error) {
	rsp, err := c.UnlinkPublicIp(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkPublicIpResponse(rsp)
}

// ReadRouteTablesWithResponse request returning *ReadRouteTablesResponse
func (c *ClientWithResponses) ReadRouteTablesWithResponse(ctx context.Context, spaceId SpaceId, params *ReadRouteTablesParams, reqEditors ...RequestEditorFn) (*ReadRouteTablesResponse, error) {
	rsp, err := c.ReadRouteTables(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadRouteTablesResponse(rsp)
}

// CreateRouteTableWithBodyWithResponse request with arbitrary body returning *CreateRouteTableResponse
func (c *ClientWithResponses) CreateRouteTableWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRouteTableResponse, error) {
	rsp, err := c.CreateRouteTableWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRouteTableResponse(rsp)
}

func (c *ClientWithResponses) CreateRouteTableWithResponse(ctx context.Context, spaceId SpaceId, body CreateRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRouteTableResponse, error) {
	rsp, err := c.CreateRouteTable(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRouteTableResponse(rsp)
}

// DeleteRouteTableWithResponse request returning *DeleteRouteTableResponse
func (c *ClientWithResponses) DeleteRouteTableWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteRouteTableResponse, error) {
	rsp, err := c.DeleteRouteTable(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRouteTableResponse(rsp)
}

// ReadRouteTablesByIdWithResponse request returning *ReadRouteTablesByIdResponse
func (c *ClientWithResponses) ReadRouteTablesByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadRouteTablesByIdResponse, error) {
	rsp, err := c.ReadRouteTablesById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadRouteTablesByIdResponse(rsp)
}

// UpdateRouteTableRoutePropagationWithBodyWithResponse request with arbitrary body returning *UpdateRouteTableRoutePropagationResponse
func (c *ClientWithResponses) UpdateRouteTableRoutePropagationWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRouteTableRoutePropagationResponse, error) {
	rsp, err := c.UpdateRouteTableRoutePropagationWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRouteTableRoutePropagationResponse(rsp)
}

func (c *ClientWithResponses) UpdateRouteTableRoutePropagationWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateRouteTableRoutePropagationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRouteTableRoutePropagationResponse, error) {
	rsp, err := c.UpdateRouteTableRoutePropagation(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRouteTableRoutePropagationResponse(rsp)
}

// DeleteRouteWithBodyWithResponse request with arbitrary body returning *DeleteRouteResponse
func (c *ClientWithResponses) DeleteRouteWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteRouteResponse, error) {
	rsp, err := c.DeleteRouteWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRouteResponse(rsp)
}

func (c *ClientWithResponses) DeleteRouteWithResponse(ctx context.Context, spaceId SpaceId, id string, body DeleteRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteRouteResponse, error) {
	rsp, err := c.DeleteRoute(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRouteResponse(rsp)
}

// CreateRouteWithBodyWithResponse request with arbitrary body returning *CreateRouteResponse
func (c *ClientWithResponses) CreateRouteWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRouteResponse, error) {
	rsp, err := c.CreateRouteWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRouteResponse(rsp)
}

func (c *ClientWithResponses) CreateRouteWithResponse(ctx context.Context, spaceId SpaceId, id string, body CreateRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRouteResponse, error) {
	rsp, err := c.CreateRoute(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRouteResponse(rsp)
}

// UpdateRouteWithBodyWithResponse request with arbitrary body returning *UpdateRouteResponse
func (c *ClientWithResponses) UpdateRouteWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRouteResponse, error) {
	rsp, err := c.UpdateRouteWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRouteResponse(rsp)
}

func (c *ClientWithResponses) UpdateRouteWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRouteResponse, error) {
	rsp, err := c.UpdateRoute(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRouteResponse(rsp)
}

// LinkRouteTableWithBodyWithResponse request with arbitrary body returning *LinkRouteTableResponse
func (c *ClientWithResponses) LinkRouteTableWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkRouteTableResponse, error) {
	rsp, err := c.LinkRouteTableWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkRouteTableResponse(rsp)
}

func (c *ClientWithResponses) LinkRouteTableWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkRouteTableResponse, error) {
	rsp, err := c.LinkRouteTable(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkRouteTableResponse(rsp)
}

// UnlinkRouteTableWithBodyWithResponse request with arbitrary body returning *UnlinkRouteTableResponse
func (c *ClientWithResponses) UnlinkRouteTableWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkRouteTableResponse, error) {
	rsp, err := c.UnlinkRouteTableWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkRouteTableResponse(rsp)
}

func (c *ClientWithResponses) UnlinkRouteTableWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkRouteTableResponse, error) {
	rsp, err := c.UnlinkRouteTable(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkRouteTableResponse(rsp)
}

// ReadSecurityGroupsWithResponse request returning *ReadSecurityGroupsResponse
func (c *ClientWithResponses) ReadSecurityGroupsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadSecurityGroupsParams, reqEditors ...RequestEditorFn) (*ReadSecurityGroupsResponse, error) {
	rsp, err := c.ReadSecurityGroups(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadSecurityGroupsResponse(rsp)
}

// CreateSecurityGroupWithBodyWithResponse request with arbitrary body returning *CreateSecurityGroupResponse
func (c *ClientWithResponses) CreateSecurityGroupWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSecurityGroupResponse, error) {
	rsp, err := c.CreateSecurityGroupWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSecurityGroupResponse(rsp)
}

func (c *ClientWithResponses) CreateSecurityGroupWithResponse(ctx context.Context, spaceId SpaceId, body CreateSecurityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSecurityGroupResponse, error) {
	rsp, err := c.CreateSecurityGroup(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSecurityGroupResponse(rsp)
}

// DeleteSecurityGroupWithResponse request returning *DeleteSecurityGroupResponse
func (c *ClientWithResponses) DeleteSecurityGroupWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteSecurityGroupResponse, error) {
	rsp, err := c.DeleteSecurityGroup(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSecurityGroupResponse(rsp)
}

// ReadSecurityGroupsByIdWithResponse request returning *ReadSecurityGroupsByIdResponse
func (c *ClientWithResponses) ReadSecurityGroupsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadSecurityGroupsByIdResponse, error) {
	rsp, err := c.ReadSecurityGroupsById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadSecurityGroupsByIdResponse(rsp)
}

// DeleteSecurityGroupRuleWithBodyWithResponse request with arbitrary body returning *DeleteSecurityGroupRuleResponse
func (c *ClientWithResponses) DeleteSecurityGroupRuleWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteSecurityGroupRuleResponse, error) {
	rsp, err := c.DeleteSecurityGroupRuleWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSecurityGroupRuleResponse(rsp)
}

func (c *ClientWithResponses) DeleteSecurityGroupRuleWithResponse(ctx context.Context, spaceId SpaceId, id string, body DeleteSecurityGroupRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteSecurityGroupRuleResponse, error) {
	rsp, err := c.DeleteSecurityGroupRule(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSecurityGroupRuleResponse(rsp)
}

// CreateSecurityGroupRuleWithBodyWithResponse request with arbitrary body returning *CreateSecurityGroupRuleResponse
func (c *ClientWithResponses) CreateSecurityGroupRuleWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSecurityGroupRuleResponse, error) {
	rsp, err := c.CreateSecurityGroupRuleWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSecurityGroupRuleResponse(rsp)
}

func (c *ClientWithResponses) CreateSecurityGroupRuleWithResponse(ctx context.Context, spaceId SpaceId, id string, body CreateSecurityGroupRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSecurityGroupRuleResponse, error) {
	rsp, err := c.CreateSecurityGroupRule(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSecurityGroupRuleResponse(rsp)
}

// ReadSnapshotsWithResponse request returning *ReadSnapshotsResponse
func (c *ClientWithResponses) ReadSnapshotsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadSnapshotsParams, reqEditors ...RequestEditorFn) (*ReadSnapshotsResponse, error) {
	rsp, err := c.ReadSnapshots(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadSnapshotsResponse(rsp)
}

// CreateSnapshotWithBodyWithResponse request with arbitrary body returning *CreateSnapshotResponse
func (c *ClientWithResponses) CreateSnapshotWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSnapshotResponse, error) {
	rsp, err := c.CreateSnapshotWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSnapshotResponse(rsp)
}

func (c *ClientWithResponses) CreateSnapshotWithResponse(ctx context.Context, spaceId SpaceId, body CreateSnapshotJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSnapshotResponse, error) {
	rsp, err := c.CreateSnapshot(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSnapshotResponse(rsp)
}

// DeleteSnapshotWithResponse request returning *DeleteSnapshotResponse
func (c *ClientWithResponses) DeleteSnapshotWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteSnapshotResponse, error) {
	rsp, err := c.DeleteSnapshot(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSnapshotResponse(rsp)
}

// ReadSnapshotsByIdWithResponse request returning *ReadSnapshotsByIdResponse
func (c *ClientWithResponses) ReadSnapshotsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadSnapshotsByIdResponse, error) {
	rsp, err := c.ReadSnapshotsById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadSnapshotsByIdResponse(rsp)
}

// ReadSubnetsWithResponse request returning *ReadSubnetsResponse
func (c *ClientWithResponses) ReadSubnetsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadSubnetsParams, reqEditors ...RequestEditorFn) (*ReadSubnetsResponse, error) {
	rsp, err := c.ReadSubnets(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadSubnetsResponse(rsp)
}

// CreateSubnetWithBodyWithResponse request with arbitrary body returning *CreateSubnetResponse
func (c *ClientWithResponses) CreateSubnetWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSubnetResponse, error) {
	rsp, err := c.CreateSubnetWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSubnetResponse(rsp)
}

func (c *ClientWithResponses) CreateSubnetWithResponse(ctx context.Context, spaceId SpaceId, body CreateSubnetJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSubnetResponse, error) {
	rsp, err := c.CreateSubnet(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSubnetResponse(rsp)
}

// DeleteSubnetWithResponse request returning *DeleteSubnetResponse
func (c *ClientWithResponses) DeleteSubnetWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteSubnetResponse, error) {
	rsp, err := c.DeleteSubnet(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSubnetResponse(rsp)
}

// ReadSubnetsByIdWithResponse request returning *ReadSubnetsByIdResponse
func (c *ClientWithResponses) ReadSubnetsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadSubnetsByIdResponse, error) {
	rsp, err := c.ReadSubnetsById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadSubnetsByIdResponse(rsp)
}

// UpdateSubnetWithBodyWithResponse request with arbitrary body returning *UpdateSubnetResponse
func (c *ClientWithResponses) UpdateSubnetWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSubnetResponse, error) {
	rsp, err := c.UpdateSubnetWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSubnetResponse(rsp)
}

func (c *ClientWithResponses) UpdateSubnetWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateSubnetJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSubnetResponse, error) {
	rsp, err := c.UpdateSubnet(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSubnetResponse(rsp)
}

// ReadTagsWithResponse request returning *ReadTagsResponse
func (c *ClientWithResponses) ReadTagsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadTagsParams, reqEditors ...RequestEditorFn) (*ReadTagsResponse, error) {
	rsp, err := c.ReadTags(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadTagsResponse(rsp)
}

// ReadVirtualGatewaysWithResponse request returning *ReadVirtualGatewaysResponse
func (c *ClientWithResponses) ReadVirtualGatewaysWithResponse(ctx context.Context, spaceId SpaceId, params *ReadVirtualGatewaysParams, reqEditors ...RequestEditorFn) (*ReadVirtualGatewaysResponse, error) {
	rsp, err := c.ReadVirtualGateways(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVirtualGatewaysResponse(rsp)
}

// CreateVirtualGatewayWithBodyWithResponse request with arbitrary body returning *CreateVirtualGatewayResponse
func (c *ClientWithResponses) CreateVirtualGatewayWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVirtualGatewayResponse, error) {
	rsp, err := c.CreateVirtualGatewayWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVirtualGatewayResponse(rsp)
}

func (c *ClientWithResponses) CreateVirtualGatewayWithResponse(ctx context.Context, spaceId SpaceId, body CreateVirtualGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVirtualGatewayResponse, error) {
	rsp, err := c.CreateVirtualGateway(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVirtualGatewayResponse(rsp)
}

// DeleteVirtualGatewayWithResponse request returning *DeleteVirtualGatewayResponse
func (c *ClientWithResponses) DeleteVirtualGatewayWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteVirtualGatewayResponse, error) {
	rsp, err := c.DeleteVirtualGateway(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVirtualGatewayResponse(rsp)
}

// ReadVirtualGatewaysByIdWithResponse request returning *ReadVirtualGatewaysByIdResponse
func (c *ClientWithResponses) ReadVirtualGatewaysByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadVirtualGatewaysByIdResponse, error) {
	rsp, err := c.ReadVirtualGatewaysById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVirtualGatewaysByIdResponse(rsp)
}

// LinkVirtualGatewayToVpcWithBodyWithResponse request with arbitrary body returning *LinkVirtualGatewayToVpcResponse
func (c *ClientWithResponses) LinkVirtualGatewayToVpcWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkVirtualGatewayToVpcResponse, error) {
	rsp, err := c.LinkVirtualGatewayToVpcWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkVirtualGatewayToVpcResponse(rsp)
}

func (c *ClientWithResponses) LinkVirtualGatewayToVpcWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkVirtualGatewayToVpcJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkVirtualGatewayToVpcResponse, error) {
	rsp, err := c.LinkVirtualGatewayToVpc(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkVirtualGatewayToVpcResponse(rsp)
}

// UnlinkVirtualGatewayToVpcWithBodyWithResponse request with arbitrary body returning *UnlinkVirtualGatewayToVpcResponse
func (c *ClientWithResponses) UnlinkVirtualGatewayToVpcWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkVirtualGatewayToVpcResponse, error) {
	rsp, err := c.UnlinkVirtualGatewayToVpcWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkVirtualGatewayToVpcResponse(rsp)
}

func (c *ClientWithResponses) UnlinkVirtualGatewayToVpcWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkVirtualGatewayToVpcJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkVirtualGatewayToVpcResponse, error) {
	rsp, err := c.UnlinkVirtualGatewayToVpc(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkVirtualGatewayToVpcResponse(rsp)
}

// ReadVmsWithResponse request returning *ReadVmsResponse
func (c *ClientWithResponses) ReadVmsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadVmsParams, reqEditors ...RequestEditorFn) (*ReadVmsResponse, error) {
	rsp, err := c.ReadVms(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVmsResponse(rsp)
}

// CreateVmsWithBodyWithResponse request with arbitrary body returning *CreateVmsResponse
func (c *ClientWithResponses) CreateVmsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVmsResponse, error) {
	rsp, err := c.CreateVmsWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVmsResponse(rsp)
}

func (c *ClientWithResponses) CreateVmsWithResponse(ctx context.Context, spaceId SpaceId, body CreateVmsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVmsResponse, error) {
	rsp, err := c.CreateVms(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVmsResponse(rsp)
}

// ReadVmsStateWithResponse request returning *ReadVmsStateResponse
func (c *ClientWithResponses) ReadVmsStateWithResponse(ctx context.Context, spaceId SpaceId, params *ReadVmsStateParams, reqEditors ...RequestEditorFn) (*ReadVmsStateResponse, error) {
	rsp, err := c.ReadVmsState(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVmsStateResponse(rsp)
}

// DeleteVmsWithResponse request returning *DeleteVmsResponse
func (c *ClientWithResponses) DeleteVmsWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteVmsResponse, error) {
	rsp, err := c.DeleteVms(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVmsResponse(rsp)
}

// ReadVmsByIdWithResponse request returning *ReadVmsByIdResponse
func (c *ClientWithResponses) ReadVmsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadVmsByIdResponse, error) {
	rsp, err := c.ReadVmsById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVmsByIdResponse(rsp)
}

// UpdateVmWithBodyWithResponse request with arbitrary body returning *UpdateVmResponse
func (c *ClientWithResponses) UpdateVmWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVmResponse, error) {
	rsp, err := c.UpdateVmWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVmResponse(rsp)
}

func (c *ClientWithResponses) UpdateVmWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateVmJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVmResponse, error) {
	rsp, err := c.UpdateVm(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVmResponse(rsp)
}

// ReadAdminPasswordWithResponse request returning *ReadAdminPasswordResponse
func (c *ClientWithResponses) ReadAdminPasswordWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadAdminPasswordResponse, error) {
	rsp, err := c.ReadAdminPassword(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadAdminPasswordResponse(rsp)
}

// ReadConsoleOutputWithResponse request returning *ReadConsoleOutputResponse
func (c *ClientWithResponses) ReadConsoleOutputWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadConsoleOutputResponse, error) {
	rsp, err := c.ReadConsoleOutput(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadConsoleOutputResponse(rsp)
}

// RebootVmWithResponse request returning *RebootVmResponse
func (c *ClientWithResponses) RebootVmWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*RebootVmResponse, error) {
	rsp, err := c.RebootVm(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRebootVmResponse(rsp)
}

// StartVmWithResponse request returning *StartVmResponse
func (c *ClientWithResponses) StartVmWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*StartVmResponse, error) {
	rsp, err := c.StartVm(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartVmResponse(rsp)
}

// StopVmWithBodyWithResponse request with arbitrary body returning *StopVmResponse
func (c *ClientWithResponses) StopVmWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StopVmResponse, error) {
	rsp, err := c.StopVmWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopVmResponse(rsp)
}

func (c *ClientWithResponses) StopVmWithResponse(ctx context.Context, spaceId SpaceId, id string, body StopVmJSONRequestBody, reqEditors ...RequestEditorFn) (*StopVmResponse, error) {
	rsp, err := c.StopVm(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopVmResponse(rsp)
}

// ReadVolumesWithResponse request returning *ReadVolumesResponse
func (c *ClientWithResponses) ReadVolumesWithResponse(ctx context.Context, spaceId SpaceId, params *ReadVolumesParams, reqEditors ...RequestEditorFn) (*ReadVolumesResponse, error) {
	rsp, err := c.ReadVolumes(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVolumesResponse(rsp)
}

// CreateVolumeWithBodyWithResponse request with arbitrary body returning *CreateVolumeResponse
func (c *ClientWithResponses) CreateVolumeWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVolumeResponse, error) {
	rsp, err := c.CreateVolumeWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVolumeResponse(rsp)
}

func (c *ClientWithResponses) CreateVolumeWithResponse(ctx context.Context, spaceId SpaceId, body CreateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVolumeResponse, error) {
	rsp, err := c.CreateVolume(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVolumeResponse(rsp)
}

// DeleteVolumeWithResponse request returning *DeleteVolumeResponse
func (c *ClientWithResponses) DeleteVolumeWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteVolumeResponse, error) {
	rsp, err := c.DeleteVolume(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVolumeResponse(rsp)
}

// ReadVolumesByIdWithResponse request returning *ReadVolumesByIdResponse
func (c *ClientWithResponses) ReadVolumesByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadVolumesByIdResponse, error) {
	rsp, err := c.ReadVolumesById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVolumesByIdResponse(rsp)
}

// UpdateVolumeWithBodyWithResponse request with arbitrary body returning *UpdateVolumeResponse
func (c *ClientWithResponses) UpdateVolumeWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVolumeResponse, error) {
	rsp, err := c.UpdateVolumeWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVolumeResponse(rsp)
}

func (c *ClientWithResponses) UpdateVolumeWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVolumeResponse, error) {
	rsp, err := c.UpdateVolume(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVolumeResponse(rsp)
}

// LinkVolumeWithBodyWithResponse request with arbitrary body returning *LinkVolumeResponse
func (c *ClientWithResponses) LinkVolumeWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkVolumeResponse, error) {
	rsp, err := c.LinkVolumeWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkVolumeResponse(rsp)
}

func (c *ClientWithResponses) LinkVolumeWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkVolumeResponse, error) {
	rsp, err := c.LinkVolume(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkVolumeResponse(rsp)
}

// UnlinkVolumeWithBodyWithResponse request with arbitrary body returning *UnlinkVolumeResponse
func (c *ClientWithResponses) UnlinkVolumeWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkVolumeResponse, error) {
	rsp, err := c.UnlinkVolumeWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkVolumeResponse(rsp)
}

func (c *ClientWithResponses) UnlinkVolumeWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkVolumeResponse, error) {
	rsp, err := c.UnlinkVolume(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkVolumeResponse(rsp)
}

// ReadVpcAccessPointsWithResponse request returning *ReadVpcAccessPointsResponse
func (c *ClientWithResponses) ReadVpcAccessPointsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadVpcAccessPointsParams, reqEditors ...RequestEditorFn) (*ReadVpcAccessPointsResponse, error) {
	rsp, err := c.ReadVpcAccessPoints(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVpcAccessPointsResponse(rsp)
}

// CreateVpcAccessPointWithBodyWithResponse request with arbitrary body returning *CreateVpcAccessPointResponse
func (c *ClientWithResponses) CreateVpcAccessPointWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVpcAccessPointResponse, error) {
	rsp, err := c.CreateVpcAccessPointWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVpcAccessPointResponse(rsp)
}

func (c *ClientWithResponses) CreateVpcAccessPointWithResponse(ctx context.Context, spaceId SpaceId, body CreateVpcAccessPointJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVpcAccessPointResponse, error) {
	rsp, err := c.CreateVpcAccessPoint(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVpcAccessPointResponse(rsp)
}

// DeleteVpcAccessPointWithResponse request returning *DeleteVpcAccessPointResponse
func (c *ClientWithResponses) DeleteVpcAccessPointWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteVpcAccessPointResponse, error) {
	rsp, err := c.DeleteVpcAccessPoint(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVpcAccessPointResponse(rsp)
}

// ReadVpcAccessPointsByIdWithResponse request returning *ReadVpcAccessPointsByIdResponse
func (c *ClientWithResponses) ReadVpcAccessPointsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadVpcAccessPointsByIdResponse, error) {
	rsp, err := c.ReadVpcAccessPointsById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVpcAccessPointsByIdResponse(rsp)
}

// UpdateVpcAccessPointWithBodyWithResponse request with arbitrary body returning *UpdateVpcAccessPointResponse
func (c *ClientWithResponses) UpdateVpcAccessPointWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVpcAccessPointResponse, error) {
	rsp, err := c.UpdateVpcAccessPointWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVpcAccessPointResponse(rsp)
}

func (c *ClientWithResponses) UpdateVpcAccessPointWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateVpcAccessPointJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVpcAccessPointResponse, error) {
	rsp, err := c.UpdateVpcAccessPoint(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVpcAccessPointResponse(rsp)
}

// ReadVpcPeeringsWithResponse request returning *ReadVpcPeeringsResponse
func (c *ClientWithResponses) ReadVpcPeeringsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadVpcPeeringsParams, reqEditors ...RequestEditorFn) (*ReadVpcPeeringsResponse, error) {
	rsp, err := c.ReadVpcPeerings(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVpcPeeringsResponse(rsp)
}

// CreateVpcPeeringWithBodyWithResponse request with arbitrary body returning *CreateVpcPeeringResponse
func (c *ClientWithResponses) CreateVpcPeeringWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVpcPeeringResponse, error) {
	rsp, err := c.CreateVpcPeeringWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVpcPeeringResponse(rsp)
}

func (c *ClientWithResponses) CreateVpcPeeringWithResponse(ctx context.Context, spaceId SpaceId, body CreateVpcPeeringJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVpcPeeringResponse, error) {
	rsp, err := c.CreateVpcPeering(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVpcPeeringResponse(rsp)
}

// DeleteVpcPeeringWithResponse request returning *DeleteVpcPeeringResponse
func (c *ClientWithResponses) DeleteVpcPeeringWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteVpcPeeringResponse, error) {
	rsp, err := c.DeleteVpcPeering(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVpcPeeringResponse(rsp)
}

// ReadVpcPeeringsByIdWithResponse request returning *ReadVpcPeeringsByIdResponse
func (c *ClientWithResponses) ReadVpcPeeringsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadVpcPeeringsByIdResponse, error) {
	rsp, err := c.ReadVpcPeeringsById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVpcPeeringsByIdResponse(rsp)
}

// AcceptVpcPeeringWithResponse request returning *AcceptVpcPeeringResponse
func (c *ClientWithResponses) AcceptVpcPeeringWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*AcceptVpcPeeringResponse, error) {
	rsp, err := c.AcceptVpcPeering(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcceptVpcPeeringResponse(rsp)
}

// RejectVpcPeeringWithResponse request returning *RejectVpcPeeringResponse
func (c *ClientWithResponses) RejectVpcPeeringWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*RejectVpcPeeringResponse, error) {
	rsp, err := c.RejectVpcPeering(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRejectVpcPeeringResponse(rsp)
}

// ReadVpcsWithResponse request returning *ReadVpcsResponse
func (c *ClientWithResponses) ReadVpcsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadVpcsParams, reqEditors ...RequestEditorFn) (*ReadVpcsResponse, error) {
	rsp, err := c.ReadVpcs(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVpcsResponse(rsp)
}

// CreateVpcWithBodyWithResponse request with arbitrary body returning *CreateVpcResponse
func (c *ClientWithResponses) CreateVpcWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVpcResponse, error) {
	rsp, err := c.CreateVpcWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVpcResponse(rsp)
}

func (c *ClientWithResponses) CreateVpcWithResponse(ctx context.Context, spaceId SpaceId, body CreateVpcJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVpcResponse, error) {
	rsp, err := c.CreateVpc(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVpcResponse(rsp)
}

// DeleteVpcWithResponse request returning *DeleteVpcResponse
func (c *ClientWithResponses) DeleteVpcWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteVpcResponse, error) {
	rsp, err := c.DeleteVpc(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVpcResponse(rsp)
}

// ReadVpcsByIdWithResponse request returning *ReadVpcsByIdResponse
func (c *ClientWithResponses) ReadVpcsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadVpcsByIdResponse, error) {
	rsp, err := c.ReadVpcsById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVpcsByIdResponse(rsp)
}

// UpdateVpcWithBodyWithResponse request with arbitrary body returning *UpdateVpcResponse
func (c *ClientWithResponses) UpdateVpcWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVpcResponse, error) {
	rsp, err := c.UpdateVpcWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVpcResponse(rsp)
}

func (c *ClientWithResponses) UpdateVpcWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateVpcJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVpcResponse, error) {
	rsp, err := c.UpdateVpc(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVpcResponse(rsp)
}

// ReadVpnConnectionsWithResponse request returning *ReadVpnConnectionsResponse
func (c *ClientWithResponses) ReadVpnConnectionsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadVpnConnectionsParams, reqEditors ...RequestEditorFn) (*ReadVpnConnectionsResponse, error) {
	rsp, err := c.ReadVpnConnections(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVpnConnectionsResponse(rsp)
}

// CreateVpnConnectionWithBodyWithResponse request with arbitrary body returning *CreateVpnConnectionResponse
func (c *ClientWithResponses) CreateVpnConnectionWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVpnConnectionResponse, error) {
	rsp, err := c.CreateVpnConnectionWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVpnConnectionResponse(rsp)
}

func (c *ClientWithResponses) CreateVpnConnectionWithResponse(ctx context.Context, spaceId SpaceId, body CreateVpnConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVpnConnectionResponse, error) {
	rsp, err := c.CreateVpnConnection(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVpnConnectionResponse(rsp)
}

// DeleteVpnConnectionWithResponse request returning *DeleteVpnConnectionResponse
func (c *ClientWithResponses) DeleteVpnConnectionWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteVpnConnectionResponse, error) {
	rsp, err := c.DeleteVpnConnection(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVpnConnectionResponse(rsp)
}

// ReadVpnConnectionsByIdWithResponse request returning *ReadVpnConnectionsByIdResponse
func (c *ClientWithResponses) ReadVpnConnectionsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadVpnConnectionsByIdResponse, error) {
	rsp, err := c.ReadVpnConnectionsById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVpnConnectionsByIdResponse(rsp)
}

// UpdateVpnConnectionWithBodyWithResponse request with arbitrary body returning *UpdateVpnConnectionResponse
func (c *ClientWithResponses) UpdateVpnConnectionWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVpnConnectionResponse, error) {
	rsp, err := c.UpdateVpnConnectionWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVpnConnectionResponse(rsp)
}

func (c *ClientWithResponses) UpdateVpnConnectionWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateVpnConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVpnConnectionResponse, error) {
	rsp, err := c.UpdateVpnConnection(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVpnConnectionResponse(rsp)
}

// DeleteVpnConnectionRouteWithBodyWithResponse request with arbitrary body returning *DeleteVpnConnectionRouteResponse
func (c *ClientWithResponses) DeleteVpnConnectionRouteWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteVpnConnectionRouteResponse, error) {
	rsp, err := c.DeleteVpnConnectionRouteWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVpnConnectionRouteResponse(rsp)
}

func (c *ClientWithResponses) DeleteVpnConnectionRouteWithResponse(ctx context.Context, spaceId SpaceId, id string, body DeleteVpnConnectionRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteVpnConnectionRouteResponse, error) {
	rsp, err := c.DeleteVpnConnectionRoute(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVpnConnectionRouteResponse(rsp)
}

// CreateVpnConnectionRouteWithBodyWithResponse request with arbitrary body returning *CreateVpnConnectionRouteResponse
func (c *ClientWithResponses) CreateVpnConnectionRouteWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVpnConnectionRouteResponse, error) {
	rsp, err := c.CreateVpnConnectionRouteWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVpnConnectionRouteResponse(rsp)
}

func (c *ClientWithResponses) CreateVpnConnectionRouteWithResponse(ctx context.Context, spaceId SpaceId, id string, body CreateVpnConnectionRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVpnConnectionRouteResponse, error) {
	rsp, err := c.CreateVpnConnectionRoute(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVpnConnectionRouteResponse(rsp)
}

// ParseDeleteLoadBalancerTagsResponse parses an HTTP response from a DeleteLoadBalancerTagsWithResponse call
func ParseDeleteLoadBalancerTagsResponse(rsp *http.Response) (*DeleteLoadBalancerTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLoadBalancerTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateLoadBalancerTagsResponse parses an HTTP response from a CreateLoadBalancerTagsWithResponse call
func ParseCreateLoadBalancerTagsResponse(rsp *http.Response) (*CreateLoadBalancerTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLoadBalancerTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteTagsResponse parses an HTTP response from a DeleteTagsWithResponse call
func ParseDeleteTagsResponse(rsp *http.Response) (*DeleteTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateTagsResponse parses an HTTP response from a CreateTagsWithResponse call
func ParseCreateTagsResponse(rsp *http.Response) (*CreateTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadClientGatewaysResponse parses an HTTP response from a ReadClientGatewaysWithResponse call
func ParseReadClientGatewaysResponse(rsp *http.Response) (*ReadClientGatewaysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadClientGatewaysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadClientGatewaysResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateClientGatewayResponse parses an HTTP response from a CreateClientGatewayWithResponse call
func ParseCreateClientGatewayResponse(rsp *http.Response) (*CreateClientGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateClientGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateClientGatewayResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteClientGatewayResponse parses an HTTP response from a DeleteClientGatewayWithResponse call
func ParseDeleteClientGatewayResponse(rsp *http.Response) (*DeleteClientGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClientGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadClientGatewaysByIdResponse parses an HTTP response from a ReadClientGatewaysByIdWithResponse call
func ParseReadClientGatewaysByIdResponse(rsp *http.Response) (*ReadClientGatewaysByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadClientGatewaysByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadClientGatewaysByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadDhcpOptionsResponse parses an HTTP response from a ReadDhcpOptionsWithResponse call
func ParseReadDhcpOptionsResponse(rsp *http.Response) (*ReadDhcpOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadDhcpOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadDhcpOptionsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateDhcpOptionsResponse parses an HTTP response from a CreateDhcpOptionsWithResponse call
func ParseCreateDhcpOptionsResponse(rsp *http.Response) (*CreateDhcpOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDhcpOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateDhcpOptionsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteDhcpOptionsResponse parses an HTTP response from a DeleteDhcpOptionsWithResponse call
func ParseDeleteDhcpOptionsResponse(rsp *http.Response) (*DeleteDhcpOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDhcpOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadDhcpOptionsByIdResponse parses an HTTP response from a ReadDhcpOptionsByIdWithResponse call
func ParseReadDhcpOptionsByIdResponse(rsp *http.Response) (*ReadDhcpOptionsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadDhcpOptionsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadDhcpOptionsByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadDirectLinkInterfacesResponse parses an HTTP response from a ReadDirectLinkInterfacesWithResponse call
func ParseReadDirectLinkInterfacesResponse(rsp *http.Response) (*ReadDirectLinkInterfacesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadDirectLinkInterfacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadDirectLinkInterfacesResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateDirectLinkInterfaceResponse parses an HTTP response from a CreateDirectLinkInterfaceWithResponse call
func ParseCreateDirectLinkInterfaceResponse(rsp *http.Response) (*CreateDirectLinkInterfaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDirectLinkInterfaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateDirectLinkInterfaceResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteDirectLinkInterfaceResponse parses an HTTP response from a DeleteDirectLinkInterfaceWithResponse call
func ParseDeleteDirectLinkInterfaceResponse(rsp *http.Response) (*DeleteDirectLinkInterfaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDirectLinkInterfaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadDirectLinkInterfacesByIdResponse parses an HTTP response from a ReadDirectLinkInterfacesByIdWithResponse call
func ParseReadDirectLinkInterfacesByIdResponse(rsp *http.Response) (*ReadDirectLinkInterfacesByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadDirectLinkInterfacesByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadDirectLinkInterfacesByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateDirectLinkInterfaceResponse parses an HTTP response from a UpdateDirectLinkInterfaceWithResponse call
func ParseUpdateDirectLinkInterfaceResponse(rsp *http.Response) (*UpdateDirectLinkInterfaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDirectLinkInterfaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateDirectLinkInterfaceResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadDirectLinksResponse parses an HTTP response from a ReadDirectLinksWithResponse call
func ParseReadDirectLinksResponse(rsp *http.Response) (*ReadDirectLinksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadDirectLinksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadDirectLinksResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateDirectLinkResponse parses an HTTP response from a CreateDirectLinkWithResponse call
func ParseCreateDirectLinkResponse(rsp *http.Response) (*CreateDirectLinkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDirectLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateDirectLinkResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteDirectLinkResponse parses an HTTP response from a DeleteDirectLinkWithResponse call
func ParseDeleteDirectLinkResponse(rsp *http.Response) (*DeleteDirectLinkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDirectLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadDirectLinksByIdResponse parses an HTTP response from a ReadDirectLinksByIdWithResponse call
func ParseReadDirectLinksByIdResponse(rsp *http.Response) (*ReadDirectLinksByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadDirectLinksByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadDirectLinksByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadFlexibleGpuCatalogResponse parses an HTTP response from a ReadFlexibleGpuCatalogWithResponse call
func ParseReadFlexibleGpuCatalogResponse(rsp *http.Response) (*ReadFlexibleGpuCatalogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadFlexibleGpuCatalogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadFlexibleGpuCatalogResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadFlexibleGpusResponse parses an HTTP response from a ReadFlexibleGpusWithResponse call
func ParseReadFlexibleGpusResponse(rsp *http.Response) (*ReadFlexibleGpusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadFlexibleGpusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadFlexibleGpusResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateFlexibleGpuResponse parses an HTTP response from a CreateFlexibleGpuWithResponse call
func ParseCreateFlexibleGpuResponse(rsp *http.Response) (*CreateFlexibleGpuResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFlexibleGpuResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateFlexibleGpuResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteFlexibleGpuResponse parses an HTTP response from a DeleteFlexibleGpuWithResponse call
func ParseDeleteFlexibleGpuResponse(rsp *http.Response) (*DeleteFlexibleGpuResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFlexibleGpuResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadFlexibleGpusByIdResponse parses an HTTP response from a ReadFlexibleGpusByIdWithResponse call
func ParseReadFlexibleGpusByIdResponse(rsp *http.Response) (*ReadFlexibleGpusByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadFlexibleGpusByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadFlexibleGpusByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateFlexibleGpuResponse parses an HTTP response from a UpdateFlexibleGpuWithResponse call
func ParseUpdateFlexibleGpuResponse(rsp *http.Response) (*UpdateFlexibleGpuResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateFlexibleGpuResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateFlexibleGpuResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseLinkFlexibleGpuResponse parses an HTTP response from a LinkFlexibleGpuWithResponse call
func ParseLinkFlexibleGpuResponse(rsp *http.Response) (*LinkFlexibleGpuResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkFlexibleGpuResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnlinkFlexibleGpuResponse parses an HTTP response from a UnlinkFlexibleGpuWithResponse call
func ParseUnlinkFlexibleGpuResponse(rsp *http.Response) (*UnlinkFlexibleGpuResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkFlexibleGpuResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadImagesResponse parses an HTTP response from a ReadImagesWithResponse call
func ParseReadImagesResponse(rsp *http.Response) (*ReadImagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadImagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadImagesResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateImageResponse parses an HTTP response from a CreateImageWithResponse call
func ParseCreateImageResponse(rsp *http.Response) (*CreateImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateImageResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteImageResponse parses an HTTP response from a DeleteImageWithResponse call
func ParseDeleteImageResponse(rsp *http.Response) (*DeleteImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadImagesByIdResponse parses an HTTP response from a ReadImagesByIdWithResponse call
func ParseReadImagesByIdResponse(rsp *http.Response) (*ReadImagesByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadImagesByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadImagesByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateImageResponse parses an HTTP response from a UpdateImageWithResponse call
func ParseUpdateImageResponse(rsp *http.Response) (*UpdateImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateImageResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadInternetGatewaysResponse parses an HTTP response from a ReadInternetGatewaysWithResponse call
func ParseReadInternetGatewaysResponse(rsp *http.Response) (*ReadInternetGatewaysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadInternetGatewaysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadInternetGatewaysResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateInternetGatewayResponse parses an HTTP response from a CreateInternetGatewayWithResponse call
func ParseCreateInternetGatewayResponse(rsp *http.Response) (*CreateInternetGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateInternetGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateInternetGatewayResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteInternetGatewayResponse parses an HTTP response from a DeleteInternetGatewayWithResponse call
func ParseDeleteInternetGatewayResponse(rsp *http.Response) (*DeleteInternetGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteInternetGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadInternetGatewaysByIdResponse parses an HTTP response from a ReadInternetGatewaysByIdWithResponse call
func ParseReadInternetGatewaysByIdResponse(rsp *http.Response) (*ReadInternetGatewaysByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadInternetGatewaysByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadInternetGatewaysByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseLinkInternetGatewayResponse parses an HTTP response from a LinkInternetGatewayWithResponse call
func ParseLinkInternetGatewayResponse(rsp *http.Response) (*LinkInternetGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkInternetGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnlinkInternetGatewayResponse parses an HTTP response from a UnlinkInternetGatewayWithResponse call
func ParseUnlinkInternetGatewayResponse(rsp *http.Response) (*UnlinkInternetGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkInternetGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadKeypairsResponse parses an HTTP response from a ReadKeypairsWithResponse call
func ParseReadKeypairsResponse(rsp *http.Response) (*ReadKeypairsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadKeypairsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadKeypairsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateKeypairResponse parses an HTTP response from a CreateKeypairWithResponse call
func ParseCreateKeypairResponse(rsp *http.Response) (*CreateKeypairResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateKeypairResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateKeypairResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteKeypairResponse parses an HTTP response from a DeleteKeypairWithResponse call
func ParseDeleteKeypairResponse(rsp *http.Response) (*DeleteKeypairResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteKeypairResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadKeypairsByIdResponse parses an HTTP response from a ReadKeypairsByIdWithResponse call
func ParseReadKeypairsByIdResponse(rsp *http.Response) (*ReadKeypairsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadKeypairsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadKeypairsByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadListenerRulesResponse parses an HTTP response from a ReadListenerRulesWithResponse call
func ParseReadListenerRulesResponse(rsp *http.Response) (*ReadListenerRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadListenerRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadListenerRulesResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateListenerRuleResponse parses an HTTP response from a CreateListenerRuleWithResponse call
func ParseCreateListenerRuleResponse(rsp *http.Response) (*CreateListenerRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateListenerRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateListenerRuleResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteListenerRuleResponse parses an HTTP response from a DeleteListenerRuleWithResponse call
func ParseDeleteListenerRuleResponse(rsp *http.Response) (*DeleteListenerRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteListenerRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadListenerRulesByIdResponse parses an HTTP response from a ReadListenerRulesByIdWithResponse call
func ParseReadListenerRulesByIdResponse(rsp *http.Response) (*ReadListenerRulesByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadListenerRulesByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadListenerRulesByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateListenerRuleResponse parses an HTTP response from a UpdateListenerRuleWithResponse call
func ParseUpdateListenerRuleResponse(rsp *http.Response) (*UpdateListenerRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateListenerRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateListenerRuleResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadLoadBalancersResponse parses an HTTP response from a ReadLoadBalancersWithResponse call
func ParseReadLoadBalancersResponse(rsp *http.Response) (*ReadLoadBalancersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadLoadBalancersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadLoadBalancersResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateLoadBalancerResponse parses an HTTP response from a CreateLoadBalancerWithResponse call
func ParseCreateLoadBalancerResponse(rsp *http.Response) (*CreateLoadBalancerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLoadBalancerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateLoadBalancerResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteLoadBalancerResponse parses an HTTP response from a DeleteLoadBalancerWithResponse call
func ParseDeleteLoadBalancerResponse(rsp *http.Response) (*DeleteLoadBalancerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLoadBalancerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadLoadBalancersByIdResponse parses an HTTP response from a ReadLoadBalancersByIdWithResponse call
func ParseReadLoadBalancersByIdResponse(rsp *http.Response) (*ReadLoadBalancersByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadLoadBalancersByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadLoadBalancersByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateLoadBalancerResponse parses an HTTP response from a UpdateLoadBalancerWithResponse call
func ParseUpdateLoadBalancerResponse(rsp *http.Response) (*UpdateLoadBalancerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateLoadBalancerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateLoadBalancerResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseLinkLoadBalancerBackendMachinesResponse parses an HTTP response from a LinkLoadBalancerBackendMachinesWithResponse call
func ParseLinkLoadBalancerBackendMachinesResponse(rsp *http.Response) (*LinkLoadBalancerBackendMachinesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkLoadBalancerBackendMachinesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnlinkLoadBalancerBackendMachinesResponse parses an HTTP response from a UnlinkLoadBalancerBackendMachinesWithResponse call
func ParseUnlinkLoadBalancerBackendMachinesResponse(rsp *http.Response) (*UnlinkLoadBalancerBackendMachinesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkLoadBalancerBackendMachinesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteLoadBalancerListenersResponse parses an HTTP response from a DeleteLoadBalancerListenersWithResponse call
func ParseDeleteLoadBalancerListenersResponse(rsp *http.Response) (*DeleteLoadBalancerListenersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLoadBalancerListenersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateLoadBalancerListenersResponse parses an HTTP response from a CreateLoadBalancerListenersWithResponse call
func ParseCreateLoadBalancerListenersResponse(rsp *http.Response) (*CreateLoadBalancerListenersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLoadBalancerListenersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateLoadBalancerListenersResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteLoadBalancerPolicyResponse parses an HTTP response from a DeleteLoadBalancerPolicyWithResponse call
func ParseDeleteLoadBalancerPolicyResponse(rsp *http.Response) (*DeleteLoadBalancerPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLoadBalancerPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateLoadBalancerPolicyResponse parses an HTTP response from a CreateLoadBalancerPolicyWithResponse call
func ParseCreateLoadBalancerPolicyResponse(rsp *http.Response) (*CreateLoadBalancerPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLoadBalancerPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateLoadBalancerPolicyResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadVmsHealthResponse parses an HTTP response from a ReadVmsHealthWithResponse call
func ParseReadVmsHealthResponse(rsp *http.Response) (*ReadVmsHealthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVmsHealthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVmsHealthResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadLoadBalancerTagsResponse parses an HTTP response from a ReadLoadBalancerTagsWithResponse call
func ParseReadLoadBalancerTagsResponse(rsp *http.Response) (*ReadLoadBalancerTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadLoadBalancerTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadLoadBalancerTagsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadLocationsResponse parses an HTTP response from a ReadLocationsWithResponse call
func ParseReadLocationsResponse(rsp *http.Response) (*ReadLocationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadLocationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadLocationsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadNatGatewayResponse parses an HTTP response from a ReadNatGatewayWithResponse call
func ParseReadNatGatewayResponse(rsp *http.Response) (*ReadNatGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadNatGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadNatGatewayResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateNatGatewayResponse parses an HTTP response from a CreateNatGatewayWithResponse call
func ParseCreateNatGatewayResponse(rsp *http.Response) (*CreateNatGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNatGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateNatGatewayResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteNatGatewayResponse parses an HTTP response from a DeleteNatGatewayWithResponse call
func ParseDeleteNatGatewayResponse(rsp *http.Response) (*DeleteNatGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNatGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadNatGatewayByIdResponse parses an HTTP response from a ReadNatGatewayByIdWithResponse call
func ParseReadNatGatewayByIdResponse(rsp *http.Response) (*ReadNatGatewayByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadNatGatewayByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadNatGatewayByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadNicsResponse parses an HTTP response from a ReadNicsWithResponse call
func ParseReadNicsResponse(rsp *http.Response) (*ReadNicsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadNicsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadNicsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateNicResponse parses an HTTP response from a CreateNicWithResponse call
func ParseCreateNicResponse(rsp *http.Response) (*CreateNicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateNicResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteNicResponse parses an HTTP response from a DeleteNicWithResponse call
func ParseDeleteNicResponse(rsp *http.Response) (*DeleteNicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadNicsByIdResponse parses an HTTP response from a ReadNicsByIdWithResponse call
func ParseReadNicsByIdResponse(rsp *http.Response) (*ReadNicsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadNicsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadNicsByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateNicResponse parses an HTTP response from a UpdateNicWithResponse call
func ParseUpdateNicResponse(rsp *http.Response) (*UpdateNicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateNicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateNicResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseLinkPrivateIpsResponse parses an HTTP response from a LinkPrivateIpsWithResponse call
func ParseLinkPrivateIpsResponse(rsp *http.Response) (*LinkPrivateIpsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkPrivateIpsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnlinkPrivateIpsResponse parses an HTTP response from a UnlinkPrivateIpsWithResponse call
func ParseUnlinkPrivateIpsResponse(rsp *http.Response) (*UnlinkPrivateIpsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkPrivateIpsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseLinkNicResponse parses an HTTP response from a LinkNicWithResponse call
func ParseLinkNicResponse(rsp *http.Response) (*LinkNicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkNicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinkNicResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnlinkNicResponse parses an HTTP response from a UnlinkNicWithResponse call
func ParseUnlinkNicResponse(rsp *http.Response) (*UnlinkNicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkNicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadProductTypesResponse parses an HTTP response from a ReadProductTypesWithResponse call
func ParseReadProductTypesResponse(rsp *http.Response) (*ReadProductTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadProductTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadProductTypesResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadProductTypesByIdResponse parses an HTTP response from a ReadProductTypesByIdWithResponse call
func ParseReadProductTypesByIdResponse(rsp *http.Response) (*ReadProductTypesByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadProductTypesByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadProductTypesByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadPublicIpRangesResponse parses an HTTP response from a ReadPublicIpRangesWithResponse call
func ParseReadPublicIpRangesResponse(rsp *http.Response) (*ReadPublicIpRangesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadPublicIpRangesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadPublicIpRangesResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadPublicIpsResponse parses an HTTP response from a ReadPublicIpsWithResponse call
func ParseReadPublicIpsResponse(rsp *http.Response) (*ReadPublicIpsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadPublicIpsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadPublicIpsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreatePublicIpResponse parses an HTTP response from a CreatePublicIpWithResponse call
func ParseCreatePublicIpResponse(rsp *http.Response) (*CreatePublicIpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePublicIpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreatePublicIpResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeletePublicIpResponse parses an HTTP response from a DeletePublicIpWithResponse call
func ParseDeletePublicIpResponse(rsp *http.Response) (*DeletePublicIpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePublicIpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadPublicIpsByIdResponse parses an HTTP response from a ReadPublicIpsByIdWithResponse call
func ParseReadPublicIpsByIdResponse(rsp *http.Response) (*ReadPublicIpsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadPublicIpsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadPublicIpsByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseLinkPublicIpResponse parses an HTTP response from a LinkPublicIpWithResponse call
func ParseLinkPublicIpResponse(rsp *http.Response) (*LinkPublicIpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkPublicIpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinkPublicIpResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnlinkPublicIpResponse parses an HTTP response from a UnlinkPublicIpWithResponse call
func ParseUnlinkPublicIpResponse(rsp *http.Response) (*UnlinkPublicIpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkPublicIpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadRouteTablesResponse parses an HTTP response from a ReadRouteTablesWithResponse call
func ParseReadRouteTablesResponse(rsp *http.Response) (*ReadRouteTablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadRouteTablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadRouteTablesResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateRouteTableResponse parses an HTTP response from a CreateRouteTableWithResponse call
func ParseCreateRouteTableResponse(rsp *http.Response) (*CreateRouteTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRouteTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateRouteTableResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteRouteTableResponse parses an HTTP response from a DeleteRouteTableWithResponse call
func ParseDeleteRouteTableResponse(rsp *http.Response) (*DeleteRouteTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRouteTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadRouteTablesByIdResponse parses an HTTP response from a ReadRouteTablesByIdWithResponse call
func ParseReadRouteTablesByIdResponse(rsp *http.Response) (*ReadRouteTablesByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadRouteTablesByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadRouteTablesByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateRouteTableRoutePropagationResponse parses an HTTP response from a UpdateRouteTableRoutePropagationWithResponse call
func ParseUpdateRouteTableRoutePropagationResponse(rsp *http.Response) (*UpdateRouteTableRoutePropagationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRouteTableRoutePropagationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateRouteTableRoutePropagationResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteRouteResponse parses an HTTP response from a DeleteRouteWithResponse call
func ParseDeleteRouteResponse(rsp *http.Response) (*DeleteRouteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRouteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateRouteResponse parses an HTTP response from a CreateRouteWithResponse call
func ParseCreateRouteResponse(rsp *http.Response) (*CreateRouteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRouteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateRouteResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateRouteResponse parses an HTTP response from a UpdateRouteWithResponse call
func ParseUpdateRouteResponse(rsp *http.Response) (*UpdateRouteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRouteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateRouteResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseLinkRouteTableResponse parses an HTTP response from a LinkRouteTableWithResponse call
func ParseLinkRouteTableResponse(rsp *http.Response) (*LinkRouteTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkRouteTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinkRouteTableResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnlinkRouteTableResponse parses an HTTP response from a UnlinkRouteTableWithResponse call
func ParseUnlinkRouteTableResponse(rsp *http.Response) (*UnlinkRouteTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkRouteTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadSecurityGroupsResponse parses an HTTP response from a ReadSecurityGroupsWithResponse call
func ParseReadSecurityGroupsResponse(rsp *http.Response) (*ReadSecurityGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadSecurityGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadSecurityGroupsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateSecurityGroupResponse parses an HTTP response from a CreateSecurityGroupWithResponse call
func ParseCreateSecurityGroupResponse(rsp *http.Response) (*CreateSecurityGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSecurityGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateSecurityGroupResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSecurityGroupResponse parses an HTTP response from a DeleteSecurityGroupWithResponse call
func ParseDeleteSecurityGroupResponse(rsp *http.Response) (*DeleteSecurityGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSecurityGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadSecurityGroupsByIdResponse parses an HTTP response from a ReadSecurityGroupsByIdWithResponse call
func ParseReadSecurityGroupsByIdResponse(rsp *http.Response) (*ReadSecurityGroupsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadSecurityGroupsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadSecurityGroupsByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSecurityGroupRuleResponse parses an HTTP response from a DeleteSecurityGroupRuleWithResponse call
func ParseDeleteSecurityGroupRuleResponse(rsp *http.Response) (*DeleteSecurityGroupRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSecurityGroupRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateSecurityGroupRuleResponse parses an HTTP response from a CreateSecurityGroupRuleWithResponse call
func ParseCreateSecurityGroupRuleResponse(rsp *http.Response) (*CreateSecurityGroupRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSecurityGroupRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateSecurityGroupRuleResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadSnapshotsResponse parses an HTTP response from a ReadSnapshotsWithResponse call
func ParseReadSnapshotsResponse(rsp *http.Response) (*ReadSnapshotsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadSnapshotsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadSnapshotsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateSnapshotResponse parses an HTTP response from a CreateSnapshotWithResponse call
func ParseCreateSnapshotResponse(rsp *http.Response) (*CreateSnapshotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSnapshotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateSnapshotResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSnapshotResponse parses an HTTP response from a DeleteSnapshotWithResponse call
func ParseDeleteSnapshotResponse(rsp *http.Response) (*DeleteSnapshotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSnapshotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadSnapshotsByIdResponse parses an HTTP response from a ReadSnapshotsByIdWithResponse call
func ParseReadSnapshotsByIdResponse(rsp *http.Response) (*ReadSnapshotsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadSnapshotsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadSnapshotsByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadSubnetsResponse parses an HTTP response from a ReadSubnetsWithResponse call
func ParseReadSubnetsResponse(rsp *http.Response) (*ReadSubnetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadSubnetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadSubnetsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateSubnetResponse parses an HTTP response from a CreateSubnetWithResponse call
func ParseCreateSubnetResponse(rsp *http.Response) (*CreateSubnetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSubnetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateSubnetResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSubnetResponse parses an HTTP response from a DeleteSubnetWithResponse call
func ParseDeleteSubnetResponse(rsp *http.Response) (*DeleteSubnetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSubnetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadSubnetsByIdResponse parses an HTTP response from a ReadSubnetsByIdWithResponse call
func ParseReadSubnetsByIdResponse(rsp *http.Response) (*ReadSubnetsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadSubnetsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadSubnetsByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateSubnetResponse parses an HTTP response from a UpdateSubnetWithResponse call
func ParseUpdateSubnetResponse(rsp *http.Response) (*UpdateSubnetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSubnetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateSubnetResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadTagsResponse parses an HTTP response from a ReadTagsWithResponse call
func ParseReadTagsResponse(rsp *http.Response) (*ReadTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadTagsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadVirtualGatewaysResponse parses an HTTP response from a ReadVirtualGatewaysWithResponse call
func ParseReadVirtualGatewaysResponse(rsp *http.Response) (*ReadVirtualGatewaysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVirtualGatewaysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVirtualGatewaysResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateVirtualGatewayResponse parses an HTTP response from a CreateVirtualGatewayWithResponse call
func ParseCreateVirtualGatewayResponse(rsp *http.Response) (*CreateVirtualGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVirtualGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateVirtualGatewayResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteVirtualGatewayResponse parses an HTTP response from a DeleteVirtualGatewayWithResponse call
func ParseDeleteVirtualGatewayResponse(rsp *http.Response) (*DeleteVirtualGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVirtualGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadVirtualGatewaysByIdResponse parses an HTTP response from a ReadVirtualGatewaysByIdWithResponse call
func ParseReadVirtualGatewaysByIdResponse(rsp *http.Response) (*ReadVirtualGatewaysByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVirtualGatewaysByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVirtualGatewaysByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseLinkVirtualGatewayToVpcResponse parses an HTTP response from a LinkVirtualGatewayToVpcWithResponse call
func ParseLinkVirtualGatewayToVpcResponse(rsp *http.Response) (*LinkVirtualGatewayToVpcResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkVirtualGatewayToVpcResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinkVirtualGatewayToVpcResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnlinkVirtualGatewayToVpcResponse parses an HTTP response from a UnlinkVirtualGatewayToVpcWithResponse call
func ParseUnlinkVirtualGatewayToVpcResponse(rsp *http.Response) (*UnlinkVirtualGatewayToVpcResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkVirtualGatewayToVpcResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadVmsResponse parses an HTTP response from a ReadVmsWithResponse call
func ParseReadVmsResponse(rsp *http.Response) (*ReadVmsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVmsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVmsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateVmsResponse parses an HTTP response from a CreateVmsWithResponse call
func ParseCreateVmsResponse(rsp *http.Response) (*CreateVmsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVmsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateVmsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadVmsStateResponse parses an HTTP response from a ReadVmsStateWithResponse call
func ParseReadVmsStateResponse(rsp *http.Response) (*ReadVmsStateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVmsStateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVmsStateResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteVmsResponse parses an HTTP response from a DeleteVmsWithResponse call
func ParseDeleteVmsResponse(rsp *http.Response) (*DeleteVmsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVmsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadVmsByIdResponse parses an HTTP response from a ReadVmsByIdWithResponse call
func ParseReadVmsByIdResponse(rsp *http.Response) (*ReadVmsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVmsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVmsByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateVmResponse parses an HTTP response from a UpdateVmWithResponse call
func ParseUpdateVmResponse(rsp *http.Response) (*UpdateVmResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVmResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateVmResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadAdminPasswordResponse parses an HTTP response from a ReadAdminPasswordWithResponse call
func ParseReadAdminPasswordResponse(rsp *http.Response) (*ReadAdminPasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadAdminPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadAdminPasswordResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadConsoleOutputResponse parses an HTTP response from a ReadConsoleOutputWithResponse call
func ParseReadConsoleOutputResponse(rsp *http.Response) (*ReadConsoleOutputResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadConsoleOutputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadConsoleOutputResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseRebootVmResponse parses an HTTP response from a RebootVmWithResponse call
func ParseRebootVmResponse(rsp *http.Response) (*RebootVmResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RebootVmResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseStartVmResponse parses an HTTP response from a StartVmWithResponse call
func ParseStartVmResponse(rsp *http.Response) (*StartVmResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartVmResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StartVmResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseStopVmResponse parses an HTTP response from a StopVmWithResponse call
func ParseStopVmResponse(rsp *http.Response) (*StopVmResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StopVmResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StopVmResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadVolumesResponse parses an HTTP response from a ReadVolumesWithResponse call
func ParseReadVolumesResponse(rsp *http.Response) (*ReadVolumesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVolumesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVolumesResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateVolumeResponse parses an HTTP response from a CreateVolumeWithResponse call
func ParseCreateVolumeResponse(rsp *http.Response) (*CreateVolumeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateVolumeResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteVolumeResponse parses an HTTP response from a DeleteVolumeWithResponse call
func ParseDeleteVolumeResponse(rsp *http.Response) (*DeleteVolumeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadVolumesByIdResponse parses an HTTP response from a ReadVolumesByIdWithResponse call
func ParseReadVolumesByIdResponse(rsp *http.Response) (*ReadVolumesByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVolumesByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVolumesByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateVolumeResponse parses an HTTP response from a UpdateVolumeWithResponse call
func ParseUpdateVolumeResponse(rsp *http.Response) (*UpdateVolumeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateVolumeResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseLinkVolumeResponse parses an HTTP response from a LinkVolumeWithResponse call
func ParseLinkVolumeResponse(rsp *http.Response) (*LinkVolumeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkVolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnlinkVolumeResponse parses an HTTP response from a UnlinkVolumeWithResponse call
func ParseUnlinkVolumeResponse(rsp *http.Response) (*UnlinkVolumeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkVolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadVpcAccessPointsResponse parses an HTTP response from a ReadVpcAccessPointsWithResponse call
func ParseReadVpcAccessPointsResponse(rsp *http.Response) (*ReadVpcAccessPointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVpcAccessPointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVpcAccessPointsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateVpcAccessPointResponse parses an HTTP response from a CreateVpcAccessPointWithResponse call
func ParseCreateVpcAccessPointResponse(rsp *http.Response) (*CreateVpcAccessPointResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVpcAccessPointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateVpcAccessPointResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteVpcAccessPointResponse parses an HTTP response from a DeleteVpcAccessPointWithResponse call
func ParseDeleteVpcAccessPointResponse(rsp *http.Response) (*DeleteVpcAccessPointResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVpcAccessPointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadVpcAccessPointsByIdResponse parses an HTTP response from a ReadVpcAccessPointsByIdWithResponse call
func ParseReadVpcAccessPointsByIdResponse(rsp *http.Response) (*ReadVpcAccessPointsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVpcAccessPointsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVpcAccessPointsByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateVpcAccessPointResponse parses an HTTP response from a UpdateVpcAccessPointWithResponse call
func ParseUpdateVpcAccessPointResponse(rsp *http.Response) (*UpdateVpcAccessPointResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVpcAccessPointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateVpcAccessPointResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadVpcPeeringsResponse parses an HTTP response from a ReadVpcPeeringsWithResponse call
func ParseReadVpcPeeringsResponse(rsp *http.Response) (*ReadVpcPeeringsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVpcPeeringsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVpcPeeringsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateVpcPeeringResponse parses an HTTP response from a CreateVpcPeeringWithResponse call
func ParseCreateVpcPeeringResponse(rsp *http.Response) (*CreateVpcPeeringResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVpcPeeringResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateVpcPeeringResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteVpcPeeringResponse parses an HTTP response from a DeleteVpcPeeringWithResponse call
func ParseDeleteVpcPeeringResponse(rsp *http.Response) (*DeleteVpcPeeringResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVpcPeeringResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadVpcPeeringsByIdResponse parses an HTTP response from a ReadVpcPeeringsByIdWithResponse call
func ParseReadVpcPeeringsByIdResponse(rsp *http.Response) (*ReadVpcPeeringsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVpcPeeringsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVpcPeeringsByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseAcceptVpcPeeringResponse parses an HTTP response from a AcceptVpcPeeringWithResponse call
func ParseAcceptVpcPeeringResponse(rsp *http.Response) (*AcceptVpcPeeringResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AcceptVpcPeeringResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AcceptVpcPeeringResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseRejectVpcPeeringResponse parses an HTTP response from a RejectVpcPeeringWithResponse call
func ParseRejectVpcPeeringResponse(rsp *http.Response) (*RejectVpcPeeringResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RejectVpcPeeringResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadVpcsResponse parses an HTTP response from a ReadVpcsWithResponse call
func ParseReadVpcsResponse(rsp *http.Response) (*ReadVpcsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVpcsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVpcsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateVpcResponse parses an HTTP response from a CreateVpcWithResponse call
func ParseCreateVpcResponse(rsp *http.Response) (*CreateVpcResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVpcResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateVpcResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteVpcResponse parses an HTTP response from a DeleteVpcWithResponse call
func ParseDeleteVpcResponse(rsp *http.Response) (*DeleteVpcResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVpcResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadVpcsByIdResponse parses an HTTP response from a ReadVpcsByIdWithResponse call
func ParseReadVpcsByIdResponse(rsp *http.Response) (*ReadVpcsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVpcsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVpcsByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateVpcResponse parses an HTTP response from a UpdateVpcWithResponse call
func ParseUpdateVpcResponse(rsp *http.Response) (*UpdateVpcResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVpcResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateVpcResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadVpnConnectionsResponse parses an HTTP response from a ReadVpnConnectionsWithResponse call
func ParseReadVpnConnectionsResponse(rsp *http.Response) (*ReadVpnConnectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVpnConnectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVpnConnectionsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateVpnConnectionResponse parses an HTTP response from a CreateVpnConnectionWithResponse call
func ParseCreateVpnConnectionResponse(rsp *http.Response) (*CreateVpnConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVpnConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateVpnConnectionResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteVpnConnectionResponse parses an HTTP response from a DeleteVpnConnectionWithResponse call
func ParseDeleteVpnConnectionResponse(rsp *http.Response) (*DeleteVpnConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVpnConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadVpnConnectionsByIdResponse parses an HTTP response from a ReadVpnConnectionsByIdWithResponse call
func ParseReadVpnConnectionsByIdResponse(rsp *http.Response) (*ReadVpnConnectionsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVpnConnectionsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVpnConnectionsByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateVpnConnectionResponse parses an HTTP response from a UpdateVpnConnectionWithResponse call
func ParseUpdateVpnConnectionResponse(rsp *http.Response) (*UpdateVpnConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVpnConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateVpnConnectionResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteVpnConnectionRouteResponse parses an HTTP response from a DeleteVpnConnectionRouteWithResponse call
func ParseDeleteVpnConnectionRouteResponse(rsp *http.Response) (*DeleteVpnConnectionRouteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVpnConnectionRouteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateVpnConnectionRouteResponse parses an HTTP response from a CreateVpnConnectionRouteWithResponse call
func ParseCreateVpnConnectionRouteResponse(rsp *http.Response) (*CreateVpnConnectionRouteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVpnConnectionRouteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}
