// Package numspot provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package numspot

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BasicAuthScopes  = "BasicAuth.Scopes"
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for AuthenticatorAssuranceLevel.
const (
	Aal0 AuthenticatorAssuranceLevel = "aal0"
	Aal1 AuthenticatorAssuranceLevel = "aal1"
	Aal2 AuthenticatorAssuranceLevel = "aal2"
	Aal3 AuthenticatorAssuranceLevel = "aal3"
)

// Defines values for ContinueWithRecoveryUiAction.
const (
	ShowRecoveryUi ContinueWithRecoveryUiAction = "show_recovery_ui"
)

// Defines values for ContinueWithSetSessionTokenAction.
const (
	SetSessionToken ContinueWithSetSessionTokenAction = "set_session_token"
)

// Defines values for ContinueWithSettingsUiAction.
const (
	ShowSettingsUi ContinueWithSettingsUiAction = "show_settings_ui"
)

// Defines values for ContinueWithVerificationUiAction.
const (
	ShowVerificationUi ContinueWithVerificationUiAction = "show_verification_ui"
)

// Defines values for ErrorDocumentationUrl.
const (
	HttpsportalApiNumspotComerrorsAmbiguousGranularPermissionElements ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#ambiguous_granular_permission_elements"
	HttpsportalApiNumspotComerrorsAmbiguousPermissionElements         ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#ambiguous_permission_elements"
	HttpsportalApiNumspotComerrorsAmbiguousRoleElements               ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#ambiguous_role_elements"
	HttpsportalApiNumspotComerrorsDuplicateResource                   ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#duplicate_resource"
	HttpsportalApiNumspotComerrorsDuplicateRole                       ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#duplicate_role"
	HttpsportalApiNumspotComerrorsForbidden                           ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#forbidden"
	HttpsportalApiNumspotComerrorsForbiddenAccess                     ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#forbidden_access"
	HttpsportalApiNumspotComerrorsIdentityNotFound                    ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#identity_not_found"
	HttpsportalApiNumspotComerrorsInactiveToken                       ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#inactive_token"
	HttpsportalApiNumspotComerrorsInternalServerError                 ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#internal_server_error"
	HttpsportalApiNumspotComerrorsInvalidParameter                    ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#invalid_parameter"
	HttpsportalApiNumspotComerrorsMethodNotAllowed                    ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#method_not_allowed"
	HttpsportalApiNumspotComerrorsMissingRoles                        ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#missing_roles"
	HttpsportalApiNumspotComerrorsNamespaceNotFound                   ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#namespace_not_found"
	HttpsportalApiNumspotComerrorsNotInTenantRoles                    ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#not_in_tenant_roles"
	HttpsportalApiNumspotComerrorsPermissionNotFound                  ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#permission_not_found"
	HttpsportalApiNumspotComerrorsResourceNotFound                    ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#resource_not_found"
	HttpsportalApiNumspotComerrorsRoleNotFound                        ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#role_not_found"
	HttpsportalApiNumspotComerrorsUnauthenticatedAccess               ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#unauthenticated_access"
	HttpsportalApiNumspotComerrorsUnexpectedTokenUsage                ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#unexpected_token_usage"
	HttpsportalApiNumspotComerrorsUriTooLong                          ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#uri_too_long"
)

// Defines values for Gpu.
const (
	A10080 Gpu = "A100-80"
	P100   Gpu = "P100"
	P6     Gpu = "P6"
	V100   Gpu = "V100"
)

// Defines values for IdentityState.
const (
	Active   IdentityState = "active"
	Inactive IdentityState = "inactive"
)

// Defines values for IdentityCredentialsType.
const (
	IdentityCredentialsTypeCode         IdentityCredentialsType = "code"
	IdentityCredentialsTypeCodeRecovery IdentityCredentialsType = "code_recovery"
	IdentityCredentialsTypeLinkRecovery IdentityCredentialsType = "link_recovery"
	IdentityCredentialsTypeLookupSecret IdentityCredentialsType = "lookup_secret"
	IdentityCredentialsTypeOidc         IdentityCredentialsType = "oidc"
	IdentityCredentialsTypePassword     IdentityCredentialsType = "password"
	IdentityCredentialsTypeTotp         IdentityCredentialsType = "totp"
	IdentityCredentialsTypeWebauthn     IdentityCredentialsType = "webauthn"
)

// Defines values for ImmutableSpaceStatus.
const (
	ImmutableSpaceStatusFAILED  ImmutableSpaceStatus = "FAILED"
	ImmutableSpaceStatusQUEUED  ImmutableSpaceStatus = "QUEUED"
	ImmutableSpaceStatusREADY   ImmutableSpaceStatus = "READY"
	ImmutableSpaceStatusRUNNING ImmutableSpaceStatus = "RUNNING"
)

// Defines values for LoginFlowActive.
const (
	LoginFlowActiveCode         LoginFlowActive = "code"
	LoginFlowActiveCodeRecovery LoginFlowActive = "code_recovery"
	LoginFlowActiveLinkRecovery LoginFlowActive = "link_recovery"
	LoginFlowActiveLookupSecret LoginFlowActive = "lookup_secret"
	LoginFlowActiveOidc         LoginFlowActive = "oidc"
	LoginFlowActivePassword     LoginFlowActive = "password"
	LoginFlowActiveTotp         LoginFlowActive = "totp"
	LoginFlowActiveWebauthn     LoginFlowActive = "webauthn"
)

// Defines values for NodeProfile.
const (
	LARGE     NodeProfile = "LARGE"
	MEDIUM    NodeProfile = "MEDIUM"
	SMALL     NodeProfile = "SMALL"
	VERYLARGE NodeProfile = "VERY_LARGE"
)

// Defines values for OperationStatus.
const (
	OperationStatusDONE    OperationStatus = "DONE"
	OperationStatusFAILED  OperationStatus = "FAILED"
	OperationStatusPENDING OperationStatus = "PENDING"
	OperationStatusRUNNING OperationStatus = "RUNNING"
)

// Defines values for RegistrationFlowActive.
const (
	RegistrationFlowActiveCode         RegistrationFlowActive = "code"
	RegistrationFlowActiveCodeRecovery RegistrationFlowActive = "code_recovery"
	RegistrationFlowActiveLinkRecovery RegistrationFlowActive = "link_recovery"
	RegistrationFlowActiveLookupSecret RegistrationFlowActive = "lookup_secret"
	RegistrationFlowActiveOidc         RegistrationFlowActive = "oidc"
	RegistrationFlowActivePassword     RegistrationFlowActive = "password"
	RegistrationFlowActiveTotp         RegistrationFlowActive = "totp"
	RegistrationFlowActiveWebauthn     RegistrationFlowActive = "webauthn"
)

// Defines values for SessionAuthenticationMethodMethod.
const (
	SessionAuthenticationMethodMethodCode             SessionAuthenticationMethodMethod = "code"
	SessionAuthenticationMethodMethodCodeRecovery     SessionAuthenticationMethodMethod = "code_recovery"
	SessionAuthenticationMethodMethodLinkRecovery     SessionAuthenticationMethodMethod = "link_recovery"
	SessionAuthenticationMethodMethodLookupSecret     SessionAuthenticationMethodMethod = "lookup_secret"
	SessionAuthenticationMethodMethodOidc             SessionAuthenticationMethodMethod = "oidc"
	SessionAuthenticationMethodMethodPassword         SessionAuthenticationMethodMethod = "password"
	SessionAuthenticationMethodMethodTotp             SessionAuthenticationMethodMethod = "totp"
	SessionAuthenticationMethodMethodV06LegacySession SessionAuthenticationMethodMethod = "v0.6_legacy_session"
	SessionAuthenticationMethodMethodWebauthn         SessionAuthenticationMethodMethod = "webauthn"
)

// Defines values for SpaceStatus.
const (
	FAILED  SpaceStatus = "FAILED"
	QUEUED  SpaceStatus = "QUEUED"
	READY   SpaceStatus = "READY"
	RUNNING SpaceStatus = "RUNNING"
)

// Defines values for SubjectType.
const (
	ServiceAccounts SubjectType = "serviceAccounts"
	Users           SubjectType = "users"
)

// Defines values for UiNodeGroup.
const (
	UiNodeGroupCode         UiNodeGroup = "code"
	UiNodeGroupDefault      UiNodeGroup = "default"
	UiNodeGroupLink         UiNodeGroup = "link"
	UiNodeGroupLookupSecret UiNodeGroup = "lookup_secret"
	UiNodeGroupOidc         UiNodeGroup = "oidc"
	UiNodeGroupPassword     UiNodeGroup = "password"
	UiNodeGroupProfile      UiNodeGroup = "profile"
	UiNodeGroupTotp         UiNodeGroup = "totp"
	UiNodeGroupWebauthn     UiNodeGroup = "webauthn"
)

// Defines values for UiNodeType.
const (
	A      UiNodeType = "a"
	Img    UiNodeType = "img"
	Input  UiNodeType = "input"
	Script UiNodeType = "script"
	Text   UiNodeType = "text"
)

// Defines values for UiNodeInputAttributesAutocomplete.
const (
	UiNodeInputAttributesAutocompleteCurrentPassword UiNodeInputAttributesAutocomplete = "current-password"
	UiNodeInputAttributesAutocompleteEmail           UiNodeInputAttributesAutocomplete = "email"
	UiNodeInputAttributesAutocompleteNewPassword     UiNodeInputAttributesAutocomplete = "new-password"
	UiNodeInputAttributesAutocompleteOneTimeCode     UiNodeInputAttributesAutocomplete = "one-time-code"
	UiNodeInputAttributesAutocompleteTel             UiNodeInputAttributesAutocomplete = "tel"
	UiNodeInputAttributesAutocompleteUrl             UiNodeInputAttributesAutocomplete = "url"
)

// Defines values for UiNodeInputAttributesType.
const (
	UiNodeInputAttributesTypeButton        UiNodeInputAttributesType = "button"
	UiNodeInputAttributesTypeCheckbox      UiNodeInputAttributesType = "checkbox"
	UiNodeInputAttributesTypeDate          UiNodeInputAttributesType = "date"
	UiNodeInputAttributesTypeDatetimeLocal UiNodeInputAttributesType = "datetime-local"
	UiNodeInputAttributesTypeEmail         UiNodeInputAttributesType = "email"
	UiNodeInputAttributesTypeHidden        UiNodeInputAttributesType = "hidden"
	UiNodeInputAttributesTypeNumber        UiNodeInputAttributesType = "number"
	UiNodeInputAttributesTypePassword      UiNodeInputAttributesType = "password"
	UiNodeInputAttributesTypeSubmit        UiNodeInputAttributesType = "submit"
	UiNodeInputAttributesTypeTel           UiNodeInputAttributesType = "tel"
	UiNodeInputAttributesTypeText          UiNodeInputAttributesType = "text"
	UiNodeInputAttributesTypeUrl           UiNodeInputAttributesType = "url"
)

// Defines values for UiTextType.
const (
	UiTextTypeError   UiTextType = "error"
	UiTextTypeInfo    UiTextType = "info"
	UiTextTypeSuccess UiTextType = "success"
)

// Defines values for UpdateRecoveryFlowWithCodeMethodMethod.
const (
	UpdateRecoveryFlowWithCodeMethodMethodCode UpdateRecoveryFlowWithCodeMethodMethod = "code"
	UpdateRecoveryFlowWithCodeMethodMethodLink UpdateRecoveryFlowWithCodeMethodMethod = "link"
)

// Defines values for UpdateRecoveryFlowWithLinkMethodMethod.
const (
	UpdateRecoveryFlowWithLinkMethodMethodCode UpdateRecoveryFlowWithLinkMethodMethod = "code"
	UpdateRecoveryFlowWithLinkMethodMethodLink UpdateRecoveryFlowWithLinkMethodMethod = "link"
)

// Defines values for UpdateVerificationFlowWithCodeMethodMethod.
const (
	UpdateVerificationFlowWithCodeMethodMethodCode UpdateVerificationFlowWithCodeMethodMethod = "code"
	UpdateVerificationFlowWithCodeMethodMethodLink UpdateVerificationFlowWithCodeMethodMethod = "link"
)

// Defines values for UpdateVerificationFlowWithLinkMethodMethod.
const (
	UpdateVerificationFlowWithLinkMethodMethodCode UpdateVerificationFlowWithLinkMethodMethod = "code"
	UpdateVerificationFlowWithLinkMethodMethodLink UpdateVerificationFlowWithLinkMethodMethod = "link"
)

// Defines values for VerifiableIdentityAddressVia.
const (
	VerifiableIdentityAddressViaEmail VerifiableIdentityAddressVia = "email"
	VerifiableIdentityAddressViaSms   VerifiableIdentityAddressVia = "sms"
)

// ACL defines model for ACL.
type ACL struct {
	// PermissionId id of the permission
	PermissionId openapi_types.UUID `json:"permissionId"`

	// Resource Type of the resource being accessed
	Resource string `json:"resource"`

	// ResourceId Unique identifier of a resource
	ResourceId string `json:"resourceId"`

	// Service Name of the service making the call
	Service string `json:"service"`

	// Subresource Specific type of the subresource within the main resource
	Subresource *string `json:"subresource,omitempty"`
}

// ACLList List of ACLs.
type ACLList struct {
	Items []ACL `json:"items"`
}

// ACLPaginatedList defines model for ACLPaginatedList.
type ACLPaginatedList struct {
	Items []ACL `json:"items"`

	// NextPageToken This token is used to retrieve the next page. If this field is omitted, there are no subsequent pages.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// TotalSize Equivalent to int32
	TotalSize *Int `json:"totalSize,omitempty"`
}

// AuthenticatorAssuranceLevel The authenticator assurance level can be one of "aal1", "aal2", or "aal3". A higher number means that it is harder
// for an attacker to compromise the account.
// Generally, "aal1" implies that one authentication factor was used while AAL2 implies that two factors (password + TOTP) have been used.
type AuthenticatorAssuranceLevel string

// BadRequestError defines model for BadRequestError.
type BadRequestError struct {
	// Detail Human-readable explanation specific to this occurrence of the problem.
	Detail   *string `json:"detail,omitempty"`
	Instance *Url    `json:"instance,omitempty"`

	// Title Human-readable summary of the problem type.
	Title string `json:"title"`

	// Type Documentation URL for the domain error
	Type ErrorDocumentationUrl `json:"type"`

	// Violations Array of violations to provide a per-field detail.
	Violations *[]Violation `json:"violations,omitempty"`
}

// ContinueWith defines model for ContinueWith.
type ContinueWith struct {
	union json.RawMessage
}

// ContinueWithRecoveryUi Indicates, that the UI flow could be continued by showing a recovery ui
type ContinueWithRecoveryUi struct {
	// Action Action will always be `show_recovery_ui`
	// show_recovery_ui ContinueWithActionShowRecoveryUIString
	Action ContinueWithRecoveryUiAction `json:"action"`
	Flow   ContinueWithRecoveryUiFlow   `json:"flow"`
}

// ContinueWithRecoveryUiAction Action will always be `show_recovery_ui`
// show_recovery_ui ContinueWithActionShowRecoveryUIString
type ContinueWithRecoveryUiAction string

// ContinueWithRecoveryUiFlow defines model for ContinueWithRecoveryUiFlow.
type ContinueWithRecoveryUiFlow struct {
	// Id The ID of the recovery flow
	Id openapi_types.UUID `json:"id"`

	// Url The URL of the recovery flow
	Url *string `json:"url,omitempty"`
}

// ContinueWithSetSessionToken Indicates that a session was issued, and the application should use this token for authenticated requests
type ContinueWithSetSessionToken struct {
	// Action Action will always be `set_session_token`
	// set_session_token ContinueWithActionSetSessionTokenString
	Action ContinueWithSetSessionTokenAction `json:"action"`

	// SessionToken Token is the token of the session
	SessionToken string `json:"session_token"`
}

// ContinueWithSetSessionTokenAction Action will always be `set_session_token`
// set_session_token ContinueWithActionSetSessionTokenString
type ContinueWithSetSessionTokenAction string

// ContinueWithSettingsUi Indicates, that the UI flow could be continued by showing a settings ui
type ContinueWithSettingsUi struct {
	// Action Action will always be `show_settings_ui`
	// show_settings_ui ContinueWithActionShowSettingsUIString
	Action ContinueWithSettingsUiAction `json:"action"`
	Flow   ContinueWithSettingsUiFlow   `json:"flow"`
}

// ContinueWithSettingsUiAction Action will always be `show_settings_ui`
// show_settings_ui ContinueWithActionShowSettingsUIString
type ContinueWithSettingsUiAction string

// ContinueWithSettingsUiFlow defines model for ContinueWithSettingsUiFlow.
type ContinueWithSettingsUiFlow struct {
	// Id The ID of the settings flow
	Id openapi_types.UUID `json:"id"`
}

// ContinueWithVerificationUi Indicates, that the UI flow could be continued by showing a verification ui
type ContinueWithVerificationUi struct {
	// Action Action will always be `show_verification_ui`
	// show_verification_ui ContinueWithActionShowVerificationUIString
	Action ContinueWithVerificationUiAction `json:"action"`
	Flow   ContinueWithVerificationUiFlow   `json:"flow"`
}

// ContinueWithVerificationUiAction Action will always be `show_verification_ui`
// show_verification_ui ContinueWithActionShowVerificationUIString
type ContinueWithVerificationUiAction string

// ContinueWithVerificationUiFlow defines model for ContinueWithVerificationUiFlow.
type ContinueWithVerificationUiFlow struct {
	// Id The ID of the verification flow
	Id openapi_types.UUID `json:"id"`

	// Url The URL of the verification flow
	Url *string `json:"url,omitempty"`

	// VerifiableAddress The address that should be verified in this flow
	VerifiableAddress string `json:"verifiable_address"`
}

// CreateCluster defines model for CreateCluster.
type CreateCluster struct {
	// Cidr IP addresses in CIDR notation
	Cidr        string              `json:"cidr"`
	Description *string             `json:"description,omitempty"`
	Name        string              `json:"name"`
	NodePools   []OpenShiftNodepool `json:"nodePools"`
	Version     string              `json:"version"`
}

// CreateNodepool defines model for CreateNodepool.
type CreateNodepool struct {
	Name      string `json:"name"`
	NodeCount int    `json:"nodeCount"`

	// NodeProfile Node profiles
	NodeProfile NodeProfile `json:"nodeProfile"`
}

// CreateSpace defines model for CreateSpace.
type CreateSpace struct {
	// Description Space description
	Description string `json:"description"`

	// Name Space name
	Name string `json:"name"`
}

// CreatedServiceAccount defines model for CreatedServiceAccount.
type CreatedServiceAccount struct {
	// Id Service account ID
	Id string `json:"id"`

	// Name Service Accounts name
	Name string `json:"name"`

	// Secret Service account secret.
	Secret string `json:"secret"`
}

// CredentialSupportedDraft00 Includes information about the supported verifiable credentials.
type CredentialSupportedDraft00 struct {
	// CryptographicBindingMethodsSupported OpenID Connect Verifiable Credentials Cryptographic Binding Methods Supported
	//
	// Contains a list of cryptographic binding methods supported for signing the proof.
	CryptographicBindingMethodsSupported *[]string `json:"cryptographic_binding_methods_supported,omitempty"`

	// CryptographicSuitesSupported OpenID Connect Verifiable Credentials Cryptographic Suites Supported
	//
	// Contains a list of cryptographic suites methods supported for signing the proof.
	CryptographicSuitesSupported *[]string `json:"cryptographic_suites_supported,omitempty"`

	// Format OpenID Connect Verifiable Credentials Format
	//
	// Contains the format that is supported by this authorization server.
	Format *string `json:"format,omitempty"`

	// Types OpenID Connect Verifiable Credentials Types
	//
	// Contains the types of verifiable credentials supported.
	Types *[]string `json:"types,omitempty"`
}

// DateTime defines model for DateTime.
type DateTime = time.Time

// DeleteMySessionsCount Deleted Session Count
type DeleteMySessionsCount struct {
	// Count The number of sessions that were revoked.
	Count *int64 `json:"count,omitempty"`
}

// Email defines model for Email.
type Email = openapi_types.Email

// Error For HTTP errors, we implement the https://datatracker.ietf.org/doc/html/rfc9457
type Error struct {
	// Detail Human-readable explanation specific to this occurrence of the problem.
	Detail   *string `json:"detail,omitempty"`
	Instance *Url    `json:"instance,omitempty"`

	// Title Human-readable summary of the problem type.
	Title string `json:"title"`

	// Type Documentation URL for the domain error
	Type ErrorDocumentationUrl `json:"type"`
}

// ErrorBrowserLocationChangeRequired defines model for ErrorBrowserLocationChangeRequired.
type ErrorBrowserLocationChangeRequired struct {
	// Error The standard  JSON API error format.
	Error *ErrorGeneric `json:"error,omitempty"`

	// RedirectBrowserTo Points to where to redirect the user to next.
	RedirectBrowserTo *string `json:"redirect_browser_to,omitempty"`
}

// ErrorDocumentationUrl Documentation URL for the domain error
type ErrorDocumentationUrl string

// ErrorGeneric The standard  JSON API error format.
type ErrorGeneric struct {
	Error GenericError `json:"error"`
}

// ErrorOauth2 defines model for ErrorOauth2.
type ErrorOauth2 struct {
	// Error The error type.
	Error string `json:"error"`

	// ErrorDescription A human-readable explanation specific to this occurrence of the problem.
	ErrorDescription *string `json:"error_description,omitempty"`
}

// FlowError defines model for FlowError.
type FlowError struct {
	// CreatedAt CreatedAt is a helper struct field for gobuffalo.pop.
	CreatedAt *time.Time              `json:"created_at,omitempty"`
	Error     *map[string]interface{} `json:"error,omitempty"`

	// Id ID of the error container.
	Id openapi_types.UUID `json:"id"`

	// UpdatedAt UpdatedAt is a helper struct field for gobuffalo.pop.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// GenericError defines model for GenericError.
type GenericError struct {
	// Code The status code
	Code *int64 `json:"code,omitempty"`

	// Debug Debug information
	//
	// This field is often not exposed to protect against leaking
	// sensitive information.
	Debug *string `json:"debug,omitempty"`

	// Details Further error details
	Details *map[string]interface{} `json:"details,omitempty"`

	// Id The error ID
	//
	// Useful when trying to identify various errors in application logic.
	Id *string `json:"id,omitempty"`

	// Message Error message
	//
	// The error's message.
	Message string `json:"message"`

	// Reason A human-readable reason for the error
	Reason *string `json:"reason,omitempty"`

	// Request The request ID
	//
	// The request ID is often exposed internally in order to trace
	// errors across service architectures. This is often a UUID.
	Request *string `json:"request,omitempty"`

	// Status The status description
	Status *string `json:"status,omitempty"`
}

// Gpu GPU values
type Gpu string

// GranularPermission defines model for GranularPermission.
type GranularPermission struct {
	// Action Type of action (e.g., owners, editors, getters)
	Action string `json:"action"`

	// ObjectId ID of the object
	ObjectId string `json:"objectId"`
}

// GranularPolicyList defines model for GranularPolicyList.
type GranularPolicyList = []GranularPermission

// IAMGranularPolicyList defines model for IAMGranularPolicyList.
type IAMGranularPolicyList struct {
	Items []GranularPermission `json:"items"`

	// NextPageToken This token is used to retrieve the next page. If this field is omitted, there are no subsequent pages.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// TotalSize Equivalent to int32
	TotalSize *Int `json:"totalSize,omitempty"`
}

// IAMPolicy defines model for IAMPolicy.
type IAMPolicy struct {
	// Permissions List of permission UUIDs
	Permissions *[]openapi_types.UUID `json:"permissions,omitempty"`

	// Roles List of role UUIDs
	Roles *[]openapi_types.UUID `json:"roles,omitempty"`
}

// ID defines model for ID.
type ID = int64

// IdentitiesIdsList defines model for IdentitiesIdsList.
type IdentitiesIdsList struct {
	Items []openapi_types.UUID `json:"items"`
}

// Identity An identity represents a (human) user.
type Identity struct {
	// CreatedAt CreatedAt is a helper struct field for gobuffalo.pop.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Credentials Credentials represents all credentials that can be used for authenticating this identity.
	Credentials *map[string]IdentityCredentials `json:"credentials,omitempty"`

	// Id ID is the identity's unique identifier.
	// The Identity ID can not be changed and can not be chosen. This ensures future
	// compatibility and optimization for distributed stores such as CockroachDB.
	Id             openapi_types.UUID  `json:"id"`
	MetadataAdmin  *NullJsonRawMessage `json:"metadata_admin"`
	MetadataPublic *NullJsonRawMessage `json:"metadata_public"`
	OrganizationId *NullUUID           `json:"organization_id"`

	// RecoveryAddresses RecoveryAddresses contains all the addresses that can be used to recover an identity.
	RecoveryAddresses *[]RecoveryIdentityAddress `json:"recovery_addresses,omitempty"`

	// SchemaId SchemaID is the ID of the JSON Schema to be used for validating the identity's traits.
	SchemaId string `json:"schema_id"`

	// SchemaUrl SchemaURL is the URL of the endpoint where the identity's traits schema can be fetched from.
	SchemaUrl string `json:"schema_url"`

	// State State is the identity's state.
	//
	// This value has currently no effect.
	// active StateActive
	// inactive StateInactive
	State          *IdentityState `json:"state,omitempty"`
	StateChangedAt *NullTime      `json:"state_changed_at"`

	// Traits Traits represent an identity's traits. The identity is able to create, modify, and delete traits in a self-service manner. The input will always be validated against the JSON Schema defined in `schema_url`.
	Traits IdentityTraits `json:"traits"`

	// UpdatedAt UpdatedAt is a helper struct field for gobuffalo.pop.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// VerifiableAddresses VerifiableAddresses contains all the addresses that can be verified by the user.
	VerifiableAddresses *[]VerifiableIdentityAddress `json:"verifiable_addresses,omitempty"`
}

// IdentityState State is the identity's state.
//
// This value has currently no effect.
// active StateActive
// inactive StateInactive
type IdentityState string

// IdentityCredentials Credentials represents a specific credential type
type IdentityCredentials struct {
	// Config JSONRawMessage represents a json.RawMessage that works well with JSON, SQL, and Swagger.
	Config *JSONRawMessage `json:"config,omitempty"`

	// CreatedAt CreatedAt is a helper struct field for gobuffalo.pop.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Identifiers Identifiers represents a list of unique identifiers this credential type matches.
	Identifiers *[]string `json:"identifiers,omitempty"`

	// Type Type discriminates between different types of credentials.
	// password CredentialsTypePassword
	// oidc CredentialsTypeOIDC
	// totp CredentialsTypeTOTP
	// lookup_secret CredentialsTypeLookup
	// webauthn CredentialsTypeWebAuthn
	// code CredentialsTypeCodeAuth
	// link_recovery CredentialsTypeRecoveryLink  CredentialsTypeRecoveryLink is a special credential type linked to the link strategy (recovery flow).  It is not used within the credentials object itself.
	// code_recovery CredentialsTypeRecoveryCode
	Type *IdentityCredentialsType `json:"type,omitempty"`

	// UpdatedAt UpdatedAt is a helper struct field for gobuffalo.pop.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Version Version refers to the version of the credential. Useful when changing the config schema.
	Version *int64 `json:"version,omitempty"`
}

// IdentityCredentialsType Type discriminates between different types of credentials.
// password CredentialsTypePassword
// oidc CredentialsTypeOIDC
// totp CredentialsTypeTOTP
// lookup_secret CredentialsTypeLookup
// webauthn CredentialsTypeWebAuthn
// code CredentialsTypeCodeAuth
// link_recovery CredentialsTypeRecoveryLink  CredentialsTypeRecoveryLink is a special credential type linked to the link strategy (recovery flow).  It is not used within the credentials object itself.
// code_recovery CredentialsTypeRecoveryCode
type IdentityCredentialsType string

// IdentityTraits Traits represent an identity's traits. The identity is able to create, modify, and delete traits in a self-service manner. The input will always be validated against the JSON Schema defined in `schema_url`.
type IdentityTraits = interface{}

// IdentityVerifiableAddressStatus VerifiableAddressStatus must not exceed 16 characters as that is the limitation in the SQL Schema
type IdentityVerifiableAddressStatus = string

// ImmutableSpace defines model for ImmutableSpace.
type ImmutableSpace struct {
	CreatedOn DateTime `json:"createdOn"`

	// Id Internal ID
	Id openapi_types.UUID `json:"id"`

	// OrganisationId Organisation_id
	OrganisationId openapi_types.UUID `json:"organisationId"`

	// Status status of the space, the space can only be used when the status is ready.
	Status    ImmutableSpaceStatus `json:"status"`
	UpdatedOn DateTime             `json:"updatedOn"`
}

// ImmutableSpaceStatus status of the space, the space can only be used when the status is ready.
type ImmutableSpaceStatus string

// Int Equivalent to int32
type Int = int32

// IntrospectResp defines model for IntrospectResp.
type IntrospectResp struct {
	// Active A boolean value indicating whether the token is active or not.
	Active bool `json:"active"`

	// Aud The intended audience of the token, specifying who the token is intended for.
	Aud *[]string `json:"aud,omitempty"`

	// ClientId The unique identifier of the client application that requested the token.
	ClientId *string `json:"client_id,omitempty"`

	// Exp The expiration time of the token in seconds since the Unix epoch.
	Exp *int `json:"exp,omitempty"`

	// Iat The issued-at time of the token in seconds since the Unix epoch.
	Iat *int `json:"iat,omitempty"`

	// Iss The issuer of the token, identify the authorization server that issued the token.
	Iss *string `json:"iss,omitempty"`

	// Nbf The not-before time of the token in seconds since the Unix epoch, indicating the earliest time the token can be used.
	Nbf *int `json:"nbf,omitempty"`

	// Scope The scope of the token, defining the permissions it grants.
	Scope *string `json:"scope,omitempty"`

	// Sub The subject of the token, typically the user or resource the token is issued for.
	Sub *string `json:"sub,omitempty"`

	// TokenType Indicate the type of the token, such as "Bearer".
	TokenType *string `json:"token_type,omitempty"`

	// TokenUse Specify the intended use of the token, such as "access" or "refresh".
	TokenUse *string `json:"token_use,omitempty"`
}

// JSONRawMessage JSONRawMessage represents a json.RawMessage that works well with JSON, SQL, and Swagger.
type JSONRawMessage = map[string]interface{}

// JsonWebKey defines model for JsonWebKey.
type JsonWebKey struct {
	// Alg The "alg" (algorithm) parameter identifies the algorithm intended for use with the key.  The values used should either be registered in the IANA "JSON Web Signature and Encryption Algorithms" registry established by [JWA] or be a value that contains a Collision-Resistant Name.
	Alg string  `json:"alg"`
	Crv *string `json:"crv,omitempty"`
	D   *string `json:"d,omitempty"`
	Dp  *string `json:"dp,omitempty"`
	Dq  *string `json:"dq,omitempty"`
	E   *string `json:"e,omitempty"`
	K   *string `json:"k,omitempty"`

	// Kid The "kid" (key ID) parameter is used to match a specific key. This is used, for instance, to choose among a set of keys within a JWK Set during key rollover.  The structure of the "kid" value is unspecified. When "kid" values are used within a JWK Set, different keys within the JWK Set SHOULD use distinct "kid" values. (One example in which different keys might use the same "kid" value is if they have different "kty" (key type) values but are considered to be equivalent alternatives by the application using them.)  The "kid" value is a case-sensitive string.
	Kid string `json:"kid"`

	// Kty The "kty" parameter in JSON Web Keys (JWK) specifies the cryptographic algorithm family,such as "RSA" or "EC". It must be a case-sensitive string and is required in a JWK. The value should be registered in the IANA "JSON Web Key Types" registry or be a Collision-Resistant Name
	Kty string  `json:"kty"`
	N   *string `json:"n,omitempty"`
	P   *string `json:"p,omitempty"`
	Q   *string `json:"q,omitempty"`
	Qi  *string `json:"qi,omitempty"`

	// Use Use ("public key use") identifies the intended use of the public key. The "use" parameter is employed to indicate whether a public key is used for encrypting data or verifying the signature on data. Values are commonly "sig" (signature) or "enc" (encryption).
	Use string  `json:"use"`
	X   *string `json:"x,omitempty"`

	// X5c The "x5c" parameter in JSON Web Keys (JWK) includes a chain of one or more PKIX certificates, represented as a JSON array of base64-encoded DER certificate values. The first certificate must contain the key value and must match the public key represented by other JWK members. Additional certificates can follow, with each certifying the previous one. This parameter is optional.
	X5c *[]string `json:"x5c,omitempty"`
	Y   *string   `json:"y,omitempty"`
}

// JsonWebKeySet JSON Web Key Set
type JsonWebKeySet struct {
	// Keys List of JSON Web Keys The value of the "keys" parameter is an array of JSON Web Key (JWK) values. By default, the order of the JWK values within the array does not imply an order of preference among them, although applications  of JWK Sets can choose to assign a meaning to the order for their  purposes, if desired.
	Keys *[]JsonWebKey `json:"keys,omitempty"`
}

// ListClusters defines model for ListClusters.
type ListClusters struct {
	Items     *[]OpenShiftCluster `json:"items,omitempty"`
	TotalSize *int                `json:"totalSize,omitempty"`
}

// ListNodepools defines model for ListNodepools.
type ListNodepools struct {
	Items     *[]OpenShiftNodepool `json:"items,omitempty"`
	TotalSize *int                 `json:"totalSize,omitempty"`
}

// ListVersions defines model for ListVersions.
type ListVersions struct {
	Items     *[]OpenShiftVersion `json:"items,omitempty"`
	TotalSize *int                `json:"totalSize,omitempty"`
}

// LoginFlow This object represents a login flow. A login flow is initiated at the "Initiate Login API / Browser Flow"
// endpoint by a client.
//
// Once a login flow is completed successfully, a session cookie or session token will be issued.
type LoginFlow struct {
	// Active The active login method
	//
	// If set contains the login method used. If the flow is new, it is unset.
	// password CredentialsTypePassword
	// oidc CredentialsTypeOIDC
	// totp CredentialsTypeTOTP
	// lookup_secret CredentialsTypeLookup
	// webauthn CredentialsTypeWebAuthn
	// code CredentialsTypeCodeAuth
	// link_recovery CredentialsTypeRecoveryLink  CredentialsTypeRecoveryLink is a special credential type linked to the link strategy (recovery flow).  It is not used within the credentials object itself.
	// code_recovery CredentialsTypeRecoveryCode
	Active *LoginFlowActive `json:"active,omitempty"`

	// CreatedAt CreatedAt is a helper struct field for gobuffalo.pop.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// ExpiresAt ExpiresAt is the time (UTC) when the flow expires. If the user still wishes to log in,
	// a new flow has to be initiated.
	ExpiresAt time.Time `json:"expires_at"`

	// Id ID represents the flow's unique ID. When performing the login flow, this
	// represents the id in the login UI's query parameter: http://<selfservice.flows.login.ui_url>/?flow=<flow_id>
	Id openapi_types.UUID `json:"id"`

	// IssuedAt IssuedAt is the time (UTC) when the flow started.
	IssuedAt             time.Time `json:"issued_at"`
	Oauth2LoginChallenge *string   `json:"oauth2_login_challenge,omitempty"`

	// Oauth2LoginRequest OAuth2LoginRequest struct for OAuth2LoginRequest
	Oauth2LoginRequest *OAuth2LoginRequest `json:"oauth2_login_request,omitempty"`
	OrganizationId     *NullUUID           `json:"organization_id"`

	// Refresh Refresh stores whether this login flow should enforce re-authentication.
	Refresh *bool `json:"refresh,omitempty"`

	// RequestUrl RequestURL is the initial URL that was requested. It can be used
	// to forward information contained in the URL's path or query for example.
	RequestUrl string `json:"request_url"`

	// RequestedAal The authenticator assurance level can be one of "aal1", "aal2", or "aal3". A higher number means that it is harder
	// for an attacker to compromise the account.
	// Generally, "aal1" implies that one authentication factor was used while AAL2 implies that two factors (password + TOTP) have been used.
	RequestedAal *AuthenticatorAssuranceLevel `json:"requested_aal,omitempty"`

	// ReturnTo ReturnTo contains the requested return_to URL.
	ReturnTo *string `json:"return_to,omitempty"`

	// SessionTokenExchangeCode SessionTokenExchangeCode holds the secret code that the client can use to retrieve a session token after the login flow has been completed.
	// This is only set if the client has requested a session token exchange code, and if the flow is of type "api",
	// and only on creating the login flow.
	SessionTokenExchangeCode *string `json:"session_token_exchange_code,omitempty"`

	// State State represents the state of this request:
	//
	// choose_method: ask the user to choose a method to sign in with
	// sent_email: the email has been sent to the user
	// passed_challenge: the request was successful and the login challenge was passed.
	State interface{} `json:"state"`

	// Type The flow type can either be `api` or `browser`.
	Type SelfServiceFlowType `json:"type"`

	// Ui Container represents a HTML Form. The container can work with both HTTP Form and JSON requests.
	Ui UiContainer `json:"ui"`

	// UpdatedAt UpdatedAt is a helper struct field for gobuffalo.pop.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// LoginFlowActive The active login method
//
// If set contains the login method used. If the flow is new, it is unset.
// password CredentialsTypePassword
// oidc CredentialsTypeOIDC
// totp CredentialsTypeTOTP
// lookup_secret CredentialsTypeLookup
// webauthn CredentialsTypeWebAuthn
// code CredentialsTypeCodeAuth
// link_recovery CredentialsTypeRecoveryLink  CredentialsTypeRecoveryLink is a special credential type linked to the link strategy (recovery flow).  It is not used within the credentials object itself.
// code_recovery CredentialsTypeRecoveryCode
type LoginFlowActive string

// LogoutFlow Logout Flow
type LogoutFlow struct {
	// LogoutToken LogoutToken can be used to perform logout using AJAX.
	LogoutToken string `json:"logout_token"`

	// LogoutUrl LogoutURL can be opened in a browser to sign the user out.
	//
	// format: uri
	LogoutUrl string `json:"logout_url"`
}

// MutableSpace defines model for MutableSpace.
type MutableSpace struct {
	// Description Space description
	Description *string `json:"description,omitempty"`

	// Name Space name
	Name *string `json:"name,omitempty"`
}

// NodeProfile Node profiles
type NodeProfile string

// NullJsonRawMessage defines model for NullJsonRawMessage.
type NullJsonRawMessage = interface{}

// NullTime defines model for NullTime.
type NullTime = time.Time

// NullUUID defines model for NullUUID.
type NullUUID = string

// OAuth2Client OAuth2Client OAuth 2.0 Clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
type OAuth2Client struct {
	// AccessTokenStrategy OAuth 2.0 Access Token Strategy  AccessTokenStrategy is the strategy used to generate access tokens. Valid options are `jwt` and `opaque`. `jwt` is a bad idea.
	AccessTokenStrategy *string   `json:"access_token_strategy,omitempty"`
	AllowedCorsOrigins  *[]string `json:"allowed_cors_origins,omitempty"`
	Audience            *[]string `json:"audience,omitempty"`

	// AuthorizationCodeGrantAccessTokenLifespan Specify a time duration in milliseconds, seconds, minutes, hours.
	AuthorizationCodeGrantAccessTokenLifespan *string `json:"authorization_code_grant_access_token_lifespan,omitempty"`

	// AuthorizationCodeGrantIdTokenLifespan Specify a time duration in milliseconds, seconds, minutes, hours.
	AuthorizationCodeGrantIdTokenLifespan *string `json:"authorization_code_grant_id_token_lifespan,omitempty"`

	// AuthorizationCodeGrantRefreshTokenLifespan Specify a time duration in milliseconds, seconds, minutes, hours.
	AuthorizationCodeGrantRefreshTokenLifespan *string `json:"authorization_code_grant_refresh_token_lifespan,omitempty"`

	// BackchannelLogoutSessionRequired OpenID Connect Back-Channel Logout Session Required  Boolean value specifying whether the RP requires that a sid (session ID) Claim be included in the Logout Token to identify the RP session with the OP when the backchannel_logout_uri is used. If omitted, the default value is false.
	BackchannelLogoutSessionRequired *bool `json:"backchannel_logout_session_required,omitempty"`

	// BackchannelLogoutUri OpenID Connect Back-Channel Logout URI  RP URL that will cause the RP to log itself out when sent a Logout Token by the OP.
	BackchannelLogoutUri *string `json:"backchannel_logout_uri,omitempty"`

	// ClientCredentialsGrantAccessTokenLifespan Specify a time duration in milliseconds, seconds, minutes, hours.
	ClientCredentialsGrantAccessTokenLifespan *string `json:"client_credentials_grant_access_token_lifespan,omitempty"`

	// ClientId OAuth 2.0 Client ID  The ID is immutable. If no ID is provided, a UUID4 will be generated.
	ClientId *string `json:"client_id,omitempty"`

	// ClientName OAuth 2.0 Client Name  The human-readable name of the client to be presented to the end-user during authorization.
	ClientName *string `json:"client_name,omitempty"`

	// ClientSecret OAuth 2.0 Client Secret  The secret will be included in the create request as cleartext, and then never again. The secret is kept in hashed format and is not recoverable once lost.
	ClientSecret *string `json:"client_secret,omitempty"`

	// ClientSecretExpiresAt OAuth 2.0 Client Secret Expires At  The field is currently not supported and its value is always 0.
	ClientSecretExpiresAt *int64 `json:"client_secret_expires_at,omitempty"`

	// ClientUri OAuth 2.0 Client URI  ClientURI is a URL string of a web page providing information about the client. If present, the server SHOULD display this URL to the end-user in a clickable fashion.
	ClientUri *string   `json:"client_uri,omitempty"`
	Contacts  *[]string `json:"contacts,omitempty"`

	// CreatedAt OAuth 2.0 Client Creation Date  CreatedAt returns the timestamp of the client's creation.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// FrontchannelLogoutSessionRequired OpenID Connect Front-Channel Logout Session Required  Boolean value specifying whether the RP requires that iss (issuer) and sid (session ID) query parameters be included to identify the RP session with the OP when the frontchannel_logout_uri is used. If omitted, the default value is false.
	FrontchannelLogoutSessionRequired *bool `json:"frontchannel_logout_session_required,omitempty"`

	// FrontchannelLogoutUri OpenID Connect Front-Channel Logout URI  RP URL that will cause the RP to log itself out when rendered in an iframe by the OP. An iss (issuer) query parameter and a sid (session ID) query parameter MAY be included by the OP to enable the RP to validate the request and to determine which of the potentially multiple sessions is to be logged out; if either is included, both MUST be.
	FrontchannelLogoutUri *string   `json:"frontchannel_logout_uri,omitempty"`
	GrantTypes            *[]string `json:"grant_types,omitempty"`

	// ImplicitGrantAccessTokenLifespan Specify a time duration in milliseconds, seconds, minutes, hours.
	ImplicitGrantAccessTokenLifespan *string `json:"implicit_grant_access_token_lifespan,omitempty"`

	// ImplicitGrantIdTokenLifespan Specify a time duration in milliseconds, seconds, minutes, hours.
	ImplicitGrantIdTokenLifespan *string `json:"implicit_grant_id_token_lifespan,omitempty"`

	// Jwks OAuth 2.0 Client JSON Web Key Set  Client's JSON Web Key Set [JWK] document, passed by value. The semantics of the jwks parameter are the same as the jwks_uri parameter, other than that the JWK Set is passed by value, rather than by reference. This parameter is intended only to be used by Clients that, for some reason, are unable to use the jwks_uri parameter, for instance, by native applications that might not have a location to host the contents of the JWK Set. If a Client can use jwks_uri, it MUST NOT use jwks. One significant downside of jwks is that it does not enable key rotation (which jwks_uri does, as described in Section 10 of OpenID Connect Core 1.0 [OpenID.Core]). The jwks_uri and jwks parameters MUST NOT be used together.
	Jwks *interface{} `json:"jwks,omitempty"`

	// JwksUri OAuth 2.0 Client JSON Web Key Set URL  URL for the Client's JSON Web Key Set [JWK] document. If the Client signs requests to the Server, it contains the signing key(s) the Server uses to validate signatures from the Client. The JWK Set MAY also contain the Client's encryption keys(s), which are used by the Server to encrypt responses to the Client. When both signing and encryption keys are made available, a use (Key Use) parameter value is REQUIRED for all keys in the referenced JWK Set to indicate each key's intended usage. Although some algorithms allow the same key to be used for both signatures and encryption, doing so is NOT RECOMMENDED, as it is less secure. The JWK x5c parameter MAY be used to provide X.509 representations of keys provided. When used, the bare key values MUST still be present and MUST match those in the certificate.
	JwksUri *string `json:"jwks_uri,omitempty"`

	// JwtBearerGrantAccessTokenLifespan Specify a time duration in milliseconds, seconds, minutes, hours.
	JwtBearerGrantAccessTokenLifespan *string `json:"jwt_bearer_grant_access_token_lifespan,omitempty"`

	// LogoUri OAuth 2.0 Client Logo URI  A URL string referencing the client's logo.
	LogoUri  *string      `json:"logo_uri,omitempty"`
	Metadata *interface{} `json:"metadata,omitempty"`

	// Owner OAuth 2.0 Client Owner  Owner is a string identifying the owner of the OAuth 2.0 Client.
	Owner *string `json:"owner,omitempty"`

	// PolicyUri OAuth 2.0 Client Policy URI  PolicyURI is a URL string that points to a human-readable privacy policy document that describes how the deployment organization collects, uses, retains, and discloses personal data.
	PolicyUri              *string   `json:"policy_uri,omitempty"`
	PostLogoutRedirectUris *[]string `json:"post_logout_redirect_uris,omitempty"`
	RedirectUris           *[]string `json:"redirect_uris,omitempty"`

	// RefreshTokenGrantAccessTokenLifespan Specify a time duration in milliseconds, seconds, minutes, hours.
	RefreshTokenGrantAccessTokenLifespan *string `json:"refresh_token_grant_access_token_lifespan,omitempty"`

	// RefreshTokenGrantIdTokenLifespan Specify a time duration in milliseconds, seconds, minutes, hours.
	RefreshTokenGrantIdTokenLifespan *string `json:"refresh_token_grant_id_token_lifespan,omitempty"`

	// RefreshTokenGrantRefreshTokenLifespan Specify a time duration in milliseconds, seconds, minutes, hours.
	RefreshTokenGrantRefreshTokenLifespan *string `json:"refresh_token_grant_refresh_token_lifespan,omitempty"`

	// RegistrationAccessToken OpenID Connect Dynamic Client Registration Access Token  RegistrationAccessToken can be used to update, get, or delete the OAuth2 Client. It is sent when creating a client using Dynamic Client Registration.
	RegistrationAccessToken *string `json:"registration_access_token,omitempty"`

	// RegistrationClientUri OpenID Connect Dynamic Client Registration URL  RegistrationClientURI is the URL used to update, get, or delete the OAuth2 Client.
	RegistrationClientUri *string `json:"registration_client_uri,omitempty"`

	// RequestObjectSigningAlg OpenID Connect Request Object Signing Algorithm  JWS [JWS] alg algorithm [JWA] that MUST be used for signing Request Objects sent to the OP. All Request Objects from this Client MUST be rejected, if not signed with this algorithm.
	RequestObjectSigningAlg *string   `json:"request_object_signing_alg,omitempty"`
	RequestUris             *[]string `json:"request_uris,omitempty"`
	ResponseTypes           *[]string `json:"response_types,omitempty"`

	// Scope OAuth 2.0 Client Scope  Scope is a string containing a space-separated list of scope values (as described in Section 3.3 of OAuth 2.0 [RFC6749]) that the client can use when requesting access tokens.
	Scope *string `json:"scope,omitempty"`

	// SectorIdentifierUri OpenID Connect Sector Identifier URI  URL using the https scheme to be used in calculating Pseudonymous Identifiers by the OP. The URL references a file with a single JSON array of redirect_uri values.
	SectorIdentifierUri *string `json:"sector_identifier_uri,omitempty"`

	// SkipConsent SkipConsent skips the consent screen for this client. This field can only be set from the admin API.
	SkipConsent *bool `json:"skip_consent,omitempty"`

	// SkipLogoutConsent SkipLogoutConsent skips the logout consent screen for this client. This field can only be set from the admin API.
	SkipLogoutConsent *bool `json:"skip_logout_consent,omitempty"`

	// SubjectType OpenID Connect Subject Type  The `subject_types_supported` Discovery parameter contains a list of the supported subject_type values for this server. Valid types include `pairwise` and `public`.
	SubjectType *string `json:"subject_type,omitempty"`

	// TokenEndpointAuthMethod OAuth 2.0 Token Endpoint Authentication Method  Requested Client Authentication method for the Token Endpoint. The options are:  `client_secret_basic`: (default) Send `client_id` and `client_secret` as `application/x-www-form-urlencoded` encoded in the HTTP Authorization header. `client_secret_post`: Send `client_id` and `client_secret` as `application/x-www-form-urlencoded` in the HTTP body. `private_key_jwt`: Use JSON Web Tokens to authenticate the client. `none`: Used for public clients (native apps, mobile apps) which can not have secrets.
	TokenEndpointAuthMethod *string `json:"token_endpoint_auth_method,omitempty"`

	// TokenEndpointAuthSigningAlg OAuth 2.0 Token Endpoint Signing Algorithm  Requested Client Authentication signing algorithm for the Token Endpoint.
	TokenEndpointAuthSigningAlg *string `json:"token_endpoint_auth_signing_alg,omitempty"`

	// TosUri OAuth 2.0 Client Terms of Service URI  A URL string pointing to a human-readable terms of service document for the client that describes a contractual relationship between the end-user and the client that the end-user accepts when authorizing the client.
	TosUri *string `json:"tos_uri,omitempty"`

	// UpdatedAt OAuth 2.0 Client Last Update Date  UpdatedAt returns the timestamp of the last update.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// UserinfoSignedResponseAlg OpenID Connect Request Userinfo Signed Response Algorithm  JWS alg algorithm [JWA] REQUIRED for signing UserInfo Responses. If this is specified, the response will be JWT [JWT] serialized, and signed using JWS. The default, if omitted, is for the UserInfo Response to return the Claims as a UTF-8 encoded JSON object using the application/json content-type.
	UserinfoSignedResponseAlg *string `json:"userinfo_signed_response_alg,omitempty"`
}

// OAuth2ConsentRequestOpenIDConnectContext OAuth2ConsentRequestOpenIDConnectContext struct
type OAuth2ConsentRequestOpenIDConnectContext struct {
	// AcrValues ACRValues is the Authentication AuthorizationContext Class Reference requested in the OAuth 2.0 Authorization request. It is a parameter defined by OpenID Connect and expresses which level of authentication (e.g. 2FA) is required.  OpenID Connect defines it as follows: > Requested Authentication AuthorizationContext Class Reference values. Space-separated string that specifies the acr values that the Authorization Server is being requested to use for processing this Authentication Request, with the values appearing in order of preference. The Authentication AuthorizationContext Class satisfied by the authentication performed is returned as the acr Claim Value, as specified in Section 2. The acr Claim is requested as a Voluntary Claim by this parameter.
	AcrValues *[]string `json:"acr_values,omitempty"`

	// Display Display is a string value that specifies how the Authorization Server displays the authentication and consent user interface pages to the End-User. The defined values are: page: The Authorization Server SHOULD display the authentication and consent UI consistent with a full User Agent page view. If the display parameter is not specified, this is the default display mode. popup: The Authorization Server SHOULD display the authentication and consent UI consistent with a popup User Agent window. The popup User Agent window should be of an appropriate size for a login-focused dialog and should not obscure the entire window that it is popping up over. touch: The Authorization Server SHOULD display the authentication and consent UI consistent with a device that leverages a touch interface. wap: The Authorization Server SHOULD display the authentication and consent UI consistent with a \"feature phone\" type display.  The Authorization Server MAY also attempt to detect the capabilities of the User Agent and present an appropriate display.
	Display *string `json:"display,omitempty"`

	// IdTokenHintClaims IDTokenHintClaims are the claims of the ID Token previously issued by the Authorization Server being passed as a hint about the End-User's current or past authenticated session with the Client.
	IdTokenHintClaims *map[string]interface{} `json:"id_token_hint_claims,omitempty"`

	// LoginHint LoginHint hints about the login identifier the End-User might use to log in (if necessary). This hint can be used by an RP if it first asks the End-User for their e-mail address (or other identifier) and then wants to pass that value as a hint to the discovered authorization service. This value MAY also be a phone number in the format specified for the phone_number Claim. The use of this parameter is optional.
	LoginHint *string `json:"login_hint,omitempty"`

	// UiLocales UILocales is the End-User'id preferred languages and scripts for the user interface, represented as a space-separated list of BCP47 [RFC5646] language tag values, ordered by preference. For instance, the value \"fr-CA fr en\" represents a preference for French as spoken in Canada, then French (without a region designation), followed by English (without a region designation). An error SHOULD NOT result if some or all of the requested locales are not supported by the OpenID Provider.
	UiLocales *[]string `json:"ui_locales,omitempty"`
}

// OAuth2LoginRequest OAuth2LoginRequest struct for OAuth2LoginRequest
type OAuth2LoginRequest struct {
	// Challenge ID is the identifier (\"login challenge\") of the login request. It is used to identify the session.
	Challenge *string `json:"challenge,omitempty"`

	// Client OAuth2Client OAuth 2.0 Clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
	Client *OAuth2Client `json:"client,omitempty"`

	// OidcContext OAuth2ConsentRequestOpenIDConnectContext struct
	OidcContext *OAuth2ConsentRequestOpenIDConnectContext `json:"oidc_context,omitempty"`

	// RequestUrl RequestURL is the original OAuth 2.0 Authorization URL requested by the OAuth 2.0 client. It is the URL which initiates the OAuth 2.0 Authorization Code or OAuth 2.0 Implicit flow. This URL is typically not needed, but might come in handy if you want to deal with additional request parameters.
	RequestUrl                   *string   `json:"request_url,omitempty"`
	RequestedAccessTokenAudience *[]string `json:"requested_access_token_audience,omitempty"`
	RequestedScope               *[]string `json:"requested_scope,omitempty"`

	// SessionId SessionID is the login session ID. If the user-agent reuses a login session (via cookie / remember flag) this ID will remain the same. If the user-agent did not have an existing authentication session (e.g. remember is false) this will be a new random value. This value is used as the \"sid\" parameter in the ID Token and in OIDC Front-/Back- channel logout. It's value can generally be used to associate consecutive login requests by a certain user.
	SessionId *string `json:"session_id,omitempty"`

	// Skip Skip, if true, implies that the client has requested the same scopes from the same user previously. If true, you can skip asking the user to grant the requested scopes, and simply forward the user to the redirect URL.  This feature allows you to update / set session information.
	Skip *bool `json:"skip,omitempty"`

	// Subject Subject is the user ID of the end-user that authenticated. Now, that end user needs to grant or deny the scope requested by the OAuth 2.0 client. If this value is set and `skip` is true, you MUST include this subject type when accepting the login request, or the request will fail.
	Subject *string `json:"subject,omitempty"`
}

// OidcConfiguration Includes links to several endpoints and exposes information on supported signature algorithms among others.
type OidcConfiguration struct {
	// AuthorizationEndpoint OAuth 2.0 Authorization Endpoint URL
	AuthorizationEndpoint string `json:"authorization_endpoint"`

	// BackchannelLogoutSessionSupported OpenID Connect Back-Channel Logout Session Required
	// Boolean value specifying whether the OP can pass a sid (session ID) Claim in the Logout Token to identify the RP session with the OP. If supported, the sid Claim is also included in ID Tokens issued by the OP.
	BackchannelLogoutSessionSupported *bool `json:"backchannel_logout_session_supported,omitempty"`

	// BackchannelLogoutSupported OpenID Connect Back-Channel Logout Supported
	// Boolean value specifying whether the OP supports back-channel logout, with true indicating support.
	BackchannelLogoutSupported *bool `json:"backchannel_logout_supported,omitempty"`

	// ClaimsParameterSupported OpenID Connect Claims Parameter Parameter Supported
	// Boolean value specifying whether the OP supports use of the claims parameter, with true indicating support.
	ClaimsParameterSupported *bool `json:"claims_parameter_supported,omitempty"`

	// ClaimsSupported OpenID Connect Supported Claims
	// JSON array containing a list of the Claim Names of the Claims that the OpenID Provider MAY be able to supply values for. Note that for privacy or other reasons, this might not be an exhaustive list.
	ClaimsSupported *[]string `json:"claims_supported,omitempty"`

	// CodeChallengeMethodsSupported OAuth 2.0 PKCE Supported Code Challenge Methods
	// JSON array containing a list of Proof Key for Code Exchange (PKCE) [RFC7636] code challenge methods supported by this authorization server.
	CodeChallengeMethodsSupported *[]string `json:"code_challenge_methods_supported,omitempty"`

	// CredentialsEndpointDraft00 OpenID Connect Verifiable Credentials Endpoint
	//
	// Contains the URL of the Verifiable Credentials Endpoint.
	CredentialsEndpointDraft00 *string `json:"credentials_endpoint_draft_00,omitempty"`

	// CredentialsSupportedDraft00 OpenID Connect Verifiable Credentials Supported
	// JSON array containing a list of the Verifiable Credentials supported by this authorization server.
	CredentialsSupportedDraft00 *[]CredentialSupportedDraft00 `json:"credentials_supported_draft_00,omitempty"`

	// EndSessionEndpoint OpenID Connect End-Session Endpoint
	// An URL provided by the OpenID Provider (OP) that a Relying Party (RP) can redirect to, to initiate a logout process for the End-User at the OP. This is part of the OpenID Connect session management functionality,  allowing for single sign-out across applications.
	EndSessionEndpoint *string `json:"end_session_endpoint,omitempty"`

	// FrontchannelLogoutSessionSupported OpenID Connect Front-Channel Logout Session Required
	// The boolean indicates if the OpenID Provider (OP) can use issuer (iss) and session ID (sid) parameters to identify the Relying Party (RP) session during logout via the  frontchannel_logout_uri. If this is supported, the sid claim is also included in ID Tokens issued by the OP.
	FrontchannelLogoutSessionSupported *bool `json:"frontchannel_logout_session_supported,omitempty"`

	// FrontchannelLogoutSupported OpenID Connect Front-Channel Logout Supported
	// Boolean value specifying whether the OP supports HTTP-based logout, with true indicating support.
	FrontchannelLogoutSupported *bool `json:"frontchannel_logout_supported,omitempty"`

	// GrantTypesSupported OAuth 2.0 Supported Grant Types
	// JSON array containing a list of the OAuth 2.0 Grant Type values that this OP supports.
	GrantTypesSupported *[]string `json:"grant_types_supported,omitempty"`

	// IdTokenSignedResponseAlg OpenID Connect Default ID Token Signing Algorithms
	//
	// Algorithm used to sign OpenID Connect ID Tokens.
	IdTokenSignedResponseAlg []string `json:"id_token_signed_response_alg"`

	// IdTokenSigningAlgValuesSupported OpenID Connect Supported ID Token Signing Algorithms
	//
	// JSON array containing a list of the JWS signing algorithms (alg values) supported by the OP for the ID Token to encode the Claims in a JWT.
	IdTokenSigningAlgValuesSupported []string `json:"id_token_signing_alg_values_supported"`

	// Issuer OpenID Connect Issuer URL
	// An URL using the https scheme with no query or fragment component that the OP asserts as its IssuerURL Identifier. If IssuerURL discovery is supported, this value MUST be identical to the issuer value returned by WebFinger. This also MUST be identical to the iss Claim value in ID Tokens issued from this IssuerURL.
	Issuer string `json:"issuer"`

	// JwksUri OpenID Connect Well-Known JSON Web Keys URL
	// The jwks_uri is the URL for the OpenID Provider's (OP) JSON Web Key Set (JWK) document, which contains the keys used by the Relying Party (RP) to validate the OP's signatures and, optionally, encrypt requests. Each key must specify its use (signing or encryption) for security purposes. The JWK set may include X.509  representations of keys via the x5c parameter, but the bare key values must still be present and match those in the certificate.
	JwksUri string `json:"jwks_uri"`

	// RegistrationEndpoint OpenID Connect Dynamic Client Registration Endpoint URL
	RegistrationEndpoint *string `json:"registration_endpoint,omitempty"`

	// RequestObjectSigningAlgValuesSupported OpenID Connect Supported Request Object Signing Algorithms
	// JSON array containing a list of the JWS signing algorithms (alg values) supported by the OP for Request Objects, which are described in Section 6.1 of OpenID Connect Core 1.0 [OpenID.Core]. These algorithms are used both when the Request Object is passed by value (using the request parameter) and when it is passed by reference (using the request_uri parameter).
	RequestObjectSigningAlgValuesSupported *[]string `json:"request_object_signing_alg_values_supported,omitempty"`

	// RequestParameterSupported OpenID Connect Request Parameter Supported
	// Boolean value specifying whether the OP supports use of the request parameter, with true indicating support.
	RequestParameterSupported *bool `json:"request_parameter_supported,omitempty"`

	// RequestUriParameterSupported OpenID Connect Request URI Parameter Supported
	// Boolean value specifying whether the OP supports use of the request_uri parameter, with true indicating support.
	RequestUriParameterSupported *bool `json:"request_uri_parameter_supported,omitempty"`

	// RequireRequestUriRegistration OpenID Connect Requires Request URI Registration
	// Boolean value specifying whether the OP requires any request_uri values used to be pre-registered using the request_uris registration parameter.
	RequireRequestUriRegistration *bool `json:"require_request_uri_registration,omitempty"`

	// ResponseModesSupported OAuth 2.0 Supported Response Modes
	// JSON array containing a list of the OAuth 2.0 response_mode values that this OP supports.
	ResponseModesSupported *[]string `json:"response_modes_supported,omitempty"`

	// ResponseTypesSupported OAuth 2.0 Supported Response Types
	// JSON array containing a list of the OAuth 2.0 response_type values that this OP supports. Dynamic OpenID Providers MUST support the code, id_token, and the token id_token Response Type values.
	ResponseTypesSupported []string `json:"response_types_supported"`

	// RevocationEndpoint OAuth 2.0 Token Revocation URL
	//
	// URL of the authorization server's OAuth 2.0 revocation endpoint.
	RevocationEndpoint *string `json:"revocation_endpoint,omitempty"`

	// ScopesSupported OAuth 2.0 Supported Scope Values
	// JSON array containing a list of the OAuth 2.0 [RFC6749] scope values that this server supports. The server MUST support the openid scope value. Servers MAY choose not to advertise some supported scope values even when this parameter is used
	ScopesSupported *[]string `json:"scopes_supported,omitempty"`

	// SubjectTypesSupported OpenID Connect Supported Subject Types
	// JSON array containing a list of the Subject Identifier types that this OP supports. Valid types include pairwise and public.
	SubjectTypesSupported []string `json:"subject_types_supported"`

	// TokenEndpoint OAuth 2.0 Token Endpoint URL
	TokenEndpoint string `json:"token_endpoint"`

	// TokenEndpointAuthMethodsSupported OAuth 2.0 Supported Client Authentication Methods
	//
	// JSON array containing a list of Client Authentication methods supported by this Token Endpoint. The options are client_secret_post, client_secret_basic, client_secret_jwt, and private_key_jwt, as described in Section 9 of OpenID Connect Core 1.0
	TokenEndpointAuthMethodsSupported *[]string `json:"token_endpoint_auth_methods_supported,omitempty"`

	// UserinfoEndpoint OpenID Connect Userinfo URL
	//
	// URL of the OP's UserInfo Endpoint.
	UserinfoEndpoint *string `json:"userinfo_endpoint,omitempty"`

	// UserinfoSignedResponseAlg OpenID Connect User Userinfo Signing Algorithm
	//
	// Algorithm used to sign OpenID Connect Userinfo Responses.
	UserinfoSignedResponseAlg []string `json:"userinfo_signed_response_alg"`

	// UserinfoSigningAlgValuesSupported OpenID Connect Supported Userinfo Signing Algorithm
	// JSON array containing a list of the JWS [JWS] signing algorithms (alg values) [JWA] supported by the UserInfo Endpoint to encode the Claims in a JWT [JWT].
	UserinfoSigningAlgValuesSupported *[]string `json:"userinfo_signing_alg_values_supported,omitempty"`
}

// OpenShiftCluster defines model for OpenShiftCluster.
type OpenShiftCluster struct {
	Cidr        *string               `json:"cidr,omitempty"`
	Description *string               `json:"description,omitempty"`
	Id          *openapi_types.UUID   `json:"id,omitempty"`
	Name        *string               `json:"name,omitempty"`
	NodePools   *[]OpenShiftNodepool  `json:"nodePools,omitempty"`
	Urls        *OpenShiftClusterUrls `json:"urls,omitempty"`
	Version     *string               `json:"version,omitempty"`
}

// OpenShiftClusterUrls defines model for OpenShiftClusterUrls.
type OpenShiftClusterUrls struct {
	Api     *string `json:"api,omitempty"`
	Console *string `json:"console,omitempty"`
}

// OpenShiftNodepool defines model for OpenShiftNodepool.
type OpenShiftNodepool struct {
	// Gpu GPU values
	Gpu       *Gpu   `json:"gpu,omitempty"`
	Name      string `json:"name"`
	NodeCount int    `json:"nodeCount"`

	// NodeProfile Node profiles
	NodeProfile NodeProfile `json:"nodeProfile"`
	Tina        *string     `json:"tina,omitempty"`
}

// OpenShiftVersion defines model for OpenShiftVersion.
type OpenShiftVersion struct {
	Name    *string `json:"name,omitempty"`
	Version string  `json:"version"`
}

// Operation defines model for Operation.
type Operation struct {
	CreateTime *time.Time          `json:"createTime,omitempty"`
	Data       *Operation_Data     `json:"data,omitempty"`
	EndTime    *time.Time          `json:"endTime,omitempty"`
	Error      *Operation_Error    `json:"error,omitempty"`
	Id         *openapi_types.UUID `json:"id,omitempty"`
	Progress   *Operation_Progress `json:"progress,omitempty"`
	Result     *Operation_Result   `json:"result,omitempty"`
	SelfLink   *string             `json:"selfLink,omitempty"`
	StartTime  *time.Time          `json:"startTime,omitempty"`

	// Status Operation status
	Status     *OperationStatus `json:"status,omitempty"`
	TargetLink *string          `json:"targetLink,omitempty"`
	Type       *string          `json:"type,omitempty"`
}

// OperationData0 defines model for .
type OperationData0 = string

// OperationData1 defines model for .
type OperationData1 map[string]interface{}

// Operation_Data defines model for Operation.Data.
type Operation_Data struct {
	union json.RawMessage
}

// OperationError0 defines model for .
type OperationError0 = string

// OperationError1 defines model for .
type OperationError1 map[string]interface{}

// Operation_Error defines model for Operation.Error.
type Operation_Error struct {
	union json.RawMessage
}

// OperationProgress0 defines model for .
type OperationProgress0 = string

// OperationProgress1 defines model for .
type OperationProgress1 map[string]interface{}

// Operation_Progress defines model for Operation.Progress.
type Operation_Progress struct {
	union json.RawMessage
}

// OperationResult0 defines model for .
type OperationResult0 = string

// OperationResult1 defines model for .
type OperationResult1 map[string]interface{}

// Operation_Result defines model for Operation.Result.
type Operation_Result struct {
	union json.RawMessage
}

// OperationStatus Operation status
type OperationStatus string

// Operations defines model for Operations.
type Operations struct {
	Items     *[]Operation `json:"items,omitempty"`
	TotalSize *int         `json:"totalSize,omitempty"`
}

// OrganisationSimple defines model for OrganisationSimple.
type OrganisationSimple struct {
	// Id Organisation identifier
	Id openapi_types.UUID `json:"id"`
}

// OrganisationSimplePaginatedList defines model for OrganisationSimplePaginatedList.
type OrganisationSimplePaginatedList struct {
	Items []OrganisationSimple `json:"items"`

	// NextPageToken This token is used to retrieve the next page. If this field is omitted, there are no subsequent pages.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// TotalSize Equivalent to int32
	TotalSize *Int `json:"totalSize,omitempty"`
}

// PaginatedList Represent the common attributes of a paginated list, to be used in an allOf with the specific items attribute of the desired type.
type PaginatedList struct {
	// NextPageToken This token is used to retrieve the next page. If this field is omitted, there are no subsequent pages.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// TotalSize Equivalent to int32
	TotalSize *Int `json:"totalSize,omitempty"`
}

// PerformNativeLogoutBody Perform Native Logout Request Body
type PerformNativeLogoutBody struct {
	// SessionToken The Session Token
	//
	// Invalidate this session token.
	SessionToken string `json:"session_token"`
}

// Permission A permission in the <service>[.<resource>.[<subResource>](0,1)](0,1).<action> form
type Permission struct {
	// Action Allowed operation type
	Action string `json:"action"`

	// Description Human-readable description
	Description string `json:"description"`

	// Name Human-readable name
	Name     string  `json:"name"`
	Resource *string `json:"resource,omitempty"`

	// Service Service name
	Service     string  `json:"service"`
	SubResource *string `json:"subResource,omitempty"`
}

// PermissionsPaginatedList defines model for PermissionsPaginatedList.
type PermissionsPaginatedList struct {
	Items []RegisteredPermission `json:"items"`

	// NextPageToken This token is used to retrieve the next page. If this field is omitted, there are no subsequent pages.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// TotalSize Equivalent to int32
	TotalSize *Int `json:"totalSize,omitempty"`
}

// RecoveryAddressType RecoveryAddressType must not exceed 16 characters as that is the limitation in the SQL Schema.
type RecoveryAddressType = string

// RecoveryFlow This request is used when an identity wants to recover their account.
type RecoveryFlow struct {
	// Active Active, if set, contains the recovery method that is being used. It is initially not set.
	Active *string `json:"active,omitempty"`

	// ContinueWith Contains possible actions that could follow this flow
	ContinueWith *[]ContinueWith `json:"continue_with,omitempty"`

	// ExpiresAt ExpiresAt is the time (UTC) when the request expires. If the user still wishes to update the setting, a new request has to be initiated.
	ExpiresAt time.Time `json:"expires_at"`

	// Id ID represents the request's unique ID.
	Id openapi_types.UUID `json:"id"`

	// IssuedAt IssuedAt is the time (UTC) when the request occurred.
	IssuedAt time.Time `json:"issued_at"`

	// RequestUrl RequestURL is the initial URL that was requested. It can be used
	// to forward information contained in the URL's path or query for example.
	RequestUrl string `json:"request_url"`

	// ReturnTo ReturnTo contains the requested return_to URL.
	ReturnTo *string `json:"return_to,omitempty"`

	// State State represents the state of this request:
	// choose_method: ask the user to choose a method (e.g. recover account via email)
	// sent_email: the email has been sent to the user
	// passed_challenge: the request was successful and the recovery challenge was passed.
	State interface{} `json:"state"`

	// Type The flow type can either be `api` or `browser`.
	Type SelfServiceFlowType `json:"type"`

	// Ui Container represents a HTML Form. The container can work with both HTTP Form and JSON requests.
	Ui UiContainer `json:"ui"`
}

// RecoveryIdentityAddress defines model for RecoveryIdentityAddress.
type RecoveryIdentityAddress struct {
	// CreatedAt CreatedAt is a helper struct field for gobuffalo.pop.
	CreatedAt *time.Time         `json:"created_at,omitempty"`
	Id        openapi_types.UUID `json:"id"`

	// UpdatedAt UpdatedAt is a helper struct field for gobuffalo.pop.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
	Value     string     `json:"value"`

	// Via RecoveryAddressType must not exceed 16 characters as that is the limitation in the SQL Schema.
	Via RecoveryAddressType `json:"via"`
}

// RecoveryLink defines model for RecoveryLink.
type RecoveryLink struct {
	Expiration DateTime `json:"expiration"`

	// Link Recovery link correctly generated
	Link string `json:"link"`
}

// Registered defines model for Registered.
type Registered struct {
	// CreatedOn creation date
	CreatedOn time.Time `json:"createdOn"`

	// UpdatedOn last update
	UpdatedOn time.Time `json:"updatedOn"`

	// Uuid Internal ID
	Uuid openapi_types.UUID `json:"uuid"`
}

// RegisteredPermission defines model for RegisteredPermission.
type RegisteredPermission struct {
	// Action Allowed operation type
	Action string `json:"action"`

	// CreatedOn creation date
	CreatedOn time.Time `json:"createdOn"`

	// Description Human-readable description
	Description string `json:"description"`

	// Name Human-readable name
	Name     string  `json:"name"`
	Resource *string `json:"resource,omitempty"`

	// Service Service name
	Service     string  `json:"service"`
	SubResource *string `json:"subResource,omitempty"`

	// UpdatedOn last update
	UpdatedOn time.Time `json:"updatedOn"`

	// Uuid Internal ID
	Uuid openapi_types.UUID `json:"uuid"`
}

// RegisteredRole defines model for RegisteredRole.
type RegisteredRole struct {
	// CreatedOn creation date
	CreatedOn time.Time `json:"createdOn"`

	// Description Human-readable description
	Description string `json:"description"`

	// Name Human-readable name
	Name string `json:"name"`

	// UpdatedOn last update
	UpdatedOn time.Time `json:"updatedOn"`

	// Uuid Internal ID
	Uuid openapi_types.UUID `json:"uuid"`
}

// RegistrationFlow defines model for RegistrationFlow.
type RegistrationFlow struct {
	// Active Active, if set, contains the registration method that is being used. It is initially
	// not set.
	// password CredentialsTypePassword
	// oidc CredentialsTypeOIDC
	// totp CredentialsTypeTOTP
	// lookup_secret CredentialsTypeLookup
	// webauthn CredentialsTypeWebAuthn
	// code CredentialsTypeCodeAuth
	// link_recovery CredentialsTypeRecoveryLink  CredentialsTypeRecoveryLink is a special credential type linked to the link strategy (recovery flow).  It is not used within the credentials object itself.
	// code_recovery CredentialsTypeRecoveryCode
	Active *RegistrationFlowActive `json:"active,omitempty"`

	// ExpiresAt ExpiresAt is the time (UTC) when the flow expires. If the user still wishes to log in,
	// a new flow has to be initiated.
	ExpiresAt time.Time `json:"expires_at"`

	// Id ID represents the flow's unique ID. When performing the registration flow, this
	// represents the id in the registration ui's query parameter: http://<selfservice.flows.registration.ui_url>/?flow=<id>
	Id openapi_types.UUID `json:"id"`

	// IssuedAt IssuedAt is the time (UTC) when the flow occurred.
	IssuedAt             time.Time `json:"issued_at"`
	Oauth2LoginChallenge *string   `json:"oauth2_login_challenge,omitempty"`

	// Oauth2LoginRequest OAuth2LoginRequest struct for OAuth2LoginRequest
	Oauth2LoginRequest *OAuth2LoginRequest `json:"oauth2_login_request,omitempty"`
	OrganizationId     *NullUUID           `json:"organization_id"`

	// RequestUrl RequestURL is the initial URL that was requested. It can be used
	// to forward information contained in the URL's path or query for example.
	RequestUrl string `json:"request_url"`

	// ReturnTo ReturnTo contains the requested return_to URL.
	ReturnTo *string `json:"return_to,omitempty"`

	// SessionTokenExchangeCode SessionTokenExchangeCode holds the secret code that the client can use to retrieve a session token after the flow has been completed.
	// This is only set if the client has requested a session token exchange code, and if the flow is of type "api",
	// and only on creating the flow.
	SessionTokenExchangeCode *string `json:"session_token_exchange_code,omitempty"`

	// State State represents the state of this request:
	// choose_method: ask the user to choose a method (e.g. registration with email)
	// sent_email: the email has been sent to the user
	// passed_challenge: the request was successful and the registration challenge was passed.
	State interface{} `json:"state"`

	// TransientPayload TransientPayload is used to pass data from the registration to a webhook
	TransientPayload *map[string]interface{} `json:"transient_payload,omitempty"`

	// Type The flow type can either be `api` or `browser`.
	Type SelfServiceFlowType `json:"type"`

	// Ui Container represents a HTML Form. The container can work with both HTTP Form and JSON requests.
	Ui UiContainer `json:"ui"`
}

// RegistrationFlowActive Active, if set, contains the registration method that is being used. It is initially
// not set.
// password CredentialsTypePassword
// oidc CredentialsTypeOIDC
// totp CredentialsTypeTOTP
// lookup_secret CredentialsTypeLookup
// webauthn CredentialsTypeWebAuthn
// code CredentialsTypeCodeAuth
// link_recovery CredentialsTypeRecoveryLink  CredentialsTypeRecoveryLink is a special credential type linked to the link strategy (recovery flow).  It is not used within the credentials object itself.
// code_recovery CredentialsTypeRecoveryCode
type RegistrationFlowActive string

// ReqUpdateNodepool defines model for ReqUpdateNodepool.
type ReqUpdateNodepool struct {
	Count int `json:"count"`
}

// ResCreateCluster defines model for ResCreateCluster.
type ResCreateCluster struct {
	Id        *openapi_types.UUID `json:"id,omitempty"`
	Name      *string             `json:"name,omitempty"`
	Operation *Operation          `json:"operation,omitempty"`
}

// ResCreateNodepool defines model for ResCreateNodepool.
type ResCreateNodepool struct {
	ClusterId    *string    `json:"clusterId,omitempty"`
	NodePoolName *string    `json:"nodePoolName,omitempty"`
	Operation    *Operation `json:"operation,omitempty"`
}

// ResDeleteCluster defines model for ResDeleteCluster.
type ResDeleteCluster struct {
	Name      *string    `json:"name,omitempty"`
	Operation *Operation `json:"operation,omitempty"`
}

// RespUpdateNodepool defines model for RespUpdateNodepool.
type RespUpdateNodepool struct {
	ClusterId    *string    `json:"clusterId,omitempty"`
	NodePoolName *string    `json:"nodePoolName,omitempty"`
	Operation    *Operation `json:"operation,omitempty"`
}

// Role A role, linked to 1 or more permissions
type Role struct {
	// Description Human-readable description
	Description string `json:"description"`

	// Name Human-readable name
	Name string `json:"name"`
}

// RolePermission defines model for RolePermission.
type RolePermission struct {
	// Permissions List of permissions UUIDs
	Permissions []openapi_types.UUID `json:"permissions"`
}

// RolesPaginatedList defines model for RolesPaginatedList.
type RolesPaginatedList struct {
	Items []RegisteredRole `json:"items"`

	// NextPageToken This token is used to retrieve the next page. If this field is omitted, there are no subsequent pages.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// TotalSize Equivalent to int32
	TotalSize *Int `json:"totalSize,omitempty"`
}

// SelfServiceFlowType The flow type can either be `api` or `browser`.
type SelfServiceFlowType = string

// ServiceAccount defines model for ServiceAccount.
type ServiceAccount struct {
	// Name Service account name
	Name string `json:"name"`
}

// ServiceAccountEdited defines model for ServiceAccountEdited.
type ServiceAccountEdited struct {
	// Id Service account ID
	Id string `json:"id"`

	// Name Service Accounts name
	Name string `json:"name"`
}

// ServiceAccountPaginatedList defines model for ServiceAccountPaginatedList.
type ServiceAccountPaginatedList struct {
	Items []ServiceAccountEdited `json:"items"`

	// NextPageToken This token is used to retrieve the next page. If this field is omitted, there are no subsequent pages.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// TotalSize Equivalent to int32
	TotalSize *Int `json:"totalSize,omitempty"`
}

// Session A Session
type Session struct {
	// Active Active state. If false the session is no longer active.
	Active *bool `json:"active,omitempty"`

	// AuthenticatedAt The Session Authentication Timestamp
	//
	// When this session was authenticated at. If multi-factor authentication was used this
	// is the time when the last factor was authenticated (e.g. the TOTP code challenge was completed).
	AuthenticatedAt *time.Time `json:"authenticated_at,omitempty"`

	// AuthenticationMethods A list of authenticators which were used to authenticate the session.
	AuthenticationMethods *SessionAuthenticationMethods `json:"authentication_methods,omitempty"`

	// AuthenticatorAssuranceLevel The authenticator assurance level can be one of "aal1", "aal2", or "aal3". A higher number means that it is harder
	// for an attacker to compromise the account.
	// Generally, "aal1" implies that one authentication factor was used while AAL2 implies that two factors (password + TOTP) have been used.
	AuthenticatorAssuranceLevel *AuthenticatorAssuranceLevel `json:"authenticator_assurance_level,omitempty"`

	// Devices Devices has history of all endpoints where the session was used
	Devices *[]SessionDevice `json:"devices,omitempty"`

	// ExpiresAt The Session Expiry
	//
	// When this session expires at.
	ExpiresAt *time.Time `json:"expires_at,omitempty"`

	// Id Session ID
	Id openapi_types.UUID `json:"id"`

	// Identity An identity represents a (human) user.
	Identity *Identity `json:"identity,omitempty"`

	// IssuedAt The Session Issuance Timestamp
	//
	// When this session was issued at. Usually equal or close to `authenticated_at`.
	IssuedAt *time.Time `json:"issued_at,omitempty"`

	// Tokenized Tokenized is the tokenized (e.g. JWT) version of the session.
	//
	// It is only set when the `tokenize` query parameter was set to a valid tokenize template during calls to `/session/whoami`.
	Tokenized *string `json:"tokenized,omitempty"`
}

// SessionAuthenticationMethod A singular authenticator used during authentication / login.
type SessionAuthenticationMethod struct {
	// Aal The authenticator assurance level can be one of "aal1", "aal2", or "aal3". A higher number means that it is harder
	// for an attacker to compromise the account.
	// Generally, "aal1" implies that one authentication factor was used while AAL2 implies that two factors (password + TOTP) have been used.
	Aal *AuthenticatorAssuranceLevel `json:"aal,omitempty"`

	// CompletedAt When the authentication challenge was completed.
	CompletedAt *time.Time                         `json:"completed_at,omitempty"`
	Method      *SessionAuthenticationMethodMethod `json:"method,omitempty"`

	// Organization The Organization id used for authentication
	Organization *string `json:"organization,omitempty"`

	// Provider OIDC or SAML provider id used for authentication
	Provider *string `json:"provider,omitempty"`
}

// SessionAuthenticationMethodMethod defines model for SessionAuthenticationMethod.Method.
type SessionAuthenticationMethodMethod string

// SessionAuthenticationMethods A list of authenticators which were used to authenticate the session.
type SessionAuthenticationMethods = []SessionAuthenticationMethod

// SessionDevice Device corresponding to a Session
type SessionDevice struct {
	// Id Device record ID
	Id openapi_types.UUID `json:"id"`

	// IpAddress IPAddress of the client
	IpAddress *string `json:"ip_address,omitempty"`

	// Location Geo Location corresponding to the IP Address
	Location *string `json:"location,omitempty"`

	// UserAgent UserAgent of the client
	UserAgent *string `json:"user_agent,omitempty"`
}

// SettingsFlow This flow is used when an identity wants to update settings
type SettingsFlow struct {
	// Active Active, if set, contains the registration method that is being used. It is initially
	// not set.
	Active *string `json:"active,omitempty"`

	// ContinueWith Contains a list of actions, that could follow this flow
	//
	// It can, for example, contain a reference to the verification flow, created as part of the user's
	// registration.
	ContinueWith *[]ContinueWith `json:"continue_with,omitempty"`

	// ExpiresAt ExpiresAt is the time (UTC) when the flow expires. If the user still wishes to update the setting,
	// a new flow has to be initiated.
	ExpiresAt time.Time `json:"expires_at"`

	// Id ID represents the flow's unique ID. When performing the settings flow, this
	// represents the id in the settings ui's query parameter: http://<selfservice.flows.settings.ui_url>?flow=<id>
	Id openapi_types.UUID `json:"id"`

	// Identity An identity represents a (human) user.
	Identity Identity `json:"identity"`

	// IssuedAt IssuedAt is the time (UTC) when the flow occurred.
	IssuedAt time.Time `json:"issued_at"`

	// RequestUrl RequestURL is the initial URL that was requested. It can be used to forward information contained in the URL's path or query for example.
	RequestUrl string `json:"request_url"`

	// ReturnTo ReturnTo contains the requested return_to URL.
	ReturnTo *string `json:"return_to,omitempty"`

	// State State represents the state of this flow. It knows two states:
	// show_form: No user data has been collected, or it is invalid, and thus the form should be shown.
	// success: Indicates that the settings flow has been updated successfully with the provided data.
	// Done will stay true when repeatedly checking. If set to true, done will revert back to false only
	// when a flow with invalid (e.g. "please use a valid phone number") data was sent.
	State interface{} `json:"state"`

	// Type The flow type can either be `api` or `browser`.
	Type SelfServiceFlowType `json:"type"`

	// Ui Container represents a HTML Form. The container can work with both HTTP Form and JSON requests.
	Ui UiContainer `json:"ui"`
}

// Space defines model for Space.
type Space struct {
	CreatedOn DateTime `json:"createdOn"`

	// Description Space description
	Description string `json:"description"`

	// Id Internal ID
	Id openapi_types.UUID `json:"id"`

	// Name Space name
	Name string `json:"name"`

	// OrganisationId Organisation_id
	OrganisationId openapi_types.UUID `json:"organisationId"`

	// Status status of the space, the space can only be used when the status is ready.
	Status    SpaceStatus `json:"status"`
	UpdatedOn DateTime    `json:"updatedOn"`
}

// SpaceStatus status of the space, the space can only be used when the status is ready.
type SpaceStatus string

// SpaceIdsList defines model for SpaceIdsList.
type SpaceIdsList struct {
	Items []openapi_types.UUID `json:"items"`
}

// SpacePaginatedList defines model for SpacePaginatedList.
type SpacePaginatedList struct {
	Items []Space `json:"items"`

	// NextPageToken This token is used to retrieve the next page. If this field is omitted, there are no subsequent pages.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// TotalSize Equivalent to int32
	TotalSize *Int `json:"totalSize,omitempty"`
}

// SpaceSimple defines model for SpaceSimple.
type SpaceSimple struct {
	// Id Space identifier
	Id openapi_types.UUID `json:"id"`
}

// SpaceSimplePaginatedList defines model for SpaceSimplePaginatedList.
type SpaceSimplePaginatedList struct {
	Items []SpaceSimple `json:"items"`

	// NextPageToken This token is used to retrieve the next page. If this field is omitted, there are no subsequent pages.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// TotalSize Equivalent to int32
	TotalSize *Int `json:"totalSize,omitempty"`
}

// SubjectType defines model for SubjectType.
type SubjectType string

// SuccessfulNativeLogin The Response for Login Flows via API
type SuccessfulNativeLogin struct {
	// Session A Session
	Session Session `json:"session"`

	// SessionToken The Session Token
	// A session token is equivalent to a session cookie, but it can be sent in the HTTP Authorization
	// Header:
	// Authorization: bearer ${session-token}
	// The session token is only issued for API flows, not for Browser flows!
	SessionToken *string `json:"session_token,omitempty"`
}

// SuccessfulNativeRegistration The Response for Registration Flows via API
type SuccessfulNativeRegistration struct {
	// ContinueWith Contains a list of actions, that could follow this flow
	//
	// It can, for example, this will contain a reference to the verification flow, created as part of the user's
	// registration or the token of the session.
	ContinueWith *[]ContinueWith `json:"continue_with,omitempty"`

	// Identity An identity represents a (human) user.
	Identity Identity `json:"identity"`

	// Session A Session
	Session *Session `json:"session,omitempty"`

	// SessionToken The Session Token
	//
	// This field is only set when the session hook is configured as a post-registration hook.
	//
	// A session token is equivalent to a session cookie, but it can be sent in the HTTP Authorization
	// Header:
	//
	// Authorization: bearer ${session-token}
	//
	// The session token is only issued for API flows, not for Browser flows!
	SessionToken *string `json:"session_token,omitempty"`
}

// TokenBody defines model for TokenBody.
type TokenBody struct {
	// Token The token to provide.
	Token string `json:"token"`
}

// TokenReq defines model for TokenReq.
type TokenReq struct {
	// ClientId The client id.
	ClientId *openapi_types.UUID `json:"client_id,omitempty"`

	// ClientSecret The client secret.
	ClientSecret *string `json:"client_secret,omitempty"`

	// Code The code authorization.
	Code *string `json:"code,omitempty"`

	// GrantType The grant type.
	GrantType string `json:"grant_type"`

	// RedirectUri The URLs redirection
	RedirectUri *string `json:"redirect_uri,omitempty"`

	// RefreshToken The refresh Token
	RefreshToken *string `json:"refresh_token,omitempty"`
}

// TokenResp defines model for TokenResp.
type TokenResp struct {
	// AccessToken The access token.
	AccessToken string `json:"access_token"`

	// ExpiresIn The lifetime in seconds of the access token.
	ExpiresIn int `json:"expires_in"`

	// IdToken The id token.
	IdToken *string `json:"id_token,omitempty"`

	// RefreshToken The refresh token.
	RefreshToken *string `json:"refresh_token,omitempty"`

	// TokenType The type of the token issued.
	TokenType string `json:"token_type"`
}

// UiContainer Container represents a HTML Form. The container can work with both HTTP Form and JSON requests.
type UiContainer struct {
	// Action Action should be used as the form action URL `<form action="{{.Action }}" method="post">`.
	Action   string   `json:"action"`
	Messages *UiTexts `json:"messages,omitempty"`

	// Method Method is the form method (e.g. POST)
	Method string  `json:"method"`
	Nodes  UiNodes `json:"nodes"`
}

// UiNode Nodes are represented as HTML elements or their native UI equivalents. For example,
// a node can be an `<img>` tag, or an `<input element>` but also `some plain text`.
type UiNode struct {
	Attributes UiNodeAttributes `json:"attributes"`

	// Group Group specifies which group (e.g. password authenticator) this node belongs to.
	// default DefaultGroup
	// password PasswordGroup
	// oidc OpenIDConnectGroup
	// profile ProfileGroup
	// link LinkGroup
	// code CodeGroup
	// totp TOTPGroup
	// lookup_secret LookupGroup
	// webauthn WebAuthnGroup
	Group    UiNodeGroup `json:"group"`
	Messages UiTexts     `json:"messages"`

	// Meta This might include a label and other information that can optionally
	// be used to render UIs.
	Meta UiNodeMeta `json:"meta"`

	// Type The node's type
	// text Text
	// input Input
	// img Image
	// a Anchor
	// script Script
	Type UiNodeType `json:"type"`
}

// UiNodeGroup Group specifies which group (e.g. password authenticator) this node belongs to.
// default DefaultGroup
// password PasswordGroup
// oidc OpenIDConnectGroup
// profile ProfileGroup
// link LinkGroup
// code CodeGroup
// totp TOTPGroup
// lookup_secret LookupGroup
// webauthn WebAuthnGroup
type UiNodeGroup string

// UiNodeType The node's type
// text Text
// input Input
// img Image
// a Anchor
// script Script
type UiNodeType string

// UiNodeAnchorAttributes defines model for UiNodeAnchorAttributes.
type UiNodeAnchorAttributes struct {
	// Href The link's href (destination) URL.
	//
	// format: uri
	Href string `json:"href"`

	// Id A unique identifier
	Id string `json:"id"`

	// NodeType NodeType represents this node's types. It is a mirror of `node.type` and
	// is primarily used to allow compatibility with OpenAPI 3.0.  In this struct it technically always is "a".
	NodeType string `json:"node_type"`
	Title    UiText `json:"title"`
}

// UiNodeAttributes defines model for UiNodeAttributes.
type UiNodeAttributes struct {
	union json.RawMessage
}

// UiNodeImageAttributes defines model for UiNodeImageAttributes.
type UiNodeImageAttributes struct {
	// Height Height of the image
	Height int64 `json:"height"`

	// Id A unique identifier
	Id string `json:"id"`

	// NodeType NodeType represents this node's types. It is a mirror of `node.type` and
	// is primarily used to allow compatibility with OpenAPI 3.0.  In this struct it technically always is "img".
	NodeType string `json:"node_type"`

	// Src The image's source URL.
	//
	// format: uri
	Src string `json:"src"`

	// Width Width of the image
	Width int64 `json:"width"`
}

// UiNodeInputAttributes InputAttributes represents the attributes of an input node
type UiNodeInputAttributes struct {
	// Autocomplete The autocomplete attribute for the input.
	// email InputAttributeAutocompleteEmail
	// tel InputAttributeAutocompleteTel
	// url InputAttributeAutocompleteUrl
	// current-password InputAttributeAutocompleteCurrentPassword
	// new-password InputAttributeAutocompleteNewPassword
	// one-time-code InputAttributeAutocompleteOneTimeCode
	Autocomplete *UiNodeInputAttributesAutocomplete `json:"autocomplete,omitempty"`

	// Disabled Sets the input's disabled field to true or false.
	Disabled bool    `json:"disabled"`
	Label    *UiText `json:"label,omitempty"`

	// Name The input's element name.
	Name string `json:"name"`

	// NodeType NodeType represents this node's types. It is a mirror of `node.type` and
	// is primarily used to allow compatibility with OpenAPI 3.0.  In this struct it technically always is "input".
	NodeType string `json:"node_type"`

	// Onclick OnClick may contain javascript which should be executed on click. This is primarily
	// used for WebAuthn.
	Onclick *string `json:"onclick,omitempty"`

	// Pattern The input's pattern.
	Pattern *string `json:"pattern,omitempty"`

	// Required Mark this input field as required.
	Required *bool `json:"required,omitempty"`

	// Type The input's element type.
	// text InputAttributeTypeText
	// password InputAttributeTypePassword
	// number InputAttributeTypeNumber
	// checkbox InputAttributeTypeCheckbox
	// hidden InputAttributeTypeHidden
	// email InputAttributeTypeEmail
	// tel InputAttributeTypeTel
	// submit InputAttributeTypeSubmit
	// button InputAttributeTypeButton
	// datetime-local InputAttributeTypeDateTimeLocal
	// date InputAttributeTypeDate
	// url InputAttributeTypeURI
	Type UiNodeInputAttributesType `json:"type"`

	// Value The input's value.
	Value *interface{} `json:"value"`
}

// UiNodeInputAttributesAutocomplete The autocomplete attribute for the input.
// email InputAttributeAutocompleteEmail
// tel InputAttributeAutocompleteTel
// url InputAttributeAutocompleteUrl
// current-password InputAttributeAutocompleteCurrentPassword
// new-password InputAttributeAutocompleteNewPassword
// one-time-code InputAttributeAutocompleteOneTimeCode
type UiNodeInputAttributesAutocomplete string

// UiNodeInputAttributesType The input's element type.
// text InputAttributeTypeText
// password InputAttributeTypePassword
// number InputAttributeTypeNumber
// checkbox InputAttributeTypeCheckbox
// hidden InputAttributeTypeHidden
// email InputAttributeTypeEmail
// tel InputAttributeTypeTel
// submit InputAttributeTypeSubmit
// button InputAttributeTypeButton
// datetime-local InputAttributeTypeDateTimeLocal
// date InputAttributeTypeDate
// url InputAttributeTypeURI
type UiNodeInputAttributesType string

// UiNodeMeta This might include a label and other information that can optionally
// be used to render UIs.
type UiNodeMeta struct {
	Label *UiText `json:"label,omitempty"`
}

// UiNodeScriptAttributes defines model for UiNodeScriptAttributes.
type UiNodeScriptAttributes struct {
	// Async The script async type
	Async bool `json:"async"`

	// Crossorigin The script cross origin policy
	Crossorigin string `json:"crossorigin"`

	// Id A unique identifier
	Id string `json:"id"`

	// Integrity The script's integrity hash
	Integrity string `json:"integrity"`

	// NodeType NodeType represents this node's types. It is a mirror of `node.type` and
	// is primarily used to allow compatibility with OpenAPI 3.0. In this struct it technically always is "script".
	NodeType string `json:"node_type"`

	// Nonce Nonce for CSP
	//
	// A nonce you may want to use to improve your Content Security Policy.
	// You do not have to use this value but if you want to improve your CSP
	// policies you may use it. You can also choose to use your own nonce value!
	Nonce string `json:"nonce"`

	// Referrerpolicy The script referrer policy
	Referrerpolicy string `json:"referrerpolicy"`

	// Src The script source
	Src string `json:"src"`

	// Type The script MIME type
	Type string `json:"type"`
}

// UiNodeTextAttributes defines model for UiNodeTextAttributes.
type UiNodeTextAttributes struct {
	// Id A unique identifier
	Id string `json:"id"`

	// NodeType NodeType represents this node's types. It is a mirror of `node.type` and
	// is primarily used to allow compatibility with OpenAPI 3.0.  In this struct it technically always is "text".
	NodeType string `json:"node_type"`
	Text     UiText `json:"text"`
}

// UiNodes defines model for UiNodes.
type UiNodes = []UiNode

// UiText defines model for UiText.
type UiText struct {
	// Context The message's context. Useful when customizing messages.
	Context *map[string]interface{} `json:"context,omitempty"`
	Id      ID                      `json:"id"`

	// Text The message text. Written in american english.
	Text string `json:"text"`

	// Type The message type.
	// info Info
	// error Error
	// success Success
	Type UiTextType `json:"type"`
}

// UiTextType The message type.
// info Info
// error Error
// success Success
type UiTextType string

// UiTexts defines model for UiTexts.
type UiTexts = []UiText

// UpdateCluster defines model for UpdateCluster.
type UpdateCluster struct {
	Description *string `json:"description,omitempty"`
	Name        *string `json:"name,omitempty"`
}

// UpdateLoginFlowBody defines model for UpdateLoginFlowBody.
type UpdateLoginFlowBody struct {
	union json.RawMessage
}

// UpdateLoginFlowWithCodeMethod Update Login flow using the code method
type UpdateLoginFlowWithCodeMethod struct {
	// Code Code is the 6 digits code sent to the user
	Code *string `json:"code,omitempty"`

	// CsrfToken CSRFToken is the anti-CSRF token
	CsrfToken string `json:"csrf_token"`

	// Identifier Identifier is the code identifier
	// The identifier requires that the user has already completed the registration or settings with code flow.
	Identifier *string `json:"identifier,omitempty"`

	// Method Method should be set to "code" when logging in using the code strategy.
	Method string `json:"method"`

	// Resend Resend is set when the user wants to resend the code
	Resend *string `json:"resend,omitempty"`
}

// UpdateLoginFlowWithLookupSecretMethod Update Login Flow with Lookup Secret Method
type UpdateLoginFlowWithLookupSecretMethod struct {
	// CsrfToken Sending the anti-csrf token is only required for browser login flows.
	CsrfToken *string `json:"csrf_token,omitempty"`

	// LookupSecret The lookup secret.
	LookupSecret string `json:"lookup_secret"`

	// Method Method should be set to "lookup_secret" when logging in using the lookup_secret strategy.
	Method string `json:"method"`
}

// UpdateLoginFlowWithOidcMethod Update Login Flow with OpenID Connect Method
type UpdateLoginFlowWithOidcMethod struct {
	// CsrfToken The CSRF Token
	CsrfToken *string `json:"csrf_token,omitempty"`

	// IdToken IDToken is an optional id token provided by an OIDC provider
	//
	// If submitted, it is verified using the OIDC provider's public key set and the claims are used to populate
	// the OIDC credentials of the identity.
	// If the OIDC provider does not store additional claims (such as name, etc.) in the IDToken itself, you can use
	// the `traits` field to populate the identity's traits. Note, that Apple only includes the users email in the IDToken.
	//
	// Supported providers are
	// Apple
	IdToken *string `json:"id_token,omitempty"`

	// IdTokenNonce IDTokenNonce is the nonce, used when generating the IDToken.
	// If the provider supports nonce validation, the nonce will be validated against this value and required.
	IdTokenNonce *string `json:"id_token_nonce,omitempty"`

	// Method Method to use
	//
	// This field must be set to `oidc` when using the oidc method.
	Method string `json:"method"`

	// Provider The provider to register with
	Provider string `json:"provider"`

	// Traits The identity traits. This is a placeholder for the registration flow.
	Traits *map[string]interface{} `json:"traits,omitempty"`

	// UpstreamParameters UpstreamParameters are the parameters that are passed to the upstream identity provider.
	//
	// These parameters are optional and depend on what the upstream identity provider supports.
	// Supported parameters are:
	// `login_hint` (string): The `login_hint` parameter suppresses the account chooser and either pre-fills the email box on the sign-in form, or selects the proper session.
	// `hd` (string): The `hd` parameter limits the login/registration process to a Google Organization, e.g. `mycollege.edu`.
	// `prompt` (string): The `prompt` specifies whether the Authorization Server prompts the End-User for reauthentication and consent, e.g. `select_account`.
	UpstreamParameters *map[string]interface{} `json:"upstream_parameters,omitempty"`
}

// UpdateLoginFlowWithPasswordMethod Update Login Flow with Password Method
type UpdateLoginFlowWithPasswordMethod struct {
	// CsrfToken Sending the anti-csrf token is only required for browser login flows.
	CsrfToken *string `json:"csrf_token,omitempty"`

	// Identifier Identifier is the email or username of the user trying to log in.
	Identifier string `json:"identifier"`

	// Method Method should be set to "password" when logging in using the identifier and password strategy.
	Method string `json:"method"`

	// Password The user's password.
	Password string `json:"password"`

	// PasswordIdentifier Identifier is the email or username of the user trying to log in.
	// This field is deprecated!
	PasswordIdentifier *string `json:"password_identifier,omitempty"`
}

// UpdateLoginFlowWithTotpMethod Update Login Flow with TOTP Method
type UpdateLoginFlowWithTotpMethod struct {
	// CsrfToken Sending the anti-csrf token is only required for browser login flows.
	CsrfToken *string `json:"csrf_token,omitempty"`

	// Method Method should be set to "totp" when logging in using the TOTP strategy.
	Method string `json:"method"`

	// TotpCode The TOTP code.
	TotpCode string `json:"totp_code"`
}

// UpdateLoginFlowWithWebAuthnMethod Update Login Flow with WebAuthn Method
type UpdateLoginFlowWithWebAuthnMethod struct {
	// CsrfToken Sending the anti-csrf token is only required for browser login flows.
	CsrfToken *string `json:"csrf_token,omitempty"`

	// Identifier Identifier is the email or username of the user trying to log in.
	Identifier string `json:"identifier"`

	// Method Method should be set to "webAuthn" when logging in using the WebAuthn strategy.
	Method string `json:"method"`

	// WebauthnLogin Login a WebAuthn Security Key
	//
	// This must contain the ID of the WebAuthN connection.
	WebauthnLogin *string `json:"webauthn_login,omitempty"`
}

// UpdateRecoveryFlowBody Update Recovery Flow Request Body
type UpdateRecoveryFlowBody struct {
	union json.RawMessage
}

// UpdateRecoveryFlowWithCodeMethod Update Recovery Flow with Code Method
type UpdateRecoveryFlowWithCodeMethod struct {
	// Code Code from the recovery email
	//
	// If you want to submit a code, use this field, but make sure to _not_ include the email field, as well.
	Code *string `json:"code,omitempty"`

	// CsrfToken Sending the anti-csrf token is only required for browser login flows.
	CsrfToken *string `json:"csrf_token,omitempty"`

	// Email If the email belongs to a valid account, a recovery email will be sent.
	Email *string `json:"email,omitempty"`

	// Method Method is the method that should be used for this recovery flow
	//
	// Allowed values are `link` and `code`.
	// link RecoveryStrategyLink
	// code RecoveryStrategyCode
	Method UpdateRecoveryFlowWithCodeMethodMethod `json:"method"`
}

// UpdateRecoveryFlowWithCodeMethodMethod Method is the method that should be used for this recovery flow
//
// Allowed values are `link` and `code`.
// link RecoveryStrategyLink
// code RecoveryStrategyCode
type UpdateRecoveryFlowWithCodeMethodMethod string

// UpdateRecoveryFlowWithLinkMethod Update Recovery Flow with Link Method
type UpdateRecoveryFlowWithLinkMethod struct {
	// CsrfToken Sending the anti-csrf token is only required for browser login flows.
	CsrfToken *string `json:"csrf_token,omitempty"`

	// Email Email to Recover
	// Needs to be set when initiating the flow. If the email is a registered recovery email, a recovery link will be sent. If the email is not known,a email with details on what happened will be sent instead.
	Email openapi_types.Email `json:"email"`

	// Method Method is the method that should be used for this recovery flow
	//
	// Allowed values are `link` and `code`
	// link RecoveryStrategyLink
	// code RecoveryStrategyCode
	Method UpdateRecoveryFlowWithLinkMethodMethod `json:"method"`
}

// UpdateRecoveryFlowWithLinkMethodMethod Method is the method that should be used for this recovery flow
//
// Allowed values are `link` and `code`
// link RecoveryStrategyLink
// code RecoveryStrategyCode
type UpdateRecoveryFlowWithLinkMethodMethod string

// UpdateRegistrationFlowBody Update Registration Request Body
type UpdateRegistrationFlowBody struct {
	union json.RawMessage
}

// UpdateRegistrationFlowWithCodeMethod Update Registration Flow with Code Method
type UpdateRegistrationFlowWithCodeMethod struct {
	// Code The OTP Code sent to the user
	Code *string `json:"code,omitempty"`

	// CsrfToken The CSRF Token
	CsrfToken *string `json:"csrf_token,omitempty"`

	// Method Method to use
	//
	// This field must be set to `code` when using the code method.
	Method string `json:"method"`

	// Resend Resend restarts the flow with a new code
	Resend *string `json:"resend,omitempty"`

	// Traits The identity's traits
	Traits map[string]interface{} `json:"traits"`

	// TransientPayload Transient data to pass along to any webhooks
	TransientPayload *map[string]interface{} `json:"transient_payload,omitempty"`
}

// UpdateRegistrationFlowWithOidcMethod Update Registration Flow with OpenID Connect Method
type UpdateRegistrationFlowWithOidcMethod struct {
	// CsrfToken The CSRF Token
	CsrfToken *string `json:"csrf_token,omitempty"`

	// IdToken IDToken is an optional id token provided by an OIDC provider
	//
	// If submitted, it is verified using the OIDC provider's public key set and the claims are used to populate
	// the OIDC credentials of the identity.
	// If the OIDC provider does not store additional claims (such as name, etc.) in the IDToken itself, you can use
	// the `traits` field to populate the identity's traits. Note, that Apple only includes the users email in the IDToken.
	//
	// Supported providers are
	// Apple
	IdToken *string `json:"id_token,omitempty"`

	// IdTokenNonce IDTokenNonce is the nonce, used when generating the IDToken.
	// If the provider supports nonce validation, the nonce will be validated against this value and is required.
	IdTokenNonce *string `json:"id_token_nonce,omitempty"`

	// Method Method to use
	//
	// This field must be set to `oidc` when using the oidc method.
	Method string `json:"method"`

	// Provider The provider to register with
	Provider string `json:"provider"`

	// Traits The identity traits
	Traits *map[string]interface{} `json:"traits,omitempty"`

	// TransientPayload Transient data to pass along to any webhooks
	TransientPayload *map[string]interface{} `json:"transient_payload,omitempty"`

	// UpstreamParameters UpstreamParameters are the parameters that are passed to the upstream identity provider.
	//
	// These parameters are optional and depend on what the upstream identity provider supports.
	// Supported parameters are:
	// `login_hint` (string): The `login_hint` parameter suppresses the account chooser and either pre-fills the email box on the sign-in form, or selects the proper session.
	// `hd` (string): The `hd` parameter limits the login/registration process to a Google Organization, e.g. `mycollege.edu`.
	// `prompt` (string): The `prompt` specifies whether the Authorization Server prompts the End-User for reauthentication and consent, e.g. `select_account`.
	UpstreamParameters *map[string]interface{} `json:"upstream_parameters,omitempty"`
}

// UpdateRegistrationFlowWithPasswordMethod Update Registration Flow with Password Method
type UpdateRegistrationFlowWithPasswordMethod struct {
	// CsrfToken The CSRF Token
	CsrfToken *string `json:"csrf_token,omitempty"`

	// Method Method to use
	//
	// This field must be set to `password` when using the password method.
	Method string `json:"method"`

	// Password Password to sign the user up with
	Password string `json:"password"`

	// Traits The identity's traits
	Traits map[string]interface{} `json:"traits"`

	// TransientPayload Transient data to pass along to any webhooks
	TransientPayload *map[string]interface{} `json:"transient_payload,omitempty"`
}

// UpdateRegistrationFlowWithWebAuthnMethod Update Registration Flow with WebAuthn Method
type UpdateRegistrationFlowWithWebAuthnMethod struct {
	// CsrfToken CSRFToken is the anti-CSRF token
	CsrfToken *string `json:"csrf_token,omitempty"`

	// Method Method
	//
	// Should be set to "webauthn" when trying to add, update, or remove a webAuthn pairing.
	Method string `json:"method"`

	// Traits The identity's traits
	Traits map[string]interface{} `json:"traits"`

	// TransientPayload Transient data to pass along to any webhooks
	TransientPayload *map[string]interface{} `json:"transient_payload,omitempty"`

	// WebauthnRegister Register a WebAuthn Security Key
	//
	// It is expected that the JSON returned by the WebAuthn registration process
	// is included here.
	WebauthnRegister *string `json:"webauthn_register,omitempty"`

	// WebauthnRegisterDisplayname Name of the WebAuthn Security Key to be Added
	//
	// A human-readable name for the security key which will be added.
	WebauthnRegisterDisplayname *string `json:"webauthn_register_displayname,omitempty"`
}

// UpdateSettingsFlowBody defines model for UpdateSettingsFlowBody.
type UpdateSettingsFlowBody struct {
	union json.RawMessage
}

// UpdateSettingsFlowMethod defines model for UpdateSettingsFlowMethod.
type UpdateSettingsFlowMethod struct {
	// Method Method
	//
	// Should be set to password when trying to update a password.
	Method string `json:"method"`
}

// UpdateSettingsFlowWithPasswordMethod defines model for UpdateSettingsFlowWithPasswordMethod.
type UpdateSettingsFlowWithPasswordMethod struct {
	// CsrfToken CSRFToken is the anti-CSRF token
	CsrfToken *string     `json:"csrf_token,omitempty"`
	Method    interface{} `json:"method"`

	// Password Password is the updated password
	Password string `json:"password"`
}

// UpdateSettingsFlowWithTotpMethod defines model for UpdateSettingsFlowWithTotpMethod.
type UpdateSettingsFlowWithTotpMethod struct {
	// CsrfToken CSRFToken is the anti-CSRF token
	CsrfToken *string     `json:"csrf_token,omitempty"`
	Method    interface{} `json:"method"`

	// TotpCode ValidationTOTP must contain a valid TOTP based on the
	TotpCode *string `json:"totp_code,omitempty"`

	// TotpUnlink UnlinkTOTP if true will remove the TOTP pairing,
	// effectively removing the credential. This can be used
	// to set up a new TOTP device.
	TotpUnlink *bool `json:"totp_unlink,omitempty"`
}

// UpdateVerificationFlowBody Update Verification Flow Request Body
type UpdateVerificationFlowBody struct {
	union json.RawMessage
}

// UpdateVerificationFlowWithCodeMethod defines model for UpdateVerificationFlowWithCodeMethod.
type UpdateVerificationFlowWithCodeMethod struct {
	// Code Code from the recovery email
	//
	// If you want to submit a code, use this field, but make sure to _not_ include the email field, as well.
	Code *string `json:"code,omitempty"`

	// CsrfToken Sending the anti-csrf token is only required for browser login flows.
	CsrfToken *string `json:"csrf_token,omitempty"`

	// Email If the email belongs to a valid account, a verifiation email will be sent.
	Email *string `json:"email,omitempty"`

	// Method Method is the method that should be used for this verification flow
	//
	// Allowed values are `link` and `code`.
	// link VerificationStrategyLink
	// code VerificationStrategyCode
	Method UpdateVerificationFlowWithCodeMethodMethod `json:"method"`
}

// UpdateVerificationFlowWithCodeMethodMethod Method is the method that should be used for this verification flow
//
// Allowed values are `link` and `code`.
// link VerificationStrategyLink
// code VerificationStrategyCode
type UpdateVerificationFlowWithCodeMethodMethod string

// UpdateVerificationFlowWithLinkMethod Update Verification Flow with Link Method
type UpdateVerificationFlowWithLinkMethod struct {
	// CsrfToken Sending the anti-csrf token is only required for browser login flows.
	CsrfToken *string `json:"csrf_token,omitempty"`

	// Email Email to Verify
	//
	// Needs to be set when initiating the flow. If the email is a registered
	// verification email, a verification link will be sent. If the email is not known,
	// a email with details on what happened will be sent instead.
	//
	// format: email
	Email string `json:"email"`

	// Method Method is the method that should be used for this verification flow
	//
	// Allowed values are `link` and `code`
	// link VerificationStrategyLink
	// code VerificationStrategyCode
	Method UpdateVerificationFlowWithLinkMethodMethod `json:"method"`
}

// UpdateVerificationFlowWithLinkMethodMethod Method is the method that should be used for this verification flow
//
// Allowed values are `link` and `code`
// link VerificationStrategyLink
// code VerificationStrategyCode
type UpdateVerificationFlowWithLinkMethodMethod string

// Url defines model for Url.
type Url = string

// User defines model for User.
type User struct {
	Email Email `json:"email"`

	// Firstname Firstname
	Firstname string `json:"firstname"`

	// Lastname Lastname
	Lastname string `json:"lastname"`
}

// UserCreated defines model for UserCreated.
type UserCreated struct {
	// Active Account activation/deactivation state
	Active    bool     `json:"active"`
	CreatedOn DateTime `json:"createdOn"`
	Email     Email    `json:"email"`

	// Firstname Firstname
	Firstname string `json:"firstname"`

	// Id User ID
	Id openapi_types.UUID `json:"id"`

	// Lastname Lastname
	Lastname string `json:"lastname"`
}

// UserCreation defines model for UserCreation.
type UserCreation struct {
	// Active Account activation/deactivation state
	Active    bool     `json:"active"`
	CreatedOn DateTime `json:"createdOn"`

	// Id User ID
	Id openapi_types.UUID `json:"id"`
}

// UserEdited defines model for UserEdited.
type UserEdited struct {
	// Active Account activation/deactivation state
	Active    bool     `json:"active"`
	CreatedOn DateTime `json:"createdOn"`

	// Id User ID
	Id        openapi_types.UUID `json:"id"`
	UpdatedOn DateTime           `json:"updatedOn"`
}

// UserInfo defines model for UserInfo.
type UserInfo struct {
	Email     *string `json:"email,omitempty"`
	Firstname *string `json:"firstname,omitempty"`
	Lastname  *string `json:"lastname,omitempty"`
	Sub       string  `json:"sub"`
}

// UserModified defines model for UserModified.
type UserModified struct {
	// Active Account activation/deactivation state
	Active    bool     `json:"active"`
	CreatedOn DateTime `json:"createdOn"`
	Email     Email    `json:"email"`

	// Firstname Firstname
	Firstname string `json:"firstname"`

	// Id User ID
	Id openapi_types.UUID `json:"id"`

	// Lastname Lastname
	Lastname  string   `json:"lastname"`
	UpdatedOn DateTime `json:"updatedOn"`
}

// UserPaginatedList defines model for UserPaginatedList.
type UserPaginatedList struct {
	Items []UserModified `json:"items"`

	// NextPageToken This token is used to retrieve the next page. If this field is omitted, there are no subsequent pages.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// TotalSize Equivalent to int32
	TotalSize *Int `json:"totalSize,omitempty"`
}

// UserState defines model for UserState.
type UserState struct {
	// Active Account activation/deactivation state
	Active bool `json:"active"`
}

// UserUpdate defines model for UserUpdate.
type UserUpdate struct {
	// Active Account activation/deactivation state
	Active bool  `json:"active"`
	Email  Email `json:"email"`

	// Firstname Firstname
	Firstname string `json:"firstname"`

	// Lastname Lastname
	Lastname string `json:"lastname"`
}

// VerifiableIdentityAddress VerifiableAddress is an identity's verifiable address
type VerifiableIdentityAddress struct {
	// CreatedAt When this entry was created
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Id The ID
	Id *openapi_types.UUID `json:"id,omitempty"`

	// Status VerifiableAddressStatus must not exceed 16 characters as that is the limitation in the SQL Schema
	Status IdentityVerifiableAddressStatus `json:"status"`

	// UpdatedAt When this entry was last updated
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Value The address value
	//
	// example foo@user.com
	Value string `json:"value"`

	// Verified Indicates if the address has already been verified
	Verified   bool      `json:"verified"`
	VerifiedAt *NullTime `json:"verified_at"`

	// Via The delivery method
	Via VerifiableIdentityAddressVia `json:"via"`
}

// VerifiableIdentityAddressVia The delivery method
type VerifiableIdentityAddressVia string

// VerificationFlow Used to verify an out-of-band communication channel such as an email address or a phone number.
type VerificationFlow struct {
	// Active Active, if set, contains the registration method that is being used. It is initially
	// not set.
	Active *string `json:"active,omitempty"`

	// ExpiresAt ExpiresAt is the time (UTC) when the request expires. If the user still wishes to verify the address,
	// a new request has to be initiated.
	ExpiresAt *time.Time `json:"expires_at,omitempty"`

	// Id ID represents the request's unique ID.
	Id openapi_types.UUID `json:"id"`

	// IssuedAt IssuedAt is the time (UTC) when the request occurred.
	IssuedAt *time.Time `json:"issued_at,omitempty"`

	// RequestUrl RequestURL is the initial URL that was requested. It can be used to forward information contained in the URL's path or query for example.
	RequestUrl *string `json:"request_url,omitempty"`

	// ReturnTo ReturnTo contains the requested return_to URL.
	ReturnTo *string `json:"return_to,omitempty"`

	// State State represents the state of this request:
	//
	// choose_method: ask the user to choose a method (e.g. verify your email)
	// sent_email: the email has been sent to the user
	// passed_challenge: the request was successful and the verification challenge was passed.
	State interface{} `json:"state"`

	// Type The flow type can either be `api` or `browser`.
	Type SelfServiceFlowType `json:"type"`

	// Ui Container represents a HTML Form. The container can work with both HTTP Form and JSON requests.
	Ui UiContainer `json:"ui"`
}

// Violation defines model for Violation.
type Violation struct {
	// Description A description of why the field is violated.
	Description string `json:"description"`

	// Field The field impacted by the violation.
	Field string `json:"field"`
}

// WebAuthnJavaScript defines model for WebAuthnJavaScript.
type WebAuthnJavaScript struct {
	CreatedAt      time.Time          `json:"created_at"`
	Id             openapi_types.UUID `json:"id"`
	Name           string             `json:"name"`
	SubscriptionId *NullUUID          `json:"subscription_id"`
	UpdatedAt      time.Time          `json:"updated_at"`
}

// Action defines model for Action.
type Action = string

// Authorization defines model for Authorization.
type Authorization = string

// ClientId defines model for ClientId.
type ClientId = openapi_types.UUID

// ClusterId defines model for ClusterId.
type ClusterId = string

// ConsentChallenge defines model for ConsentChallenge.
type ConsentChallenge = string

// IdUuid defines model for IdUuid.
type IdUuid = openapi_types.UUID

// ListPermissionsPage defines model for ListPermissionsPage.
type ListPermissionsPage struct {
	// NextToken A page token received from a previous call. Provide this to retrieve the subsequent page.
	NextToken *string `json:"nextToken"`

	// Size The maximum number of items to return. The service may return fewer than this value.
	Size *int32 `json:"size"`
}

// ListRolesPage defines model for ListRolesPage.
type ListRolesPage struct {
	// NextToken A page token received from a previous call. Provide this to retrieve the subsequent page.
	NextToken *string `json:"nextToken"`

	// Size The maximum number of items to return. The service may return fewer than this value.
	Size *int32 `json:"size"`
}

// ListServiceAccounts defines model for ListServiceAccounts.
type ListServiceAccounts struct {
	// NextToken A page token received from a previous call. Provide this to retrieve the subsequent page.
	NextToken *string `json:"nextToken,omitempty"`

	// Size The maximum number of items to return. The service may return fewer than this value.
	Size *int32 `json:"size,omitempty"`
}

// ListSpacesIdentity defines model for ListSpacesIdentity.
type ListSpacesIdentity struct {
	// NextToken A page token received from a previous call. Provide this to retrieve the subsequent page.
	NextToken *string `json:"nextToken,omitempty"`

	// Size The maximum number of items to return. The service may return fewer than this value.
	Size *int32 `json:"size,omitempty"`
}

// ListSpacesOfServiceAccount defines model for ListSpacesOfServiceAccount.
type ListSpacesOfServiceAccount struct {
	// NextToken A page token received from a previous call. Provide this to retrieve the subsequent page.
	NextToken *string `json:"nextToken,omitempty"`

	// Size The maximum number of items to return. The service may return fewer than this value.
	Size *int32 `json:"size,omitempty"`
}

// ListSpacesOfUser defines model for ListSpacesOfUser.
type ListSpacesOfUser struct {
	// NextToken A page token received from a previous call. Provide this to retrieve the subsequent page.
	NextToken *string `json:"nextToken,omitempty"`

	// Size The maximum number of items to return. The service may return fewer than this value.
	Size *int32 `json:"size,omitempty"`
}

// ListSpacesPage defines model for ListSpacesPage.
type ListSpacesPage struct {
	// NextToken A page token received from a previous call. Provide this to retrieve the subsequent page.
	NextToken *string `json:"nextToken,omitempty"`

	// Size The maximum number of items to return. The service may return fewer than this value.
	Size *int32 `json:"size,omitempty"`
}

// ListUser defines model for ListUser.
type ListUser struct {
	// NextToken A page token received from a previous call. Provide this to retrieve the subsequent page.
	NextToken *string `json:"nextToken,omitempty"`

	// Size The maximum number of items to return. The service may return fewer than this value.
	Size *int32 `json:"size,omitempty"`
}

// ListUserOrganisations defines model for ListUserOrganisations.
type ListUserOrganisations struct {
	// NextToken A page token received from a previous call. Provide this to retrieve the subsequent page.
	NextToken *string `json:"nextToken,omitempty"`

	// Size The maximum number of items to return. The service may return fewer than this value.
	Size *int32 `json:"size,omitempty"`
}

// NodepoolName defines model for NodepoolName.
type NodepoolName = string

// ObjectType defines model for ObjectType.
type ObjectType = string

// OperationStatuses defines model for OperationStatuses.
type OperationStatuses = []OperationStatus

// OrganisationId defines model for OrganisationId.
type OrganisationId = openapi_types.UUID

// PermissionUuid defines model for PermissionUuid.
type PermissionUuid = openapi_types.UUID

// QueryClusterId defines model for QueryClusterId.
type QueryClusterId = string

// RedirectUri defines model for RedirectUri.
type RedirectUri = string

// Resource defines model for Resource.
type Resource = string

// ResponseType defines model for ResponseType.
type ResponseType = string

// RoleName defines model for RoleName.
type RoleName = string

// RoleUuid defines model for RoleUuid.
type RoleUuid = openapi_types.UUID

// Scope defines model for Scope.
type Scope = string

// Service defines model for Service.
type Service = string

// ServiceAccountId defines model for ServiceAccountId.
type ServiceAccountId = openapi_types.UUID

// SpaceId defines model for SpaceId.
type SpaceId = openapi_types.UUID

// State defines model for State.
type State = string

// SubResource defines model for SubResource.
type SubResource = string

// SubjectId defines model for SubjectId.
type SubjectId = openapi_types.UUID

// SubjectTypeParam defines model for SubjectTypeParam.
type SubjectTypeParam = SubjectType

// UserEmail defines model for UserEmail.
type UserEmail = openapi_types.Email

// UserId defines model for UserId.
type UserId = openapi_types.UUID

// ClusterCreateResponseSchema defines model for ClusterCreateResponse.
type ClusterCreateResponseSchema = ResCreateCluster

// ClusterDeleteResponseSchema defines model for ClusterDeleteResponse.
type ClusterDeleteResponseSchema = ResDeleteCluster

// ClusterGetResponseSchema defines model for ClusterGetResponse.
type ClusterGetResponseSchema = OpenShiftCluster

// ClustersResponseSchema defines model for ClustersResponse.
type ClustersResponseSchema = ListClusters

// CreateRole200ResponseSchema defines model for CreateRole200Response.
type CreateRole200ResponseSchema = RegisteredRole

// CreateServiceAccount201ResponseSchema defines model for CreateServiceAccount201Response.
type CreateServiceAccount201ResponseSchema = CreatedServiceAccount

// CreateSpace200ResponseSchema defines model for CreateSpace200Response.
type CreateSpace200ResponseSchema = Space

// CreateUser201ResponseSchema defines model for CreateUser201Response.
type CreateUser201ResponseSchema = UserCreated

// Error400Schema For HTTP 400 bad request errors, we implement the https://datatracker.ietf.org/doc/html/rfc9457
type Error400Schema = BadRequestError

// Error404Schema For HTTP errors, we implement the https://datatracker.ietf.org/doc/html/rfc9457
type Error404Schema = Error

// Error500Schema For HTTP errors, we implement the https://datatracker.ietf.org/doc/html/rfc9457
type Error500Schema = Error

// GetACL200ResponseSchema defines model for GetACL200Response.
type GetACL200ResponseSchema = ACLPaginatedList

// GetIAMGranularPolicy200ResponseSchema defines model for GetIAMGranularPolicy200Response.
type GetIAMGranularPolicy200ResponseSchema = IAMGranularPolicyList

// GetIAMPolicy200ResponseSchema defines model for GetIAMPolicy200Response.
type GetIAMPolicy200ResponseSchema = IAMPolicy

// GetPermission200ResponseSchema defines model for GetPermission200Response.
type GetPermission200ResponseSchema = RegisteredPermission

// GetRole200ResponseSchema defines model for GetRole200Response.
type GetRole200ResponseSchema = RegisteredRole

// GetRolePermissions200ResponseSchema defines model for GetRolePermissions200Response.
type GetRolePermissions200ResponseSchema = PermissionsPaginatedList

// GetServiceAccount200ResponseSchema defines model for GetServiceAccount200Response.
type GetServiceAccount200ResponseSchema = ServiceAccountEdited

// GetSpaceById200ResponseSchema defines model for GetSpaceById200Response.
type GetSpaceById200ResponseSchema = Space

// GetUser200ResponseSchema defines model for GetUser200Response.
type GetUser200ResponseSchema = UserModified

// GetUserInfo200ResponseSchema defines model for GetUserInfo200Response.
type GetUserInfo200ResponseSchema = UserInfo

// IntrospectResponseSchema defines model for IntrospectResponse.
type IntrospectResponseSchema = IntrospectResp

// JsonWebKeysResponseSchema JSON Web Key Set
type JsonWebKeysResponseSchema = JsonWebKeySet

// ListMySessionsResponseSchema defines model for ListMySessionsResponse.
type ListMySessionsResponseSchema = []Session

// ListPermissions200ResponseSchema defines model for ListPermissions200Response.
type ListPermissions200ResponseSchema = PermissionsPaginatedList

// ListRoles200ResponseSchema defines model for ListRoles200Response.
type ListRoles200ResponseSchema = RolesPaginatedList

// ListServiceAccount200ResponseSchema defines model for ListServiceAccount200Response.
type ListServiceAccount200ResponseSchema = ServiceAccountPaginatedList

// ListSpaces200ResponseSchema defines model for ListSpaces200Response.
type ListSpaces200ResponseSchema = SpacePaginatedList

// ListSpacesIdentity200ResponseSchema defines model for ListSpacesIdentity200Response.
type ListSpacesIdentity200ResponseSchema = SpaceSimplePaginatedList

// ListSpacesServiceAccount200ResponseSchema defines model for ListSpacesServiceAccount200Response.
type ListSpacesServiceAccount200ResponseSchema = SpaceSimplePaginatedList

// ListSpacesUser200ResponseSchema defines model for ListSpacesUser200Response.
type ListSpacesUser200ResponseSchema = SpaceSimplePaginatedList

// ListUser200ResponseSchema defines model for ListUser200Response.
type ListUser200ResponseSchema = UserPaginatedList

// ListUserOrganisations200ResponseSchema defines model for ListUserOrganisations200Response.
type ListUserOrganisations200ResponseSchema = OrganisationSimplePaginatedList

// NodepoolCreateResponseSchema defines model for NodepoolCreateResponse.
type NodepoolCreateResponseSchema = ResCreateNodepool

// NodepoolDeleteResponseSchema defines model for NodepoolDeleteResponse.
type NodepoolDeleteResponseSchema = ResDeleteCluster

// NodepoolsResponseSchema defines model for NodepoolsResponse.
type NodepoolsResponseSchema = ListNodepools

// OperationResponseSchema defines model for OperationResponse.
type OperationResponseSchema = Operation

// OperationsResponseSchema defines model for OperationsResponse.
type OperationsResponseSchema = Operations

// PatchUserState200ResponseSchema defines model for PatchUserState200Response.
type PatchUserState200ResponseSchema = UserEdited

// RecoverUser200ResponseSchema defines model for RecoverUser200Response.
type RecoverUser200ResponseSchema = RecoveryLink

// TokenResponseSchema defines model for TokenResponse.
type TokenResponseSchema = TokenResp

// UpdateNodeCountResponseSchema defines model for UpdateNodeCountResponse.
type UpdateNodeCountResponseSchema = RespUpdateNodepool

// UpdateServiceAccount200ResponseSchema defines model for UpdateServiceAccount200Response.
type UpdateServiceAccount200ResponseSchema = ServiceAccountEdited

// UpdateUser200ResponseSchema defines model for UpdateUser200Response.
type UpdateUser200ResponseSchema = UserModified

// VersionsResponseSchema defines model for VersionsResponse.
type VersionsResponseSchema = ListVersions

// WebAuthnJavaScriptResponseSchema defines model for WebAuthnJavaScriptResponse.
type WebAuthnJavaScriptResponseSchema = WebAuthnJavaScript

// AddRolePermissionsRequest defines model for AddRolePermissionsRequest.
type AddRolePermissionsRequest = RolePermission

// CreateClusterRequest defines model for CreateClusterRequest.
type CreateClusterRequest = CreateCluster

// CreateNodepoolRequest defines model for CreateNodepoolRequest.
type CreateNodepoolRequest = CreateNodepool

// CreateRoleRequest A role, linked to 1 or more permissions
type CreateRoleRequest = Role

// CreateServiceAccountRequest defines model for CreateServiceAccountRequest.
type CreateServiceAccountRequest = ServiceAccount

// CreateSpaceRequest defines model for CreateSpaceRequest.
type CreateSpaceRequest = CreateSpace

// CreateUserRequest defines model for CreateUserRequest.
type CreateUserRequest = User

// DeleteACLRequest List of ACLs.
type DeleteACLRequest = ACLList

// ListIdentitiesByAccessRequest defines model for ListIdentitiesByAccessRequest.
type ListIdentitiesByAccessRequest = IdentitiesIdsList

// ListSpaceIdsRequest defines model for ListSpaceIdsRequest.
type ListSpaceIdsRequest = SpaceIdsList

// PatchUserStateRequest defines model for PatchUserStateRequest.
type PatchUserStateRequest = UserState

// RemoveRolePermissionsRequest defines model for RemoveRolePermissionsRequest.
type RemoveRolePermissionsRequest = RolePermission

// SetACLRequest List of ACLs.
type SetACLRequest = ACLList

// SetIAMGranularPolicyRequest Defines the structure for modification instructions for roles and permissions
type SetIAMGranularPolicyRequest struct {
	Add    *GranularPolicyList `json:"add,omitempty"`
	Delete *GranularPolicyList `json:"delete,omitempty"`
}

// SetIAMPolicyRequest Defines the structure for modification instructions for roles and permissions
type SetIAMPolicyRequest struct {
	Add    *IAMPolicy `json:"add,omitempty"`
	Delete *IAMPolicy `json:"delete,omitempty"`
}

// UpdateClusterRequest defines model for UpdateClusterRequest.
type UpdateClusterRequest = UpdateCluster

// UpdateNodepoolRequest defines model for UpdateNodepoolRequest.
type UpdateNodepoolRequest = ReqUpdateNodepool

// UpdateRoleRequest defines model for UpdateRoleRequest.
type UpdateRoleRequest struct {
	// Description Human-readable description
	Description *string `json:"description,omitempty"`

	// Name Human-readable name
	Name *string `json:"name,omitempty"`
}

// UpdateServiceAccountRequest defines model for UpdateServiceAccountRequest.
type UpdateServiceAccountRequest = ServiceAccount

// UpdateSpaceRequest defines model for UpdateSpaceRequest.
type UpdateSpaceRequest = MutableSpace

// UpdateUserRequest defines model for UpdateUserRequest.
type UpdateUserRequest = UserUpdate

// AuthorizeParams defines parameters for Authorize.
type AuthorizeParams struct {
	// ClientId The client identifier.
	ClientId *ClientId `form:"client_id,omitempty" json:"client_id,omitempty"`

	// RedirectUri The client's redirect URI.
	RedirectUri *RedirectUri `form:"redirect_uri,omitempty" json:"redirect_uri,omitempty"`

	// ResponseType The expected response type.
	ResponseType ResponseType `form:"response_type" json:"response_type"`

	// Scope The requested scopes.
	Scope *Scope `form:"scope,omitempty" json:"scope,omitempty"`

	// State An opaque value passed to the application after authentication.
	State *State `form:"state,omitempty" json:"state,omitempty"`
}

// ConsentParams defines parameters for Consent.
type ConsentParams struct {
	// ConsentChallenge token consent challenge
	ConsentChallenge ConsentChallenge `form:"consent_challenge" json:"consent_challenge"`
}

// GetFlowErrorParams defines parameters for GetFlowError.
type GetFlowErrorParams struct {
	// Id Error is the error's ID
	Id string `form:"id" json:"id"`
}

// UpdateLoginFlowParams defines parameters for UpdateLoginFlow.
type UpdateLoginFlowParams struct {
	// Flow The Login Flow ID
	// The value for this parameter comes from `flow` URL Query parameter sent to your application (`/login?flow=abcde`).
	Flow string `form:"flow" json:"flow"`

	// XSessionToken The Session Token of the Identity performing the settings flow.
	XSessionToken *string `json:"X-Session-Token,omitempty"`

	// Cookie HTTP Cookies
	// When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header
	// sent by the client to your server here. This ensures that CSRF and session cookies are respected.
	Cookie *string `json:"Cookie,omitempty"`
}

// CreateNativeLoginFlowParams defines parameters for CreateNativeLoginFlow.
type CreateNativeLoginFlowParams struct {
	// Refresh Refresh a login session
	//
	// If set to true, this will refresh an existing login session by
	// asking the user to sign in again. This will reset the
	// authenticated_at time of the session.
	Refresh *bool `form:"refresh,omitempty" json:"refresh,omitempty"`

	// Aal Request a Specific AuthenticationMethod Assurance Level
	// Use this parameter to upgrade an existing session's authenticator assurance level (AAL). This
	// allows you to ask for multi-factor authentication. When an identity sign in using e.g. username+password,
	// the AAL is 1. If you wish to "upgrade" the session's security by asking the user to perform TOTP / WebAuth, you would set this to "aal2".
	Aal *string `form:"aal,omitempty" json:"aal,omitempty"`

	// ReturnSessionTokenExchangeCode EnableSessionTokenExchangeCode requests the login flow to include a code that can be used to retrieve the session token
	// after the login flow has been completed.
	ReturnSessionTokenExchangeCode *bool `form:"return_session_token_exchange_code,omitempty" json:"return_session_token_exchange_code,omitempty"`

	// ReturnTo The URL to return the browser to after the flow was completed.
	ReturnTo *string `form:"return_to,omitempty" json:"return_to,omitempty"`

	// Via Via should contain the identity's credential the code should be sent to. Only relevant in aal2 flows.
	Via *string `form:"via,omitempty" json:"via,omitempty"`

	// XSessionToken The Session Token of the Identity performing the settings flow.
	XSessionToken *string `json:"X-Session-Token,omitempty"`
}

// CreateBrowserLoginFlowParams defines parameters for CreateBrowserLoginFlow.
type CreateBrowserLoginFlowParams struct {
	// Refresh Refresh a login session
	//
	// If set to true, this will refresh an existing login session by
	// asking the user to sign in again. This will reset the
	// authenticated_at time of the session.
	Refresh *bool `form:"refresh,omitempty" json:"refresh,omitempty"`

	// Aal Request a Specific AuthenticationMethod Assurance Level
	//
	// Use this parameter to upgrade an existing session's authenticator assurance level (AAL). This
	// allows you to ask for multi-factor authentication. When an identity sign in using e.g. username+password,
	// the AAL is 1. If you wish to "upgrade" the session's security by asking the user to perform TOTP / WebAuth/ ...
	// you would set this to "aal2".
	Aal *string `form:"aal,omitempty" json:"aal,omitempty"`

	// ReturnTo The URL to return the browser to after the flow was completed.
	ReturnTo *string `form:"return_to,omitempty" json:"return_to,omitempty"`

	// LoginChallenge The value for this parameter comes from `login_challenge` URL Query parameter sent to your application.
	LoginChallenge *string `form:"login_challenge,omitempty" json:"login_challenge,omitempty"`

	// Organization An optional organization ID that should be used for logging this user in.
	// This parameter is only effective in the  Network.
	Organization *string `form:"organization,omitempty" json:"organization,omitempty"`

	// Cookie HTTP Cookies
	//
	// When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header
	// sent by the client to your server here. This ensures that CSRF and session cookies are respected.
	Cookie *string `json:"Cookie,omitempty"`
}

// GetLoginFlowParams defines parameters for GetLoginFlow.
type GetLoginFlowParams struct {
	// Id The Login Flow ID
	//
	// The value for this parameter comes from `flow` URL Query parameter sent to your
	// application (e.g. `/login?flow=abcde`).
	Id string `form:"id" json:"id"`

	// Cookie HTTP Cookies
	// When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header
	// sent by the client to your server here. This ensures that CSRF and session cookies are respected.
	Cookie *string `json:"Cookie,omitempty"`
}

// UpdateLogoutFlowParams defines parameters for UpdateLogoutFlow.
type UpdateLogoutFlowParams struct {
	// Token A Valid Logout Token
	// If you do not have a logout token because you only have a session cookie,
	// call `/self-service/logout/browser` to generate a URL for this endpoint.
	Token *string `form:"token,omitempty" json:"token,omitempty"`

	// ReturnTo The URL to return to after the logout was completed.
	ReturnTo *string `form:"return_to,omitempty" json:"return_to,omitempty"`

	// Cookie HTTP Cookies
	//
	// When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header
	// sent by the client to your server here. This ensures that CSRF and session cookies are respected.
	Cookie *string `json:"Cookie,omitempty"`
}

// CreateBrowserLogoutFlowParams defines parameters for CreateBrowserLogoutFlow.
type CreateBrowserLogoutFlowParams struct {
	// ReturnTo Return to URL
	//
	// The URL to which the browser should be redirected to after the logout
	// has been performed.
	ReturnTo *string `form:"return_to,omitempty" json:"return_to,omitempty"`

	// Cookie HTTP Cookies
	//
	// If you call this endpoint from a backend, please include the
	// original Cookie header in the request.
	Cookie *string `json:"cookie,omitempty"`
}

// InitRecoveryFlowParams defines parameters for InitRecoveryFlow.
type InitRecoveryFlowParams struct {
	// Flow recovery flowId
	Flow string `form:"flow" json:"flow"`

	// Token Recovery Token
	// The recovery token which completes the recovery request. If the token
	// is invalid (e.g. expired) an error will be shown to the end-user.
	// This parameter is usually set in a link and not used by any direct API call.
	Token *string `form:"token,omitempty" json:"token,omitempty"`

	// Cookie HTTP Cookies
	// When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header
	// sent by the client to your server here. This ensures that CSRF and session cookies are respected.
	Cookie *string `json:"Cookie,omitempty"`
}

// UpdateRecoveryFlowParams defines parameters for UpdateRecoveryFlow.
type UpdateRecoveryFlowParams struct {
	// Flow The Recovery Flow ID
	//
	// The value for this parameter comes from `flow` URL Query parameter sent to your
	// application (e.g. `/recovery?flow=abcde`).
	Flow string `form:"flow" json:"flow"`

	// Token Recovery Token
	// The recovery token which completes the recovery request. If the token
	// is invalid (e.g. expired) an error will be shown to the end-user.
	// This parameter is usually set in a link and not used by any direct API call.
	Token *string `form:"token,omitempty" json:"token,omitempty"`

	// Cookie HTTP Cookies
	// When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header
	// sent by the client to your server here. This ensures that CSRF and session cookies are respected.
	Cookie *string `json:"Cookie,omitempty"`
}

// CreateBrowserRecoveryFlowParams defines parameters for CreateBrowserRecoveryFlow.
type CreateBrowserRecoveryFlowParams struct {
	// ReturnTo The URL to return the browser to after the flow was completed.
	ReturnTo *string `form:"return_to,omitempty" json:"return_to,omitempty"`
}

// GetRecoveryFlowParams defines parameters for GetRecoveryFlow.
type GetRecoveryFlowParams struct {
	// Id The Flow ID
	// The value for this parameter comes from `request` URL Query parameter sent to your application (`/recovery?flow=abcde`).
	Id string `form:"id" json:"id"`

	// Cookie HTTP Cookies
	//
	// When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header
	// sent by the client to your server here. This ensures that CSRF and session cookies are respected.
	Cookie *string `json:"Cookie,omitempty"`
}

// UpdateRegistrationFlowParams defines parameters for UpdateRegistrationFlow.
type UpdateRegistrationFlowParams struct {
	// Flow The Registration Flow ID
	// The value for this parameter comes from `flow` URL Query parameter sent to your application.
	Flow string `form:"flow" json:"flow"`

	// Cookie HTTP Cookies
	//
	// When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header
	// sent by the client to your server here. This ensures that CSRF and session cookies are respected.
	Cookie *string `json:"Cookie,omitempty"`
}

// CreateNativeRegistrationFlowParams defines parameters for CreateNativeRegistrationFlow.
type CreateNativeRegistrationFlowParams struct {
	// ReturnSessionTokenExchangeCode EnableSessionTokenExchangeCode requests the login flow to include a code that can be used to retrieve the session token the login flow has been completed.
	ReturnSessionTokenExchangeCode *bool `form:"return_session_token_exchange_code,omitempty" json:"return_session_token_exchange_code,omitempty"`

	// ReturnTo The URL to return the browser to after the flow was completed.
	ReturnTo *string `form:"return_to,omitempty" json:"return_to,omitempty"`
}

// CreateBrowserRegistrationFlowParams defines parameters for CreateBrowserRegistrationFlow.
type CreateBrowserRegistrationFlowParams struct {
	ReturnTo                  *string `form:"return_to,omitempty" json:"return_to,omitempty"`
	LoginChallenge            *string `form:"login_challenge,omitempty" json:"login_challenge,omitempty"`
	AfterVerificationReturnTo *string `form:"after_verification_return_to,omitempty" json:"after_verification_return_to,omitempty"`
	Organization              *string `form:"organization,omitempty" json:"organization,omitempty"`
}

// GetRegistrationFlowParams defines parameters for GetRegistrationFlow.
type GetRegistrationFlowParams struct {
	// Id The Registration Flow ID
	//
	// The value for this parameter comes from `flow` URL Query parameter sent to your
	// application (e.g. `/registration?flow=abcde`).
	Id string `form:"id" json:"id"`

	// Cookie HTTP Cookies
	//
	// When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header
	// sent by the client to your server here. This ensures that CSRF and session cookies are respected.
	Cookie *string `json:"Cookie,omitempty"`
}

// UpdateSettingsFloParams defines parameters for UpdateSettingsFlo.
type UpdateSettingsFloParams struct {
	// Flow The Settings Flow ID
	// The value for this parameter comes from `flow` URL Query parameter sent to your application (e.g. `/settings?flow=abcde`).
	Flow string `form:"flow" json:"flow"`

	// XSessionToken The Session Token of the Identity performing the settings flow.
	XSessionToken *string `json:"X-Session-Token,omitempty"`

	// Cookie HTTP Cookies
	//
	// When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header
	// sent by the client to your server here. This ensures that CSRF and session cookies are respected.
	Cookie *string `json:"Cookie,omitempty"`
}

// CreateNativeSettingsFlowParams defines parameters for CreateNativeSettingsFlow.
type CreateNativeSettingsFlowParams struct {
	// XSessionToken The Session Token of the Identity performing the settings flow.
	XSessionToken *string `json:"X-Session-Token,omitempty"`
}

// CreateBrowserSettingsFlowParams defines parameters for CreateBrowserSettingsFlow.
type CreateBrowserSettingsFlowParams struct {
	// ReturnTo The URL to return the browser to after the flow was completed.
	ReturnTo *string `form:"return_to,omitempty" json:"return_to,omitempty"`

	// Cookie HTTP Cookies
	// When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header
	// sent by the client to your server here. This ensures that CSRF and session cookies are respected.
	Cookie *string `json:"Cookie,omitempty"`
}

// GetSettingsFlowParams defines parameters for GetSettingsFlow.
type GetSettingsFlowParams struct {
	// Id ID is the Settings Flow ID
	//
	// The value for this parameter comes from `flow` URL Query parameter sent to your
	// application (e.g. `/settings?flow=abcde`).
	Id string `form:"id" json:"id"`

	// XSessionToken The Session Token
	//
	// When using the SDK in an app without a browser, please include the
	// session token here.
	XSessionToken *string `json:"X-Session-Token,omitempty"`

	// Cookie HTTP Cookies
	//
	// When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header
	// sent by the client to your server here. This ensures that CSRF and session cookies are respected.
	Cookie *string `json:"Cookie,omitempty"`
}

// UpdateVerificationFlowParams defines parameters for UpdateVerificationFlow.
type UpdateVerificationFlowParams struct {
	// Flow The Verification Flow ID
	//
	// The value for this parameter comes from `flow` URL Query parameter sent to your
	// application (e.g. `/verification?flow=abcde`).
	Flow string `form:"flow" json:"flow"`

	// Token Verification Token
	//
	// The verification token which completes the verification request. If the token
	// is invalid (e.g. expired) an error will be shown to the end-user.
	//
	// This parameter is usually set in a link and not used by any direct API call.
	Token *string `form:"token,omitempty" json:"token,omitempty"`

	// Cookie HTTP Cookies
	//
	// When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header
	// sent by the client to your server here. This ensures that CSRF and session cookies are respected.
	Cookie *string `json:"Cookie,omitempty"`
}

// CreateBrowserVerificationFlowParams defines parameters for CreateBrowserVerificationFlow.
type CreateBrowserVerificationFlowParams struct {
	// ReturnTo The URL to return the browser to after the flow was completed.
	ReturnTo *string `form:"return_to,omitempty" json:"return_to,omitempty"`
}

// GetVerificationFlowParams defines parameters for GetVerificationFlow.
type GetVerificationFlowParams struct {
	// Id The Flow ID
	//
	// The value for this parameter comes from `request` URL Query parameter sent to your
	// application (e.g. `/verification?flow=abcde`).
	Id string `form:"id" json:"id"`

	// Cookie HTTP Cookies
	//
	// When using the SDK on the server side you must include the HTTP Cookie Header
	// originally sent to your HTTP handler here.
	Cookie *string `json:"cookie,omitempty"`
}

// DisableMyOtherSessionsParams defines parameters for DisableMyOtherSessions.
type DisableMyOtherSessionsParams struct {
	// XSessionToken Set the Session Token when calling from non-browser clients. A session token has a format of `MP2YWEMeM8MxjkGKpH4dqOQ4Q4DlSPaj`.
	XSessionToken *string `json:"X-Session-Token,omitempty"`

	// Cookie Set the Cookie Header. This is especially useful when calling this endpoint from a server-side application. In that
	// scenario you must include the HTTP Cookie Header which originally was included in the request to your server.
	// It is ok if more than one cookie are included here as all other cookies will be ignored.
	Cookie *string `json:"Cookie,omitempty"`
}

// ListMySessionsParams defines parameters for ListMySessions.
type ListMySessionsParams struct {
	// PerPage Deprecated Items per Page
	//
	// DEPRECATED: Please use `page_token` instead. This parameter will be removed in the future.
	//
	// This is the number of items per page.
	PerPage *int64 `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Deprecated Pagination Page
	//
	// DEPRECATED: Please use `page_token` instead. This parameter will be removed in the future.
	//
	// This value is currently an integer, but it is not sequential. The value is not the page number, but a
	// reference. The next page can be any number and some numbers might return an empty list.
	//
	// For example, page 2 might not follow after page 1. And even if page 3 and 5 exist, but page 4 might not exist.
	// The first page can be retrieved by omitting this parameter. Following page pointers will be returned in the
	// `Link` header.
	Page *int64 `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page Size
	// This is the number of items per page to return.
	PageSize *int64 `form:"page_size,omitempty" json:"page_size,omitempty"`

	// PageToken Next Page Token
	PageToken *string `form:"page_token,omitempty" json:"page_token,omitempty"`

	// XSessionToken Set the Session Token when calling from non-browser clients. A session token has a format of `MP2YWEMeM8MxjkGKpH4dqOQ4Q4DlSPaj`.
	XSessionToken *string `json:"X-Session-Token,omitempty"`

	// Cookie Set the Cookie Header. This is especially useful when calling this endpoint from a server-side application. In that
	// scenario you must include the HTTP Cookie Header which originally was included in the request to your server.
	// It is ok if more than one cookie are included here as all other cookies will be ignored.
	Cookie *string `json:"Cookie,omitempty"`
}

// ExchangeSessionTokenParams defines parameters for ExchangeSessionToken.
type ExchangeSessionTokenParams struct {
	// InitCode The part of the code return when initializing the flow.
	InitCode string `form:"init_code" json:"init_code"`

	// ReturnToCode The part of the code returned by the return_to URL.
	ReturnToCode string `form:"return_to_code" json:"return_to_code"`
}

// ToSessionParams defines parameters for ToSession.
type ToSessionParams struct {
	// TokenizeAs Returns the session additionally as a token (such as a JWT). The value of this parameter has to be a valid, configured Session token template.
	TokenizeAs *string `form:"tokenize_as,omitempty" json:"tokenize_as,omitempty"`

	// XSessionToken Set the Session Token when calling from non-browser clients.
	XSessionToken *string `json:"X-Session-Token,omitempty"`

	// Cookie Set the Cookie Header. This is especially useful when calling this endpoint from a server-side application. In that
	// scenario you must include the HTTP Cookie Header which originally was included in the request to your server.
	// It is ok if more than one cookie are included here as all other cookies will be ignored.
	Cookie *string `json:"Cookie,omitempty"`
}

// ListOrganisationsIdentityParams defines parameters for ListOrganisationsIdentity.
type ListOrganisationsIdentityParams struct {
	// Page Paginated request
	Page *ListUserOrganisations `json:"page,omitempty"`
}

// SetIAMGranularPolicyOrganisationJSONBody defines parameters for SetIAMGranularPolicyOrganisation.
type SetIAMGranularPolicyOrganisationJSONBody struct {
	Add    *GranularPolicyList `json:"add,omitempty"`
	Delete *GranularPolicyList `json:"delete,omitempty"`
}

// SetIAMPolicyOrganisationJSONBody defines parameters for SetIAMPolicyOrganisation.
type SetIAMPolicyOrganisationJSONBody struct {
	Add    *IAMPolicy `json:"add,omitempty"`
	Delete *IAMPolicy `json:"delete,omitempty"`
}

// ListPermissionsOrganisationParams defines parameters for ListPermissionsOrganisation.
type ListPermissionsOrganisationParams struct {
	// Service service the permission is related to
	Service *Service `form:"service,omitempty" json:"service,omitempty"`

	// Resource resource the permission is related to
	Resource *Resource `form:"resource,omitempty" json:"resource,omitempty"`

	// Subresource subresource the permission is related to
	Subresource *SubResource `form:"subresource,omitempty" json:"subresource,omitempty"`

	// Action action the permission allows to perform
	Action *Action `form:"action,omitempty" json:"action,omitempty"`

	// Page Paginated request
	Page *ListPermissionsPage `json:"page,omitempty"`
}

// ListRolesOrganisationParams defines parameters for ListRolesOrganisation.
type ListRolesOrganisationParams struct {
	// Name Role name
	Name *RoleName `form:"name,omitempty" json:"name,omitempty"`

	// Page Paginated request
	Page *ListRolesPage `json:"page,omitempty"`
}

// UpdateRoleOrganisationJSONBody defines parameters for UpdateRoleOrganisation.
type UpdateRoleOrganisationJSONBody struct {
	// Description Human-readable description
	Description *string `json:"description,omitempty"`

	// Name Human-readable name
	Name *string `json:"name,omitempty"`
}

// ListServiceAccountOrganisationParams defines parameters for ListServiceAccountOrganisation.
type ListServiceAccountOrganisationParams struct {
	// Page Paginated request
	Page *ListServiceAccounts `json:"page,omitempty"`
}

// GetACLServiceAccountOrganisationParams defines parameters for GetACLServiceAccountOrganisation.
type GetACLServiceAccountOrganisationParams struct {
	Service     string  `form:"service" json:"service"`
	Resource    string  `form:"resource" json:"resource"`
	Subresource *string `form:"subresource,omitempty" json:"subresource,omitempty"`
}

// ListSpacesOfServiceAccountParams defines parameters for ListSpacesOfServiceAccount.
type ListSpacesOfServiceAccountParams struct {
	// Page Paginated request
	Page *ListSpacesOfServiceAccount `json:"page,omitempty"`
}

// ListSpacesIdentityParams defines parameters for ListSpacesIdentity.
type ListSpacesIdentityParams struct {
	// Page Paginated request
	Page *ListSpacesIdentity `json:"page,omitempty"`
}

// ListUserOrganisationParams defines parameters for ListUserOrganisation.
type ListUserOrganisationParams struct {
	// Email User email
	Email *UserEmail `form:"email,omitempty" json:"email,omitempty"`

	// Page Paginated request
	Page *ListUser `json:"page,omitempty"`
}

// GetACLUserOrganisationParams defines parameters for GetACLUserOrganisation.
type GetACLUserOrganisationParams struct {
	Service     string  `form:"service" json:"service"`
	Resource    string  `form:"resource" json:"resource"`
	Subresource *string `form:"subresource,omitempty" json:"subresource,omitempty"`
}

// ListSpacesOfUserParams defines parameters for ListSpacesOfUser.
type ListSpacesOfUserParams struct {
	// Page Paginated request
	Page *ListSpacesOfUser `json:"page,omitempty"`
}

// RevokeParams defines parameters for Revoke.
type RevokeParams struct {
	// Authorization The client identifier.
	Authorization *Authorization `json:"Authorization,omitempty"`
}

// SetIAMGranularPolicySpaceJSONBody defines parameters for SetIAMGranularPolicySpace.
type SetIAMGranularPolicySpaceJSONBody struct {
	Add    *GranularPolicyList `json:"add,omitempty"`
	Delete *GranularPolicyList `json:"delete,omitempty"`
}

// SetIAMPolicySpaceJSONBody defines parameters for SetIAMPolicySpace.
type SetIAMPolicySpaceJSONBody struct {
	Add    *IAMPolicy `json:"add,omitempty"`
	Delete *IAMPolicy `json:"delete,omitempty"`
}

// ListPermissionsSpaceParams defines parameters for ListPermissionsSpace.
type ListPermissionsSpaceParams struct {
	// Service service the permission is related to
	Service *Service `form:"service,omitempty" json:"service,omitempty"`

	// Resource resource the permission is related to
	Resource *Resource `form:"resource,omitempty" json:"resource,omitempty"`

	// Subresource subresource the permission is related to
	Subresource *SubResource `form:"subresource,omitempty" json:"subresource,omitempty"`

	// Action action the permission allows to perform
	Action *Action `form:"action,omitempty" json:"action,omitempty"`

	// Page Paginated request
	Page *ListPermissionsPage `json:"page,omitempty"`
}

// ListRolesSpaceParams defines parameters for ListRolesSpace.
type ListRolesSpaceParams struct {
	// Name Role name
	Name *RoleName `form:"name,omitempty" json:"name,omitempty"`

	// Page Paginated request
	Page *ListRolesPage `json:"page,omitempty"`
}

// UpdateRoleSpaceJSONBody defines parameters for UpdateRoleSpace.
type UpdateRoleSpaceJSONBody struct {
	// Description Human-readable description
	Description *string `json:"description,omitempty"`

	// Name Human-readable name
	Name *string `json:"name,omitempty"`
}

// ListServiceAccountSpaceParams defines parameters for ListServiceAccountSpace.
type ListServiceAccountSpaceParams struct {
	// Page Paginated request
	Page *ListServiceAccounts `json:"page,omitempty"`
}

// GetACLServiceAccountSpaceParams defines parameters for GetACLServiceAccountSpace.
type GetACLServiceAccountSpaceParams struct {
	Service     string  `form:"service" json:"service"`
	Resource    string  `form:"resource" json:"resource"`
	Subresource *string `form:"subresource,omitempty" json:"subresource,omitempty"`
}

// ListUserSpaceParams defines parameters for ListUserSpace.
type ListUserSpaceParams struct {
	// Email User email
	Email *UserEmail `form:"email,omitempty" json:"email,omitempty"`

	// Page Paginated request
	Page *ListUser `json:"page,omitempty"`
}

// GetACLUserSpaceParams defines parameters for GetACLUserSpace.
type GetACLUserSpaceParams struct {
	Service     string  `form:"service" json:"service"`
	Resource    string  `form:"resource" json:"resource"`
	Subresource *string `form:"subresource,omitempty" json:"subresource,omitempty"`
}

// TokenParams defines parameters for Token.
type TokenParams struct {
	// Authorization The client identifier.
	Authorization *Authorization `json:"Authorization,omitempty"`
}

// GetUserInfoParams defines parameters for GetUserInfo.
type GetUserInfoParams struct {
	// Authorization The client identifier.
	Authorization *Authorization `json:"Authorization,omitempty"`
}

// ListOperationsParams defines parameters for ListOperations.
type ListOperationsParams struct {
	Status    *OperationStatuses `form:"status,omitempty" json:"status,omitempty"`
	ClusterId *QueryClusterId    `form:"clusterId,omitempty" json:"clusterId,omitempty"`
}

// ListSpacesParams defines parameters for ListSpaces.
type ListSpacesParams struct {
	// Page list spaces paginated request
	Page *ListSpacesPage `json:"page,omitempty"`
}

// CreateAdminServiceAccountSpaceJSONRequestBody defines body for CreateAdminServiceAccountSpace for application/json ContentType.
type CreateAdminServiceAccountSpaceJSONRequestBody = ServiceAccount

// UpdateLoginFlowJSONRequestBody defines body for UpdateLoginFlow for application/json ContentType.
type UpdateLoginFlowJSONRequestBody = UpdateLoginFlowBody

// UpdateLoginFlowFormdataRequestBody defines body for UpdateLoginFlow for application/x-www-form-urlencoded ContentType.
type UpdateLoginFlowFormdataRequestBody = UpdateLoginFlowBody

// PerformNativeLogoutJSONRequestBody defines body for PerformNativeLogout for application/json ContentType.
type PerformNativeLogoutJSONRequestBody = PerformNativeLogoutBody

// UpdateRecoveryFlowJSONRequestBody defines body for UpdateRecoveryFlow for application/json ContentType.
type UpdateRecoveryFlowJSONRequestBody = UpdateRecoveryFlowBody

// UpdateRecoveryFlowFormdataRequestBody defines body for UpdateRecoveryFlow for application/x-www-form-urlencoded ContentType.
type UpdateRecoveryFlowFormdataRequestBody = UpdateRecoveryFlowBody

// UpdateRegistrationFlowJSONRequestBody defines body for UpdateRegistrationFlow for application/json ContentType.
type UpdateRegistrationFlowJSONRequestBody = UpdateRegistrationFlowBody

// UpdateRegistrationFlowFormdataRequestBody defines body for UpdateRegistrationFlow for application/x-www-form-urlencoded ContentType.
type UpdateRegistrationFlowFormdataRequestBody = UpdateRegistrationFlowBody

// UpdateSettingsFloJSONRequestBody defines body for UpdateSettingsFlo for application/json ContentType.
type UpdateSettingsFloJSONRequestBody = UpdateSettingsFlowBody

// UpdateSettingsFloFormdataRequestBody defines body for UpdateSettingsFlo for application/x-www-form-urlencoded ContentType.
type UpdateSettingsFloFormdataRequestBody = UpdateSettingsFlowBody

// UpdateVerificationFlowJSONRequestBody defines body for UpdateVerificationFlow for application/json ContentType.
type UpdateVerificationFlowJSONRequestBody = UpdateVerificationFlowBody

// UpdateVerificationFlowFormdataRequestBody defines body for UpdateVerificationFlow for application/x-www-form-urlencoded ContentType.
type UpdateVerificationFlowFormdataRequestBody = UpdateVerificationFlowBody

// IntrospectFormdataRequestBody defines body for Introspect for application/x-www-form-urlencoded ContentType.
type IntrospectFormdataRequestBody = TokenBody

// SetIAMGranularPolicyOrganisationJSONRequestBody defines body for SetIAMGranularPolicyOrganisation for application/json ContentType.
type SetIAMGranularPolicyOrganisationJSONRequestBody SetIAMGranularPolicyOrganisationJSONBody

// SetIAMPolicyOrganisationJSONRequestBody defines body for SetIAMPolicyOrganisation for application/json ContentType.
type SetIAMPolicyOrganisationJSONRequestBody SetIAMPolicyOrganisationJSONBody

// CreateRoleOrganisationJSONRequestBody defines body for CreateRoleOrganisation for application/json ContentType.
type CreateRoleOrganisationJSONRequestBody = Role

// UpdateRoleOrganisationJSONRequestBody defines body for UpdateRoleOrganisation for application/json ContentType.
type UpdateRoleOrganisationJSONRequestBody UpdateRoleOrganisationJSONBody

// RemoveRolePermissionsOrganisationJSONRequestBody defines body for RemoveRolePermissionsOrganisation for application/json ContentType.
type RemoveRolePermissionsOrganisationJSONRequestBody = RolePermission

// AddRolePermissionsOrganisationJSONRequestBody defines body for AddRolePermissionsOrganisation for application/json ContentType.
type AddRolePermissionsOrganisationJSONRequestBody = RolePermission

// ListServiceAccountOrganisationJSONRequestBody defines body for ListServiceAccountOrganisation for application/json ContentType.
type ListServiceAccountOrganisationJSONRequestBody = IdentitiesIdsList

// CreateServiceAccountOrganisationJSONRequestBody defines body for CreateServiceAccountOrganisation for application/json ContentType.
type CreateServiceAccountOrganisationJSONRequestBody = ServiceAccount

// UpdateServiceAccountOrganisationJSONRequestBody defines body for UpdateServiceAccountOrganisation for application/json ContentType.
type UpdateServiceAccountOrganisationJSONRequestBody = ServiceAccount

// DeleteACLServiceAccountOrganisationBulkJSONRequestBody defines body for DeleteACLServiceAccountOrganisationBulk for application/json ContentType.
type DeleteACLServiceAccountOrganisationBulkJSONRequestBody = ACLList

// CreateACLServiceAccountOrganisationBulkJSONRequestBody defines body for CreateACLServiceAccountOrganisationBulk for application/json ContentType.
type CreateACLServiceAccountOrganisationBulkJSONRequestBody = ACLList

// ListUserOrganisationJSONRequestBody defines body for ListUserOrganisation for application/json ContentType.
type ListUserOrganisationJSONRequestBody = IdentitiesIdsList

// CreateUserOrganisationJSONRequestBody defines body for CreateUserOrganisation for application/json ContentType.
type CreateUserOrganisationJSONRequestBody = User

// PatchUserStateOrganisationJSONRequestBody defines body for PatchUserStateOrganisation for application/json ContentType.
type PatchUserStateOrganisationJSONRequestBody = UserState

// UpdateUserOrganisationJSONRequestBody defines body for UpdateUserOrganisation for application/json ContentType.
type UpdateUserOrganisationJSONRequestBody = UserUpdate

// DeleteACLUserOrganisationBulkJSONRequestBody defines body for DeleteACLUserOrganisationBulk for application/json ContentType.
type DeleteACLUserOrganisationBulkJSONRequestBody = ACLList

// CreateACLUserOrganisationBulkJSONRequestBody defines body for CreateACLUserOrganisationBulk for application/json ContentType.
type CreateACLUserOrganisationBulkJSONRequestBody = ACLList

// RevokeFormdataRequestBody defines body for Revoke for application/x-www-form-urlencoded ContentType.
type RevokeFormdataRequestBody = TokenBody

// SetIAMGranularPolicySpaceJSONRequestBody defines body for SetIAMGranularPolicySpace for application/json ContentType.
type SetIAMGranularPolicySpaceJSONRequestBody SetIAMGranularPolicySpaceJSONBody

// SetIAMPolicySpaceJSONRequestBody defines body for SetIAMPolicySpace for application/json ContentType.
type SetIAMPolicySpaceJSONRequestBody SetIAMPolicySpaceJSONBody

// CreateRoleSpaceJSONRequestBody defines body for CreateRoleSpace for application/json ContentType.
type CreateRoleSpaceJSONRequestBody = Role

// UpdateRoleSpaceJSONRequestBody defines body for UpdateRoleSpace for application/json ContentType.
type UpdateRoleSpaceJSONRequestBody UpdateRoleSpaceJSONBody

// RemoveRolePermissionsSpaceJSONRequestBody defines body for RemoveRolePermissionsSpace for application/json ContentType.
type RemoveRolePermissionsSpaceJSONRequestBody = RolePermission

// AddRolePermissionsSpaceJSONRequestBody defines body for AddRolePermissionsSpace for application/json ContentType.
type AddRolePermissionsSpaceJSONRequestBody = RolePermission

// ListServiceAccountSpaceJSONRequestBody defines body for ListServiceAccountSpace for application/json ContentType.
type ListServiceAccountSpaceJSONRequestBody = IdentitiesIdsList

// CreateServiceAccountSpaceJSONRequestBody defines body for CreateServiceAccountSpace for application/json ContentType.
type CreateServiceAccountSpaceJSONRequestBody = ServiceAccount

// UpdateServiceAccountSpaceJSONRequestBody defines body for UpdateServiceAccountSpace for application/json ContentType.
type UpdateServiceAccountSpaceJSONRequestBody = ServiceAccount

// DeleteACLServiceAccountSpaceBulkJSONRequestBody defines body for DeleteACLServiceAccountSpaceBulk for application/json ContentType.
type DeleteACLServiceAccountSpaceBulkJSONRequestBody = ACLList

// CreateACLServiceAccountSpaceBulkJSONRequestBody defines body for CreateACLServiceAccountSpaceBulk for application/json ContentType.
type CreateACLServiceAccountSpaceBulkJSONRequestBody = ACLList

// ListUserSpaceJSONRequestBody defines body for ListUserSpace for application/json ContentType.
type ListUserSpaceJSONRequestBody = IdentitiesIdsList

// CreateUserSpaceJSONRequestBody defines body for CreateUserSpace for application/json ContentType.
type CreateUserSpaceJSONRequestBody = User

// PatchUserStateSpaceJSONRequestBody defines body for PatchUserStateSpace for application/json ContentType.
type PatchUserStateSpaceJSONRequestBody = UserState

// UpdateUserSpaceJSONRequestBody defines body for UpdateUserSpace for application/json ContentType.
type UpdateUserSpaceJSONRequestBody = UserUpdate

// DeleteACLUserSpaceBulkJSONRequestBody defines body for DeleteACLUserSpaceBulk for application/json ContentType.
type DeleteACLUserSpaceBulkJSONRequestBody = ACLList

// CreateACLUserSpaceBulkJSONRequestBody defines body for CreateACLUserSpaceBulk for application/json ContentType.
type CreateACLUserSpaceBulkJSONRequestBody = ACLList

// TokenFormdataRequestBody defines body for Token for application/x-www-form-urlencoded ContentType.
type TokenFormdataRequestBody = TokenReq

// CreateClusterJSONRequestBody defines body for CreateCluster for application/json ContentType.
type CreateClusterJSONRequestBody = CreateCluster

// UpdateClusterJSONRequestBody defines body for UpdateCluster for application/json ContentType.
type UpdateClusterJSONRequestBody = UpdateCluster

// CreateNodePoolJSONRequestBody defines body for CreateNodePool for application/json ContentType.
type CreateNodePoolJSONRequestBody = CreateNodepool

// UpdateNodepoolJSONRequestBody defines body for UpdateNodepool for application/json ContentType.
type UpdateNodepoolJSONRequestBody = ReqUpdateNodepool

// UpdateSpaceJSONRequestBody defines body for UpdateSpace for application/json ContentType.
type UpdateSpaceJSONRequestBody = MutableSpace

// ListSpacesJSONRequestBody defines body for ListSpaces for application/json ContentType.
type ListSpacesJSONRequestBody = SpaceIdsList

// CreateSpaceJSONRequestBody defines body for CreateSpace for application/json ContentType.
type CreateSpaceJSONRequestBody = CreateSpace

// AsContinueWithVerificationUi returns the union data inside the ContinueWith as a ContinueWithVerificationUi
func (t ContinueWith) AsContinueWithVerificationUi() (ContinueWithVerificationUi, error) {
	var body ContinueWithVerificationUi
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContinueWithVerificationUi overwrites any union data inside the ContinueWith as the provided ContinueWithVerificationUi
func (t *ContinueWith) FromContinueWithVerificationUi(v ContinueWithVerificationUi) error {
	v.Action = "show_verification_ui"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContinueWithVerificationUi performs a merge with any union data inside the ContinueWith, using the provided ContinueWithVerificationUi
func (t *ContinueWith) MergeContinueWithVerificationUi(v ContinueWithVerificationUi) error {
	v.Action = "show_verification_ui"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContinueWithSetSessionToken returns the union data inside the ContinueWith as a ContinueWithSetSessionToken
func (t ContinueWith) AsContinueWithSetSessionToken() (ContinueWithSetSessionToken, error) {
	var body ContinueWithSetSessionToken
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContinueWithSetSessionToken overwrites any union data inside the ContinueWith as the provided ContinueWithSetSessionToken
func (t *ContinueWith) FromContinueWithSetSessionToken(v ContinueWithSetSessionToken) error {
	v.Action = "set_session_token"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContinueWithSetSessionToken performs a merge with any union data inside the ContinueWith, using the provided ContinueWithSetSessionToken
func (t *ContinueWith) MergeContinueWithSetSessionToken(v ContinueWithSetSessionToken) error {
	v.Action = "set_session_token"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContinueWithSettingsUi returns the union data inside the ContinueWith as a ContinueWithSettingsUi
func (t ContinueWith) AsContinueWithSettingsUi() (ContinueWithSettingsUi, error) {
	var body ContinueWithSettingsUi
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContinueWithSettingsUi overwrites any union data inside the ContinueWith as the provided ContinueWithSettingsUi
func (t *ContinueWith) FromContinueWithSettingsUi(v ContinueWithSettingsUi) error {
	v.Action = "show_settings_ui"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContinueWithSettingsUi performs a merge with any union data inside the ContinueWith, using the provided ContinueWithSettingsUi
func (t *ContinueWith) MergeContinueWithSettingsUi(v ContinueWithSettingsUi) error {
	v.Action = "show_settings_ui"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContinueWithRecoveryUi returns the union data inside the ContinueWith as a ContinueWithRecoveryUi
func (t ContinueWith) AsContinueWithRecoveryUi() (ContinueWithRecoveryUi, error) {
	var body ContinueWithRecoveryUi
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContinueWithRecoveryUi overwrites any union data inside the ContinueWith as the provided ContinueWithRecoveryUi
func (t *ContinueWith) FromContinueWithRecoveryUi(v ContinueWithRecoveryUi) error {
	v.Action = "show_recovery_ui"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContinueWithRecoveryUi performs a merge with any union data inside the ContinueWith, using the provided ContinueWithRecoveryUi
func (t *ContinueWith) MergeContinueWithRecoveryUi(v ContinueWithRecoveryUi) error {
	v.Action = "show_recovery_ui"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ContinueWith) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"action"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ContinueWith) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "set_session_token":
		return t.AsContinueWithSetSessionToken()
	case "show_recovery_ui":
		return t.AsContinueWithRecoveryUi()
	case "show_settings_ui":
		return t.AsContinueWithSettingsUi()
	case "show_verification_ui":
		return t.AsContinueWithVerificationUi()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ContinueWith) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ContinueWith) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOperationData0 returns the union data inside the Operation_Data as a OperationData0
func (t Operation_Data) AsOperationData0() (OperationData0, error) {
	var body OperationData0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOperationData0 overwrites any union data inside the Operation_Data as the provided OperationData0
func (t *Operation_Data) FromOperationData0(v OperationData0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOperationData0 performs a merge with any union data inside the Operation_Data, using the provided OperationData0
func (t *Operation_Data) MergeOperationData0(v OperationData0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOperationData1 returns the union data inside the Operation_Data as a OperationData1
func (t Operation_Data) AsOperationData1() (OperationData1, error) {
	var body OperationData1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOperationData1 overwrites any union data inside the Operation_Data as the provided OperationData1
func (t *Operation_Data) FromOperationData1(v OperationData1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOperationData1 performs a merge with any union data inside the Operation_Data, using the provided OperationData1
func (t *Operation_Data) MergeOperationData1(v OperationData1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Operation_Data) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Operation_Data) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOperationError0 returns the union data inside the Operation_Error as a OperationError0
func (t Operation_Error) AsOperationError0() (OperationError0, error) {
	var body OperationError0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOperationError0 overwrites any union data inside the Operation_Error as the provided OperationError0
func (t *Operation_Error) FromOperationError0(v OperationError0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOperationError0 performs a merge with any union data inside the Operation_Error, using the provided OperationError0
func (t *Operation_Error) MergeOperationError0(v OperationError0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOperationError1 returns the union data inside the Operation_Error as a OperationError1
func (t Operation_Error) AsOperationError1() (OperationError1, error) {
	var body OperationError1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOperationError1 overwrites any union data inside the Operation_Error as the provided OperationError1
func (t *Operation_Error) FromOperationError1(v OperationError1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOperationError1 performs a merge with any union data inside the Operation_Error, using the provided OperationError1
func (t *Operation_Error) MergeOperationError1(v OperationError1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Operation_Error) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Operation_Error) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOperationProgress0 returns the union data inside the Operation_Progress as a OperationProgress0
func (t Operation_Progress) AsOperationProgress0() (OperationProgress0, error) {
	var body OperationProgress0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOperationProgress0 overwrites any union data inside the Operation_Progress as the provided OperationProgress0
func (t *Operation_Progress) FromOperationProgress0(v OperationProgress0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOperationProgress0 performs a merge with any union data inside the Operation_Progress, using the provided OperationProgress0
func (t *Operation_Progress) MergeOperationProgress0(v OperationProgress0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOperationProgress1 returns the union data inside the Operation_Progress as a OperationProgress1
func (t Operation_Progress) AsOperationProgress1() (OperationProgress1, error) {
	var body OperationProgress1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOperationProgress1 overwrites any union data inside the Operation_Progress as the provided OperationProgress1
func (t *Operation_Progress) FromOperationProgress1(v OperationProgress1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOperationProgress1 performs a merge with any union data inside the Operation_Progress, using the provided OperationProgress1
func (t *Operation_Progress) MergeOperationProgress1(v OperationProgress1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Operation_Progress) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Operation_Progress) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOperationResult0 returns the union data inside the Operation_Result as a OperationResult0
func (t Operation_Result) AsOperationResult0() (OperationResult0, error) {
	var body OperationResult0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOperationResult0 overwrites any union data inside the Operation_Result as the provided OperationResult0
func (t *Operation_Result) FromOperationResult0(v OperationResult0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOperationResult0 performs a merge with any union data inside the Operation_Result, using the provided OperationResult0
func (t *Operation_Result) MergeOperationResult0(v OperationResult0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOperationResult1 returns the union data inside the Operation_Result as a OperationResult1
func (t Operation_Result) AsOperationResult1() (OperationResult1, error) {
	var body OperationResult1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOperationResult1 overwrites any union data inside the Operation_Result as the provided OperationResult1
func (t *Operation_Result) FromOperationResult1(v OperationResult1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOperationResult1 performs a merge with any union data inside the Operation_Result, using the provided OperationResult1
func (t *Operation_Result) MergeOperationResult1(v OperationResult1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Operation_Result) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Operation_Result) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUiNodeInputAttributes returns the union data inside the UiNodeAttributes as a UiNodeInputAttributes
func (t UiNodeAttributes) AsUiNodeInputAttributes() (UiNodeInputAttributes, error) {
	var body UiNodeInputAttributes
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUiNodeInputAttributes overwrites any union data inside the UiNodeAttributes as the provided UiNodeInputAttributes
func (t *UiNodeAttributes) FromUiNodeInputAttributes(v UiNodeInputAttributes) error {
	v.NodeType = "input"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUiNodeInputAttributes performs a merge with any union data inside the UiNodeAttributes, using the provided UiNodeInputAttributes
func (t *UiNodeAttributes) MergeUiNodeInputAttributes(v UiNodeInputAttributes) error {
	v.NodeType = "input"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUiNodeTextAttributes returns the union data inside the UiNodeAttributes as a UiNodeTextAttributes
func (t UiNodeAttributes) AsUiNodeTextAttributes() (UiNodeTextAttributes, error) {
	var body UiNodeTextAttributes
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUiNodeTextAttributes overwrites any union data inside the UiNodeAttributes as the provided UiNodeTextAttributes
func (t *UiNodeAttributes) FromUiNodeTextAttributes(v UiNodeTextAttributes) error {
	v.NodeType = "text"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUiNodeTextAttributes performs a merge with any union data inside the UiNodeAttributes, using the provided UiNodeTextAttributes
func (t *UiNodeAttributes) MergeUiNodeTextAttributes(v UiNodeTextAttributes) error {
	v.NodeType = "text"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUiNodeImageAttributes returns the union data inside the UiNodeAttributes as a UiNodeImageAttributes
func (t UiNodeAttributes) AsUiNodeImageAttributes() (UiNodeImageAttributes, error) {
	var body UiNodeImageAttributes
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUiNodeImageAttributes overwrites any union data inside the UiNodeAttributes as the provided UiNodeImageAttributes
func (t *UiNodeAttributes) FromUiNodeImageAttributes(v UiNodeImageAttributes) error {
	v.NodeType = "img"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUiNodeImageAttributes performs a merge with any union data inside the UiNodeAttributes, using the provided UiNodeImageAttributes
func (t *UiNodeAttributes) MergeUiNodeImageAttributes(v UiNodeImageAttributes) error {
	v.NodeType = "img"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUiNodeAnchorAttributes returns the union data inside the UiNodeAttributes as a UiNodeAnchorAttributes
func (t UiNodeAttributes) AsUiNodeAnchorAttributes() (UiNodeAnchorAttributes, error) {
	var body UiNodeAnchorAttributes
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUiNodeAnchorAttributes overwrites any union data inside the UiNodeAttributes as the provided UiNodeAnchorAttributes
func (t *UiNodeAttributes) FromUiNodeAnchorAttributes(v UiNodeAnchorAttributes) error {
	v.NodeType = "a"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUiNodeAnchorAttributes performs a merge with any union data inside the UiNodeAttributes, using the provided UiNodeAnchorAttributes
func (t *UiNodeAttributes) MergeUiNodeAnchorAttributes(v UiNodeAnchorAttributes) error {
	v.NodeType = "a"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUiNodeScriptAttributes returns the union data inside the UiNodeAttributes as a UiNodeScriptAttributes
func (t UiNodeAttributes) AsUiNodeScriptAttributes() (UiNodeScriptAttributes, error) {
	var body UiNodeScriptAttributes
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUiNodeScriptAttributes overwrites any union data inside the UiNodeAttributes as the provided UiNodeScriptAttributes
func (t *UiNodeAttributes) FromUiNodeScriptAttributes(v UiNodeScriptAttributes) error {
	v.NodeType = "script"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUiNodeScriptAttributes performs a merge with any union data inside the UiNodeAttributes, using the provided UiNodeScriptAttributes
func (t *UiNodeAttributes) MergeUiNodeScriptAttributes(v UiNodeScriptAttributes) error {
	v.NodeType = "script"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UiNodeAttributes) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"node_type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t UiNodeAttributes) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "a":
		return t.AsUiNodeAnchorAttributes()
	case "img":
		return t.AsUiNodeImageAttributes()
	case "input":
		return t.AsUiNodeInputAttributes()
	case "script":
		return t.AsUiNodeScriptAttributes()
	case "text":
		return t.AsUiNodeTextAttributes()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t UiNodeAttributes) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UiNodeAttributes) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUpdateLoginFlowWithPasswordMethod returns the union data inside the UpdateLoginFlowBody as a UpdateLoginFlowWithPasswordMethod
func (t UpdateLoginFlowBody) AsUpdateLoginFlowWithPasswordMethod() (UpdateLoginFlowWithPasswordMethod, error) {
	var body UpdateLoginFlowWithPasswordMethod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateLoginFlowWithPasswordMethod overwrites any union data inside the UpdateLoginFlowBody as the provided UpdateLoginFlowWithPasswordMethod
func (t *UpdateLoginFlowBody) FromUpdateLoginFlowWithPasswordMethod(v UpdateLoginFlowWithPasswordMethod) error {
	v.Method = "password"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateLoginFlowWithPasswordMethod performs a merge with any union data inside the UpdateLoginFlowBody, using the provided UpdateLoginFlowWithPasswordMethod
func (t *UpdateLoginFlowBody) MergeUpdateLoginFlowWithPasswordMethod(v UpdateLoginFlowWithPasswordMethod) error {
	v.Method = "password"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateLoginFlowWithOidcMethod returns the union data inside the UpdateLoginFlowBody as a UpdateLoginFlowWithOidcMethod
func (t UpdateLoginFlowBody) AsUpdateLoginFlowWithOidcMethod() (UpdateLoginFlowWithOidcMethod, error) {
	var body UpdateLoginFlowWithOidcMethod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateLoginFlowWithOidcMethod overwrites any union data inside the UpdateLoginFlowBody as the provided UpdateLoginFlowWithOidcMethod
func (t *UpdateLoginFlowBody) FromUpdateLoginFlowWithOidcMethod(v UpdateLoginFlowWithOidcMethod) error {
	v.Method = "oidc"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateLoginFlowWithOidcMethod performs a merge with any union data inside the UpdateLoginFlowBody, using the provided UpdateLoginFlowWithOidcMethod
func (t *UpdateLoginFlowBody) MergeUpdateLoginFlowWithOidcMethod(v UpdateLoginFlowWithOidcMethod) error {
	v.Method = "oidc"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateLoginFlowWithTotpMethod returns the union data inside the UpdateLoginFlowBody as a UpdateLoginFlowWithTotpMethod
func (t UpdateLoginFlowBody) AsUpdateLoginFlowWithTotpMethod() (UpdateLoginFlowWithTotpMethod, error) {
	var body UpdateLoginFlowWithTotpMethod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateLoginFlowWithTotpMethod overwrites any union data inside the UpdateLoginFlowBody as the provided UpdateLoginFlowWithTotpMethod
func (t *UpdateLoginFlowBody) FromUpdateLoginFlowWithTotpMethod(v UpdateLoginFlowWithTotpMethod) error {
	v.Method = "totp"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateLoginFlowWithTotpMethod performs a merge with any union data inside the UpdateLoginFlowBody, using the provided UpdateLoginFlowWithTotpMethod
func (t *UpdateLoginFlowBody) MergeUpdateLoginFlowWithTotpMethod(v UpdateLoginFlowWithTotpMethod) error {
	v.Method = "totp"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateLoginFlowWithWebAuthnMethod returns the union data inside the UpdateLoginFlowBody as a UpdateLoginFlowWithWebAuthnMethod
func (t UpdateLoginFlowBody) AsUpdateLoginFlowWithWebAuthnMethod() (UpdateLoginFlowWithWebAuthnMethod, error) {
	var body UpdateLoginFlowWithWebAuthnMethod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateLoginFlowWithWebAuthnMethod overwrites any union data inside the UpdateLoginFlowBody as the provided UpdateLoginFlowWithWebAuthnMethod
func (t *UpdateLoginFlowBody) FromUpdateLoginFlowWithWebAuthnMethod(v UpdateLoginFlowWithWebAuthnMethod) error {
	v.Method = "webauthn"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateLoginFlowWithWebAuthnMethod performs a merge with any union data inside the UpdateLoginFlowBody, using the provided UpdateLoginFlowWithWebAuthnMethod
func (t *UpdateLoginFlowBody) MergeUpdateLoginFlowWithWebAuthnMethod(v UpdateLoginFlowWithWebAuthnMethod) error {
	v.Method = "webauthn"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateLoginFlowWithLookupSecretMethod returns the union data inside the UpdateLoginFlowBody as a UpdateLoginFlowWithLookupSecretMethod
func (t UpdateLoginFlowBody) AsUpdateLoginFlowWithLookupSecretMethod() (UpdateLoginFlowWithLookupSecretMethod, error) {
	var body UpdateLoginFlowWithLookupSecretMethod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateLoginFlowWithLookupSecretMethod overwrites any union data inside the UpdateLoginFlowBody as the provided UpdateLoginFlowWithLookupSecretMethod
func (t *UpdateLoginFlowBody) FromUpdateLoginFlowWithLookupSecretMethod(v UpdateLoginFlowWithLookupSecretMethod) error {
	v.Method = "lookup_secret"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateLoginFlowWithLookupSecretMethod performs a merge with any union data inside the UpdateLoginFlowBody, using the provided UpdateLoginFlowWithLookupSecretMethod
func (t *UpdateLoginFlowBody) MergeUpdateLoginFlowWithLookupSecretMethod(v UpdateLoginFlowWithLookupSecretMethod) error {
	v.Method = "lookup_secret"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateLoginFlowWithCodeMethod returns the union data inside the UpdateLoginFlowBody as a UpdateLoginFlowWithCodeMethod
func (t UpdateLoginFlowBody) AsUpdateLoginFlowWithCodeMethod() (UpdateLoginFlowWithCodeMethod, error) {
	var body UpdateLoginFlowWithCodeMethod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateLoginFlowWithCodeMethod overwrites any union data inside the UpdateLoginFlowBody as the provided UpdateLoginFlowWithCodeMethod
func (t *UpdateLoginFlowBody) FromUpdateLoginFlowWithCodeMethod(v UpdateLoginFlowWithCodeMethod) error {
	v.Method = "code"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateLoginFlowWithCodeMethod performs a merge with any union data inside the UpdateLoginFlowBody, using the provided UpdateLoginFlowWithCodeMethod
func (t *UpdateLoginFlowBody) MergeUpdateLoginFlowWithCodeMethod(v UpdateLoginFlowWithCodeMethod) error {
	v.Method = "code"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateLoginFlowBody) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"method"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t UpdateLoginFlowBody) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "code":
		return t.AsUpdateLoginFlowWithCodeMethod()
	case "lookup_secret":
		return t.AsUpdateLoginFlowWithLookupSecretMethod()
	case "oidc":
		return t.AsUpdateLoginFlowWithOidcMethod()
	case "password":
		return t.AsUpdateLoginFlowWithPasswordMethod()
	case "totp":
		return t.AsUpdateLoginFlowWithTotpMethod()
	case "webauthn":
		return t.AsUpdateLoginFlowWithWebAuthnMethod()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t UpdateLoginFlowBody) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateLoginFlowBody) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUpdateRecoveryFlowWithLinkMethod returns the union data inside the UpdateRecoveryFlowBody as a UpdateRecoveryFlowWithLinkMethod
func (t UpdateRecoveryFlowBody) AsUpdateRecoveryFlowWithLinkMethod() (UpdateRecoveryFlowWithLinkMethod, error) {
	var body UpdateRecoveryFlowWithLinkMethod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateRecoveryFlowWithLinkMethod overwrites any union data inside the UpdateRecoveryFlowBody as the provided UpdateRecoveryFlowWithLinkMethod
func (t *UpdateRecoveryFlowBody) FromUpdateRecoveryFlowWithLinkMethod(v UpdateRecoveryFlowWithLinkMethod) error {
	v.Method = "link"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateRecoveryFlowWithLinkMethod performs a merge with any union data inside the UpdateRecoveryFlowBody, using the provided UpdateRecoveryFlowWithLinkMethod
func (t *UpdateRecoveryFlowBody) MergeUpdateRecoveryFlowWithLinkMethod(v UpdateRecoveryFlowWithLinkMethod) error {
	v.Method = "link"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateRecoveryFlowWithCodeMethod returns the union data inside the UpdateRecoveryFlowBody as a UpdateRecoveryFlowWithCodeMethod
func (t UpdateRecoveryFlowBody) AsUpdateRecoveryFlowWithCodeMethod() (UpdateRecoveryFlowWithCodeMethod, error) {
	var body UpdateRecoveryFlowWithCodeMethod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateRecoveryFlowWithCodeMethod overwrites any union data inside the UpdateRecoveryFlowBody as the provided UpdateRecoveryFlowWithCodeMethod
func (t *UpdateRecoveryFlowBody) FromUpdateRecoveryFlowWithCodeMethod(v UpdateRecoveryFlowWithCodeMethod) error {
	v.Method = "code"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateRecoveryFlowWithCodeMethod performs a merge with any union data inside the UpdateRecoveryFlowBody, using the provided UpdateRecoveryFlowWithCodeMethod
func (t *UpdateRecoveryFlowBody) MergeUpdateRecoveryFlowWithCodeMethod(v UpdateRecoveryFlowWithCodeMethod) error {
	v.Method = "code"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateRecoveryFlowBody) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"method"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t UpdateRecoveryFlowBody) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "code":
		return t.AsUpdateRecoveryFlowWithCodeMethod()
	case "link":
		return t.AsUpdateRecoveryFlowWithLinkMethod()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t UpdateRecoveryFlowBody) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateRecoveryFlowBody) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUpdateRegistrationFlowWithPasswordMethod returns the union data inside the UpdateRegistrationFlowBody as a UpdateRegistrationFlowWithPasswordMethod
func (t UpdateRegistrationFlowBody) AsUpdateRegistrationFlowWithPasswordMethod() (UpdateRegistrationFlowWithPasswordMethod, error) {
	var body UpdateRegistrationFlowWithPasswordMethod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateRegistrationFlowWithPasswordMethod overwrites any union data inside the UpdateRegistrationFlowBody as the provided UpdateRegistrationFlowWithPasswordMethod
func (t *UpdateRegistrationFlowBody) FromUpdateRegistrationFlowWithPasswordMethod(v UpdateRegistrationFlowWithPasswordMethod) error {
	v.Method = "password"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateRegistrationFlowWithPasswordMethod performs a merge with any union data inside the UpdateRegistrationFlowBody, using the provided UpdateRegistrationFlowWithPasswordMethod
func (t *UpdateRegistrationFlowBody) MergeUpdateRegistrationFlowWithPasswordMethod(v UpdateRegistrationFlowWithPasswordMethod) error {
	v.Method = "password"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateRegistrationFlowWithOidcMethod returns the union data inside the UpdateRegistrationFlowBody as a UpdateRegistrationFlowWithOidcMethod
func (t UpdateRegistrationFlowBody) AsUpdateRegistrationFlowWithOidcMethod() (UpdateRegistrationFlowWithOidcMethod, error) {
	var body UpdateRegistrationFlowWithOidcMethod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateRegistrationFlowWithOidcMethod overwrites any union data inside the UpdateRegistrationFlowBody as the provided UpdateRegistrationFlowWithOidcMethod
func (t *UpdateRegistrationFlowBody) FromUpdateRegistrationFlowWithOidcMethod(v UpdateRegistrationFlowWithOidcMethod) error {
	v.Method = "oidc"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateRegistrationFlowWithOidcMethod performs a merge with any union data inside the UpdateRegistrationFlowBody, using the provided UpdateRegistrationFlowWithOidcMethod
func (t *UpdateRegistrationFlowBody) MergeUpdateRegistrationFlowWithOidcMethod(v UpdateRegistrationFlowWithOidcMethod) error {
	v.Method = "oidc"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateRegistrationFlowWithWebAuthnMethod returns the union data inside the UpdateRegistrationFlowBody as a UpdateRegistrationFlowWithWebAuthnMethod
func (t UpdateRegistrationFlowBody) AsUpdateRegistrationFlowWithWebAuthnMethod() (UpdateRegistrationFlowWithWebAuthnMethod, error) {
	var body UpdateRegistrationFlowWithWebAuthnMethod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateRegistrationFlowWithWebAuthnMethod overwrites any union data inside the UpdateRegistrationFlowBody as the provided UpdateRegistrationFlowWithWebAuthnMethod
func (t *UpdateRegistrationFlowBody) FromUpdateRegistrationFlowWithWebAuthnMethod(v UpdateRegistrationFlowWithWebAuthnMethod) error {
	v.Method = "webauthn"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateRegistrationFlowWithWebAuthnMethod performs a merge with any union data inside the UpdateRegistrationFlowBody, using the provided UpdateRegistrationFlowWithWebAuthnMethod
func (t *UpdateRegistrationFlowBody) MergeUpdateRegistrationFlowWithWebAuthnMethod(v UpdateRegistrationFlowWithWebAuthnMethod) error {
	v.Method = "webauthn"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateRegistrationFlowWithCodeMethod returns the union data inside the UpdateRegistrationFlowBody as a UpdateRegistrationFlowWithCodeMethod
func (t UpdateRegistrationFlowBody) AsUpdateRegistrationFlowWithCodeMethod() (UpdateRegistrationFlowWithCodeMethod, error) {
	var body UpdateRegistrationFlowWithCodeMethod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateRegistrationFlowWithCodeMethod overwrites any union data inside the UpdateRegistrationFlowBody as the provided UpdateRegistrationFlowWithCodeMethod
func (t *UpdateRegistrationFlowBody) FromUpdateRegistrationFlowWithCodeMethod(v UpdateRegistrationFlowWithCodeMethod) error {
	v.Method = "code"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateRegistrationFlowWithCodeMethod performs a merge with any union data inside the UpdateRegistrationFlowBody, using the provided UpdateRegistrationFlowWithCodeMethod
func (t *UpdateRegistrationFlowBody) MergeUpdateRegistrationFlowWithCodeMethod(v UpdateRegistrationFlowWithCodeMethod) error {
	v.Method = "code"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateRegistrationFlowBody) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"method"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t UpdateRegistrationFlowBody) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "code":
		return t.AsUpdateRegistrationFlowWithCodeMethod()
	case "oidc":
		return t.AsUpdateRegistrationFlowWithOidcMethod()
	case "password":
		return t.AsUpdateRegistrationFlowWithPasswordMethod()
	case "webauthn":
		return t.AsUpdateRegistrationFlowWithWebAuthnMethod()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t UpdateRegistrationFlowBody) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateRegistrationFlowBody) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUpdateSettingsFlowWithPasswordMethod returns the union data inside the UpdateSettingsFlowBody as a UpdateSettingsFlowWithPasswordMethod
func (t UpdateSettingsFlowBody) AsUpdateSettingsFlowWithPasswordMethod() (UpdateSettingsFlowWithPasswordMethod, error) {
	var body UpdateSettingsFlowWithPasswordMethod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateSettingsFlowWithPasswordMethod overwrites any union data inside the UpdateSettingsFlowBody as the provided UpdateSettingsFlowWithPasswordMethod
func (t *UpdateSettingsFlowBody) FromUpdateSettingsFlowWithPasswordMethod(v UpdateSettingsFlowWithPasswordMethod) error {
	v.Method = "password"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateSettingsFlowWithPasswordMethod performs a merge with any union data inside the UpdateSettingsFlowBody, using the provided UpdateSettingsFlowWithPasswordMethod
func (t *UpdateSettingsFlowBody) MergeUpdateSettingsFlowWithPasswordMethod(v UpdateSettingsFlowWithPasswordMethod) error {
	v.Method = "password"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateSettingsFlowWithTotpMethod returns the union data inside the UpdateSettingsFlowBody as a UpdateSettingsFlowWithTotpMethod
func (t UpdateSettingsFlowBody) AsUpdateSettingsFlowWithTotpMethod() (UpdateSettingsFlowWithTotpMethod, error) {
	var body UpdateSettingsFlowWithTotpMethod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateSettingsFlowWithTotpMethod overwrites any union data inside the UpdateSettingsFlowBody as the provided UpdateSettingsFlowWithTotpMethod
func (t *UpdateSettingsFlowBody) FromUpdateSettingsFlowWithTotpMethod(v UpdateSettingsFlowWithTotpMethod) error {
	v.Method = "totp"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateSettingsFlowWithTotpMethod performs a merge with any union data inside the UpdateSettingsFlowBody, using the provided UpdateSettingsFlowWithTotpMethod
func (t *UpdateSettingsFlowBody) MergeUpdateSettingsFlowWithTotpMethod(v UpdateSettingsFlowWithTotpMethod) error {
	v.Method = "totp"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateSettingsFlowBody) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"method"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t UpdateSettingsFlowBody) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "password":
		return t.AsUpdateSettingsFlowWithPasswordMethod()
	case "totp":
		return t.AsUpdateSettingsFlowWithTotpMethod()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t UpdateSettingsFlowBody) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateSettingsFlowBody) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUpdateVerificationFlowWithLinkMethod returns the union data inside the UpdateVerificationFlowBody as a UpdateVerificationFlowWithLinkMethod
func (t UpdateVerificationFlowBody) AsUpdateVerificationFlowWithLinkMethod() (UpdateVerificationFlowWithLinkMethod, error) {
	var body UpdateVerificationFlowWithLinkMethod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateVerificationFlowWithLinkMethod overwrites any union data inside the UpdateVerificationFlowBody as the provided UpdateVerificationFlowWithLinkMethod
func (t *UpdateVerificationFlowBody) FromUpdateVerificationFlowWithLinkMethod(v UpdateVerificationFlowWithLinkMethod) error {
	v.Method = "link"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateVerificationFlowWithLinkMethod performs a merge with any union data inside the UpdateVerificationFlowBody, using the provided UpdateVerificationFlowWithLinkMethod
func (t *UpdateVerificationFlowBody) MergeUpdateVerificationFlowWithLinkMethod(v UpdateVerificationFlowWithLinkMethod) error {
	v.Method = "link"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateVerificationFlowWithCodeMethod returns the union data inside the UpdateVerificationFlowBody as a UpdateVerificationFlowWithCodeMethod
func (t UpdateVerificationFlowBody) AsUpdateVerificationFlowWithCodeMethod() (UpdateVerificationFlowWithCodeMethod, error) {
	var body UpdateVerificationFlowWithCodeMethod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateVerificationFlowWithCodeMethod overwrites any union data inside the UpdateVerificationFlowBody as the provided UpdateVerificationFlowWithCodeMethod
func (t *UpdateVerificationFlowBody) FromUpdateVerificationFlowWithCodeMethod(v UpdateVerificationFlowWithCodeMethod) error {
	v.Method = "code"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateVerificationFlowWithCodeMethod performs a merge with any union data inside the UpdateVerificationFlowBody, using the provided UpdateVerificationFlowWithCodeMethod
func (t *UpdateVerificationFlowBody) MergeUpdateVerificationFlowWithCodeMethod(v UpdateVerificationFlowWithCodeMethod) error {
	v.Method = "code"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateVerificationFlowBody) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"method"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t UpdateVerificationFlowBody) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "code":
		return t.AsUpdateVerificationFlowWithCodeMethod()
	case "link":
		return t.AsUpdateVerificationFlowWithLinkMethod()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t UpdateVerificationFlowBody) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateVerificationFlowBody) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// JsonWebKeys request
	JsonWebKeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DiscoverOidcConfiguration request
	DiscoverOidcConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWebAuthnJavaScript request
	GetWebAuthnJavaScript(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAdminServiceAccountSpaceWithBody request with any body
	CreateAdminServiceAccountSpaceWithBody(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAdminServiceAccountSpace(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, body CreateAdminServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Authorize request
	Authorize(ctx context.Context, params *AuthorizeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Consent request
	Consent(ctx context.Context, params *ConsentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFlowError request
	GetFlowError(ctx context.Context, params *GetFlowErrorParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateLoginFlowWithBody request with any body
	UpdateLoginFlowWithBody(ctx context.Context, params *UpdateLoginFlowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateLoginFlow(ctx context.Context, params *UpdateLoginFlowParams, body UpdateLoginFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateLoginFlowWithFormdataBody(ctx context.Context, params *UpdateLoginFlowParams, body UpdateLoginFlowFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNativeLoginFlow request
	CreateNativeLoginFlow(ctx context.Context, params *CreateNativeLoginFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBrowserLoginFlow request
	CreateBrowserLoginFlow(ctx context.Context, params *CreateBrowserLoginFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLoginFlow request
	GetLoginFlow(ctx context.Context, params *GetLoginFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateLogoutFlow request
	UpdateLogoutFlow(ctx context.Context, params *UpdateLogoutFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PerformNativeLogoutWithBody request with any body
	PerformNativeLogoutWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PerformNativeLogout(ctx context.Context, body PerformNativeLogoutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBrowserLogoutFlow request
	CreateBrowserLogoutFlow(ctx context.Context, params *CreateBrowserLogoutFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InitRecoveryFlow request
	InitRecoveryFlow(ctx context.Context, params *InitRecoveryFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRecoveryFlowWithBody request with any body
	UpdateRecoveryFlowWithBody(ctx context.Context, params *UpdateRecoveryFlowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRecoveryFlow(ctx context.Context, params *UpdateRecoveryFlowParams, body UpdateRecoveryFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRecoveryFlowWithFormdataBody(ctx context.Context, params *UpdateRecoveryFlowParams, body UpdateRecoveryFlowFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNativeRecoveryFlow request
	CreateNativeRecoveryFlow(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBrowserRecoveryFlow request
	CreateBrowserRecoveryFlow(ctx context.Context, params *CreateBrowserRecoveryFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRecoveryFlow request
	GetRecoveryFlow(ctx context.Context, params *GetRecoveryFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRegistrationFlowWithBody request with any body
	UpdateRegistrationFlowWithBody(ctx context.Context, params *UpdateRegistrationFlowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRegistrationFlow(ctx context.Context, params *UpdateRegistrationFlowParams, body UpdateRegistrationFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRegistrationFlowWithFormdataBody(ctx context.Context, params *UpdateRegistrationFlowParams, body UpdateRegistrationFlowFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNativeRegistrationFlow request
	CreateNativeRegistrationFlow(ctx context.Context, params *CreateNativeRegistrationFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBrowserRegistrationFlow request
	CreateBrowserRegistrationFlow(ctx context.Context, params *CreateBrowserRegistrationFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRegistrationFlow request
	GetRegistrationFlow(ctx context.Context, params *GetRegistrationFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSettingsFloWithBody request with any body
	UpdateSettingsFloWithBody(ctx context.Context, params *UpdateSettingsFloParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSettingsFlo(ctx context.Context, params *UpdateSettingsFloParams, body UpdateSettingsFloJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSettingsFloWithFormdataBody(ctx context.Context, params *UpdateSettingsFloParams, body UpdateSettingsFloFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNativeSettingsFlow request
	CreateNativeSettingsFlow(ctx context.Context, params *CreateNativeSettingsFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBrowserSettingsFlow request
	CreateBrowserSettingsFlow(ctx context.Context, params *CreateBrowserSettingsFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSettingsFlow request
	GetSettingsFlow(ctx context.Context, params *GetSettingsFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVerificationFlowWithBody request with any body
	UpdateVerificationFlowWithBody(ctx context.Context, params *UpdateVerificationFlowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVerificationFlow(ctx context.Context, params *UpdateVerificationFlowParams, body UpdateVerificationFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVerificationFlowWithFormdataBody(ctx context.Context, params *UpdateVerificationFlowParams, body UpdateVerificationFlowFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNativeVerificationFlow request
	CreateNativeVerificationFlow(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBrowserVerificationFlow request
	CreateBrowserVerificationFlow(ctx context.Context, params *CreateBrowserVerificationFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVerificationFlow request
	GetVerificationFlow(ctx context.Context, params *GetVerificationFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DisableMyOtherSessions request
	DisableMyOtherSessions(ctx context.Context, params *DisableMyOtherSessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMySessions request
	ListMySessions(ctx context.Context, params *ListMySessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExchangeSessionToken request
	ExchangeSessionToken(ctx context.Context, params *ExchangeSessionTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ToSession request
	ToSession(ctx context.Context, params *ToSessionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IntrospectWithBody request with any body
	IntrospectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IntrospectWithFormdataBody(ctx context.Context, body IntrospectFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListOrganisationsIdentity request
	ListOrganisationsIdentity(ctx context.Context, params *ListOrganisationsIdentityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIAMGranularPolicyOrganisation request
	GetIAMGranularPolicyOrganisation(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetIAMGranularPolicyOrganisationWithBody request with any body
	SetIAMGranularPolicyOrganisationWithBody(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetIAMGranularPolicyOrganisation(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, body SetIAMGranularPolicyOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIAMPolicyOrganisation request
	GetIAMPolicyOrganisation(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetIAMPolicyOrganisationWithBody request with any body
	SetIAMPolicyOrganisationWithBody(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetIAMPolicyOrganisation(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, body SetIAMPolicyOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPermissionsOrganisation request
	ListPermissionsOrganisation(ctx context.Context, organisationId OrganisationId, params *ListPermissionsOrganisationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPermissionOrganisation request
	GetPermissionOrganisation(ctx context.Context, organisationId OrganisationId, permissionUuid PermissionUuid, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRolesOrganisation request
	ListRolesOrganisation(ctx context.Context, organisationId OrganisationId, params *ListRolesOrganisationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRoleOrganisationWithBody request with any body
	CreateRoleOrganisationWithBody(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRoleOrganisation(ctx context.Context, organisationId OrganisationId, body CreateRoleOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRoleOrganisation request
	DeleteRoleOrganisation(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRoleOrganisation request
	GetRoleOrganisation(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRoleOrganisationWithBody request with any body
	UpdateRoleOrganisationWithBody(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRoleOrganisation(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, body UpdateRoleOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveRolePermissionsOrganisationWithBody request with any body
	RemoveRolePermissionsOrganisationWithBody(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveRolePermissionsOrganisation(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, body RemoveRolePermissionsOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRolePermissionsOrganisation request
	GetRolePermissionsOrganisation(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddRolePermissionsOrganisationWithBody request with any body
	AddRolePermissionsOrganisationWithBody(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddRolePermissionsOrganisation(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, body AddRolePermissionsOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListServiceAccountOrganisationWithBody request with any body
	ListServiceAccountOrganisationWithBody(ctx context.Context, organisationId OrganisationId, params *ListServiceAccountOrganisationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListServiceAccountOrganisation(ctx context.Context, organisationId OrganisationId, params *ListServiceAccountOrganisationParams, body ListServiceAccountOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateServiceAccountOrganisationWithBody request with any body
	CreateServiceAccountOrganisationWithBody(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateServiceAccountOrganisation(ctx context.Context, organisationId OrganisationId, body CreateServiceAccountOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServiceAccountOrganisation request
	DeleteServiceAccountOrganisation(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServiceAccountOrganisation request
	GetServiceAccountOrganisation(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateServiceAccountOrganisationWithBody request with any body
	UpdateServiceAccountOrganisationWithBody(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateServiceAccountOrganisation(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, body UpdateServiceAccountOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetACLServiceAccountOrganisation request
	GetACLServiceAccountOrganisation(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, params *GetACLServiceAccountOrganisationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteACLServiceAccountOrganisationBulkWithBody request with any body
	DeleteACLServiceAccountOrganisationBulkWithBody(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteACLServiceAccountOrganisationBulk(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, body DeleteACLServiceAccountOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateACLServiceAccountOrganisationBulkWithBody request with any body
	CreateACLServiceAccountOrganisationBulkWithBody(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateACLServiceAccountOrganisationBulk(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, body CreateACLServiceAccountOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSpacesOfServiceAccount request
	ListSpacesOfServiceAccount(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, params *ListSpacesOfServiceAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSpacesIdentity request
	ListSpacesIdentity(ctx context.Context, organisationId OrganisationId, params *ListSpacesIdentityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserOrganisationWithBody request with any body
	ListUserOrganisationWithBody(ctx context.Context, organisationId OrganisationId, params *ListUserOrganisationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListUserOrganisation(ctx context.Context, organisationId OrganisationId, params *ListUserOrganisationParams, body ListUserOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserOrganisationWithBody request with any body
	CreateUserOrganisationWithBody(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUserOrganisation(ctx context.Context, organisationId OrganisationId, body CreateUserOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserOrganisation request
	DeleteUserOrganisation(ctx context.Context, organisationId OrganisationId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserOrganisation request
	GetUserOrganisation(ctx context.Context, organisationId OrganisationId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchUserStateOrganisationWithBody request with any body
	PatchUserStateOrganisationWithBody(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchUserStateOrganisation(ctx context.Context, organisationId OrganisationId, userId UserId, body PatchUserStateOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserOrganisationWithBody request with any body
	UpdateUserOrganisationWithBody(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUserOrganisation(ctx context.Context, organisationId OrganisationId, userId UserId, body UpdateUserOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetACLUserOrganisation request
	GetACLUserOrganisation(ctx context.Context, organisationId OrganisationId, userId UserId, params *GetACLUserOrganisationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteACLUserOrganisationBulkWithBody request with any body
	DeleteACLUserOrganisationBulkWithBody(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteACLUserOrganisationBulk(ctx context.Context, organisationId OrganisationId, userId UserId, body DeleteACLUserOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateACLUserOrganisationBulkWithBody request with any body
	CreateACLUserOrganisationBulkWithBody(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateACLUserOrganisationBulk(ctx context.Context, organisationId OrganisationId, userId UserId, body CreateACLUserOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RecoverUserOrganisation request
	RecoverUserOrganisation(ctx context.Context, organisationId OrganisationId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSpacesOfUser request
	ListSpacesOfUser(ctx context.Context, organisationId OrganisationId, userId UserId, params *ListSpacesOfUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevokeWithBody request with any body
	RevokeWithBody(ctx context.Context, params *RevokeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevokeWithFormdataBody(ctx context.Context, params *RevokeParams, body RevokeFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIAMGranularPolicySpace request
	GetIAMGranularPolicySpace(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetIAMGranularPolicySpaceWithBody request with any body
	SetIAMGranularPolicySpaceWithBody(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetIAMGranularPolicySpace(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, body SetIAMGranularPolicySpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIAMPolicySpace request
	GetIAMPolicySpace(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetIAMPolicySpaceWithBody request with any body
	SetIAMPolicySpaceWithBody(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetIAMPolicySpace(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, body SetIAMPolicySpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPermissionsSpace request
	ListPermissionsSpace(ctx context.Context, spaceId SpaceId, params *ListPermissionsSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPermissionSpace request
	GetPermissionSpace(ctx context.Context, spaceId SpaceId, permissionUuid PermissionUuid, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRolesSpace request
	ListRolesSpace(ctx context.Context, spaceId SpaceId, params *ListRolesSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRoleSpaceWithBody request with any body
	CreateRoleSpaceWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRoleSpace(ctx context.Context, spaceId SpaceId, body CreateRoleSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRoleSpace request
	DeleteRoleSpace(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRoleSpace request
	GetRoleSpace(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRoleSpaceWithBody request with any body
	UpdateRoleSpaceWithBody(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRoleSpace(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, body UpdateRoleSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveRolePermissionsSpaceWithBody request with any body
	RemoveRolePermissionsSpaceWithBody(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveRolePermissionsSpace(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, body RemoveRolePermissionsSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRolePermissionsSpace request
	GetRolePermissionsSpace(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddRolePermissionsSpaceWithBody request with any body
	AddRolePermissionsSpaceWithBody(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddRolePermissionsSpace(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, body AddRolePermissionsSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListServiceAccountSpaceWithBody request with any body
	ListServiceAccountSpaceWithBody(ctx context.Context, spaceId SpaceId, params *ListServiceAccountSpaceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListServiceAccountSpace(ctx context.Context, spaceId SpaceId, params *ListServiceAccountSpaceParams, body ListServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateServiceAccountSpaceWithBody request with any body
	CreateServiceAccountSpaceWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateServiceAccountSpace(ctx context.Context, spaceId SpaceId, body CreateServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServiceAccountSpace request
	DeleteServiceAccountSpace(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServiceAccountSpace request
	GetServiceAccountSpace(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignServiceAccountToSpace request
	AssignServiceAccountToSpace(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateServiceAccountSpaceWithBody request with any body
	UpdateServiceAccountSpaceWithBody(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateServiceAccountSpace(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, body UpdateServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetACLServiceAccountSpace request
	GetACLServiceAccountSpace(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, params *GetACLServiceAccountSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteACLServiceAccountSpaceBulkWithBody request with any body
	DeleteACLServiceAccountSpaceBulkWithBody(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteACLServiceAccountSpaceBulk(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, body DeleteACLServiceAccountSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateACLServiceAccountSpaceBulkWithBody request with any body
	CreateACLServiceAccountSpaceBulkWithBody(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateACLServiceAccountSpaceBulk(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, body CreateACLServiceAccountSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserSpaceWithBody request with any body
	ListUserSpaceWithBody(ctx context.Context, spaceId SpaceId, params *ListUserSpaceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListUserSpace(ctx context.Context, spaceId SpaceId, params *ListUserSpaceParams, body ListUserSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserSpaceWithBody request with any body
	CreateUserSpaceWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUserSpace(ctx context.Context, spaceId SpaceId, body CreateUserSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserSpace request
	DeleteUserSpace(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserSpace request
	GetUserSpace(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchUserStateSpaceWithBody request with any body
	PatchUserStateSpaceWithBody(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchUserStateSpace(ctx context.Context, spaceId SpaceId, userId UserId, body PatchUserStateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignUserToSpace request
	AssignUserToSpace(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserSpaceWithBody request with any body
	UpdateUserSpaceWithBody(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUserSpace(ctx context.Context, spaceId SpaceId, userId UserId, body UpdateUserSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetACLUserSpace request
	GetACLUserSpace(ctx context.Context, spaceId SpaceId, userId UserId, params *GetACLUserSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteACLUserSpaceBulkWithBody request with any body
	DeleteACLUserSpaceBulkWithBody(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteACLUserSpaceBulk(ctx context.Context, spaceId SpaceId, userId UserId, body DeleteACLUserSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateACLUserSpaceBulkWithBody request with any body
	CreateACLUserSpaceBulkWithBody(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateACLUserSpaceBulk(ctx context.Context, spaceId SpaceId, userId UserId, body CreateACLUserSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RecoverUserSpace request
	RecoverUserSpace(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TokenWithBody request with any body
	TokenWithBody(ctx context.Context, params *TokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TokenWithFormdataBody(ctx context.Context, params *TokenParams, body TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserInfo request
	GetUserInfo(ctx context.Context, params *GetUserInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListClusters request
	ListClusters(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateClusterWithBody request with any body
	CreateClusterWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCluster(ctx context.Context, spaceId SpaceId, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCluster request
	DeleteCluster(ctx context.Context, spaceId SpaceId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCluster request
	GetCluster(ctx context.Context, spaceId SpaceId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateClusterWithBody request with any body
	UpdateClusterWithBody(ctx context.Context, spaceId SpaceId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCluster(ctx context.Context, spaceId SpaceId, clusterId ClusterId, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListNodepools request
	ListNodepools(ctx context.Context, spaceId SpaceId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNodePoolWithBody request with any body
	CreateNodePoolWithBody(ctx context.Context, spaceId SpaceId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNodePool(ctx context.Context, spaceId SpaceId, clusterId ClusterId, body CreateNodePoolJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNodePool request
	DeleteNodePool(ctx context.Context, spaceId SpaceId, clusterId ClusterId, nodePoolName NodepoolName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateNodepoolWithBody request with any body
	UpdateNodepoolWithBody(ctx context.Context, spaceId SpaceId, clusterId ClusterId, nodePoolName NodepoolName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateNodepool(ctx context.Context, spaceId SpaceId, clusterId ClusterId, nodePoolName NodepoolName, body UpdateNodepoolJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListOperations request
	ListOperations(ctx context.Context, spaceId SpaceId, params *ListOperationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOperation request
	GetOperation(ctx context.Context, spaceId SpaceId, id IdUuid, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListVersions request
	ListVersions(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSpace request
	DeleteSpace(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpaceById request
	GetSpaceById(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSpaceWithBody request with any body
	UpdateSpaceWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSpace(ctx context.Context, spaceId SpaceId, body UpdateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSpacesWithBody request with any body
	ListSpacesWithBody(ctx context.Context, organisationId OrganisationId, params *ListSpacesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListSpaces(ctx context.Context, organisationId OrganisationId, params *ListSpacesParams, body ListSpacesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSpaceWithBody request with any body
	CreateSpaceWithBody(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSpace(ctx context.Context, organisationId OrganisationId, body CreateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) JsonWebKeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJsonWebKeysRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DiscoverOidcConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDiscoverOidcConfigurationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWebAuthnJavaScript(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebAuthnJavaScriptRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAdminServiceAccountSpaceWithBody(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAdminServiceAccountSpaceRequestWithBody(c.Server, organisationId, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAdminServiceAccountSpace(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, body CreateAdminServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAdminServiceAccountSpaceRequest(c.Server, organisationId, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Authorize(ctx context.Context, params *AuthorizeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthorizeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Consent(ctx context.Context, params *ConsentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConsentRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFlowError(ctx context.Context, params *GetFlowErrorParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFlowErrorRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLoginFlowWithBody(ctx context.Context, params *UpdateLoginFlowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLoginFlowRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLoginFlow(ctx context.Context, params *UpdateLoginFlowParams, body UpdateLoginFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLoginFlowRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLoginFlowWithFormdataBody(ctx context.Context, params *UpdateLoginFlowParams, body UpdateLoginFlowFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLoginFlowRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNativeLoginFlow(ctx context.Context, params *CreateNativeLoginFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNativeLoginFlowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBrowserLoginFlow(ctx context.Context, params *CreateBrowserLoginFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBrowserLoginFlowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLoginFlow(ctx context.Context, params *GetLoginFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLoginFlowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLogoutFlow(ctx context.Context, params *UpdateLogoutFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLogoutFlowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PerformNativeLogoutWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPerformNativeLogoutRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PerformNativeLogout(ctx context.Context, body PerformNativeLogoutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPerformNativeLogoutRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBrowserLogoutFlow(ctx context.Context, params *CreateBrowserLogoutFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBrowserLogoutFlowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InitRecoveryFlow(ctx context.Context, params *InitRecoveryFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInitRecoveryFlowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRecoveryFlowWithBody(ctx context.Context, params *UpdateRecoveryFlowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRecoveryFlowRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRecoveryFlow(ctx context.Context, params *UpdateRecoveryFlowParams, body UpdateRecoveryFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRecoveryFlowRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRecoveryFlowWithFormdataBody(ctx context.Context, params *UpdateRecoveryFlowParams, body UpdateRecoveryFlowFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRecoveryFlowRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNativeRecoveryFlow(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNativeRecoveryFlowRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBrowserRecoveryFlow(ctx context.Context, params *CreateBrowserRecoveryFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBrowserRecoveryFlowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRecoveryFlow(ctx context.Context, params *GetRecoveryFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRecoveryFlowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRegistrationFlowWithBody(ctx context.Context, params *UpdateRegistrationFlowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRegistrationFlowRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRegistrationFlow(ctx context.Context, params *UpdateRegistrationFlowParams, body UpdateRegistrationFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRegistrationFlowRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRegistrationFlowWithFormdataBody(ctx context.Context, params *UpdateRegistrationFlowParams, body UpdateRegistrationFlowFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRegistrationFlowRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNativeRegistrationFlow(ctx context.Context, params *CreateNativeRegistrationFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNativeRegistrationFlowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBrowserRegistrationFlow(ctx context.Context, params *CreateBrowserRegistrationFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBrowserRegistrationFlowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRegistrationFlow(ctx context.Context, params *GetRegistrationFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRegistrationFlowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSettingsFloWithBody(ctx context.Context, params *UpdateSettingsFloParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSettingsFloRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSettingsFlo(ctx context.Context, params *UpdateSettingsFloParams, body UpdateSettingsFloJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSettingsFloRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSettingsFloWithFormdataBody(ctx context.Context, params *UpdateSettingsFloParams, body UpdateSettingsFloFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSettingsFloRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNativeSettingsFlow(ctx context.Context, params *CreateNativeSettingsFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNativeSettingsFlowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBrowserSettingsFlow(ctx context.Context, params *CreateBrowserSettingsFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBrowserSettingsFlowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSettingsFlow(ctx context.Context, params *GetSettingsFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSettingsFlowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVerificationFlowWithBody(ctx context.Context, params *UpdateVerificationFlowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVerificationFlowRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVerificationFlow(ctx context.Context, params *UpdateVerificationFlowParams, body UpdateVerificationFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVerificationFlowRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVerificationFlowWithFormdataBody(ctx context.Context, params *UpdateVerificationFlowParams, body UpdateVerificationFlowFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVerificationFlowRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNativeVerificationFlow(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNativeVerificationFlowRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBrowserVerificationFlow(ctx context.Context, params *CreateBrowserVerificationFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBrowserVerificationFlowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVerificationFlow(ctx context.Context, params *GetVerificationFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVerificationFlowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisableMyOtherSessions(ctx context.Context, params *DisableMyOtherSessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisableMyOtherSessionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMySessions(ctx context.Context, params *ListMySessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMySessionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExchangeSessionToken(ctx context.Context, params *ExchangeSessionTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExchangeSessionTokenRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToSession(ctx context.Context, params *ToSessionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToSessionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IntrospectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIntrospectRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IntrospectWithFormdataBody(ctx context.Context, body IntrospectFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIntrospectRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListOrganisationsIdentity(ctx context.Context, params *ListOrganisationsIdentityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListOrganisationsIdentityRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIAMGranularPolicyOrganisation(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIAMGranularPolicyOrganisationRequest(c.Server, organisationId, subjectType, subjectId, objectType)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetIAMGranularPolicyOrganisationWithBody(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetIAMGranularPolicyOrganisationRequestWithBody(c.Server, organisationId, subjectType, subjectId, objectType, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetIAMGranularPolicyOrganisation(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, body SetIAMGranularPolicyOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetIAMGranularPolicyOrganisationRequest(c.Server, organisationId, subjectType, subjectId, objectType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIAMPolicyOrganisation(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIAMPolicyOrganisationRequest(c.Server, organisationId, subjectType, subjectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetIAMPolicyOrganisationWithBody(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetIAMPolicyOrganisationRequestWithBody(c.Server, organisationId, subjectType, subjectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetIAMPolicyOrganisation(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, body SetIAMPolicyOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetIAMPolicyOrganisationRequest(c.Server, organisationId, subjectType, subjectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPermissionsOrganisation(ctx context.Context, organisationId OrganisationId, params *ListPermissionsOrganisationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPermissionsOrganisationRequest(c.Server, organisationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPermissionOrganisation(ctx context.Context, organisationId OrganisationId, permissionUuid PermissionUuid, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPermissionOrganisationRequest(c.Server, organisationId, permissionUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRolesOrganisation(ctx context.Context, organisationId OrganisationId, params *ListRolesOrganisationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRolesOrganisationRequest(c.Server, organisationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRoleOrganisationWithBody(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRoleOrganisationRequestWithBody(c.Server, organisationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRoleOrganisation(ctx context.Context, organisationId OrganisationId, body CreateRoleOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRoleOrganisationRequest(c.Server, organisationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRoleOrganisation(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRoleOrganisationRequest(c.Server, organisationId, roleUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRoleOrganisation(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRoleOrganisationRequest(c.Server, organisationId, roleUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRoleOrganisationWithBody(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRoleOrganisationRequestWithBody(c.Server, organisationId, roleUuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRoleOrganisation(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, body UpdateRoleOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRoleOrganisationRequest(c.Server, organisationId, roleUuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveRolePermissionsOrganisationWithBody(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveRolePermissionsOrganisationRequestWithBody(c.Server, organisationId, roleUuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveRolePermissionsOrganisation(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, body RemoveRolePermissionsOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveRolePermissionsOrganisationRequest(c.Server, organisationId, roleUuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRolePermissionsOrganisation(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRolePermissionsOrganisationRequest(c.Server, organisationId, roleUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddRolePermissionsOrganisationWithBody(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddRolePermissionsOrganisationRequestWithBody(c.Server, organisationId, roleUuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddRolePermissionsOrganisation(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, body AddRolePermissionsOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddRolePermissionsOrganisationRequest(c.Server, organisationId, roleUuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListServiceAccountOrganisationWithBody(ctx context.Context, organisationId OrganisationId, params *ListServiceAccountOrganisationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListServiceAccountOrganisationRequestWithBody(c.Server, organisationId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListServiceAccountOrganisation(ctx context.Context, organisationId OrganisationId, params *ListServiceAccountOrganisationParams, body ListServiceAccountOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListServiceAccountOrganisationRequest(c.Server, organisationId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServiceAccountOrganisationWithBody(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceAccountOrganisationRequestWithBody(c.Server, organisationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServiceAccountOrganisation(ctx context.Context, organisationId OrganisationId, body CreateServiceAccountOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceAccountOrganisationRequest(c.Server, organisationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServiceAccountOrganisation(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServiceAccountOrganisationRequest(c.Server, organisationId, serviceAccountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServiceAccountOrganisation(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServiceAccountOrganisationRequest(c.Server, organisationId, serviceAccountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServiceAccountOrganisationWithBody(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServiceAccountOrganisationRequestWithBody(c.Server, organisationId, serviceAccountId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServiceAccountOrganisation(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, body UpdateServiceAccountOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServiceAccountOrganisationRequest(c.Server, organisationId, serviceAccountId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetACLServiceAccountOrganisation(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, params *GetACLServiceAccountOrganisationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetACLServiceAccountOrganisationRequest(c.Server, organisationId, serviceAccountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteACLServiceAccountOrganisationBulkWithBody(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteACLServiceAccountOrganisationBulkRequestWithBody(c.Server, organisationId, serviceAccountId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteACLServiceAccountOrganisationBulk(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, body DeleteACLServiceAccountOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteACLServiceAccountOrganisationBulkRequest(c.Server, organisationId, serviceAccountId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateACLServiceAccountOrganisationBulkWithBody(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateACLServiceAccountOrganisationBulkRequestWithBody(c.Server, organisationId, serviceAccountId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateACLServiceAccountOrganisationBulk(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, body CreateACLServiceAccountOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateACLServiceAccountOrganisationBulkRequest(c.Server, organisationId, serviceAccountId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSpacesOfServiceAccount(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, params *ListSpacesOfServiceAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSpacesOfServiceAccountRequest(c.Server, organisationId, serviceAccountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSpacesIdentity(ctx context.Context, organisationId OrganisationId, params *ListSpacesIdentityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSpacesIdentityRequest(c.Server, organisationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserOrganisationWithBody(ctx context.Context, organisationId OrganisationId, params *ListUserOrganisationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserOrganisationRequestWithBody(c.Server, organisationId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserOrganisation(ctx context.Context, organisationId OrganisationId, params *ListUserOrganisationParams, body ListUserOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserOrganisationRequest(c.Server, organisationId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserOrganisationWithBody(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserOrganisationRequestWithBody(c.Server, organisationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserOrganisation(ctx context.Context, organisationId OrganisationId, body CreateUserOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserOrganisationRequest(c.Server, organisationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserOrganisation(ctx context.Context, organisationId OrganisationId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserOrganisationRequest(c.Server, organisationId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserOrganisation(ctx context.Context, organisationId OrganisationId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserOrganisationRequest(c.Server, organisationId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchUserStateOrganisationWithBody(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchUserStateOrganisationRequestWithBody(c.Server, organisationId, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchUserStateOrganisation(ctx context.Context, organisationId OrganisationId, userId UserId, body PatchUserStateOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchUserStateOrganisationRequest(c.Server, organisationId, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserOrganisationWithBody(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserOrganisationRequestWithBody(c.Server, organisationId, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserOrganisation(ctx context.Context, organisationId OrganisationId, userId UserId, body UpdateUserOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserOrganisationRequest(c.Server, organisationId, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetACLUserOrganisation(ctx context.Context, organisationId OrganisationId, userId UserId, params *GetACLUserOrganisationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetACLUserOrganisationRequest(c.Server, organisationId, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteACLUserOrganisationBulkWithBody(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteACLUserOrganisationBulkRequestWithBody(c.Server, organisationId, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteACLUserOrganisationBulk(ctx context.Context, organisationId OrganisationId, userId UserId, body DeleteACLUserOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteACLUserOrganisationBulkRequest(c.Server, organisationId, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateACLUserOrganisationBulkWithBody(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateACLUserOrganisationBulkRequestWithBody(c.Server, organisationId, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateACLUserOrganisationBulk(ctx context.Context, organisationId OrganisationId, userId UserId, body CreateACLUserOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateACLUserOrganisationBulkRequest(c.Server, organisationId, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RecoverUserOrganisation(ctx context.Context, organisationId OrganisationId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRecoverUserOrganisationRequest(c.Server, organisationId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSpacesOfUser(ctx context.Context, organisationId OrganisationId, userId UserId, params *ListSpacesOfUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSpacesOfUserRequest(c.Server, organisationId, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokeWithBody(ctx context.Context, params *RevokeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokeRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokeWithFormdataBody(ctx context.Context, params *RevokeParams, body RevokeFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokeRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIAMGranularPolicySpace(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIAMGranularPolicySpaceRequest(c.Server, spaceId, subjectType, subjectId, objectType)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetIAMGranularPolicySpaceWithBody(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetIAMGranularPolicySpaceRequestWithBody(c.Server, spaceId, subjectType, subjectId, objectType, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetIAMGranularPolicySpace(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, body SetIAMGranularPolicySpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetIAMGranularPolicySpaceRequest(c.Server, spaceId, subjectType, subjectId, objectType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIAMPolicySpace(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIAMPolicySpaceRequest(c.Server, spaceId, subjectType, subjectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetIAMPolicySpaceWithBody(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetIAMPolicySpaceRequestWithBody(c.Server, spaceId, subjectType, subjectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetIAMPolicySpace(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, body SetIAMPolicySpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetIAMPolicySpaceRequest(c.Server, spaceId, subjectType, subjectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPermissionsSpace(ctx context.Context, spaceId SpaceId, params *ListPermissionsSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPermissionsSpaceRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPermissionSpace(ctx context.Context, spaceId SpaceId, permissionUuid PermissionUuid, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPermissionSpaceRequest(c.Server, spaceId, permissionUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRolesSpace(ctx context.Context, spaceId SpaceId, params *ListRolesSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRolesSpaceRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRoleSpaceWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRoleSpaceRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRoleSpace(ctx context.Context, spaceId SpaceId, body CreateRoleSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRoleSpaceRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRoleSpace(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRoleSpaceRequest(c.Server, spaceId, roleUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRoleSpace(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRoleSpaceRequest(c.Server, spaceId, roleUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRoleSpaceWithBody(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRoleSpaceRequestWithBody(c.Server, spaceId, roleUuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRoleSpace(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, body UpdateRoleSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRoleSpaceRequest(c.Server, spaceId, roleUuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveRolePermissionsSpaceWithBody(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveRolePermissionsSpaceRequestWithBody(c.Server, spaceId, roleUuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveRolePermissionsSpace(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, body RemoveRolePermissionsSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveRolePermissionsSpaceRequest(c.Server, spaceId, roleUuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRolePermissionsSpace(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRolePermissionsSpaceRequest(c.Server, spaceId, roleUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddRolePermissionsSpaceWithBody(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddRolePermissionsSpaceRequestWithBody(c.Server, spaceId, roleUuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddRolePermissionsSpace(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, body AddRolePermissionsSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddRolePermissionsSpaceRequest(c.Server, spaceId, roleUuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListServiceAccountSpaceWithBody(ctx context.Context, spaceId SpaceId, params *ListServiceAccountSpaceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListServiceAccountSpaceRequestWithBody(c.Server, spaceId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListServiceAccountSpace(ctx context.Context, spaceId SpaceId, params *ListServiceAccountSpaceParams, body ListServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListServiceAccountSpaceRequest(c.Server, spaceId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServiceAccountSpaceWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceAccountSpaceRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServiceAccountSpace(ctx context.Context, spaceId SpaceId, body CreateServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceAccountSpaceRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServiceAccountSpace(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServiceAccountSpaceRequest(c.Server, spaceId, serviceAccountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServiceAccountSpace(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServiceAccountSpaceRequest(c.Server, spaceId, serviceAccountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignServiceAccountToSpace(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignServiceAccountToSpaceRequest(c.Server, spaceId, serviceAccountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServiceAccountSpaceWithBody(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServiceAccountSpaceRequestWithBody(c.Server, spaceId, serviceAccountId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServiceAccountSpace(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, body UpdateServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServiceAccountSpaceRequest(c.Server, spaceId, serviceAccountId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetACLServiceAccountSpace(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, params *GetACLServiceAccountSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetACLServiceAccountSpaceRequest(c.Server, spaceId, serviceAccountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteACLServiceAccountSpaceBulkWithBody(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteACLServiceAccountSpaceBulkRequestWithBody(c.Server, spaceId, serviceAccountId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteACLServiceAccountSpaceBulk(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, body DeleteACLServiceAccountSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteACLServiceAccountSpaceBulkRequest(c.Server, spaceId, serviceAccountId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateACLServiceAccountSpaceBulkWithBody(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateACLServiceAccountSpaceBulkRequestWithBody(c.Server, spaceId, serviceAccountId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateACLServiceAccountSpaceBulk(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, body CreateACLServiceAccountSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateACLServiceAccountSpaceBulkRequest(c.Server, spaceId, serviceAccountId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserSpaceWithBody(ctx context.Context, spaceId SpaceId, params *ListUserSpaceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserSpaceRequestWithBody(c.Server, spaceId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserSpace(ctx context.Context, spaceId SpaceId, params *ListUserSpaceParams, body ListUserSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserSpaceRequest(c.Server, spaceId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserSpaceWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserSpaceRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserSpace(ctx context.Context, spaceId SpaceId, body CreateUserSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserSpaceRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserSpace(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserSpaceRequest(c.Server, spaceId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserSpace(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserSpaceRequest(c.Server, spaceId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchUserStateSpaceWithBody(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchUserStateSpaceRequestWithBody(c.Server, spaceId, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchUserStateSpace(ctx context.Context, spaceId SpaceId, userId UserId, body PatchUserStateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchUserStateSpaceRequest(c.Server, spaceId, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignUserToSpace(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignUserToSpaceRequest(c.Server, spaceId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserSpaceWithBody(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserSpaceRequestWithBody(c.Server, spaceId, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserSpace(ctx context.Context, spaceId SpaceId, userId UserId, body UpdateUserSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserSpaceRequest(c.Server, spaceId, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetACLUserSpace(ctx context.Context, spaceId SpaceId, userId UserId, params *GetACLUserSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetACLUserSpaceRequest(c.Server, spaceId, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteACLUserSpaceBulkWithBody(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteACLUserSpaceBulkRequestWithBody(c.Server, spaceId, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteACLUserSpaceBulk(ctx context.Context, spaceId SpaceId, userId UserId, body DeleteACLUserSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteACLUserSpaceBulkRequest(c.Server, spaceId, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateACLUserSpaceBulkWithBody(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateACLUserSpaceBulkRequestWithBody(c.Server, spaceId, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateACLUserSpaceBulk(ctx context.Context, spaceId SpaceId, userId UserId, body CreateACLUserSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateACLUserSpaceBulkRequest(c.Server, spaceId, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RecoverUserSpace(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRecoverUserSpaceRequest(c.Server, spaceId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TokenWithBody(ctx context.Context, params *TokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTokenRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TokenWithFormdataBody(ctx context.Context, params *TokenParams, body TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTokenRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserInfo(ctx context.Context, params *GetUserInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserInfoRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListClusters(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListClustersRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClusterWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClusterRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCluster(ctx context.Context, spaceId SpaceId, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClusterRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCluster(ctx context.Context, spaceId SpaceId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClusterRequest(c.Server, spaceId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCluster(ctx context.Context, spaceId SpaceId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterRequest(c.Server, spaceId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClusterWithBody(ctx context.Context, spaceId SpaceId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClusterRequestWithBody(c.Server, spaceId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCluster(ctx context.Context, spaceId SpaceId, clusterId ClusterId, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClusterRequest(c.Server, spaceId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListNodepools(ctx context.Context, spaceId SpaceId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListNodepoolsRequest(c.Server, spaceId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNodePoolWithBody(ctx context.Context, spaceId SpaceId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNodePoolRequestWithBody(c.Server, spaceId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNodePool(ctx context.Context, spaceId SpaceId, clusterId ClusterId, body CreateNodePoolJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNodePoolRequest(c.Server, spaceId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNodePool(ctx context.Context, spaceId SpaceId, clusterId ClusterId, nodePoolName NodepoolName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNodePoolRequest(c.Server, spaceId, clusterId, nodePoolName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNodepoolWithBody(ctx context.Context, spaceId SpaceId, clusterId ClusterId, nodePoolName NodepoolName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNodepoolRequestWithBody(c.Server, spaceId, clusterId, nodePoolName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNodepool(ctx context.Context, spaceId SpaceId, clusterId ClusterId, nodePoolName NodepoolName, body UpdateNodepoolJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNodepoolRequest(c.Server, spaceId, clusterId, nodePoolName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListOperations(ctx context.Context, spaceId SpaceId, params *ListOperationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListOperationsRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOperation(ctx context.Context, spaceId SpaceId, id IdUuid, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOperationRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListVersions(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVersionsRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSpace(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSpaceRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpaceById(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpaceByIdRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSpaceWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSpaceRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSpace(ctx context.Context, spaceId SpaceId, body UpdateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSpaceRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSpacesWithBody(ctx context.Context, organisationId OrganisationId, params *ListSpacesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSpacesRequestWithBody(c.Server, organisationId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSpaces(ctx context.Context, organisationId OrganisationId, params *ListSpacesParams, body ListSpacesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSpacesRequest(c.Server, organisationId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpaceWithBody(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpaceRequestWithBody(c.Server, organisationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpace(ctx context.Context, organisationId OrganisationId, body CreateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpaceRequest(c.Server, organisationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewJsonWebKeysRequest generates requests for JsonWebKeys
func NewJsonWebKeysRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/.well-known/jwks.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDiscoverOidcConfigurationRequest generates requests for DiscoverOidcConfiguration
func NewDiscoverOidcConfigurationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/.well-known/openid-configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWebAuthnJavaScriptRequest generates requests for GetWebAuthnJavaScript
func NewGetWebAuthnJavaScriptRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/.well-known/webauthn.js")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAdminServiceAccountSpaceRequest calls the generic CreateAdminServiceAccountSpace builder with application/json body
func NewCreateAdminServiceAccountSpaceRequest(server string, organisationId OrganisationId, spaceId SpaceId, body CreateAdminServiceAccountSpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAdminServiceAccountSpaceRequestWithBody(server, organisationId, spaceId, "application/json", bodyReader)
}

// NewCreateAdminServiceAccountSpaceRequestWithBody generates requests for CreateAdminServiceAccountSpace with any type of body
func NewCreateAdminServiceAccountSpaceRequestWithBody(server string, organisationId OrganisationId, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/admin/organisations/%s/spaces/%s/serviceAccounts", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuthorizeRequest generates requests for Authorize
func NewAuthorizeRequest(server string, params *AuthorizeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/authorize")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ClientId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, *params.ClientId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RedirectUri != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect_uri", runtime.ParamLocationQuery, *params.RedirectUri); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_type", runtime.ParamLocationQuery, params.ResponseType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Scope != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scope", runtime.ParamLocationQuery, *params.Scope); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConsentRequest generates requests for Consent
func NewConsentRequest(server string, params *ConsentParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/consent")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "consent_challenge", runtime.ParamLocationQuery, params.ConsentChallenge); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFlowErrorRequest generates requests for GetFlowError
func NewGetFlowErrorRequest(server string, params *GetFlowErrorParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/errors")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateLoginFlowRequest calls the generic UpdateLoginFlow builder with application/json body
func NewUpdateLoginFlowRequest(server string, params *UpdateLoginFlowParams, body UpdateLoginFlowJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateLoginFlowRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateLoginFlowRequestWithFormdataBody calls the generic UpdateLoginFlow builder with application/x-www-form-urlencoded body
func NewUpdateLoginFlowRequestWithFormdataBody(server string, params *UpdateLoginFlowParams, body UpdateLoginFlowFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewUpdateLoginFlowRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewUpdateLoginFlowRequestWithBody generates requests for UpdateLoginFlow with any type of body
func NewUpdateLoginFlowRequestWithBody(server string, params *UpdateLoginFlowParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "flow", runtime.ParamLocationQuery, params.Flow); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XSessionToken != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Session-Token", runtime.ParamLocationHeader, *params.XSessionToken)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Session-Token", headerParam0)
		}

		if params.Cookie != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam1)
		}

	}

	return req, nil
}

// NewCreateNativeLoginFlowRequest generates requests for CreateNativeLoginFlow
func NewCreateNativeLoginFlowRequest(server string, params *CreateNativeLoginFlowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/login/api")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Refresh != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "refresh", runtime.ParamLocationQuery, *params.Refresh); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Aal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "aal", runtime.ParamLocationQuery, *params.Aal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReturnSessionTokenExchangeCode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return_session_token_exchange_code", runtime.ParamLocationQuery, *params.ReturnSessionTokenExchangeCode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReturnTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return_to", runtime.ParamLocationQuery, *params.ReturnTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Via != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "via", runtime.ParamLocationQuery, *params.Via); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XSessionToken != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Session-Token", runtime.ParamLocationHeader, *params.XSessionToken)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Session-Token", headerParam0)
		}

	}

	return req, nil
}

// NewCreateBrowserLoginFlowRequest generates requests for CreateBrowserLoginFlow
func NewCreateBrowserLoginFlowRequest(server string, params *CreateBrowserLoginFlowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/login/browser")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Refresh != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "refresh", runtime.ParamLocationQuery, *params.Refresh); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Aal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "aal", runtime.ParamLocationQuery, *params.Aal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReturnTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return_to", runtime.ParamLocationQuery, *params.ReturnTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LoginChallenge != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "login_challenge", runtime.ParamLocationQuery, *params.LoginChallenge); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Organization != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organization", runtime.ParamLocationQuery, *params.Organization); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Cookie != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam0)
		}

	}

	return req, nil
}

// NewGetLoginFlowRequest generates requests for GetLoginFlow
func NewGetLoginFlowRequest(server string, params *GetLoginFlowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/login/flows")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Cookie != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateLogoutFlowRequest generates requests for UpdateLogoutFlow
func NewUpdateLogoutFlowRequest(server string, params *UpdateLogoutFlowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Token != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token", runtime.ParamLocationQuery, *params.Token); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReturnTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return_to", runtime.ParamLocationQuery, *params.ReturnTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Cookie != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam0)
		}

	}

	return req, nil
}

// NewPerformNativeLogoutRequest calls the generic PerformNativeLogout builder with application/json body
func NewPerformNativeLogoutRequest(server string, body PerformNativeLogoutJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPerformNativeLogoutRequestWithBody(server, "application/json", bodyReader)
}

// NewPerformNativeLogoutRequestWithBody generates requests for PerformNativeLogout with any type of body
func NewPerformNativeLogoutRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/logout/api")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateBrowserLogoutFlowRequest generates requests for CreateBrowserLogoutFlow
func NewCreateBrowserLogoutFlowRequest(server string, params *CreateBrowserLogoutFlowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/logout/browser")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ReturnTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return_to", runtime.ParamLocationQuery, *params.ReturnTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Cookie != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("cookie", headerParam0)
		}

	}

	return req, nil
}

// NewInitRecoveryFlowRequest generates requests for InitRecoveryFlow
func NewInitRecoveryFlowRequest(server string, params *InitRecoveryFlowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/recovery")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "flow", runtime.ParamLocationQuery, params.Flow); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Token != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token", runtime.ParamLocationQuery, *params.Token); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Cookie != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateRecoveryFlowRequest calls the generic UpdateRecoveryFlow builder with application/json body
func NewUpdateRecoveryFlowRequest(server string, params *UpdateRecoveryFlowParams, body UpdateRecoveryFlowJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRecoveryFlowRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateRecoveryFlowRequestWithFormdataBody calls the generic UpdateRecoveryFlow builder with application/x-www-form-urlencoded body
func NewUpdateRecoveryFlowRequestWithFormdataBody(server string, params *UpdateRecoveryFlowParams, body UpdateRecoveryFlowFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewUpdateRecoveryFlowRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewUpdateRecoveryFlowRequestWithBody generates requests for UpdateRecoveryFlow with any type of body
func NewUpdateRecoveryFlowRequestWithBody(server string, params *UpdateRecoveryFlowParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/recovery")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "flow", runtime.ParamLocationQuery, params.Flow); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Token != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token", runtime.ParamLocationQuery, *params.Token); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Cookie != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam0)
		}

	}

	return req, nil
}

// NewCreateNativeRecoveryFlowRequest generates requests for CreateNativeRecoveryFlow
func NewCreateNativeRecoveryFlowRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/recovery/api")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBrowserRecoveryFlowRequest generates requests for CreateBrowserRecoveryFlow
func NewCreateBrowserRecoveryFlowRequest(server string, params *CreateBrowserRecoveryFlowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/recovery/browser")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ReturnTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return_to", runtime.ParamLocationQuery, *params.ReturnTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRecoveryFlowRequest generates requests for GetRecoveryFlow
func NewGetRecoveryFlowRequest(server string, params *GetRecoveryFlowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/recovery/flows")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Cookie != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateRegistrationFlowRequest calls the generic UpdateRegistrationFlow builder with application/json body
func NewUpdateRegistrationFlowRequest(server string, params *UpdateRegistrationFlowParams, body UpdateRegistrationFlowJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRegistrationFlowRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateRegistrationFlowRequestWithFormdataBody calls the generic UpdateRegistrationFlow builder with application/x-www-form-urlencoded body
func NewUpdateRegistrationFlowRequestWithFormdataBody(server string, params *UpdateRegistrationFlowParams, body UpdateRegistrationFlowFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewUpdateRegistrationFlowRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewUpdateRegistrationFlowRequestWithBody generates requests for UpdateRegistrationFlow with any type of body
func NewUpdateRegistrationFlowRequestWithBody(server string, params *UpdateRegistrationFlowParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/registration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "flow", runtime.ParamLocationQuery, params.Flow); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Cookie != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam0)
		}

	}

	return req, nil
}

// NewCreateNativeRegistrationFlowRequest generates requests for CreateNativeRegistrationFlow
func NewCreateNativeRegistrationFlowRequest(server string, params *CreateNativeRegistrationFlowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/registration/api")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ReturnSessionTokenExchangeCode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return_session_token_exchange_code", runtime.ParamLocationQuery, *params.ReturnSessionTokenExchangeCode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReturnTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return_to", runtime.ParamLocationQuery, *params.ReturnTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBrowserRegistrationFlowRequest generates requests for CreateBrowserRegistrationFlow
func NewCreateBrowserRegistrationFlowRequest(server string, params *CreateBrowserRegistrationFlowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/registration/browser")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ReturnTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return_to", runtime.ParamLocationQuery, *params.ReturnTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LoginChallenge != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "login_challenge", runtime.ParamLocationQuery, *params.LoginChallenge); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AfterVerificationReturnTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after_verification_return_to", runtime.ParamLocationQuery, *params.AfterVerificationReturnTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Organization != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organization", runtime.ParamLocationQuery, *params.Organization); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRegistrationFlowRequest generates requests for GetRegistrationFlow
func NewGetRegistrationFlowRequest(server string, params *GetRegistrationFlowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/registration/flows")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Cookie != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateSettingsFloRequest calls the generic UpdateSettingsFlo builder with application/json body
func NewUpdateSettingsFloRequest(server string, params *UpdateSettingsFloParams, body UpdateSettingsFloJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSettingsFloRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateSettingsFloRequestWithFormdataBody calls the generic UpdateSettingsFlo builder with application/x-www-form-urlencoded body
func NewUpdateSettingsFloRequestWithFormdataBody(server string, params *UpdateSettingsFloParams, body UpdateSettingsFloFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewUpdateSettingsFloRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewUpdateSettingsFloRequestWithBody generates requests for UpdateSettingsFlo with any type of body
func NewUpdateSettingsFloRequestWithBody(server string, params *UpdateSettingsFloParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "flow", runtime.ParamLocationQuery, params.Flow); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XSessionToken != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Session-Token", runtime.ParamLocationHeader, *params.XSessionToken)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Session-Token", headerParam0)
		}

		if params.Cookie != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam1)
		}

	}

	return req, nil
}

// NewCreateNativeSettingsFlowRequest generates requests for CreateNativeSettingsFlow
func NewCreateNativeSettingsFlowRequest(server string, params *CreateNativeSettingsFlowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/settings/api")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XSessionToken != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Session-Token", runtime.ParamLocationHeader, *params.XSessionToken)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Session-Token", headerParam0)
		}

	}

	return req, nil
}

// NewCreateBrowserSettingsFlowRequest generates requests for CreateBrowserSettingsFlow
func NewCreateBrowserSettingsFlowRequest(server string, params *CreateBrowserSettingsFlowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/settings/browser")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ReturnTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return_to", runtime.ParamLocationQuery, *params.ReturnTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Cookie != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam0)
		}

	}

	return req, nil
}

// NewGetSettingsFlowRequest generates requests for GetSettingsFlow
func NewGetSettingsFlowRequest(server string, params *GetSettingsFlowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/settings/flows")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XSessionToken != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Session-Token", runtime.ParamLocationHeader, *params.XSessionToken)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Session-Token", headerParam0)
		}

		if params.Cookie != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam1)
		}

	}

	return req, nil
}

// NewUpdateVerificationFlowRequest calls the generic UpdateVerificationFlow builder with application/json body
func NewUpdateVerificationFlowRequest(server string, params *UpdateVerificationFlowParams, body UpdateVerificationFlowJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVerificationFlowRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateVerificationFlowRequestWithFormdataBody calls the generic UpdateVerificationFlow builder with application/x-www-form-urlencoded body
func NewUpdateVerificationFlowRequestWithFormdataBody(server string, params *UpdateVerificationFlowParams, body UpdateVerificationFlowFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewUpdateVerificationFlowRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewUpdateVerificationFlowRequestWithBody generates requests for UpdateVerificationFlow with any type of body
func NewUpdateVerificationFlowRequestWithBody(server string, params *UpdateVerificationFlowParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/verification")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "flow", runtime.ParamLocationQuery, params.Flow); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Token != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token", runtime.ParamLocationQuery, *params.Token); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Cookie != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam0)
		}

	}

	return req, nil
}

// NewCreateNativeVerificationFlowRequest generates requests for CreateNativeVerificationFlow
func NewCreateNativeVerificationFlowRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/verification/api")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBrowserVerificationFlowRequest generates requests for CreateBrowserVerificationFlow
func NewCreateBrowserVerificationFlowRequest(server string, params *CreateBrowserVerificationFlowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/verification/browser")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ReturnTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return_to", runtime.ParamLocationQuery, *params.ReturnTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVerificationFlowRequest generates requests for GetVerificationFlow
func NewGetVerificationFlowRequest(server string, params *GetVerificationFlowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/verification/flows")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Cookie != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("cookie", headerParam0)
		}

	}

	return req, nil
}

// NewDisableMyOtherSessionsRequest generates requests for DisableMyOtherSessions
func NewDisableMyOtherSessionsRequest(server string, params *DisableMyOtherSessionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/sessions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XSessionToken != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Session-Token", runtime.ParamLocationHeader, *params.XSessionToken)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Session-Token", headerParam0)
		}

		if params.Cookie != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam1)
		}

	}

	return req, nil
}

// NewListMySessionsRequest generates requests for ListMySessions
func NewListMySessionsRequest(server string, params *ListMySessionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/sessions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_token", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XSessionToken != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Session-Token", runtime.ParamLocationHeader, *params.XSessionToken)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Session-Token", headerParam0)
		}

		if params.Cookie != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam1)
		}

	}

	return req, nil
}

// NewExchangeSessionTokenRequest generates requests for ExchangeSessionToken
func NewExchangeSessionTokenRequest(server string, params *ExchangeSessionTokenParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/sessions/token-exchange")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "init_code", runtime.ParamLocationQuery, params.InitCode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return_to_code", runtime.ParamLocationQuery, params.ReturnToCode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewToSessionRequest generates requests for ToSession
func NewToSessionRequest(server string, params *ToSessionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/sessions/whoami")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TokenizeAs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tokenize_as", runtime.ParamLocationQuery, *params.TokenizeAs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XSessionToken != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Session-Token", runtime.ParamLocationHeader, *params.XSessionToken)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Session-Token", headerParam0)
		}

		if params.Cookie != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam1)
		}

	}

	return req, nil
}

// NewIntrospectRequestWithFormdataBody calls the generic Introspect builder with application/x-www-form-urlencoded body
func NewIntrospectRequestWithFormdataBody(server string, body IntrospectFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewIntrospectRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewIntrospectRequestWithBody generates requests for Introspect with any type of body
func NewIntrospectRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/introspect")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListOrganisationsIdentityRequest generates requests for ListOrganisationsIdentity
func NewListOrganisationsIdentityRequest(server string, params *ListOrganisationsIdentityParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIAMGranularPolicyOrganisationRequest generates requests for GetIAMGranularPolicyOrganisation
func NewGetIAMGranularPolicyOrganisationRequest(server string, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "subjectType", runtime.ParamLocationPath, subjectType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "subjectId", runtime.ParamLocationPath, subjectId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "objectType", runtime.ParamLocationPath, objectType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/iamgranularPolicy/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetIAMGranularPolicyOrganisationRequest calls the generic SetIAMGranularPolicyOrganisation builder with application/json body
func NewSetIAMGranularPolicyOrganisationRequest(server string, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, body SetIAMGranularPolicyOrganisationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetIAMGranularPolicyOrganisationRequestWithBody(server, organisationId, subjectType, subjectId, objectType, "application/json", bodyReader)
}

// NewSetIAMGranularPolicyOrganisationRequestWithBody generates requests for SetIAMGranularPolicyOrganisation with any type of body
func NewSetIAMGranularPolicyOrganisationRequestWithBody(server string, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "subjectType", runtime.ParamLocationPath, subjectType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "subjectId", runtime.ParamLocationPath, subjectId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "objectType", runtime.ParamLocationPath, objectType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/iamgranularPolicy/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetIAMPolicyOrganisationRequest generates requests for GetIAMPolicyOrganisation
func NewGetIAMPolicyOrganisationRequest(server string, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "subjectType", runtime.ParamLocationPath, subjectType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "subjectId", runtime.ParamLocationPath, subjectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/iampolicy/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetIAMPolicyOrganisationRequest calls the generic SetIAMPolicyOrganisation builder with application/json body
func NewSetIAMPolicyOrganisationRequest(server string, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, body SetIAMPolicyOrganisationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetIAMPolicyOrganisationRequestWithBody(server, organisationId, subjectType, subjectId, "application/json", bodyReader)
}

// NewSetIAMPolicyOrganisationRequestWithBody generates requests for SetIAMPolicyOrganisation with any type of body
func NewSetIAMPolicyOrganisationRequestWithBody(server string, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "subjectType", runtime.ParamLocationPath, subjectType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "subjectId", runtime.ParamLocationPath, subjectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/iampolicy/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPermissionsOrganisationRequest generates requests for ListPermissionsOrganisation
func NewListPermissionsOrganisationRequest(server string, organisationId OrganisationId, params *ListPermissionsOrganisationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/permissions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Service != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "service", runtime.ParamLocationQuery, *params.Service); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Resource != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resource", runtime.ParamLocationQuery, *params.Resource); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Subresource != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subresource", runtime.ParamLocationQuery, *params.Subresource); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Action != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "action", runtime.ParamLocationQuery, *params.Action); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPermissionOrganisationRequest generates requests for GetPermissionOrganisation
func NewGetPermissionOrganisationRequest(server string, organisationId OrganisationId, permissionUuid PermissionUuid) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "permissionUuid", runtime.ParamLocationPath, permissionUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/permissions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRolesOrganisationRequest generates requests for ListRolesOrganisation
func NewListRolesOrganisationRequest(server string, organisationId OrganisationId, params *ListRolesOrganisationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/roles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRoleOrganisationRequest calls the generic CreateRoleOrganisation builder with application/json body
func NewCreateRoleOrganisationRequest(server string, organisationId OrganisationId, body CreateRoleOrganisationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRoleOrganisationRequestWithBody(server, organisationId, "application/json", bodyReader)
}

// NewCreateRoleOrganisationRequestWithBody generates requests for CreateRoleOrganisation with any type of body
func NewCreateRoleOrganisationRequestWithBody(server string, organisationId OrganisationId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/roles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRoleOrganisationRequest generates requests for DeleteRoleOrganisation
func NewDeleteRoleOrganisationRequest(server string, organisationId OrganisationId, roleUuid RoleUuid) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUuid", runtime.ParamLocationPath, roleUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/roles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRoleOrganisationRequest generates requests for GetRoleOrganisation
func NewGetRoleOrganisationRequest(server string, organisationId OrganisationId, roleUuid RoleUuid) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUuid", runtime.ParamLocationPath, roleUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/roles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRoleOrganisationRequest calls the generic UpdateRoleOrganisation builder with application/json body
func NewUpdateRoleOrganisationRequest(server string, organisationId OrganisationId, roleUuid RoleUuid, body UpdateRoleOrganisationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRoleOrganisationRequestWithBody(server, organisationId, roleUuid, "application/json", bodyReader)
}

// NewUpdateRoleOrganisationRequestWithBody generates requests for UpdateRoleOrganisation with any type of body
func NewUpdateRoleOrganisationRequestWithBody(server string, organisationId OrganisationId, roleUuid RoleUuid, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUuid", runtime.ParamLocationPath, roleUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/roles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveRolePermissionsOrganisationRequest calls the generic RemoveRolePermissionsOrganisation builder with application/json body
func NewRemoveRolePermissionsOrganisationRequest(server string, organisationId OrganisationId, roleUuid RoleUuid, body RemoveRolePermissionsOrganisationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveRolePermissionsOrganisationRequestWithBody(server, organisationId, roleUuid, "application/json", bodyReader)
}

// NewRemoveRolePermissionsOrganisationRequestWithBody generates requests for RemoveRolePermissionsOrganisation with any type of body
func NewRemoveRolePermissionsOrganisationRequestWithBody(server string, organisationId OrganisationId, roleUuid RoleUuid, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUuid", runtime.ParamLocationPath, roleUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/roles/%s/permissions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRolePermissionsOrganisationRequest generates requests for GetRolePermissionsOrganisation
func NewGetRolePermissionsOrganisationRequest(server string, organisationId OrganisationId, roleUuid RoleUuid) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUuid", runtime.ParamLocationPath, roleUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/roles/%s/permissions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddRolePermissionsOrganisationRequest calls the generic AddRolePermissionsOrganisation builder with application/json body
func NewAddRolePermissionsOrganisationRequest(server string, organisationId OrganisationId, roleUuid RoleUuid, body AddRolePermissionsOrganisationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddRolePermissionsOrganisationRequestWithBody(server, organisationId, roleUuid, "application/json", bodyReader)
}

// NewAddRolePermissionsOrganisationRequestWithBody generates requests for AddRolePermissionsOrganisation with any type of body
func NewAddRolePermissionsOrganisationRequestWithBody(server string, organisationId OrganisationId, roleUuid RoleUuid, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUuid", runtime.ParamLocationPath, roleUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/roles/%s/permissions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListServiceAccountOrganisationRequest calls the generic ListServiceAccountOrganisation builder with application/json body
func NewListServiceAccountOrganisationRequest(server string, organisationId OrganisationId, params *ListServiceAccountOrganisationParams, body ListServiceAccountOrganisationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListServiceAccountOrganisationRequestWithBody(server, organisationId, params, "application/json", bodyReader)
}

// NewListServiceAccountOrganisationRequestWithBody generates requests for ListServiceAccountOrganisation with any type of body
func NewListServiceAccountOrganisationRequestWithBody(server string, organisationId OrganisationId, params *ListServiceAccountOrganisationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/serviceAccounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateServiceAccountOrganisationRequest calls the generic CreateServiceAccountOrganisation builder with application/json body
func NewCreateServiceAccountOrganisationRequest(server string, organisationId OrganisationId, body CreateServiceAccountOrganisationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServiceAccountOrganisationRequestWithBody(server, organisationId, "application/json", bodyReader)
}

// NewCreateServiceAccountOrganisationRequestWithBody generates requests for CreateServiceAccountOrganisation with any type of body
func NewCreateServiceAccountOrganisationRequestWithBody(server string, organisationId OrganisationId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/serviceAccounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServiceAccountOrganisationRequest generates requests for DeleteServiceAccountOrganisation
func NewDeleteServiceAccountOrganisationRequest(server string, organisationId OrganisationId, serviceAccountId ServiceAccountId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/serviceAccounts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServiceAccountOrganisationRequest generates requests for GetServiceAccountOrganisation
func NewGetServiceAccountOrganisationRequest(server string, organisationId OrganisationId, serviceAccountId ServiceAccountId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/serviceAccounts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateServiceAccountOrganisationRequest calls the generic UpdateServiceAccountOrganisation builder with application/json body
func NewUpdateServiceAccountOrganisationRequest(server string, organisationId OrganisationId, serviceAccountId ServiceAccountId, body UpdateServiceAccountOrganisationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateServiceAccountOrganisationRequestWithBody(server, organisationId, serviceAccountId, "application/json", bodyReader)
}

// NewUpdateServiceAccountOrganisationRequestWithBody generates requests for UpdateServiceAccountOrganisation with any type of body
func NewUpdateServiceAccountOrganisationRequestWithBody(server string, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/serviceAccounts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetACLServiceAccountOrganisationRequest generates requests for GetACLServiceAccountOrganisation
func NewGetACLServiceAccountOrganisationRequest(server string, organisationId OrganisationId, serviceAccountId ServiceAccountId, params *GetACLServiceAccountOrganisationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/serviceAccounts/%s/acl", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "service", runtime.ParamLocationQuery, params.Service); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resource", runtime.ParamLocationQuery, params.Resource); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Subresource != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subresource", runtime.ParamLocationQuery, *params.Subresource); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteACLServiceAccountOrganisationBulkRequest calls the generic DeleteACLServiceAccountOrganisationBulk builder with application/json body
func NewDeleteACLServiceAccountOrganisationBulkRequest(server string, organisationId OrganisationId, serviceAccountId ServiceAccountId, body DeleteACLServiceAccountOrganisationBulkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteACLServiceAccountOrganisationBulkRequestWithBody(server, organisationId, serviceAccountId, "application/json", bodyReader)
}

// NewDeleteACLServiceAccountOrganisationBulkRequestWithBody generates requests for DeleteACLServiceAccountOrganisationBulk with any type of body
func NewDeleteACLServiceAccountOrganisationBulkRequestWithBody(server string, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/serviceAccounts/%s/bulk/acl", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateACLServiceAccountOrganisationBulkRequest calls the generic CreateACLServiceAccountOrganisationBulk builder with application/json body
func NewCreateACLServiceAccountOrganisationBulkRequest(server string, organisationId OrganisationId, serviceAccountId ServiceAccountId, body CreateACLServiceAccountOrganisationBulkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateACLServiceAccountOrganisationBulkRequestWithBody(server, organisationId, serviceAccountId, "application/json", bodyReader)
}

// NewCreateACLServiceAccountOrganisationBulkRequestWithBody generates requests for CreateACLServiceAccountOrganisationBulk with any type of body
func NewCreateACLServiceAccountOrganisationBulkRequestWithBody(server string, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/serviceAccounts/%s/bulk/acl", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListSpacesOfServiceAccountRequest generates requests for ListSpacesOfServiceAccount
func NewListSpacesOfServiceAccountRequest(server string, organisationId OrganisationId, serviceAccountId ServiceAccountId, params *ListSpacesOfServiceAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/serviceAccounts/%s/spaces", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSpacesIdentityRequest generates requests for ListSpacesIdentity
func NewListSpacesIdentityRequest(server string, organisationId OrganisationId, params *ListSpacesIdentityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/spaces", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUserOrganisationRequest calls the generic ListUserOrganisation builder with application/json body
func NewListUserOrganisationRequest(server string, organisationId OrganisationId, params *ListUserOrganisationParams, body ListUserOrganisationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListUserOrganisationRequestWithBody(server, organisationId, params, "application/json", bodyReader)
}

// NewListUserOrganisationRequestWithBody generates requests for ListUserOrganisation with any type of body
func NewListUserOrganisationRequestWithBody(server string, organisationId OrganisationId, params *ListUserOrganisationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Email != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "email", runtime.ParamLocationQuery, *params.Email); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateUserOrganisationRequest calls the generic CreateUserOrganisation builder with application/json body
func NewCreateUserOrganisationRequest(server string, organisationId OrganisationId, body CreateUserOrganisationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserOrganisationRequestWithBody(server, organisationId, "application/json", bodyReader)
}

// NewCreateUserOrganisationRequestWithBody generates requests for CreateUserOrganisation with any type of body
func NewCreateUserOrganisationRequestWithBody(server string, organisationId OrganisationId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserOrganisationRequest generates requests for DeleteUserOrganisation
func NewDeleteUserOrganisationRequest(server string, organisationId OrganisationId, userId UserId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserOrganisationRequest generates requests for GetUserOrganisation
func NewGetUserOrganisationRequest(server string, organisationId OrganisationId, userId UserId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchUserStateOrganisationRequest calls the generic PatchUserStateOrganisation builder with application/json body
func NewPatchUserStateOrganisationRequest(server string, organisationId OrganisationId, userId UserId, body PatchUserStateOrganisationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchUserStateOrganisationRequestWithBody(server, organisationId, userId, "application/json", bodyReader)
}

// NewPatchUserStateOrganisationRequestWithBody generates requests for PatchUserStateOrganisation with any type of body
func NewPatchUserStateOrganisationRequestWithBody(server string, organisationId OrganisationId, userId UserId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateUserOrganisationRequest calls the generic UpdateUserOrganisation builder with application/json body
func NewUpdateUserOrganisationRequest(server string, organisationId OrganisationId, userId UserId, body UpdateUserOrganisationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserOrganisationRequestWithBody(server, organisationId, userId, "application/json", bodyReader)
}

// NewUpdateUserOrganisationRequestWithBody generates requests for UpdateUserOrganisation with any type of body
func NewUpdateUserOrganisationRequestWithBody(server string, organisationId OrganisationId, userId UserId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetACLUserOrganisationRequest generates requests for GetACLUserOrganisation
func NewGetACLUserOrganisationRequest(server string, organisationId OrganisationId, userId UserId, params *GetACLUserOrganisationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/users/%s/acl", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "service", runtime.ParamLocationQuery, params.Service); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resource", runtime.ParamLocationQuery, params.Resource); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Subresource != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subresource", runtime.ParamLocationQuery, *params.Subresource); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteACLUserOrganisationBulkRequest calls the generic DeleteACLUserOrganisationBulk builder with application/json body
func NewDeleteACLUserOrganisationBulkRequest(server string, organisationId OrganisationId, userId UserId, body DeleteACLUserOrganisationBulkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteACLUserOrganisationBulkRequestWithBody(server, organisationId, userId, "application/json", bodyReader)
}

// NewDeleteACLUserOrganisationBulkRequestWithBody generates requests for DeleteACLUserOrganisationBulk with any type of body
func NewDeleteACLUserOrganisationBulkRequestWithBody(server string, organisationId OrganisationId, userId UserId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/users/%s/bulk/acl", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateACLUserOrganisationBulkRequest calls the generic CreateACLUserOrganisationBulk builder with application/json body
func NewCreateACLUserOrganisationBulkRequest(server string, organisationId OrganisationId, userId UserId, body CreateACLUserOrganisationBulkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateACLUserOrganisationBulkRequestWithBody(server, organisationId, userId, "application/json", bodyReader)
}

// NewCreateACLUserOrganisationBulkRequestWithBody generates requests for CreateACLUserOrganisationBulk with any type of body
func NewCreateACLUserOrganisationBulkRequestWithBody(server string, organisationId OrganisationId, userId UserId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/users/%s/bulk/acl", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRecoverUserOrganisationRequest generates requests for RecoverUserOrganisation
func NewRecoverUserOrganisationRequest(server string, organisationId OrganisationId, userId UserId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/users/%s/recover", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSpacesOfUserRequest generates requests for ListSpacesOfUser
func NewListSpacesOfUserRequest(server string, organisationId OrganisationId, userId UserId, params *ListSpacesOfUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/users/%s/spaces", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRevokeRequestWithFormdataBody calls the generic Revoke builder with application/x-www-form-urlencoded body
func NewRevokeRequestWithFormdataBody(server string, params *RevokeParams, body RevokeFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewRevokeRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewRevokeRequestWithBody generates requests for Revoke with any type of body
func NewRevokeRequestWithBody(server string, params *RevokeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/revoke")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Authorization != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, *params.Authorization)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Authorization", headerParam0)
		}

	}

	return req, nil
}

// NewGetIAMGranularPolicySpaceRequest generates requests for GetIAMGranularPolicySpace
func NewGetIAMGranularPolicySpaceRequest(server string, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "subjectType", runtime.ParamLocationPath, subjectType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "subjectId", runtime.ParamLocationPath, subjectId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "objectType", runtime.ParamLocationPath, objectType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/iamgranularPolicy/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetIAMGranularPolicySpaceRequest calls the generic SetIAMGranularPolicySpace builder with application/json body
func NewSetIAMGranularPolicySpaceRequest(server string, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, body SetIAMGranularPolicySpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetIAMGranularPolicySpaceRequestWithBody(server, spaceId, subjectType, subjectId, objectType, "application/json", bodyReader)
}

// NewSetIAMGranularPolicySpaceRequestWithBody generates requests for SetIAMGranularPolicySpace with any type of body
func NewSetIAMGranularPolicySpaceRequestWithBody(server string, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "subjectType", runtime.ParamLocationPath, subjectType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "subjectId", runtime.ParamLocationPath, subjectId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "objectType", runtime.ParamLocationPath, objectType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/iamgranularPolicy/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetIAMPolicySpaceRequest generates requests for GetIAMPolicySpace
func NewGetIAMPolicySpaceRequest(server string, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "subjectType", runtime.ParamLocationPath, subjectType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "subjectId", runtime.ParamLocationPath, subjectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/iampolicy/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetIAMPolicySpaceRequest calls the generic SetIAMPolicySpace builder with application/json body
func NewSetIAMPolicySpaceRequest(server string, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, body SetIAMPolicySpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetIAMPolicySpaceRequestWithBody(server, spaceId, subjectType, subjectId, "application/json", bodyReader)
}

// NewSetIAMPolicySpaceRequestWithBody generates requests for SetIAMPolicySpace with any type of body
func NewSetIAMPolicySpaceRequestWithBody(server string, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "subjectType", runtime.ParamLocationPath, subjectType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "subjectId", runtime.ParamLocationPath, subjectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/iampolicy/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPermissionsSpaceRequest generates requests for ListPermissionsSpace
func NewListPermissionsSpaceRequest(server string, spaceId SpaceId, params *ListPermissionsSpaceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/permissions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Service != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "service", runtime.ParamLocationQuery, *params.Service); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Resource != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resource", runtime.ParamLocationQuery, *params.Resource); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Subresource != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subresource", runtime.ParamLocationQuery, *params.Subresource); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Action != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "action", runtime.ParamLocationQuery, *params.Action); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPermissionSpaceRequest generates requests for GetPermissionSpace
func NewGetPermissionSpaceRequest(server string, spaceId SpaceId, permissionUuid PermissionUuid) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "permissionUuid", runtime.ParamLocationPath, permissionUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/permissions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRolesSpaceRequest generates requests for ListRolesSpace
func NewListRolesSpaceRequest(server string, spaceId SpaceId, params *ListRolesSpaceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/roles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRoleSpaceRequest calls the generic CreateRoleSpace builder with application/json body
func NewCreateRoleSpaceRequest(server string, spaceId SpaceId, body CreateRoleSpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRoleSpaceRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateRoleSpaceRequestWithBody generates requests for CreateRoleSpace with any type of body
func NewCreateRoleSpaceRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/roles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRoleSpaceRequest generates requests for DeleteRoleSpace
func NewDeleteRoleSpaceRequest(server string, spaceId SpaceId, roleUuid RoleUuid) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUuid", runtime.ParamLocationPath, roleUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/roles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRoleSpaceRequest generates requests for GetRoleSpace
func NewGetRoleSpaceRequest(server string, spaceId SpaceId, roleUuid RoleUuid) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUuid", runtime.ParamLocationPath, roleUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/roles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRoleSpaceRequest calls the generic UpdateRoleSpace builder with application/json body
func NewUpdateRoleSpaceRequest(server string, spaceId SpaceId, roleUuid RoleUuid, body UpdateRoleSpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRoleSpaceRequestWithBody(server, spaceId, roleUuid, "application/json", bodyReader)
}

// NewUpdateRoleSpaceRequestWithBody generates requests for UpdateRoleSpace with any type of body
func NewUpdateRoleSpaceRequestWithBody(server string, spaceId SpaceId, roleUuid RoleUuid, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUuid", runtime.ParamLocationPath, roleUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/roles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveRolePermissionsSpaceRequest calls the generic RemoveRolePermissionsSpace builder with application/json body
func NewRemoveRolePermissionsSpaceRequest(server string, spaceId SpaceId, roleUuid RoleUuid, body RemoveRolePermissionsSpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveRolePermissionsSpaceRequestWithBody(server, spaceId, roleUuid, "application/json", bodyReader)
}

// NewRemoveRolePermissionsSpaceRequestWithBody generates requests for RemoveRolePermissionsSpace with any type of body
func NewRemoveRolePermissionsSpaceRequestWithBody(server string, spaceId SpaceId, roleUuid RoleUuid, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUuid", runtime.ParamLocationPath, roleUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/roles/%s/permissions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRolePermissionsSpaceRequest generates requests for GetRolePermissionsSpace
func NewGetRolePermissionsSpaceRequest(server string, spaceId SpaceId, roleUuid RoleUuid) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUuid", runtime.ParamLocationPath, roleUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/roles/%s/permissions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddRolePermissionsSpaceRequest calls the generic AddRolePermissionsSpace builder with application/json body
func NewAddRolePermissionsSpaceRequest(server string, spaceId SpaceId, roleUuid RoleUuid, body AddRolePermissionsSpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddRolePermissionsSpaceRequestWithBody(server, spaceId, roleUuid, "application/json", bodyReader)
}

// NewAddRolePermissionsSpaceRequestWithBody generates requests for AddRolePermissionsSpace with any type of body
func NewAddRolePermissionsSpaceRequestWithBody(server string, spaceId SpaceId, roleUuid RoleUuid, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUuid", runtime.ParamLocationPath, roleUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/roles/%s/permissions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListServiceAccountSpaceRequest calls the generic ListServiceAccountSpace builder with application/json body
func NewListServiceAccountSpaceRequest(server string, spaceId SpaceId, params *ListServiceAccountSpaceParams, body ListServiceAccountSpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListServiceAccountSpaceRequestWithBody(server, spaceId, params, "application/json", bodyReader)
}

// NewListServiceAccountSpaceRequestWithBody generates requests for ListServiceAccountSpace with any type of body
func NewListServiceAccountSpaceRequestWithBody(server string, spaceId SpaceId, params *ListServiceAccountSpaceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/serviceAccounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateServiceAccountSpaceRequest calls the generic CreateServiceAccountSpace builder with application/json body
func NewCreateServiceAccountSpaceRequest(server string, spaceId SpaceId, body CreateServiceAccountSpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServiceAccountSpaceRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateServiceAccountSpaceRequestWithBody generates requests for CreateServiceAccountSpace with any type of body
func NewCreateServiceAccountSpaceRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/serviceAccounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServiceAccountSpaceRequest generates requests for DeleteServiceAccountSpace
func NewDeleteServiceAccountSpaceRequest(server string, spaceId SpaceId, serviceAccountId ServiceAccountId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/serviceAccounts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServiceAccountSpaceRequest generates requests for GetServiceAccountSpace
func NewGetServiceAccountSpaceRequest(server string, spaceId SpaceId, serviceAccountId ServiceAccountId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/serviceAccounts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignServiceAccountToSpaceRequest generates requests for AssignServiceAccountToSpace
func NewAssignServiceAccountToSpaceRequest(server string, spaceId SpaceId, serviceAccountId ServiceAccountId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/serviceAccounts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateServiceAccountSpaceRequest calls the generic UpdateServiceAccountSpace builder with application/json body
func NewUpdateServiceAccountSpaceRequest(server string, spaceId SpaceId, serviceAccountId ServiceAccountId, body UpdateServiceAccountSpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateServiceAccountSpaceRequestWithBody(server, spaceId, serviceAccountId, "application/json", bodyReader)
}

// NewUpdateServiceAccountSpaceRequestWithBody generates requests for UpdateServiceAccountSpace with any type of body
func NewUpdateServiceAccountSpaceRequestWithBody(server string, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/serviceAccounts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetACLServiceAccountSpaceRequest generates requests for GetACLServiceAccountSpace
func NewGetACLServiceAccountSpaceRequest(server string, spaceId SpaceId, serviceAccountId ServiceAccountId, params *GetACLServiceAccountSpaceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/serviceAccounts/%s/acl", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "service", runtime.ParamLocationQuery, params.Service); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resource", runtime.ParamLocationQuery, params.Resource); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Subresource != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subresource", runtime.ParamLocationQuery, *params.Subresource); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteACLServiceAccountSpaceBulkRequest calls the generic DeleteACLServiceAccountSpaceBulk builder with application/json body
func NewDeleteACLServiceAccountSpaceBulkRequest(server string, spaceId SpaceId, serviceAccountId ServiceAccountId, body DeleteACLServiceAccountSpaceBulkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteACLServiceAccountSpaceBulkRequestWithBody(server, spaceId, serviceAccountId, "application/json", bodyReader)
}

// NewDeleteACLServiceAccountSpaceBulkRequestWithBody generates requests for DeleteACLServiceAccountSpaceBulk with any type of body
func NewDeleteACLServiceAccountSpaceBulkRequestWithBody(server string, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/serviceAccounts/%s/bulk/acl", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateACLServiceAccountSpaceBulkRequest calls the generic CreateACLServiceAccountSpaceBulk builder with application/json body
func NewCreateACLServiceAccountSpaceBulkRequest(server string, spaceId SpaceId, serviceAccountId ServiceAccountId, body CreateACLServiceAccountSpaceBulkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateACLServiceAccountSpaceBulkRequestWithBody(server, spaceId, serviceAccountId, "application/json", bodyReader)
}

// NewCreateACLServiceAccountSpaceBulkRequestWithBody generates requests for CreateACLServiceAccountSpaceBulk with any type of body
func NewCreateACLServiceAccountSpaceBulkRequestWithBody(server string, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/serviceAccounts/%s/bulk/acl", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListUserSpaceRequest calls the generic ListUserSpace builder with application/json body
func NewListUserSpaceRequest(server string, spaceId SpaceId, params *ListUserSpaceParams, body ListUserSpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListUserSpaceRequestWithBody(server, spaceId, params, "application/json", bodyReader)
}

// NewListUserSpaceRequestWithBody generates requests for ListUserSpace with any type of body
func NewListUserSpaceRequestWithBody(server string, spaceId SpaceId, params *ListUserSpaceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Email != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "email", runtime.ParamLocationQuery, *params.Email); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateUserSpaceRequest calls the generic CreateUserSpace builder with application/json body
func NewCreateUserSpaceRequest(server string, spaceId SpaceId, body CreateUserSpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserSpaceRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateUserSpaceRequestWithBody generates requests for CreateUserSpace with any type of body
func NewCreateUserSpaceRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserSpaceRequest generates requests for DeleteUserSpace
func NewDeleteUserSpaceRequest(server string, spaceId SpaceId, userId UserId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserSpaceRequest generates requests for GetUserSpace
func NewGetUserSpaceRequest(server string, spaceId SpaceId, userId UserId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchUserStateSpaceRequest calls the generic PatchUserStateSpace builder with application/json body
func NewPatchUserStateSpaceRequest(server string, spaceId SpaceId, userId UserId, body PatchUserStateSpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchUserStateSpaceRequestWithBody(server, spaceId, userId, "application/json", bodyReader)
}

// NewPatchUserStateSpaceRequestWithBody generates requests for PatchUserStateSpace with any type of body
func NewPatchUserStateSpaceRequestWithBody(server string, spaceId SpaceId, userId UserId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAssignUserToSpaceRequest generates requests for AssignUserToSpace
func NewAssignUserToSpaceRequest(server string, spaceId SpaceId, userId UserId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserSpaceRequest calls the generic UpdateUserSpace builder with application/json body
func NewUpdateUserSpaceRequest(server string, spaceId SpaceId, userId UserId, body UpdateUserSpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserSpaceRequestWithBody(server, spaceId, userId, "application/json", bodyReader)
}

// NewUpdateUserSpaceRequestWithBody generates requests for UpdateUserSpace with any type of body
func NewUpdateUserSpaceRequestWithBody(server string, spaceId SpaceId, userId UserId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetACLUserSpaceRequest generates requests for GetACLUserSpace
func NewGetACLUserSpaceRequest(server string, spaceId SpaceId, userId UserId, params *GetACLUserSpaceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/users/%s/acl", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "service", runtime.ParamLocationQuery, params.Service); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resource", runtime.ParamLocationQuery, params.Resource); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Subresource != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subresource", runtime.ParamLocationQuery, *params.Subresource); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteACLUserSpaceBulkRequest calls the generic DeleteACLUserSpaceBulk builder with application/json body
func NewDeleteACLUserSpaceBulkRequest(server string, spaceId SpaceId, userId UserId, body DeleteACLUserSpaceBulkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteACLUserSpaceBulkRequestWithBody(server, spaceId, userId, "application/json", bodyReader)
}

// NewDeleteACLUserSpaceBulkRequestWithBody generates requests for DeleteACLUserSpaceBulk with any type of body
func NewDeleteACLUserSpaceBulkRequestWithBody(server string, spaceId SpaceId, userId UserId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/users/%s/bulk/acl", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateACLUserSpaceBulkRequest calls the generic CreateACLUserSpaceBulk builder with application/json body
func NewCreateACLUserSpaceBulkRequest(server string, spaceId SpaceId, userId UserId, body CreateACLUserSpaceBulkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateACLUserSpaceBulkRequestWithBody(server, spaceId, userId, "application/json", bodyReader)
}

// NewCreateACLUserSpaceBulkRequestWithBody generates requests for CreateACLUserSpaceBulk with any type of body
func NewCreateACLUserSpaceBulkRequestWithBody(server string, spaceId SpaceId, userId UserId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/users/%s/bulk/acl", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRecoverUserSpaceRequest generates requests for RecoverUserSpace
func NewRecoverUserSpaceRequest(server string, spaceId SpaceId, userId UserId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/users/%s/recover", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTokenRequestWithFormdataBody calls the generic Token builder with application/x-www-form-urlencoded body
func NewTokenRequestWithFormdataBody(server string, params *TokenParams, body TokenFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTokenRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewTokenRequestWithBody generates requests for Token with any type of body
func NewTokenRequestWithBody(server string, params *TokenParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Authorization != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, *params.Authorization)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Authorization", headerParam0)
		}

	}

	return req, nil
}

// NewGetUserInfoRequest generates requests for GetUserInfo
func NewGetUserInfoRequest(server string, params *GetUserInfoParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/userinfo")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Authorization != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, *params.Authorization)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Authorization", headerParam0)
		}

	}

	return req, nil
}

// NewListClustersRequest generates requests for ListClusters
func NewListClustersRequest(server string, spaceId SpaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openshift/spaces/%s/clusters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateClusterRequest calls the generic CreateCluster builder with application/json body
func NewCreateClusterRequest(server string, spaceId SpaceId, body CreateClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateClusterRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateClusterRequestWithBody generates requests for CreateCluster with any type of body
func NewCreateClusterRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openshift/spaces/%s/clusters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteClusterRequest generates requests for DeleteCluster
func NewDeleteClusterRequest(server string, spaceId SpaceId, clusterId ClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openshift/spaces/%s/clusters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClusterRequest generates requests for GetCluster
func NewGetClusterRequest(server string, spaceId SpaceId, clusterId ClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openshift/spaces/%s/clusters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateClusterRequest calls the generic UpdateCluster builder with application/json body
func NewUpdateClusterRequest(server string, spaceId SpaceId, clusterId ClusterId, body UpdateClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateClusterRequestWithBody(server, spaceId, clusterId, "application/json", bodyReader)
}

// NewUpdateClusterRequestWithBody generates requests for UpdateCluster with any type of body
func NewUpdateClusterRequestWithBody(server string, spaceId SpaceId, clusterId ClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openshift/spaces/%s/clusters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListNodepoolsRequest generates requests for ListNodepools
func NewListNodepoolsRequest(server string, spaceId SpaceId, clusterId ClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openshift/spaces/%s/clusters/%s/nodepools", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNodePoolRequest calls the generic CreateNodePool builder with application/json body
func NewCreateNodePoolRequest(server string, spaceId SpaceId, clusterId ClusterId, body CreateNodePoolJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNodePoolRequestWithBody(server, spaceId, clusterId, "application/json", bodyReader)
}

// NewCreateNodePoolRequestWithBody generates requests for CreateNodePool with any type of body
func NewCreateNodePoolRequestWithBody(server string, spaceId SpaceId, clusterId ClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openshift/spaces/%s/clusters/%s/nodepools", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteNodePoolRequest generates requests for DeleteNodePool
func NewDeleteNodePoolRequest(server string, spaceId SpaceId, clusterId ClusterId, nodePoolName NodepoolName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "nodePoolName", runtime.ParamLocationPath, nodePoolName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openshift/spaces/%s/clusters/%s/nodepools/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateNodepoolRequest calls the generic UpdateNodepool builder with application/json body
func NewUpdateNodepoolRequest(server string, spaceId SpaceId, clusterId ClusterId, nodePoolName NodepoolName, body UpdateNodepoolJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateNodepoolRequestWithBody(server, spaceId, clusterId, nodePoolName, "application/json", bodyReader)
}

// NewUpdateNodepoolRequestWithBody generates requests for UpdateNodepool with any type of body
func NewUpdateNodepoolRequestWithBody(server string, spaceId SpaceId, clusterId ClusterId, nodePoolName NodepoolName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "nodePoolName", runtime.ParamLocationPath, nodePoolName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openshift/spaces/%s/clusters/%s/nodepools/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListOperationsRequest generates requests for ListOperations
func NewListOperationsRequest(server string, spaceId SpaceId, params *ListOperationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openshift/spaces/%s/operations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClusterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "clusterId", runtime.ParamLocationQuery, *params.ClusterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOperationRequest generates requests for GetOperation
func NewGetOperationRequest(server string, spaceId SpaceId, id IdUuid) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openshift/spaces/%s/operations/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListVersionsRequest generates requests for ListVersions
func NewListVersionsRequest(server string, spaceId SpaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openshift/spaces/%s/versions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteSpaceRequest generates requests for DeleteSpace
func NewDeleteSpaceRequest(server string, spaceId SpaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organisations/spaces/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSpaceByIdRequest generates requests for GetSpaceById
func NewGetSpaceByIdRequest(server string, spaceId SpaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organisations/spaces/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSpaceRequest calls the generic UpdateSpace builder with application/json body
func NewUpdateSpaceRequest(server string, spaceId SpaceId, body UpdateSpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSpaceRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewUpdateSpaceRequestWithBody generates requests for UpdateSpace with any type of body
func NewUpdateSpaceRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organisations/spaces/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListSpacesRequest calls the generic ListSpaces builder with application/json body
func NewListSpacesRequest(server string, organisationId OrganisationId, params *ListSpacesParams, body ListSpacesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListSpacesRequestWithBody(server, organisationId, params, "application/json", bodyReader)
}

// NewListSpacesRequestWithBody generates requests for ListSpaces with any type of body
func NewListSpacesRequestWithBody(server string, organisationId OrganisationId, params *ListSpacesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organisations/%s/spaces", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateSpaceRequest calls the generic CreateSpace builder with application/json body
func NewCreateSpaceRequest(server string, organisationId OrganisationId, body CreateSpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSpaceRequestWithBody(server, organisationId, "application/json", bodyReader)
}

// NewCreateSpaceRequestWithBody generates requests for CreateSpace with any type of body
func NewCreateSpaceRequestWithBody(server string, organisationId OrganisationId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organisations/%s/spaces", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// JsonWebKeysWithResponse request
	JsonWebKeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*JsonWebKeysResponse, error)

	// DiscoverOidcConfigurationWithResponse request
	DiscoverOidcConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DiscoverOidcConfigurationResponse, error)

	// GetWebAuthnJavaScriptWithResponse request
	GetWebAuthnJavaScriptWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWebAuthnJavaScriptResponse, error)

	// CreateAdminServiceAccountSpaceWithBodyWithResponse request with any body
	CreateAdminServiceAccountSpaceWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAdminServiceAccountSpaceResponse, error)

	CreateAdminServiceAccountSpaceWithResponse(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, body CreateAdminServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAdminServiceAccountSpaceResponse, error)

	// AuthorizeWithResponse request
	AuthorizeWithResponse(ctx context.Context, params *AuthorizeParams, reqEditors ...RequestEditorFn) (*AuthorizeResponse, error)

	// ConsentWithResponse request
	ConsentWithResponse(ctx context.Context, params *ConsentParams, reqEditors ...RequestEditorFn) (*ConsentResponse, error)

	// GetFlowErrorWithResponse request
	GetFlowErrorWithResponse(ctx context.Context, params *GetFlowErrorParams, reqEditors ...RequestEditorFn) (*GetFlowErrorResponse, error)

	// UpdateLoginFlowWithBodyWithResponse request with any body
	UpdateLoginFlowWithBodyWithResponse(ctx context.Context, params *UpdateLoginFlowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLoginFlowResponse, error)

	UpdateLoginFlowWithResponse(ctx context.Context, params *UpdateLoginFlowParams, body UpdateLoginFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLoginFlowResponse, error)

	UpdateLoginFlowWithFormdataBodyWithResponse(ctx context.Context, params *UpdateLoginFlowParams, body UpdateLoginFlowFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateLoginFlowResponse, error)

	// CreateNativeLoginFlowWithResponse request
	CreateNativeLoginFlowWithResponse(ctx context.Context, params *CreateNativeLoginFlowParams, reqEditors ...RequestEditorFn) (*CreateNativeLoginFlowResponse, error)

	// CreateBrowserLoginFlowWithResponse request
	CreateBrowserLoginFlowWithResponse(ctx context.Context, params *CreateBrowserLoginFlowParams, reqEditors ...RequestEditorFn) (*CreateBrowserLoginFlowResponse, error)

	// GetLoginFlowWithResponse request
	GetLoginFlowWithResponse(ctx context.Context, params *GetLoginFlowParams, reqEditors ...RequestEditorFn) (*GetLoginFlowResponse, error)

	// UpdateLogoutFlowWithResponse request
	UpdateLogoutFlowWithResponse(ctx context.Context, params *UpdateLogoutFlowParams, reqEditors ...RequestEditorFn) (*UpdateLogoutFlowResponse, error)

	// PerformNativeLogoutWithBodyWithResponse request with any body
	PerformNativeLogoutWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PerformNativeLogoutResponse, error)

	PerformNativeLogoutWithResponse(ctx context.Context, body PerformNativeLogoutJSONRequestBody, reqEditors ...RequestEditorFn) (*PerformNativeLogoutResponse, error)

	// CreateBrowserLogoutFlowWithResponse request
	CreateBrowserLogoutFlowWithResponse(ctx context.Context, params *CreateBrowserLogoutFlowParams, reqEditors ...RequestEditorFn) (*CreateBrowserLogoutFlowResponse, error)

	// InitRecoveryFlowWithResponse request
	InitRecoveryFlowWithResponse(ctx context.Context, params *InitRecoveryFlowParams, reqEditors ...RequestEditorFn) (*InitRecoveryFlowResponse, error)

	// UpdateRecoveryFlowWithBodyWithResponse request with any body
	UpdateRecoveryFlowWithBodyWithResponse(ctx context.Context, params *UpdateRecoveryFlowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRecoveryFlowResponse, error)

	UpdateRecoveryFlowWithResponse(ctx context.Context, params *UpdateRecoveryFlowParams, body UpdateRecoveryFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRecoveryFlowResponse, error)

	UpdateRecoveryFlowWithFormdataBodyWithResponse(ctx context.Context, params *UpdateRecoveryFlowParams, body UpdateRecoveryFlowFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateRecoveryFlowResponse, error)

	// CreateNativeRecoveryFlowWithResponse request
	CreateNativeRecoveryFlowWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CreateNativeRecoveryFlowResponse, error)

	// CreateBrowserRecoveryFlowWithResponse request
	CreateBrowserRecoveryFlowWithResponse(ctx context.Context, params *CreateBrowserRecoveryFlowParams, reqEditors ...RequestEditorFn) (*CreateBrowserRecoveryFlowResponse, error)

	// GetRecoveryFlowWithResponse request
	GetRecoveryFlowWithResponse(ctx context.Context, params *GetRecoveryFlowParams, reqEditors ...RequestEditorFn) (*GetRecoveryFlowResponse, error)

	// UpdateRegistrationFlowWithBodyWithResponse request with any body
	UpdateRegistrationFlowWithBodyWithResponse(ctx context.Context, params *UpdateRegistrationFlowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRegistrationFlowResponse, error)

	UpdateRegistrationFlowWithResponse(ctx context.Context, params *UpdateRegistrationFlowParams, body UpdateRegistrationFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRegistrationFlowResponse, error)

	UpdateRegistrationFlowWithFormdataBodyWithResponse(ctx context.Context, params *UpdateRegistrationFlowParams, body UpdateRegistrationFlowFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateRegistrationFlowResponse, error)

	// CreateNativeRegistrationFlowWithResponse request
	CreateNativeRegistrationFlowWithResponse(ctx context.Context, params *CreateNativeRegistrationFlowParams, reqEditors ...RequestEditorFn) (*CreateNativeRegistrationFlowResponse, error)

	// CreateBrowserRegistrationFlowWithResponse request
	CreateBrowserRegistrationFlowWithResponse(ctx context.Context, params *CreateBrowserRegistrationFlowParams, reqEditors ...RequestEditorFn) (*CreateBrowserRegistrationFlowResponse, error)

	// GetRegistrationFlowWithResponse request
	GetRegistrationFlowWithResponse(ctx context.Context, params *GetRegistrationFlowParams, reqEditors ...RequestEditorFn) (*GetRegistrationFlowResponse, error)

	// UpdateSettingsFloWithBodyWithResponse request with any body
	UpdateSettingsFloWithBodyWithResponse(ctx context.Context, params *UpdateSettingsFloParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSettingsFloResponse, error)

	UpdateSettingsFloWithResponse(ctx context.Context, params *UpdateSettingsFloParams, body UpdateSettingsFloJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSettingsFloResponse, error)

	UpdateSettingsFloWithFormdataBodyWithResponse(ctx context.Context, params *UpdateSettingsFloParams, body UpdateSettingsFloFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateSettingsFloResponse, error)

	// CreateNativeSettingsFlowWithResponse request
	CreateNativeSettingsFlowWithResponse(ctx context.Context, params *CreateNativeSettingsFlowParams, reqEditors ...RequestEditorFn) (*CreateNativeSettingsFlowResponse, error)

	// CreateBrowserSettingsFlowWithResponse request
	CreateBrowserSettingsFlowWithResponse(ctx context.Context, params *CreateBrowserSettingsFlowParams, reqEditors ...RequestEditorFn) (*CreateBrowserSettingsFlowResponse, error)

	// GetSettingsFlowWithResponse request
	GetSettingsFlowWithResponse(ctx context.Context, params *GetSettingsFlowParams, reqEditors ...RequestEditorFn) (*GetSettingsFlowResponse, error)

	// UpdateVerificationFlowWithBodyWithResponse request with any body
	UpdateVerificationFlowWithBodyWithResponse(ctx context.Context, params *UpdateVerificationFlowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVerificationFlowResponse, error)

	UpdateVerificationFlowWithResponse(ctx context.Context, params *UpdateVerificationFlowParams, body UpdateVerificationFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVerificationFlowResponse, error)

	UpdateVerificationFlowWithFormdataBodyWithResponse(ctx context.Context, params *UpdateVerificationFlowParams, body UpdateVerificationFlowFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateVerificationFlowResponse, error)

	// CreateNativeVerificationFlowWithResponse request
	CreateNativeVerificationFlowWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CreateNativeVerificationFlowResponse, error)

	// CreateBrowserVerificationFlowWithResponse request
	CreateBrowserVerificationFlowWithResponse(ctx context.Context, params *CreateBrowserVerificationFlowParams, reqEditors ...RequestEditorFn) (*CreateBrowserVerificationFlowResponse, error)

	// GetVerificationFlowWithResponse request
	GetVerificationFlowWithResponse(ctx context.Context, params *GetVerificationFlowParams, reqEditors ...RequestEditorFn) (*GetVerificationFlowResponse, error)

	// DisableMyOtherSessionsWithResponse request
	DisableMyOtherSessionsWithResponse(ctx context.Context, params *DisableMyOtherSessionsParams, reqEditors ...RequestEditorFn) (*DisableMyOtherSessionsResponse, error)

	// ListMySessionsWithResponse request
	ListMySessionsWithResponse(ctx context.Context, params *ListMySessionsParams, reqEditors ...RequestEditorFn) (*ListMySessionsResponse, error)

	// ExchangeSessionTokenWithResponse request
	ExchangeSessionTokenWithResponse(ctx context.Context, params *ExchangeSessionTokenParams, reqEditors ...RequestEditorFn) (*ExchangeSessionTokenResponse, error)

	// ToSessionWithResponse request
	ToSessionWithResponse(ctx context.Context, params *ToSessionParams, reqEditors ...RequestEditorFn) (*ToSessionResponse, error)

	// IntrospectWithBodyWithResponse request with any body
	IntrospectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IntrospectResponse, error)

	IntrospectWithFormdataBodyWithResponse(ctx context.Context, body IntrospectFormdataRequestBody, reqEditors ...RequestEditorFn) (*IntrospectResponse, error)

	// ListOrganisationsIdentityWithResponse request
	ListOrganisationsIdentityWithResponse(ctx context.Context, params *ListOrganisationsIdentityParams, reqEditors ...RequestEditorFn) (*ListOrganisationsIdentityResponse, error)

	// GetIAMGranularPolicyOrganisationWithResponse request
	GetIAMGranularPolicyOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, reqEditors ...RequestEditorFn) (*GetIAMGranularPolicyOrganisationResponse, error)

	// SetIAMGranularPolicyOrganisationWithBodyWithResponse request with any body
	SetIAMGranularPolicyOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetIAMGranularPolicyOrganisationResponse, error)

	SetIAMGranularPolicyOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, body SetIAMGranularPolicyOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*SetIAMGranularPolicyOrganisationResponse, error)

	// GetIAMPolicyOrganisationWithResponse request
	GetIAMPolicyOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, reqEditors ...RequestEditorFn) (*GetIAMPolicyOrganisationResponse, error)

	// SetIAMPolicyOrganisationWithBodyWithResponse request with any body
	SetIAMPolicyOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetIAMPolicyOrganisationResponse, error)

	SetIAMPolicyOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, body SetIAMPolicyOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*SetIAMPolicyOrganisationResponse, error)

	// ListPermissionsOrganisationWithResponse request
	ListPermissionsOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, params *ListPermissionsOrganisationParams, reqEditors ...RequestEditorFn) (*ListPermissionsOrganisationResponse, error)

	// GetPermissionOrganisationWithResponse request
	GetPermissionOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, permissionUuid PermissionUuid, reqEditors ...RequestEditorFn) (*GetPermissionOrganisationResponse, error)

	// ListRolesOrganisationWithResponse request
	ListRolesOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, params *ListRolesOrganisationParams, reqEditors ...RequestEditorFn) (*ListRolesOrganisationResponse, error)

	// CreateRoleOrganisationWithBodyWithResponse request with any body
	CreateRoleOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRoleOrganisationResponse, error)

	CreateRoleOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, body CreateRoleOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRoleOrganisationResponse, error)

	// DeleteRoleOrganisationWithResponse request
	DeleteRoleOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*DeleteRoleOrganisationResponse, error)

	// GetRoleOrganisationWithResponse request
	GetRoleOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*GetRoleOrganisationResponse, error)

	// UpdateRoleOrganisationWithBodyWithResponse request with any body
	UpdateRoleOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRoleOrganisationResponse, error)

	UpdateRoleOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, body UpdateRoleOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRoleOrganisationResponse, error)

	// RemoveRolePermissionsOrganisationWithBodyWithResponse request with any body
	RemoveRolePermissionsOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveRolePermissionsOrganisationResponse, error)

	RemoveRolePermissionsOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, body RemoveRolePermissionsOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveRolePermissionsOrganisationResponse, error)

	// GetRolePermissionsOrganisationWithResponse request
	GetRolePermissionsOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*GetRolePermissionsOrganisationResponse, error)

	// AddRolePermissionsOrganisationWithBodyWithResponse request with any body
	AddRolePermissionsOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddRolePermissionsOrganisationResponse, error)

	AddRolePermissionsOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, body AddRolePermissionsOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*AddRolePermissionsOrganisationResponse, error)

	// ListServiceAccountOrganisationWithBodyWithResponse request with any body
	ListServiceAccountOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, params *ListServiceAccountOrganisationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListServiceAccountOrganisationResponse, error)

	ListServiceAccountOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, params *ListServiceAccountOrganisationParams, body ListServiceAccountOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*ListServiceAccountOrganisationResponse, error)

	// CreateServiceAccountOrganisationWithBodyWithResponse request with any body
	CreateServiceAccountOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceAccountOrganisationResponse, error)

	CreateServiceAccountOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, body CreateServiceAccountOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceAccountOrganisationResponse, error)

	// DeleteServiceAccountOrganisationWithResponse request
	DeleteServiceAccountOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*DeleteServiceAccountOrganisationResponse, error)

	// GetServiceAccountOrganisationWithResponse request
	GetServiceAccountOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*GetServiceAccountOrganisationResponse, error)

	// UpdateServiceAccountOrganisationWithBodyWithResponse request with any body
	UpdateServiceAccountOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServiceAccountOrganisationResponse, error)

	UpdateServiceAccountOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, body UpdateServiceAccountOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServiceAccountOrganisationResponse, error)

	// GetACLServiceAccountOrganisationWithResponse request
	GetACLServiceAccountOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, params *GetACLServiceAccountOrganisationParams, reqEditors ...RequestEditorFn) (*GetACLServiceAccountOrganisationResponse, error)

	// DeleteACLServiceAccountOrganisationBulkWithBodyWithResponse request with any body
	DeleteACLServiceAccountOrganisationBulkWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteACLServiceAccountOrganisationBulkResponse, error)

	DeleteACLServiceAccountOrganisationBulkWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, body DeleteACLServiceAccountOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteACLServiceAccountOrganisationBulkResponse, error)

	// CreateACLServiceAccountOrganisationBulkWithBodyWithResponse request with any body
	CreateACLServiceAccountOrganisationBulkWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateACLServiceAccountOrganisationBulkResponse, error)

	CreateACLServiceAccountOrganisationBulkWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, body CreateACLServiceAccountOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateACLServiceAccountOrganisationBulkResponse, error)

	// ListSpacesOfServiceAccountWithResponse request
	ListSpacesOfServiceAccountWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, params *ListSpacesOfServiceAccountParams, reqEditors ...RequestEditorFn) (*ListSpacesOfServiceAccountResponse, error)

	// ListSpacesIdentityWithResponse request
	ListSpacesIdentityWithResponse(ctx context.Context, organisationId OrganisationId, params *ListSpacesIdentityParams, reqEditors ...RequestEditorFn) (*ListSpacesIdentityResponse, error)

	// ListUserOrganisationWithBodyWithResponse request with any body
	ListUserOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, params *ListUserOrganisationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListUserOrganisationResponse, error)

	ListUserOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, params *ListUserOrganisationParams, body ListUserOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*ListUserOrganisationResponse, error)

	// CreateUserOrganisationWithBodyWithResponse request with any body
	CreateUserOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserOrganisationResponse, error)

	CreateUserOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, body CreateUserOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserOrganisationResponse, error)

	// DeleteUserOrganisationWithResponse request
	DeleteUserOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, reqEditors ...RequestEditorFn) (*DeleteUserOrganisationResponse, error)

	// GetUserOrganisationWithResponse request
	GetUserOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, reqEditors ...RequestEditorFn) (*GetUserOrganisationResponse, error)

	// PatchUserStateOrganisationWithBodyWithResponse request with any body
	PatchUserStateOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchUserStateOrganisationResponse, error)

	PatchUserStateOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, body PatchUserStateOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchUserStateOrganisationResponse, error)

	// UpdateUserOrganisationWithBodyWithResponse request with any body
	UpdateUserOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserOrganisationResponse, error)

	UpdateUserOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, body UpdateUserOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserOrganisationResponse, error)

	// GetACLUserOrganisationWithResponse request
	GetACLUserOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, params *GetACLUserOrganisationParams, reqEditors ...RequestEditorFn) (*GetACLUserOrganisationResponse, error)

	// DeleteACLUserOrganisationBulkWithBodyWithResponse request with any body
	DeleteACLUserOrganisationBulkWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteACLUserOrganisationBulkResponse, error)

	DeleteACLUserOrganisationBulkWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, body DeleteACLUserOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteACLUserOrganisationBulkResponse, error)

	// CreateACLUserOrganisationBulkWithBodyWithResponse request with any body
	CreateACLUserOrganisationBulkWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateACLUserOrganisationBulkResponse, error)

	CreateACLUserOrganisationBulkWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, body CreateACLUserOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateACLUserOrganisationBulkResponse, error)

	// RecoverUserOrganisationWithResponse request
	RecoverUserOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, reqEditors ...RequestEditorFn) (*RecoverUserOrganisationResponse, error)

	// ListSpacesOfUserWithResponse request
	ListSpacesOfUserWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, params *ListSpacesOfUserParams, reqEditors ...RequestEditorFn) (*ListSpacesOfUserResponse, error)

	// RevokeWithBodyWithResponse request with any body
	RevokeWithBodyWithResponse(ctx context.Context, params *RevokeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevokeResponse, error)

	RevokeWithFormdataBodyWithResponse(ctx context.Context, params *RevokeParams, body RevokeFormdataRequestBody, reqEditors ...RequestEditorFn) (*RevokeResponse, error)

	// GetIAMGranularPolicySpaceWithResponse request
	GetIAMGranularPolicySpaceWithResponse(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, reqEditors ...RequestEditorFn) (*GetIAMGranularPolicySpaceResponse, error)

	// SetIAMGranularPolicySpaceWithBodyWithResponse request with any body
	SetIAMGranularPolicySpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetIAMGranularPolicySpaceResponse, error)

	SetIAMGranularPolicySpaceWithResponse(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, body SetIAMGranularPolicySpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*SetIAMGranularPolicySpaceResponse, error)

	// GetIAMPolicySpaceWithResponse request
	GetIAMPolicySpaceWithResponse(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, reqEditors ...RequestEditorFn) (*GetIAMPolicySpaceResponse, error)

	// SetIAMPolicySpaceWithBodyWithResponse request with any body
	SetIAMPolicySpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetIAMPolicySpaceResponse, error)

	SetIAMPolicySpaceWithResponse(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, body SetIAMPolicySpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*SetIAMPolicySpaceResponse, error)

	// ListPermissionsSpaceWithResponse request
	ListPermissionsSpaceWithResponse(ctx context.Context, spaceId SpaceId, params *ListPermissionsSpaceParams, reqEditors ...RequestEditorFn) (*ListPermissionsSpaceResponse, error)

	// GetPermissionSpaceWithResponse request
	GetPermissionSpaceWithResponse(ctx context.Context, spaceId SpaceId, permissionUuid PermissionUuid, reqEditors ...RequestEditorFn) (*GetPermissionSpaceResponse, error)

	// ListRolesSpaceWithResponse request
	ListRolesSpaceWithResponse(ctx context.Context, spaceId SpaceId, params *ListRolesSpaceParams, reqEditors ...RequestEditorFn) (*ListRolesSpaceResponse, error)

	// CreateRoleSpaceWithBodyWithResponse request with any body
	CreateRoleSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRoleSpaceResponse, error)

	CreateRoleSpaceWithResponse(ctx context.Context, spaceId SpaceId, body CreateRoleSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRoleSpaceResponse, error)

	// DeleteRoleSpaceWithResponse request
	DeleteRoleSpaceWithResponse(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*DeleteRoleSpaceResponse, error)

	// GetRoleSpaceWithResponse request
	GetRoleSpaceWithResponse(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*GetRoleSpaceResponse, error)

	// UpdateRoleSpaceWithBodyWithResponse request with any body
	UpdateRoleSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRoleSpaceResponse, error)

	UpdateRoleSpaceWithResponse(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, body UpdateRoleSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRoleSpaceResponse, error)

	// RemoveRolePermissionsSpaceWithBodyWithResponse request with any body
	RemoveRolePermissionsSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveRolePermissionsSpaceResponse, error)

	RemoveRolePermissionsSpaceWithResponse(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, body RemoveRolePermissionsSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveRolePermissionsSpaceResponse, error)

	// GetRolePermissionsSpaceWithResponse request
	GetRolePermissionsSpaceWithResponse(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*GetRolePermissionsSpaceResponse, error)

	// AddRolePermissionsSpaceWithBodyWithResponse request with any body
	AddRolePermissionsSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddRolePermissionsSpaceResponse, error)

	AddRolePermissionsSpaceWithResponse(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, body AddRolePermissionsSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*AddRolePermissionsSpaceResponse, error)

	// ListServiceAccountSpaceWithBodyWithResponse request with any body
	ListServiceAccountSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, params *ListServiceAccountSpaceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListServiceAccountSpaceResponse, error)

	ListServiceAccountSpaceWithResponse(ctx context.Context, spaceId SpaceId, params *ListServiceAccountSpaceParams, body ListServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*ListServiceAccountSpaceResponse, error)

	// CreateServiceAccountSpaceWithBodyWithResponse request with any body
	CreateServiceAccountSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceAccountSpaceResponse, error)

	CreateServiceAccountSpaceWithResponse(ctx context.Context, spaceId SpaceId, body CreateServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceAccountSpaceResponse, error)

	// DeleteServiceAccountSpaceWithResponse request
	DeleteServiceAccountSpaceWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*DeleteServiceAccountSpaceResponse, error)

	// GetServiceAccountSpaceWithResponse request
	GetServiceAccountSpaceWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*GetServiceAccountSpaceResponse, error)

	// AssignServiceAccountToSpaceWithResponse request
	AssignServiceAccountToSpaceWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*AssignServiceAccountToSpaceResponse, error)

	// UpdateServiceAccountSpaceWithBodyWithResponse request with any body
	UpdateServiceAccountSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServiceAccountSpaceResponse, error)

	UpdateServiceAccountSpaceWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, body UpdateServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServiceAccountSpaceResponse, error)

	// GetACLServiceAccountSpaceWithResponse request
	GetACLServiceAccountSpaceWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, params *GetACLServiceAccountSpaceParams, reqEditors ...RequestEditorFn) (*GetACLServiceAccountSpaceResponse, error)

	// DeleteACLServiceAccountSpaceBulkWithBodyWithResponse request with any body
	DeleteACLServiceAccountSpaceBulkWithBodyWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteACLServiceAccountSpaceBulkResponse, error)

	DeleteACLServiceAccountSpaceBulkWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, body DeleteACLServiceAccountSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteACLServiceAccountSpaceBulkResponse, error)

	// CreateACLServiceAccountSpaceBulkWithBodyWithResponse request with any body
	CreateACLServiceAccountSpaceBulkWithBodyWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateACLServiceAccountSpaceBulkResponse, error)

	CreateACLServiceAccountSpaceBulkWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, body CreateACLServiceAccountSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateACLServiceAccountSpaceBulkResponse, error)

	// ListUserSpaceWithBodyWithResponse request with any body
	ListUserSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, params *ListUserSpaceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListUserSpaceResponse, error)

	ListUserSpaceWithResponse(ctx context.Context, spaceId SpaceId, params *ListUserSpaceParams, body ListUserSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*ListUserSpaceResponse, error)

	// CreateUserSpaceWithBodyWithResponse request with any body
	CreateUserSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserSpaceResponse, error)

	CreateUserSpaceWithResponse(ctx context.Context, spaceId SpaceId, body CreateUserSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserSpaceResponse, error)

	// DeleteUserSpaceWithResponse request
	DeleteUserSpaceWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*DeleteUserSpaceResponse, error)

	// GetUserSpaceWithResponse request
	GetUserSpaceWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*GetUserSpaceResponse, error)

	// PatchUserStateSpaceWithBodyWithResponse request with any body
	PatchUserStateSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchUserStateSpaceResponse, error)

	PatchUserStateSpaceWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, body PatchUserStateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchUserStateSpaceResponse, error)

	// AssignUserToSpaceWithResponse request
	AssignUserToSpaceWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*AssignUserToSpaceResponse, error)

	// UpdateUserSpaceWithBodyWithResponse request with any body
	UpdateUserSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserSpaceResponse, error)

	UpdateUserSpaceWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, body UpdateUserSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserSpaceResponse, error)

	// GetACLUserSpaceWithResponse request
	GetACLUserSpaceWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, params *GetACLUserSpaceParams, reqEditors ...RequestEditorFn) (*GetACLUserSpaceResponse, error)

	// DeleteACLUserSpaceBulkWithBodyWithResponse request with any body
	DeleteACLUserSpaceBulkWithBodyWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteACLUserSpaceBulkResponse, error)

	DeleteACLUserSpaceBulkWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, body DeleteACLUserSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteACLUserSpaceBulkResponse, error)

	// CreateACLUserSpaceBulkWithBodyWithResponse request with any body
	CreateACLUserSpaceBulkWithBodyWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateACLUserSpaceBulkResponse, error)

	CreateACLUserSpaceBulkWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, body CreateACLUserSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateACLUserSpaceBulkResponse, error)

	// RecoverUserSpaceWithResponse request
	RecoverUserSpaceWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*RecoverUserSpaceResponse, error)

	// TokenWithBodyWithResponse request with any body
	TokenWithBodyWithResponse(ctx context.Context, params *TokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TokenResponse, error)

	TokenWithFormdataBodyWithResponse(ctx context.Context, params *TokenParams, body TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*TokenResponse, error)

	// GetUserInfoWithResponse request
	GetUserInfoWithResponse(ctx context.Context, params *GetUserInfoParams, reqEditors ...RequestEditorFn) (*GetUserInfoResponse, error)

	// ListClustersWithResponse request
	ListClustersWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*ListClustersResponse, error)

	// CreateClusterWithBodyWithResponse request with any body
	CreateClusterWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error)

	CreateClusterWithResponse(ctx context.Context, spaceId SpaceId, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error)

	// DeleteClusterWithResponse request
	DeleteClusterWithResponse(ctx context.Context, spaceId SpaceId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*DeleteClusterResponse, error)

	// GetClusterWithResponse request
	GetClusterWithResponse(ctx context.Context, spaceId SpaceId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*GetClusterResponse, error)

	// UpdateClusterWithBodyWithResponse request with any body
	UpdateClusterWithBodyWithResponse(ctx context.Context, spaceId SpaceId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error)

	UpdateClusterWithResponse(ctx context.Context, spaceId SpaceId, clusterId ClusterId, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error)

	// ListNodepoolsWithResponse request
	ListNodepoolsWithResponse(ctx context.Context, spaceId SpaceId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*ListNodepoolsResponse, error)

	// CreateNodePoolWithBodyWithResponse request with any body
	CreateNodePoolWithBodyWithResponse(ctx context.Context, spaceId SpaceId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNodePoolResponse, error)

	CreateNodePoolWithResponse(ctx context.Context, spaceId SpaceId, clusterId ClusterId, body CreateNodePoolJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNodePoolResponse, error)

	// DeleteNodePoolWithResponse request
	DeleteNodePoolWithResponse(ctx context.Context, spaceId SpaceId, clusterId ClusterId, nodePoolName NodepoolName, reqEditors ...RequestEditorFn) (*DeleteNodePoolResponse, error)

	// UpdateNodepoolWithBodyWithResponse request with any body
	UpdateNodepoolWithBodyWithResponse(ctx context.Context, spaceId SpaceId, clusterId ClusterId, nodePoolName NodepoolName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNodepoolResponse, error)

	UpdateNodepoolWithResponse(ctx context.Context, spaceId SpaceId, clusterId ClusterId, nodePoolName NodepoolName, body UpdateNodepoolJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNodepoolResponse, error)

	// ListOperationsWithResponse request
	ListOperationsWithResponse(ctx context.Context, spaceId SpaceId, params *ListOperationsParams, reqEditors ...RequestEditorFn) (*ListOperationsResponse, error)

	// GetOperationWithResponse request
	GetOperationWithResponse(ctx context.Context, spaceId SpaceId, id IdUuid, reqEditors ...RequestEditorFn) (*GetOperationResponse, error)

	// ListVersionsWithResponse request
	ListVersionsWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*ListVersionsResponse, error)

	// DeleteSpaceWithResponse request
	DeleteSpaceWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*DeleteSpaceResponse, error)

	// GetSpaceByIdWithResponse request
	GetSpaceByIdWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*GetSpaceByIdResponse, error)

	// UpdateSpaceWithBodyWithResponse request with any body
	UpdateSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSpaceResponse, error)

	UpdateSpaceWithResponse(ctx context.Context, spaceId SpaceId, body UpdateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSpaceResponse, error)

	// ListSpacesWithBodyWithResponse request with any body
	ListSpacesWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, params *ListSpacesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListSpacesResponse, error)

	ListSpacesWithResponse(ctx context.Context, organisationId OrganisationId, params *ListSpacesParams, body ListSpacesJSONRequestBody, reqEditors ...RequestEditorFn) (*ListSpacesResponse, error)

	// CreateSpaceWithBodyWithResponse request with any body
	CreateSpaceWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpaceResponse, error)

	CreateSpaceWithResponse(ctx context.Context, organisationId OrganisationId, body CreateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpaceResponse, error)
}

type JsonWebKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JsonWebKeysResponseSchema
	JSON400      *ErrorOauth2
	JSON401      *ErrorOauth2
}

// Status returns HTTPResponse.Status
func (r JsonWebKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JsonWebKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DiscoverOidcConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OidcConfiguration
	JSONDefault  *ErrorOauth2
}

// Status returns HTTPResponse.Status
func (r DiscoverOidcConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DiscoverOidcConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWebAuthnJavaScriptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebAuthnJavaScriptResponseSchema
}

// Status returns HTTPResponse.Status
func (r GetWebAuthnJavaScriptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWebAuthnJavaScriptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAdminServiceAccountSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateServiceAccount201ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateAdminServiceAccountSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAdminServiceAccountSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthorizeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorOauth2
	JSON401      *ErrorOauth2
	JSON403      *ErrorOauth2
	JSON500      *ErrorOauth2
}

// Status returns HTTPResponse.Status
func (r AuthorizeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthorizeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConsentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ConsentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConsentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFlowErrorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FlowError
	JSON403      *ErrorGeneric
	JSON404      *ErrorGeneric
	JSON500      *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r GetFlowErrorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFlowErrorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateLoginFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessfulNativeLogin
	JSON400      *LoginFlow
	JSON410      *ErrorGeneric
	JSON422      *ErrorBrowserLocationChangeRequired
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r UpdateLoginFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateLoginFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNativeLoginFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoginFlow
	JSON400      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r CreateNativeLoginFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNativeLoginFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBrowserLoginFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoginFlow
	JSON400      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r CreateBrowserLoginFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBrowserLoginFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLoginFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoginFlow
	JSON403      *ErrorGeneric
	JSON404      *ErrorGeneric
	JSON410      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r GetLoginFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLoginFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateLogoutFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r UpdateLogoutFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateLogoutFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PerformNativeLogoutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r PerformNativeLogoutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PerformNativeLogoutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBrowserLogoutFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogoutFlow
	JSON400      *ErrorGeneric
	JSON401      *ErrorGeneric
	JSON500      *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r CreateBrowserLogoutFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBrowserLogoutFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InitRecoveryFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecoveryFlow
	JSON400      *RecoveryFlow
	JSON410      *ErrorGeneric
	JSON422      *ErrorBrowserLocationChangeRequired
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r InitRecoveryFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InitRecoveryFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRecoveryFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecoveryFlow
	JSON400      *RecoveryFlow
	JSON410      *ErrorGeneric
	JSON422      *ErrorBrowserLocationChangeRequired
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r UpdateRecoveryFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRecoveryFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNativeRecoveryFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecoveryFlow
	JSON400      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r CreateNativeRecoveryFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNativeRecoveryFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBrowserRecoveryFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecoveryFlow
	JSON400      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r CreateBrowserRecoveryFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBrowserRecoveryFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRecoveryFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecoveryFlow
	JSON404      *ErrorGeneric
	JSON410      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r GetRecoveryFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRecoveryFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRegistrationFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessfulNativeRegistration
	JSON400      *RegistrationFlow
	JSON410      *ErrorGeneric
	JSON422      *ErrorBrowserLocationChangeRequired
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r UpdateRegistrationFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRegistrationFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNativeRegistrationFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RegistrationFlow
	JSON400      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r CreateNativeRegistrationFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNativeRegistrationFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBrowserRegistrationFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RegistrationFlow
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r CreateBrowserRegistrationFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBrowserRegistrationFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRegistrationFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RegistrationFlow
	JSON403      *ErrorGeneric
	JSON404      *ErrorGeneric
	JSON410      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r GetRegistrationFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRegistrationFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSettingsFloResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SettingsFlow
	JSON400      *SettingsFlow
	JSON401      *ErrorGeneric
	JSON403      *ErrorGeneric
	JSON410      *ErrorGeneric
	JSON422      *ErrorBrowserLocationChangeRequired
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r UpdateSettingsFloResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSettingsFloResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNativeSettingsFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SettingsFlow
	JSON400      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r CreateNativeSettingsFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNativeSettingsFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBrowserSettingsFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SettingsFlow
	JSON400      *ErrorGeneric
	JSON401      *ErrorGeneric
	JSON403      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r CreateBrowserSettingsFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBrowserSettingsFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSettingsFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SettingsFlow
	JSON401      *ErrorGeneric
	JSON403      *ErrorGeneric
	JSON404      *ErrorGeneric
	JSON410      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r GetSettingsFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSettingsFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVerificationFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VerificationFlow
	JSON400      *VerificationFlow
	JSON410      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r UpdateVerificationFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVerificationFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNativeVerificationFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VerificationFlow
	JSON400      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r CreateNativeVerificationFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNativeVerificationFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBrowserVerificationFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VerificationFlow
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r CreateBrowserVerificationFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBrowserVerificationFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVerificationFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VerificationFlow
	JSON403      *ErrorGeneric
	JSON404      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r GetVerificationFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVerificationFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DisableMyOtherSessionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteMySessionsCount
	JSON400      *ErrorGeneric
	JSON401      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r DisableMyOtherSessionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DisableMyOtherSessionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMySessionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListMySessionsResponseSchema
	JSON400      *ErrorGeneric
	JSON401      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r ListMySessionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMySessionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExchangeSessionTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessfulNativeLogin
	JSON403      *ErrorGeneric
	JSON404      *ErrorGeneric
	JSON410      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r ExchangeSessionTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExchangeSessionTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ToSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Session
	JSON401      *ErrorGeneric
	JSON403      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r ToSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ToSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IntrospectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IntrospectResponseSchema
	JSON500      *ErrorOauth2
}

// Status returns HTTPResponse.Status
func (r IntrospectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IntrospectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListOrganisationsIdentityResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListUserOrganisations200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ListOrganisationsIdentityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListOrganisationsIdentityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIAMGranularPolicyOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetIAMGranularPolicy200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetIAMGranularPolicyOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIAMGranularPolicyOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetIAMGranularPolicyOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r SetIAMGranularPolicyOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetIAMGranularPolicyOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIAMPolicyOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetIAMPolicy200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetIAMPolicyOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIAMPolicyOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetIAMPolicyOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r SetIAMPolicyOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetIAMPolicyOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPermissionsOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListPermissions200ResponseSchema
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ListPermissionsOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPermissionsOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPermissionOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetPermission200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetPermissionOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPermissionOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRolesOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListRoles200ResponseSchema
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ListRolesOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRolesOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRoleOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *CreateRole200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateRoleOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRoleOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRoleOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteRoleOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRoleOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRoleOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetRole200ResponseSchema
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetRoleOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRoleOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRoleOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateRoleOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRoleOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveRolePermissionsOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r RemoveRolePermissionsOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveRolePermissionsOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRolePermissionsOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetRolePermissions200ResponseSchema
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetRolePermissionsOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRolePermissionsOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddRolePermissionsOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r AddRolePermissionsOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddRolePermissionsOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListServiceAccountOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListServiceAccount200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ListServiceAccountOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServiceAccountOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServiceAccountOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateServiceAccount201ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateServiceAccountOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServiceAccountOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServiceAccountOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteServiceAccountOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServiceAccountOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceAccountOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetServiceAccount200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetServiceAccountOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceAccountOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateServiceAccountOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateServiceAccount200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateServiceAccountOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateServiceAccountOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetACLServiceAccountOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetACL200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetACLServiceAccountOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetACLServiceAccountOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteACLServiceAccountOrganisationBulkResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteACLServiceAccountOrganisationBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteACLServiceAccountOrganisationBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateACLServiceAccountOrganisationBulkResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateACLServiceAccountOrganisationBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateACLServiceAccountOrganisationBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSpacesOfServiceAccountResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListSpacesServiceAccount200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ListSpacesOfServiceAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSpacesOfServiceAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSpacesIdentityResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListSpacesIdentity200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ListSpacesIdentityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSpacesIdentityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListUser200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ListUserOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateUser201ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateUserOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteUserOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetUser200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetUserOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchUserStateOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *PatchUserState200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchUserStateOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchUserStateOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateUser200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateUserOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetACLUserOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetACL200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetACLUserOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetACLUserOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteACLUserOrganisationBulkResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteACLUserOrganisationBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteACLUserOrganisationBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateACLUserOrganisationBulkResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateACLUserOrganisationBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateACLUserOrganisationBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RecoverUserOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *RecoverUser200ResponseSchema
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r RecoverUserOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RecoverUserOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSpacesOfUserResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListSpacesUser200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ListSpacesOfUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSpacesOfUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevokeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorOauth2
	JSON401      *ErrorOauth2
}

// Status returns HTTPResponse.Status
func (r RevokeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevokeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIAMGranularPolicySpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetIAMGranularPolicy200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetIAMGranularPolicySpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIAMGranularPolicySpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetIAMGranularPolicySpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r SetIAMGranularPolicySpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetIAMGranularPolicySpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIAMPolicySpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetIAMPolicy200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetIAMPolicySpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIAMPolicySpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetIAMPolicySpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r SetIAMPolicySpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetIAMPolicySpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPermissionsSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListPermissions200ResponseSchema
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ListPermissionsSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPermissionsSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPermissionSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetPermission200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetPermissionSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPermissionSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRolesSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListRoles200ResponseSchema
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ListRolesSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRolesSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRoleSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *CreateRole200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateRoleSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRoleSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRoleSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteRoleSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRoleSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRoleSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetRole200ResponseSchema
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetRoleSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRoleSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRoleSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateRoleSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRoleSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveRolePermissionsSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r RemoveRolePermissionsSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveRolePermissionsSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRolePermissionsSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetRolePermissions200ResponseSchema
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetRolePermissionsSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRolePermissionsSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddRolePermissionsSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r AddRolePermissionsSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddRolePermissionsSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListServiceAccountSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListServiceAccount200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ListServiceAccountSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServiceAccountSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServiceAccountSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateServiceAccount201ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateServiceAccountSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServiceAccountSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServiceAccountSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteServiceAccountSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServiceAccountSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceAccountSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetServiceAccount200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetServiceAccountSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceAccountSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignServiceAccountToSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r AssignServiceAccountToSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignServiceAccountToSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateServiceAccountSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateServiceAccount200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateServiceAccountSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateServiceAccountSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetACLServiceAccountSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetACL200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetACLServiceAccountSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetACLServiceAccountSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteACLServiceAccountSpaceBulkResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteACLServiceAccountSpaceBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteACLServiceAccountSpaceBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateACLServiceAccountSpaceBulkResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateACLServiceAccountSpaceBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateACLServiceAccountSpaceBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListUser200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ListUserSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateUser201ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateUserSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteUserSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetUser200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetUserSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchUserStateSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *PatchUserState200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchUserStateSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchUserStateSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignUserToSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r AssignUserToSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignUserToSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateUser200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateUserSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetACLUserSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetACL200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetACLUserSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetACLUserSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteACLUserSpaceBulkResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteACLUserSpaceBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteACLUserSpaceBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateACLUserSpaceBulkResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateACLUserSpaceBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateACLUserSpaceBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RecoverUserSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *RecoverUser200ResponseSchema
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r RecoverUserSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RecoverUserSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenResponseSchema
	JSON400      *ErrorOauth2
	JSON401      *ErrorOauth2
	JSON500      *ErrorOauth2
}

// Status returns HTTPResponse.Status
func (r TokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetUserInfo200ResponseSchema
	JSONDefault  *ErrorOauth2
}

// Status returns HTTPResponse.Status
func (r GetUserInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListClustersResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ClustersResponseSchema
	ApplicationproblemJSON400 *Error400Schema
	ApplicationproblemJSON500 *Error500Schema
}

// Status returns HTTPResponse.Status
func (r ListClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClusterResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *ClusterCreateResponseSchema
	ApplicationproblemJSON400 *Error400Schema
	ApplicationproblemJSON500 *Error500Schema
}

// Status returns HTTPResponse.Status
func (r CreateClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClusterResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON202                   *ClusterDeleteResponseSchema
	ApplicationproblemJSON400 *Error400Schema
	ApplicationproblemJSON404 *Error404Schema
	ApplicationproblemJSON500 *Error500Schema
}

// Status returns HTTPResponse.Status
func (r DeleteClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ClusterGetResponseSchema
	ApplicationproblemJSON400 *Error400Schema
	ApplicationproblemJSON404 *Error404Schema
	ApplicationproblemJSON500 *Error500Schema
}

// Status returns HTTPResponse.Status
func (r GetClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateClusterResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ClusterGetResponseSchema
	ApplicationproblemJSON400 *Error400Schema
	ApplicationproblemJSON404 *Error404Schema
	ApplicationproblemJSON500 *Error500Schema
}

// Status returns HTTPResponse.Status
func (r UpdateClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListNodepoolsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *NodepoolsResponseSchema
	ApplicationproblemJSON400 *Error400Schema
	ApplicationproblemJSON500 *Error500Schema
}

// Status returns HTTPResponse.Status
func (r ListNodepoolsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListNodepoolsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNodePoolResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *NodepoolCreateResponseSchema
	ApplicationproblemJSON400 *Error400Schema
	ApplicationproblemJSON500 *Error500Schema
}

// Status returns HTTPResponse.Status
func (r CreateNodePoolResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNodePoolResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNodePoolResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON202                   *NodepoolDeleteResponseSchema
	ApplicationproblemJSON400 *Error400Schema
	ApplicationproblemJSON404 *Error404Schema
	ApplicationproblemJSON500 *Error500Schema
}

// Status returns HTTPResponse.Status
func (r DeleteNodePoolResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNodePoolResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateNodepoolResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON202                   *UpdateNodeCountResponseSchema
	ApplicationproblemJSON400 *Error400Schema
	ApplicationproblemJSON404 *Error404Schema
	ApplicationproblemJSON500 *Error500Schema
}

// Status returns HTTPResponse.Status
func (r UpdateNodepoolResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateNodepoolResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListOperationsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *OperationsResponseSchema
	ApplicationproblemJSON400 *Error400Schema
	ApplicationproblemJSON500 *Error500Schema
}

// Status returns HTTPResponse.Status
func (r ListOperationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListOperationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOperationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *OperationResponseSchema
	ApplicationproblemJSON400 *Error400Schema
	ApplicationproblemJSON404 *Error404Schema
	ApplicationproblemJSON500 *Error500Schema
}

// Status returns HTTPResponse.Status
func (r GetOperationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOperationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListVersionsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *VersionsResponseSchema
	ApplicationproblemJSON400 *Error400Schema
	ApplicationproblemJSON500 *Error500Schema
}

// Status returns HTTPResponse.Status
func (r ListVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpaceByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetSpaceById200ResponseSchema
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSpaceByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpaceByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSpacesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListSpaces200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ListSpacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSpacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *CreateSpace200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// JsonWebKeysWithResponse request returning *JsonWebKeysResponse
func (c *ClientWithResponses) JsonWebKeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*JsonWebKeysResponse, error) {
	rsp, err := c.JsonWebKeys(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJsonWebKeysResponse(rsp)
}

// DiscoverOidcConfigurationWithResponse request returning *DiscoverOidcConfigurationResponse
func (c *ClientWithResponses) DiscoverOidcConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DiscoverOidcConfigurationResponse, error) {
	rsp, err := c.DiscoverOidcConfiguration(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDiscoverOidcConfigurationResponse(rsp)
}

// GetWebAuthnJavaScriptWithResponse request returning *GetWebAuthnJavaScriptResponse
func (c *ClientWithResponses) GetWebAuthnJavaScriptWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWebAuthnJavaScriptResponse, error) {
	rsp, err := c.GetWebAuthnJavaScript(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebAuthnJavaScriptResponse(rsp)
}

// CreateAdminServiceAccountSpaceWithBodyWithResponse request with arbitrary body returning *CreateAdminServiceAccountSpaceResponse
func (c *ClientWithResponses) CreateAdminServiceAccountSpaceWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAdminServiceAccountSpaceResponse, error) {
	rsp, err := c.CreateAdminServiceAccountSpaceWithBody(ctx, organisationId, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAdminServiceAccountSpaceResponse(rsp)
}

func (c *ClientWithResponses) CreateAdminServiceAccountSpaceWithResponse(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, body CreateAdminServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAdminServiceAccountSpaceResponse, error) {
	rsp, err := c.CreateAdminServiceAccountSpace(ctx, organisationId, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAdminServiceAccountSpaceResponse(rsp)
}

// AuthorizeWithResponse request returning *AuthorizeResponse
func (c *ClientWithResponses) AuthorizeWithResponse(ctx context.Context, params *AuthorizeParams, reqEditors ...RequestEditorFn) (*AuthorizeResponse, error) {
	rsp, err := c.Authorize(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthorizeResponse(rsp)
}

// ConsentWithResponse request returning *ConsentResponse
func (c *ClientWithResponses) ConsentWithResponse(ctx context.Context, params *ConsentParams, reqEditors ...RequestEditorFn) (*ConsentResponse, error) {
	rsp, err := c.Consent(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConsentResponse(rsp)
}

// GetFlowErrorWithResponse request returning *GetFlowErrorResponse
func (c *ClientWithResponses) GetFlowErrorWithResponse(ctx context.Context, params *GetFlowErrorParams, reqEditors ...RequestEditorFn) (*GetFlowErrorResponse, error) {
	rsp, err := c.GetFlowError(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFlowErrorResponse(rsp)
}

// UpdateLoginFlowWithBodyWithResponse request with arbitrary body returning *UpdateLoginFlowResponse
func (c *ClientWithResponses) UpdateLoginFlowWithBodyWithResponse(ctx context.Context, params *UpdateLoginFlowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLoginFlowResponse, error) {
	rsp, err := c.UpdateLoginFlowWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLoginFlowResponse(rsp)
}

func (c *ClientWithResponses) UpdateLoginFlowWithResponse(ctx context.Context, params *UpdateLoginFlowParams, body UpdateLoginFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLoginFlowResponse, error) {
	rsp, err := c.UpdateLoginFlow(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLoginFlowResponse(rsp)
}

func (c *ClientWithResponses) UpdateLoginFlowWithFormdataBodyWithResponse(ctx context.Context, params *UpdateLoginFlowParams, body UpdateLoginFlowFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateLoginFlowResponse, error) {
	rsp, err := c.UpdateLoginFlowWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLoginFlowResponse(rsp)
}

// CreateNativeLoginFlowWithResponse request returning *CreateNativeLoginFlowResponse
func (c *ClientWithResponses) CreateNativeLoginFlowWithResponse(ctx context.Context, params *CreateNativeLoginFlowParams, reqEditors ...RequestEditorFn) (*CreateNativeLoginFlowResponse, error) {
	rsp, err := c.CreateNativeLoginFlow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNativeLoginFlowResponse(rsp)
}

// CreateBrowserLoginFlowWithResponse request returning *CreateBrowserLoginFlowResponse
func (c *ClientWithResponses) CreateBrowserLoginFlowWithResponse(ctx context.Context, params *CreateBrowserLoginFlowParams, reqEditors ...RequestEditorFn) (*CreateBrowserLoginFlowResponse, error) {
	rsp, err := c.CreateBrowserLoginFlow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBrowserLoginFlowResponse(rsp)
}

// GetLoginFlowWithResponse request returning *GetLoginFlowResponse
func (c *ClientWithResponses) GetLoginFlowWithResponse(ctx context.Context, params *GetLoginFlowParams, reqEditors ...RequestEditorFn) (*GetLoginFlowResponse, error) {
	rsp, err := c.GetLoginFlow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLoginFlowResponse(rsp)
}

// UpdateLogoutFlowWithResponse request returning *UpdateLogoutFlowResponse
func (c *ClientWithResponses) UpdateLogoutFlowWithResponse(ctx context.Context, params *UpdateLogoutFlowParams, reqEditors ...RequestEditorFn) (*UpdateLogoutFlowResponse, error) {
	rsp, err := c.UpdateLogoutFlow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLogoutFlowResponse(rsp)
}

// PerformNativeLogoutWithBodyWithResponse request with arbitrary body returning *PerformNativeLogoutResponse
func (c *ClientWithResponses) PerformNativeLogoutWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PerformNativeLogoutResponse, error) {
	rsp, err := c.PerformNativeLogoutWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePerformNativeLogoutResponse(rsp)
}

func (c *ClientWithResponses) PerformNativeLogoutWithResponse(ctx context.Context, body PerformNativeLogoutJSONRequestBody, reqEditors ...RequestEditorFn) (*PerformNativeLogoutResponse, error) {
	rsp, err := c.PerformNativeLogout(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePerformNativeLogoutResponse(rsp)
}

// CreateBrowserLogoutFlowWithResponse request returning *CreateBrowserLogoutFlowResponse
func (c *ClientWithResponses) CreateBrowserLogoutFlowWithResponse(ctx context.Context, params *CreateBrowserLogoutFlowParams, reqEditors ...RequestEditorFn) (*CreateBrowserLogoutFlowResponse, error) {
	rsp, err := c.CreateBrowserLogoutFlow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBrowserLogoutFlowResponse(rsp)
}

// InitRecoveryFlowWithResponse request returning *InitRecoveryFlowResponse
func (c *ClientWithResponses) InitRecoveryFlowWithResponse(ctx context.Context, params *InitRecoveryFlowParams, reqEditors ...RequestEditorFn) (*InitRecoveryFlowResponse, error) {
	rsp, err := c.InitRecoveryFlow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInitRecoveryFlowResponse(rsp)
}

// UpdateRecoveryFlowWithBodyWithResponse request with arbitrary body returning *UpdateRecoveryFlowResponse
func (c *ClientWithResponses) UpdateRecoveryFlowWithBodyWithResponse(ctx context.Context, params *UpdateRecoveryFlowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRecoveryFlowResponse, error) {
	rsp, err := c.UpdateRecoveryFlowWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRecoveryFlowResponse(rsp)
}

func (c *ClientWithResponses) UpdateRecoveryFlowWithResponse(ctx context.Context, params *UpdateRecoveryFlowParams, body UpdateRecoveryFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRecoveryFlowResponse, error) {
	rsp, err := c.UpdateRecoveryFlow(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRecoveryFlowResponse(rsp)
}

func (c *ClientWithResponses) UpdateRecoveryFlowWithFormdataBodyWithResponse(ctx context.Context, params *UpdateRecoveryFlowParams, body UpdateRecoveryFlowFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateRecoveryFlowResponse, error) {
	rsp, err := c.UpdateRecoveryFlowWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRecoveryFlowResponse(rsp)
}

// CreateNativeRecoveryFlowWithResponse request returning *CreateNativeRecoveryFlowResponse
func (c *ClientWithResponses) CreateNativeRecoveryFlowWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CreateNativeRecoveryFlowResponse, error) {
	rsp, err := c.CreateNativeRecoveryFlow(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNativeRecoveryFlowResponse(rsp)
}

// CreateBrowserRecoveryFlowWithResponse request returning *CreateBrowserRecoveryFlowResponse
func (c *ClientWithResponses) CreateBrowserRecoveryFlowWithResponse(ctx context.Context, params *CreateBrowserRecoveryFlowParams, reqEditors ...RequestEditorFn) (*CreateBrowserRecoveryFlowResponse, error) {
	rsp, err := c.CreateBrowserRecoveryFlow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBrowserRecoveryFlowResponse(rsp)
}

// GetRecoveryFlowWithResponse request returning *GetRecoveryFlowResponse
func (c *ClientWithResponses) GetRecoveryFlowWithResponse(ctx context.Context, params *GetRecoveryFlowParams, reqEditors ...RequestEditorFn) (*GetRecoveryFlowResponse, error) {
	rsp, err := c.GetRecoveryFlow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRecoveryFlowResponse(rsp)
}

// UpdateRegistrationFlowWithBodyWithResponse request with arbitrary body returning *UpdateRegistrationFlowResponse
func (c *ClientWithResponses) UpdateRegistrationFlowWithBodyWithResponse(ctx context.Context, params *UpdateRegistrationFlowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRegistrationFlowResponse, error) {
	rsp, err := c.UpdateRegistrationFlowWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRegistrationFlowResponse(rsp)
}

func (c *ClientWithResponses) UpdateRegistrationFlowWithResponse(ctx context.Context, params *UpdateRegistrationFlowParams, body UpdateRegistrationFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRegistrationFlowResponse, error) {
	rsp, err := c.UpdateRegistrationFlow(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRegistrationFlowResponse(rsp)
}

func (c *ClientWithResponses) UpdateRegistrationFlowWithFormdataBodyWithResponse(ctx context.Context, params *UpdateRegistrationFlowParams, body UpdateRegistrationFlowFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateRegistrationFlowResponse, error) {
	rsp, err := c.UpdateRegistrationFlowWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRegistrationFlowResponse(rsp)
}

// CreateNativeRegistrationFlowWithResponse request returning *CreateNativeRegistrationFlowResponse
func (c *ClientWithResponses) CreateNativeRegistrationFlowWithResponse(ctx context.Context, params *CreateNativeRegistrationFlowParams, reqEditors ...RequestEditorFn) (*CreateNativeRegistrationFlowResponse, error) {
	rsp, err := c.CreateNativeRegistrationFlow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNativeRegistrationFlowResponse(rsp)
}

// CreateBrowserRegistrationFlowWithResponse request returning *CreateBrowserRegistrationFlowResponse
func (c *ClientWithResponses) CreateBrowserRegistrationFlowWithResponse(ctx context.Context, params *CreateBrowserRegistrationFlowParams, reqEditors ...RequestEditorFn) (*CreateBrowserRegistrationFlowResponse, error) {
	rsp, err := c.CreateBrowserRegistrationFlow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBrowserRegistrationFlowResponse(rsp)
}

// GetRegistrationFlowWithResponse request returning *GetRegistrationFlowResponse
func (c *ClientWithResponses) GetRegistrationFlowWithResponse(ctx context.Context, params *GetRegistrationFlowParams, reqEditors ...RequestEditorFn) (*GetRegistrationFlowResponse, error) {
	rsp, err := c.GetRegistrationFlow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRegistrationFlowResponse(rsp)
}

// UpdateSettingsFloWithBodyWithResponse request with arbitrary body returning *UpdateSettingsFloResponse
func (c *ClientWithResponses) UpdateSettingsFloWithBodyWithResponse(ctx context.Context, params *UpdateSettingsFloParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSettingsFloResponse, error) {
	rsp, err := c.UpdateSettingsFloWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSettingsFloResponse(rsp)
}

func (c *ClientWithResponses) UpdateSettingsFloWithResponse(ctx context.Context, params *UpdateSettingsFloParams, body UpdateSettingsFloJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSettingsFloResponse, error) {
	rsp, err := c.UpdateSettingsFlo(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSettingsFloResponse(rsp)
}

func (c *ClientWithResponses) UpdateSettingsFloWithFormdataBodyWithResponse(ctx context.Context, params *UpdateSettingsFloParams, body UpdateSettingsFloFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateSettingsFloResponse, error) {
	rsp, err := c.UpdateSettingsFloWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSettingsFloResponse(rsp)
}

// CreateNativeSettingsFlowWithResponse request returning *CreateNativeSettingsFlowResponse
func (c *ClientWithResponses) CreateNativeSettingsFlowWithResponse(ctx context.Context, params *CreateNativeSettingsFlowParams, reqEditors ...RequestEditorFn) (*CreateNativeSettingsFlowResponse, error) {
	rsp, err := c.CreateNativeSettingsFlow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNativeSettingsFlowResponse(rsp)
}

// CreateBrowserSettingsFlowWithResponse request returning *CreateBrowserSettingsFlowResponse
func (c *ClientWithResponses) CreateBrowserSettingsFlowWithResponse(ctx context.Context, params *CreateBrowserSettingsFlowParams, reqEditors ...RequestEditorFn) (*CreateBrowserSettingsFlowResponse, error) {
	rsp, err := c.CreateBrowserSettingsFlow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBrowserSettingsFlowResponse(rsp)
}

// GetSettingsFlowWithResponse request returning *GetSettingsFlowResponse
func (c *ClientWithResponses) GetSettingsFlowWithResponse(ctx context.Context, params *GetSettingsFlowParams, reqEditors ...RequestEditorFn) (*GetSettingsFlowResponse, error) {
	rsp, err := c.GetSettingsFlow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSettingsFlowResponse(rsp)
}

// UpdateVerificationFlowWithBodyWithResponse request with arbitrary body returning *UpdateVerificationFlowResponse
func (c *ClientWithResponses) UpdateVerificationFlowWithBodyWithResponse(ctx context.Context, params *UpdateVerificationFlowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVerificationFlowResponse, error) {
	rsp, err := c.UpdateVerificationFlowWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVerificationFlowResponse(rsp)
}

func (c *ClientWithResponses) UpdateVerificationFlowWithResponse(ctx context.Context, params *UpdateVerificationFlowParams, body UpdateVerificationFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVerificationFlowResponse, error) {
	rsp, err := c.UpdateVerificationFlow(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVerificationFlowResponse(rsp)
}

func (c *ClientWithResponses) UpdateVerificationFlowWithFormdataBodyWithResponse(ctx context.Context, params *UpdateVerificationFlowParams, body UpdateVerificationFlowFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateVerificationFlowResponse, error) {
	rsp, err := c.UpdateVerificationFlowWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVerificationFlowResponse(rsp)
}

// CreateNativeVerificationFlowWithResponse request returning *CreateNativeVerificationFlowResponse
func (c *ClientWithResponses) CreateNativeVerificationFlowWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CreateNativeVerificationFlowResponse, error) {
	rsp, err := c.CreateNativeVerificationFlow(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNativeVerificationFlowResponse(rsp)
}

// CreateBrowserVerificationFlowWithResponse request returning *CreateBrowserVerificationFlowResponse
func (c *ClientWithResponses) CreateBrowserVerificationFlowWithResponse(ctx context.Context, params *CreateBrowserVerificationFlowParams, reqEditors ...RequestEditorFn) (*CreateBrowserVerificationFlowResponse, error) {
	rsp, err := c.CreateBrowserVerificationFlow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBrowserVerificationFlowResponse(rsp)
}

// GetVerificationFlowWithResponse request returning *GetVerificationFlowResponse
func (c *ClientWithResponses) GetVerificationFlowWithResponse(ctx context.Context, params *GetVerificationFlowParams, reqEditors ...RequestEditorFn) (*GetVerificationFlowResponse, error) {
	rsp, err := c.GetVerificationFlow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVerificationFlowResponse(rsp)
}

// DisableMyOtherSessionsWithResponse request returning *DisableMyOtherSessionsResponse
func (c *ClientWithResponses) DisableMyOtherSessionsWithResponse(ctx context.Context, params *DisableMyOtherSessionsParams, reqEditors ...RequestEditorFn) (*DisableMyOtherSessionsResponse, error) {
	rsp, err := c.DisableMyOtherSessions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisableMyOtherSessionsResponse(rsp)
}

// ListMySessionsWithResponse request returning *ListMySessionsResponse
func (c *ClientWithResponses) ListMySessionsWithResponse(ctx context.Context, params *ListMySessionsParams, reqEditors ...RequestEditorFn) (*ListMySessionsResponse, error) {
	rsp, err := c.ListMySessions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMySessionsResponse(rsp)
}

// ExchangeSessionTokenWithResponse request returning *ExchangeSessionTokenResponse
func (c *ClientWithResponses) ExchangeSessionTokenWithResponse(ctx context.Context, params *ExchangeSessionTokenParams, reqEditors ...RequestEditorFn) (*ExchangeSessionTokenResponse, error) {
	rsp, err := c.ExchangeSessionToken(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExchangeSessionTokenResponse(rsp)
}

// ToSessionWithResponse request returning *ToSessionResponse
func (c *ClientWithResponses) ToSessionWithResponse(ctx context.Context, params *ToSessionParams, reqEditors ...RequestEditorFn) (*ToSessionResponse, error) {
	rsp, err := c.ToSession(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToSessionResponse(rsp)
}

// IntrospectWithBodyWithResponse request with arbitrary body returning *IntrospectResponse
func (c *ClientWithResponses) IntrospectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IntrospectResponse, error) {
	rsp, err := c.IntrospectWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIntrospectResponse(rsp)
}

func (c *ClientWithResponses) IntrospectWithFormdataBodyWithResponse(ctx context.Context, body IntrospectFormdataRequestBody, reqEditors ...RequestEditorFn) (*IntrospectResponse, error) {
	rsp, err := c.IntrospectWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIntrospectResponse(rsp)
}

// ListOrganisationsIdentityWithResponse request returning *ListOrganisationsIdentityResponse
func (c *ClientWithResponses) ListOrganisationsIdentityWithResponse(ctx context.Context, params *ListOrganisationsIdentityParams, reqEditors ...RequestEditorFn) (*ListOrganisationsIdentityResponse, error) {
	rsp, err := c.ListOrganisationsIdentity(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListOrganisationsIdentityResponse(rsp)
}

// GetIAMGranularPolicyOrganisationWithResponse request returning *GetIAMGranularPolicyOrganisationResponse
func (c *ClientWithResponses) GetIAMGranularPolicyOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, reqEditors ...RequestEditorFn) (*GetIAMGranularPolicyOrganisationResponse, error) {
	rsp, err := c.GetIAMGranularPolicyOrganisation(ctx, organisationId, subjectType, subjectId, objectType, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIAMGranularPolicyOrganisationResponse(rsp)
}

// SetIAMGranularPolicyOrganisationWithBodyWithResponse request with arbitrary body returning *SetIAMGranularPolicyOrganisationResponse
func (c *ClientWithResponses) SetIAMGranularPolicyOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetIAMGranularPolicyOrganisationResponse, error) {
	rsp, err := c.SetIAMGranularPolicyOrganisationWithBody(ctx, organisationId, subjectType, subjectId, objectType, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetIAMGranularPolicyOrganisationResponse(rsp)
}

func (c *ClientWithResponses) SetIAMGranularPolicyOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, body SetIAMGranularPolicyOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*SetIAMGranularPolicyOrganisationResponse, error) {
	rsp, err := c.SetIAMGranularPolicyOrganisation(ctx, organisationId, subjectType, subjectId, objectType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetIAMGranularPolicyOrganisationResponse(rsp)
}

// GetIAMPolicyOrganisationWithResponse request returning *GetIAMPolicyOrganisationResponse
func (c *ClientWithResponses) GetIAMPolicyOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, reqEditors ...RequestEditorFn) (*GetIAMPolicyOrganisationResponse, error) {
	rsp, err := c.GetIAMPolicyOrganisation(ctx, organisationId, subjectType, subjectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIAMPolicyOrganisationResponse(rsp)
}

// SetIAMPolicyOrganisationWithBodyWithResponse request with arbitrary body returning *SetIAMPolicyOrganisationResponse
func (c *ClientWithResponses) SetIAMPolicyOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetIAMPolicyOrganisationResponse, error) {
	rsp, err := c.SetIAMPolicyOrganisationWithBody(ctx, organisationId, subjectType, subjectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetIAMPolicyOrganisationResponse(rsp)
}

func (c *ClientWithResponses) SetIAMPolicyOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, body SetIAMPolicyOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*SetIAMPolicyOrganisationResponse, error) {
	rsp, err := c.SetIAMPolicyOrganisation(ctx, organisationId, subjectType, subjectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetIAMPolicyOrganisationResponse(rsp)
}

// ListPermissionsOrganisationWithResponse request returning *ListPermissionsOrganisationResponse
func (c *ClientWithResponses) ListPermissionsOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, params *ListPermissionsOrganisationParams, reqEditors ...RequestEditorFn) (*ListPermissionsOrganisationResponse, error) {
	rsp, err := c.ListPermissionsOrganisation(ctx, organisationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPermissionsOrganisationResponse(rsp)
}

// GetPermissionOrganisationWithResponse request returning *GetPermissionOrganisationResponse
func (c *ClientWithResponses) GetPermissionOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, permissionUuid PermissionUuid, reqEditors ...RequestEditorFn) (*GetPermissionOrganisationResponse, error) {
	rsp, err := c.GetPermissionOrganisation(ctx, organisationId, permissionUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPermissionOrganisationResponse(rsp)
}

// ListRolesOrganisationWithResponse request returning *ListRolesOrganisationResponse
func (c *ClientWithResponses) ListRolesOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, params *ListRolesOrganisationParams, reqEditors ...RequestEditorFn) (*ListRolesOrganisationResponse, error) {
	rsp, err := c.ListRolesOrganisation(ctx, organisationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRolesOrganisationResponse(rsp)
}

// CreateRoleOrganisationWithBodyWithResponse request with arbitrary body returning *CreateRoleOrganisationResponse
func (c *ClientWithResponses) CreateRoleOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRoleOrganisationResponse, error) {
	rsp, err := c.CreateRoleOrganisationWithBody(ctx, organisationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRoleOrganisationResponse(rsp)
}

func (c *ClientWithResponses) CreateRoleOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, body CreateRoleOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRoleOrganisationResponse, error) {
	rsp, err := c.CreateRoleOrganisation(ctx, organisationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRoleOrganisationResponse(rsp)
}

// DeleteRoleOrganisationWithResponse request returning *DeleteRoleOrganisationResponse
func (c *ClientWithResponses) DeleteRoleOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*DeleteRoleOrganisationResponse, error) {
	rsp, err := c.DeleteRoleOrganisation(ctx, organisationId, roleUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRoleOrganisationResponse(rsp)
}

// GetRoleOrganisationWithResponse request returning *GetRoleOrganisationResponse
func (c *ClientWithResponses) GetRoleOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*GetRoleOrganisationResponse, error) {
	rsp, err := c.GetRoleOrganisation(ctx, organisationId, roleUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRoleOrganisationResponse(rsp)
}

// UpdateRoleOrganisationWithBodyWithResponse request with arbitrary body returning *UpdateRoleOrganisationResponse
func (c *ClientWithResponses) UpdateRoleOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRoleOrganisationResponse, error) {
	rsp, err := c.UpdateRoleOrganisationWithBody(ctx, organisationId, roleUuid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRoleOrganisationResponse(rsp)
}

func (c *ClientWithResponses) UpdateRoleOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, body UpdateRoleOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRoleOrganisationResponse, error) {
	rsp, err := c.UpdateRoleOrganisation(ctx, organisationId, roleUuid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRoleOrganisationResponse(rsp)
}

// RemoveRolePermissionsOrganisationWithBodyWithResponse request with arbitrary body returning *RemoveRolePermissionsOrganisationResponse
func (c *ClientWithResponses) RemoveRolePermissionsOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveRolePermissionsOrganisationResponse, error) {
	rsp, err := c.RemoveRolePermissionsOrganisationWithBody(ctx, organisationId, roleUuid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveRolePermissionsOrganisationResponse(rsp)
}

func (c *ClientWithResponses) RemoveRolePermissionsOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, body RemoveRolePermissionsOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveRolePermissionsOrganisationResponse, error) {
	rsp, err := c.RemoveRolePermissionsOrganisation(ctx, organisationId, roleUuid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveRolePermissionsOrganisationResponse(rsp)
}

// GetRolePermissionsOrganisationWithResponse request returning *GetRolePermissionsOrganisationResponse
func (c *ClientWithResponses) GetRolePermissionsOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*GetRolePermissionsOrganisationResponse, error) {
	rsp, err := c.GetRolePermissionsOrganisation(ctx, organisationId, roleUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRolePermissionsOrganisationResponse(rsp)
}

// AddRolePermissionsOrganisationWithBodyWithResponse request with arbitrary body returning *AddRolePermissionsOrganisationResponse
func (c *ClientWithResponses) AddRolePermissionsOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddRolePermissionsOrganisationResponse, error) {
	rsp, err := c.AddRolePermissionsOrganisationWithBody(ctx, organisationId, roleUuid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddRolePermissionsOrganisationResponse(rsp)
}

func (c *ClientWithResponses) AddRolePermissionsOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, body AddRolePermissionsOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*AddRolePermissionsOrganisationResponse, error) {
	rsp, err := c.AddRolePermissionsOrganisation(ctx, organisationId, roleUuid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddRolePermissionsOrganisationResponse(rsp)
}

// ListServiceAccountOrganisationWithBodyWithResponse request with arbitrary body returning *ListServiceAccountOrganisationResponse
func (c *ClientWithResponses) ListServiceAccountOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, params *ListServiceAccountOrganisationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListServiceAccountOrganisationResponse, error) {
	rsp, err := c.ListServiceAccountOrganisationWithBody(ctx, organisationId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListServiceAccountOrganisationResponse(rsp)
}

func (c *ClientWithResponses) ListServiceAccountOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, params *ListServiceAccountOrganisationParams, body ListServiceAccountOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*ListServiceAccountOrganisationResponse, error) {
	rsp, err := c.ListServiceAccountOrganisation(ctx, organisationId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListServiceAccountOrganisationResponse(rsp)
}

// CreateServiceAccountOrganisationWithBodyWithResponse request with arbitrary body returning *CreateServiceAccountOrganisationResponse
func (c *ClientWithResponses) CreateServiceAccountOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceAccountOrganisationResponse, error) {
	rsp, err := c.CreateServiceAccountOrganisationWithBody(ctx, organisationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceAccountOrganisationResponse(rsp)
}

func (c *ClientWithResponses) CreateServiceAccountOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, body CreateServiceAccountOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceAccountOrganisationResponse, error) {
	rsp, err := c.CreateServiceAccountOrganisation(ctx, organisationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceAccountOrganisationResponse(rsp)
}

// DeleteServiceAccountOrganisationWithResponse request returning *DeleteServiceAccountOrganisationResponse
func (c *ClientWithResponses) DeleteServiceAccountOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*DeleteServiceAccountOrganisationResponse, error) {
	rsp, err := c.DeleteServiceAccountOrganisation(ctx, organisationId, serviceAccountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServiceAccountOrganisationResponse(rsp)
}

// GetServiceAccountOrganisationWithResponse request returning *GetServiceAccountOrganisationResponse
func (c *ClientWithResponses) GetServiceAccountOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*GetServiceAccountOrganisationResponse, error) {
	rsp, err := c.GetServiceAccountOrganisation(ctx, organisationId, serviceAccountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServiceAccountOrganisationResponse(rsp)
}

// UpdateServiceAccountOrganisationWithBodyWithResponse request with arbitrary body returning *UpdateServiceAccountOrganisationResponse
func (c *ClientWithResponses) UpdateServiceAccountOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServiceAccountOrganisationResponse, error) {
	rsp, err := c.UpdateServiceAccountOrganisationWithBody(ctx, organisationId, serviceAccountId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServiceAccountOrganisationResponse(rsp)
}

func (c *ClientWithResponses) UpdateServiceAccountOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, body UpdateServiceAccountOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServiceAccountOrganisationResponse, error) {
	rsp, err := c.UpdateServiceAccountOrganisation(ctx, organisationId, serviceAccountId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServiceAccountOrganisationResponse(rsp)
}

// GetACLServiceAccountOrganisationWithResponse request returning *GetACLServiceAccountOrganisationResponse
func (c *ClientWithResponses) GetACLServiceAccountOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, params *GetACLServiceAccountOrganisationParams, reqEditors ...RequestEditorFn) (*GetACLServiceAccountOrganisationResponse, error) {
	rsp, err := c.GetACLServiceAccountOrganisation(ctx, organisationId, serviceAccountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetACLServiceAccountOrganisationResponse(rsp)
}

// DeleteACLServiceAccountOrganisationBulkWithBodyWithResponse request with arbitrary body returning *DeleteACLServiceAccountOrganisationBulkResponse
func (c *ClientWithResponses) DeleteACLServiceAccountOrganisationBulkWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteACLServiceAccountOrganisationBulkResponse, error) {
	rsp, err := c.DeleteACLServiceAccountOrganisationBulkWithBody(ctx, organisationId, serviceAccountId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteACLServiceAccountOrganisationBulkResponse(rsp)
}

func (c *ClientWithResponses) DeleteACLServiceAccountOrganisationBulkWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, body DeleteACLServiceAccountOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteACLServiceAccountOrganisationBulkResponse, error) {
	rsp, err := c.DeleteACLServiceAccountOrganisationBulk(ctx, organisationId, serviceAccountId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteACLServiceAccountOrganisationBulkResponse(rsp)
}

// CreateACLServiceAccountOrganisationBulkWithBodyWithResponse request with arbitrary body returning *CreateACLServiceAccountOrganisationBulkResponse
func (c *ClientWithResponses) CreateACLServiceAccountOrganisationBulkWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateACLServiceAccountOrganisationBulkResponse, error) {
	rsp, err := c.CreateACLServiceAccountOrganisationBulkWithBody(ctx, organisationId, serviceAccountId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateACLServiceAccountOrganisationBulkResponse(rsp)
}

func (c *ClientWithResponses) CreateACLServiceAccountOrganisationBulkWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, body CreateACLServiceAccountOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateACLServiceAccountOrganisationBulkResponse, error) {
	rsp, err := c.CreateACLServiceAccountOrganisationBulk(ctx, organisationId, serviceAccountId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateACLServiceAccountOrganisationBulkResponse(rsp)
}

// ListSpacesOfServiceAccountWithResponse request returning *ListSpacesOfServiceAccountResponse
func (c *ClientWithResponses) ListSpacesOfServiceAccountWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, params *ListSpacesOfServiceAccountParams, reqEditors ...RequestEditorFn) (*ListSpacesOfServiceAccountResponse, error) {
	rsp, err := c.ListSpacesOfServiceAccount(ctx, organisationId, serviceAccountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSpacesOfServiceAccountResponse(rsp)
}

// ListSpacesIdentityWithResponse request returning *ListSpacesIdentityResponse
func (c *ClientWithResponses) ListSpacesIdentityWithResponse(ctx context.Context, organisationId OrganisationId, params *ListSpacesIdentityParams, reqEditors ...RequestEditorFn) (*ListSpacesIdentityResponse, error) {
	rsp, err := c.ListSpacesIdentity(ctx, organisationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSpacesIdentityResponse(rsp)
}

// ListUserOrganisationWithBodyWithResponse request with arbitrary body returning *ListUserOrganisationResponse
func (c *ClientWithResponses) ListUserOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, params *ListUserOrganisationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListUserOrganisationResponse, error) {
	rsp, err := c.ListUserOrganisationWithBody(ctx, organisationId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserOrganisationResponse(rsp)
}

func (c *ClientWithResponses) ListUserOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, params *ListUserOrganisationParams, body ListUserOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*ListUserOrganisationResponse, error) {
	rsp, err := c.ListUserOrganisation(ctx, organisationId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserOrganisationResponse(rsp)
}

// CreateUserOrganisationWithBodyWithResponse request with arbitrary body returning *CreateUserOrganisationResponse
func (c *ClientWithResponses) CreateUserOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserOrganisationResponse, error) {
	rsp, err := c.CreateUserOrganisationWithBody(ctx, organisationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserOrganisationResponse(rsp)
}

func (c *ClientWithResponses) CreateUserOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, body CreateUserOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserOrganisationResponse, error) {
	rsp, err := c.CreateUserOrganisation(ctx, organisationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserOrganisationResponse(rsp)
}

// DeleteUserOrganisationWithResponse request returning *DeleteUserOrganisationResponse
func (c *ClientWithResponses) DeleteUserOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, reqEditors ...RequestEditorFn) (*DeleteUserOrganisationResponse, error) {
	rsp, err := c.DeleteUserOrganisation(ctx, organisationId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserOrganisationResponse(rsp)
}

// GetUserOrganisationWithResponse request returning *GetUserOrganisationResponse
func (c *ClientWithResponses) GetUserOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, reqEditors ...RequestEditorFn) (*GetUserOrganisationResponse, error) {
	rsp, err := c.GetUserOrganisation(ctx, organisationId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserOrganisationResponse(rsp)
}

// PatchUserStateOrganisationWithBodyWithResponse request with arbitrary body returning *PatchUserStateOrganisationResponse
func (c *ClientWithResponses) PatchUserStateOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchUserStateOrganisationResponse, error) {
	rsp, err := c.PatchUserStateOrganisationWithBody(ctx, organisationId, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchUserStateOrganisationResponse(rsp)
}

func (c *ClientWithResponses) PatchUserStateOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, body PatchUserStateOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchUserStateOrganisationResponse, error) {
	rsp, err := c.PatchUserStateOrganisation(ctx, organisationId, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchUserStateOrganisationResponse(rsp)
}

// UpdateUserOrganisationWithBodyWithResponse request with arbitrary body returning *UpdateUserOrganisationResponse
func (c *ClientWithResponses) UpdateUserOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserOrganisationResponse, error) {
	rsp, err := c.UpdateUserOrganisationWithBody(ctx, organisationId, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserOrganisationResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, body UpdateUserOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserOrganisationResponse, error) {
	rsp, err := c.UpdateUserOrganisation(ctx, organisationId, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserOrganisationResponse(rsp)
}

// GetACLUserOrganisationWithResponse request returning *GetACLUserOrganisationResponse
func (c *ClientWithResponses) GetACLUserOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, params *GetACLUserOrganisationParams, reqEditors ...RequestEditorFn) (*GetACLUserOrganisationResponse, error) {
	rsp, err := c.GetACLUserOrganisation(ctx, organisationId, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetACLUserOrganisationResponse(rsp)
}

// DeleteACLUserOrganisationBulkWithBodyWithResponse request with arbitrary body returning *DeleteACLUserOrganisationBulkResponse
func (c *ClientWithResponses) DeleteACLUserOrganisationBulkWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteACLUserOrganisationBulkResponse, error) {
	rsp, err := c.DeleteACLUserOrganisationBulkWithBody(ctx, organisationId, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteACLUserOrganisationBulkResponse(rsp)
}

func (c *ClientWithResponses) DeleteACLUserOrganisationBulkWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, body DeleteACLUserOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteACLUserOrganisationBulkResponse, error) {
	rsp, err := c.DeleteACLUserOrganisationBulk(ctx, organisationId, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteACLUserOrganisationBulkResponse(rsp)
}

// CreateACLUserOrganisationBulkWithBodyWithResponse request with arbitrary body returning *CreateACLUserOrganisationBulkResponse
func (c *ClientWithResponses) CreateACLUserOrganisationBulkWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateACLUserOrganisationBulkResponse, error) {
	rsp, err := c.CreateACLUserOrganisationBulkWithBody(ctx, organisationId, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateACLUserOrganisationBulkResponse(rsp)
}

func (c *ClientWithResponses) CreateACLUserOrganisationBulkWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, body CreateACLUserOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateACLUserOrganisationBulkResponse, error) {
	rsp, err := c.CreateACLUserOrganisationBulk(ctx, organisationId, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateACLUserOrganisationBulkResponse(rsp)
}

// RecoverUserOrganisationWithResponse request returning *RecoverUserOrganisationResponse
func (c *ClientWithResponses) RecoverUserOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, reqEditors ...RequestEditorFn) (*RecoverUserOrganisationResponse, error) {
	rsp, err := c.RecoverUserOrganisation(ctx, organisationId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRecoverUserOrganisationResponse(rsp)
}

// ListSpacesOfUserWithResponse request returning *ListSpacesOfUserResponse
func (c *ClientWithResponses) ListSpacesOfUserWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, params *ListSpacesOfUserParams, reqEditors ...RequestEditorFn) (*ListSpacesOfUserResponse, error) {
	rsp, err := c.ListSpacesOfUser(ctx, organisationId, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSpacesOfUserResponse(rsp)
}

// RevokeWithBodyWithResponse request with arbitrary body returning *RevokeResponse
func (c *ClientWithResponses) RevokeWithBodyWithResponse(ctx context.Context, params *RevokeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevokeResponse, error) {
	rsp, err := c.RevokeWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokeResponse(rsp)
}

func (c *ClientWithResponses) RevokeWithFormdataBodyWithResponse(ctx context.Context, params *RevokeParams, body RevokeFormdataRequestBody, reqEditors ...RequestEditorFn) (*RevokeResponse, error) {
	rsp, err := c.RevokeWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokeResponse(rsp)
}

// GetIAMGranularPolicySpaceWithResponse request returning *GetIAMGranularPolicySpaceResponse
func (c *ClientWithResponses) GetIAMGranularPolicySpaceWithResponse(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, reqEditors ...RequestEditorFn) (*GetIAMGranularPolicySpaceResponse, error) {
	rsp, err := c.GetIAMGranularPolicySpace(ctx, spaceId, subjectType, subjectId, objectType, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIAMGranularPolicySpaceResponse(rsp)
}

// SetIAMGranularPolicySpaceWithBodyWithResponse request with arbitrary body returning *SetIAMGranularPolicySpaceResponse
func (c *ClientWithResponses) SetIAMGranularPolicySpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetIAMGranularPolicySpaceResponse, error) {
	rsp, err := c.SetIAMGranularPolicySpaceWithBody(ctx, spaceId, subjectType, subjectId, objectType, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetIAMGranularPolicySpaceResponse(rsp)
}

func (c *ClientWithResponses) SetIAMGranularPolicySpaceWithResponse(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, body SetIAMGranularPolicySpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*SetIAMGranularPolicySpaceResponse, error) {
	rsp, err := c.SetIAMGranularPolicySpace(ctx, spaceId, subjectType, subjectId, objectType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetIAMGranularPolicySpaceResponse(rsp)
}

// GetIAMPolicySpaceWithResponse request returning *GetIAMPolicySpaceResponse
func (c *ClientWithResponses) GetIAMPolicySpaceWithResponse(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, reqEditors ...RequestEditorFn) (*GetIAMPolicySpaceResponse, error) {
	rsp, err := c.GetIAMPolicySpace(ctx, spaceId, subjectType, subjectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIAMPolicySpaceResponse(rsp)
}

// SetIAMPolicySpaceWithBodyWithResponse request with arbitrary body returning *SetIAMPolicySpaceResponse
func (c *ClientWithResponses) SetIAMPolicySpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetIAMPolicySpaceResponse, error) {
	rsp, err := c.SetIAMPolicySpaceWithBody(ctx, spaceId, subjectType, subjectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetIAMPolicySpaceResponse(rsp)
}

func (c *ClientWithResponses) SetIAMPolicySpaceWithResponse(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, body SetIAMPolicySpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*SetIAMPolicySpaceResponse, error) {
	rsp, err := c.SetIAMPolicySpace(ctx, spaceId, subjectType, subjectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetIAMPolicySpaceResponse(rsp)
}

// ListPermissionsSpaceWithResponse request returning *ListPermissionsSpaceResponse
func (c *ClientWithResponses) ListPermissionsSpaceWithResponse(ctx context.Context, spaceId SpaceId, params *ListPermissionsSpaceParams, reqEditors ...RequestEditorFn) (*ListPermissionsSpaceResponse, error) {
	rsp, err := c.ListPermissionsSpace(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPermissionsSpaceResponse(rsp)
}

// GetPermissionSpaceWithResponse request returning *GetPermissionSpaceResponse
func (c *ClientWithResponses) GetPermissionSpaceWithResponse(ctx context.Context, spaceId SpaceId, permissionUuid PermissionUuid, reqEditors ...RequestEditorFn) (*GetPermissionSpaceResponse, error) {
	rsp, err := c.GetPermissionSpace(ctx, spaceId, permissionUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPermissionSpaceResponse(rsp)
}

// ListRolesSpaceWithResponse request returning *ListRolesSpaceResponse
func (c *ClientWithResponses) ListRolesSpaceWithResponse(ctx context.Context, spaceId SpaceId, params *ListRolesSpaceParams, reqEditors ...RequestEditorFn) (*ListRolesSpaceResponse, error) {
	rsp, err := c.ListRolesSpace(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRolesSpaceResponse(rsp)
}

// CreateRoleSpaceWithBodyWithResponse request with arbitrary body returning *CreateRoleSpaceResponse
func (c *ClientWithResponses) CreateRoleSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRoleSpaceResponse, error) {
	rsp, err := c.CreateRoleSpaceWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRoleSpaceResponse(rsp)
}

func (c *ClientWithResponses) CreateRoleSpaceWithResponse(ctx context.Context, spaceId SpaceId, body CreateRoleSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRoleSpaceResponse, error) {
	rsp, err := c.CreateRoleSpace(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRoleSpaceResponse(rsp)
}

// DeleteRoleSpaceWithResponse request returning *DeleteRoleSpaceResponse
func (c *ClientWithResponses) DeleteRoleSpaceWithResponse(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*DeleteRoleSpaceResponse, error) {
	rsp, err := c.DeleteRoleSpace(ctx, spaceId, roleUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRoleSpaceResponse(rsp)
}

// GetRoleSpaceWithResponse request returning *GetRoleSpaceResponse
func (c *ClientWithResponses) GetRoleSpaceWithResponse(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*GetRoleSpaceResponse, error) {
	rsp, err := c.GetRoleSpace(ctx, spaceId, roleUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRoleSpaceResponse(rsp)
}

// UpdateRoleSpaceWithBodyWithResponse request with arbitrary body returning *UpdateRoleSpaceResponse
func (c *ClientWithResponses) UpdateRoleSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRoleSpaceResponse, error) {
	rsp, err := c.UpdateRoleSpaceWithBody(ctx, spaceId, roleUuid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRoleSpaceResponse(rsp)
}

func (c *ClientWithResponses) UpdateRoleSpaceWithResponse(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, body UpdateRoleSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRoleSpaceResponse, error) {
	rsp, err := c.UpdateRoleSpace(ctx, spaceId, roleUuid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRoleSpaceResponse(rsp)
}

// RemoveRolePermissionsSpaceWithBodyWithResponse request with arbitrary body returning *RemoveRolePermissionsSpaceResponse
func (c *ClientWithResponses) RemoveRolePermissionsSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveRolePermissionsSpaceResponse, error) {
	rsp, err := c.RemoveRolePermissionsSpaceWithBody(ctx, spaceId, roleUuid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveRolePermissionsSpaceResponse(rsp)
}

func (c *ClientWithResponses) RemoveRolePermissionsSpaceWithResponse(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, body RemoveRolePermissionsSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveRolePermissionsSpaceResponse, error) {
	rsp, err := c.RemoveRolePermissionsSpace(ctx, spaceId, roleUuid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveRolePermissionsSpaceResponse(rsp)
}

// GetRolePermissionsSpaceWithResponse request returning *GetRolePermissionsSpaceResponse
func (c *ClientWithResponses) GetRolePermissionsSpaceWithResponse(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*GetRolePermissionsSpaceResponse, error) {
	rsp, err := c.GetRolePermissionsSpace(ctx, spaceId, roleUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRolePermissionsSpaceResponse(rsp)
}

// AddRolePermissionsSpaceWithBodyWithResponse request with arbitrary body returning *AddRolePermissionsSpaceResponse
func (c *ClientWithResponses) AddRolePermissionsSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddRolePermissionsSpaceResponse, error) {
	rsp, err := c.AddRolePermissionsSpaceWithBody(ctx, spaceId, roleUuid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddRolePermissionsSpaceResponse(rsp)
}

func (c *ClientWithResponses) AddRolePermissionsSpaceWithResponse(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, body AddRolePermissionsSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*AddRolePermissionsSpaceResponse, error) {
	rsp, err := c.AddRolePermissionsSpace(ctx, spaceId, roleUuid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddRolePermissionsSpaceResponse(rsp)
}

// ListServiceAccountSpaceWithBodyWithResponse request with arbitrary body returning *ListServiceAccountSpaceResponse
func (c *ClientWithResponses) ListServiceAccountSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, params *ListServiceAccountSpaceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListServiceAccountSpaceResponse, error) {
	rsp, err := c.ListServiceAccountSpaceWithBody(ctx, spaceId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListServiceAccountSpaceResponse(rsp)
}

func (c *ClientWithResponses) ListServiceAccountSpaceWithResponse(ctx context.Context, spaceId SpaceId, params *ListServiceAccountSpaceParams, body ListServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*ListServiceAccountSpaceResponse, error) {
	rsp, err := c.ListServiceAccountSpace(ctx, spaceId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListServiceAccountSpaceResponse(rsp)
}

// CreateServiceAccountSpaceWithBodyWithResponse request with arbitrary body returning *CreateServiceAccountSpaceResponse
func (c *ClientWithResponses) CreateServiceAccountSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceAccountSpaceResponse, error) {
	rsp, err := c.CreateServiceAccountSpaceWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceAccountSpaceResponse(rsp)
}

func (c *ClientWithResponses) CreateServiceAccountSpaceWithResponse(ctx context.Context, spaceId SpaceId, body CreateServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceAccountSpaceResponse, error) {
	rsp, err := c.CreateServiceAccountSpace(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceAccountSpaceResponse(rsp)
}

// DeleteServiceAccountSpaceWithResponse request returning *DeleteServiceAccountSpaceResponse
func (c *ClientWithResponses) DeleteServiceAccountSpaceWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*DeleteServiceAccountSpaceResponse, error) {
	rsp, err := c.DeleteServiceAccountSpace(ctx, spaceId, serviceAccountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServiceAccountSpaceResponse(rsp)
}

// GetServiceAccountSpaceWithResponse request returning *GetServiceAccountSpaceResponse
func (c *ClientWithResponses) GetServiceAccountSpaceWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*GetServiceAccountSpaceResponse, error) {
	rsp, err := c.GetServiceAccountSpace(ctx, spaceId, serviceAccountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServiceAccountSpaceResponse(rsp)
}

// AssignServiceAccountToSpaceWithResponse request returning *AssignServiceAccountToSpaceResponse
func (c *ClientWithResponses) AssignServiceAccountToSpaceWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*AssignServiceAccountToSpaceResponse, error) {
	rsp, err := c.AssignServiceAccountToSpace(ctx, spaceId, serviceAccountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignServiceAccountToSpaceResponse(rsp)
}

// UpdateServiceAccountSpaceWithBodyWithResponse request with arbitrary body returning *UpdateServiceAccountSpaceResponse
func (c *ClientWithResponses) UpdateServiceAccountSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServiceAccountSpaceResponse, error) {
	rsp, err := c.UpdateServiceAccountSpaceWithBody(ctx, spaceId, serviceAccountId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServiceAccountSpaceResponse(rsp)
}

func (c *ClientWithResponses) UpdateServiceAccountSpaceWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, body UpdateServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServiceAccountSpaceResponse, error) {
	rsp, err := c.UpdateServiceAccountSpace(ctx, spaceId, serviceAccountId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServiceAccountSpaceResponse(rsp)
}

// GetACLServiceAccountSpaceWithResponse request returning *GetACLServiceAccountSpaceResponse
func (c *ClientWithResponses) GetACLServiceAccountSpaceWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, params *GetACLServiceAccountSpaceParams, reqEditors ...RequestEditorFn) (*GetACLServiceAccountSpaceResponse, error) {
	rsp, err := c.GetACLServiceAccountSpace(ctx, spaceId, serviceAccountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetACLServiceAccountSpaceResponse(rsp)
}

// DeleteACLServiceAccountSpaceBulkWithBodyWithResponse request with arbitrary body returning *DeleteACLServiceAccountSpaceBulkResponse
func (c *ClientWithResponses) DeleteACLServiceAccountSpaceBulkWithBodyWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteACLServiceAccountSpaceBulkResponse, error) {
	rsp, err := c.DeleteACLServiceAccountSpaceBulkWithBody(ctx, spaceId, serviceAccountId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteACLServiceAccountSpaceBulkResponse(rsp)
}

func (c *ClientWithResponses) DeleteACLServiceAccountSpaceBulkWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, body DeleteACLServiceAccountSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteACLServiceAccountSpaceBulkResponse, error) {
	rsp, err := c.DeleteACLServiceAccountSpaceBulk(ctx, spaceId, serviceAccountId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteACLServiceAccountSpaceBulkResponse(rsp)
}

// CreateACLServiceAccountSpaceBulkWithBodyWithResponse request with arbitrary body returning *CreateACLServiceAccountSpaceBulkResponse
func (c *ClientWithResponses) CreateACLServiceAccountSpaceBulkWithBodyWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateACLServiceAccountSpaceBulkResponse, error) {
	rsp, err := c.CreateACLServiceAccountSpaceBulkWithBody(ctx, spaceId, serviceAccountId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateACLServiceAccountSpaceBulkResponse(rsp)
}

func (c *ClientWithResponses) CreateACLServiceAccountSpaceBulkWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, body CreateACLServiceAccountSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateACLServiceAccountSpaceBulkResponse, error) {
	rsp, err := c.CreateACLServiceAccountSpaceBulk(ctx, spaceId, serviceAccountId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateACLServiceAccountSpaceBulkResponse(rsp)
}

// ListUserSpaceWithBodyWithResponse request with arbitrary body returning *ListUserSpaceResponse
func (c *ClientWithResponses) ListUserSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, params *ListUserSpaceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListUserSpaceResponse, error) {
	rsp, err := c.ListUserSpaceWithBody(ctx, spaceId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserSpaceResponse(rsp)
}

func (c *ClientWithResponses) ListUserSpaceWithResponse(ctx context.Context, spaceId SpaceId, params *ListUserSpaceParams, body ListUserSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*ListUserSpaceResponse, error) {
	rsp, err := c.ListUserSpace(ctx, spaceId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserSpaceResponse(rsp)
}

// CreateUserSpaceWithBodyWithResponse request with arbitrary body returning *CreateUserSpaceResponse
func (c *ClientWithResponses) CreateUserSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserSpaceResponse, error) {
	rsp, err := c.CreateUserSpaceWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserSpaceResponse(rsp)
}

func (c *ClientWithResponses) CreateUserSpaceWithResponse(ctx context.Context, spaceId SpaceId, body CreateUserSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserSpaceResponse, error) {
	rsp, err := c.CreateUserSpace(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserSpaceResponse(rsp)
}

// DeleteUserSpaceWithResponse request returning *DeleteUserSpaceResponse
func (c *ClientWithResponses) DeleteUserSpaceWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*DeleteUserSpaceResponse, error) {
	rsp, err := c.DeleteUserSpace(ctx, spaceId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserSpaceResponse(rsp)
}

// GetUserSpaceWithResponse request returning *GetUserSpaceResponse
func (c *ClientWithResponses) GetUserSpaceWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*GetUserSpaceResponse, error) {
	rsp, err := c.GetUserSpace(ctx, spaceId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserSpaceResponse(rsp)
}

// PatchUserStateSpaceWithBodyWithResponse request with arbitrary body returning *PatchUserStateSpaceResponse
func (c *ClientWithResponses) PatchUserStateSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchUserStateSpaceResponse, error) {
	rsp, err := c.PatchUserStateSpaceWithBody(ctx, spaceId, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchUserStateSpaceResponse(rsp)
}

func (c *ClientWithResponses) PatchUserStateSpaceWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, body PatchUserStateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchUserStateSpaceResponse, error) {
	rsp, err := c.PatchUserStateSpace(ctx, spaceId, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchUserStateSpaceResponse(rsp)
}

// AssignUserToSpaceWithResponse request returning *AssignUserToSpaceResponse
func (c *ClientWithResponses) AssignUserToSpaceWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*AssignUserToSpaceResponse, error) {
	rsp, err := c.AssignUserToSpace(ctx, spaceId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignUserToSpaceResponse(rsp)
}

// UpdateUserSpaceWithBodyWithResponse request with arbitrary body returning *UpdateUserSpaceResponse
func (c *ClientWithResponses) UpdateUserSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserSpaceResponse, error) {
	rsp, err := c.UpdateUserSpaceWithBody(ctx, spaceId, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserSpaceResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserSpaceWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, body UpdateUserSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserSpaceResponse, error) {
	rsp, err := c.UpdateUserSpace(ctx, spaceId, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserSpaceResponse(rsp)
}

// GetACLUserSpaceWithResponse request returning *GetACLUserSpaceResponse
func (c *ClientWithResponses) GetACLUserSpaceWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, params *GetACLUserSpaceParams, reqEditors ...RequestEditorFn) (*GetACLUserSpaceResponse, error) {
	rsp, err := c.GetACLUserSpace(ctx, spaceId, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetACLUserSpaceResponse(rsp)
}

// DeleteACLUserSpaceBulkWithBodyWithResponse request with arbitrary body returning *DeleteACLUserSpaceBulkResponse
func (c *ClientWithResponses) DeleteACLUserSpaceBulkWithBodyWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteACLUserSpaceBulkResponse, error) {
	rsp, err := c.DeleteACLUserSpaceBulkWithBody(ctx, spaceId, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteACLUserSpaceBulkResponse(rsp)
}

func (c *ClientWithResponses) DeleteACLUserSpaceBulkWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, body DeleteACLUserSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteACLUserSpaceBulkResponse, error) {
	rsp, err := c.DeleteACLUserSpaceBulk(ctx, spaceId, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteACLUserSpaceBulkResponse(rsp)
}

// CreateACLUserSpaceBulkWithBodyWithResponse request with arbitrary body returning *CreateACLUserSpaceBulkResponse
func (c *ClientWithResponses) CreateACLUserSpaceBulkWithBodyWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateACLUserSpaceBulkResponse, error) {
	rsp, err := c.CreateACLUserSpaceBulkWithBody(ctx, spaceId, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateACLUserSpaceBulkResponse(rsp)
}

func (c *ClientWithResponses) CreateACLUserSpaceBulkWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, body CreateACLUserSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateACLUserSpaceBulkResponse, error) {
	rsp, err := c.CreateACLUserSpaceBulk(ctx, spaceId, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateACLUserSpaceBulkResponse(rsp)
}

// RecoverUserSpaceWithResponse request returning *RecoverUserSpaceResponse
func (c *ClientWithResponses) RecoverUserSpaceWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*RecoverUserSpaceResponse, error) {
	rsp, err := c.RecoverUserSpace(ctx, spaceId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRecoverUserSpaceResponse(rsp)
}

// TokenWithBodyWithResponse request with arbitrary body returning *TokenResponse
func (c *ClientWithResponses) TokenWithBodyWithResponse(ctx context.Context, params *TokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TokenResponse, error) {
	rsp, err := c.TokenWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTokenResponse(rsp)
}

func (c *ClientWithResponses) TokenWithFormdataBodyWithResponse(ctx context.Context, params *TokenParams, body TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*TokenResponse, error) {
	rsp, err := c.TokenWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTokenResponse(rsp)
}

// GetUserInfoWithResponse request returning *GetUserInfoResponse
func (c *ClientWithResponses) GetUserInfoWithResponse(ctx context.Context, params *GetUserInfoParams, reqEditors ...RequestEditorFn) (*GetUserInfoResponse, error) {
	rsp, err := c.GetUserInfo(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserInfoResponse(rsp)
}

// ListClustersWithResponse request returning *ListClustersResponse
func (c *ClientWithResponses) ListClustersWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*ListClustersResponse, error) {
	rsp, err := c.ListClusters(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListClustersResponse(rsp)
}

// CreateClusterWithBodyWithResponse request with arbitrary body returning *CreateClusterResponse
func (c *ClientWithResponses) CreateClusterWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error) {
	rsp, err := c.CreateClusterWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClusterResponse(rsp)
}

func (c *ClientWithResponses) CreateClusterWithResponse(ctx context.Context, spaceId SpaceId, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error) {
	rsp, err := c.CreateCluster(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClusterResponse(rsp)
}

// DeleteClusterWithResponse request returning *DeleteClusterResponse
func (c *ClientWithResponses) DeleteClusterWithResponse(ctx context.Context, spaceId SpaceId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*DeleteClusterResponse, error) {
	rsp, err := c.DeleteCluster(ctx, spaceId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClusterResponse(rsp)
}

// GetClusterWithResponse request returning *GetClusterResponse
func (c *ClientWithResponses) GetClusterWithResponse(ctx context.Context, spaceId SpaceId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*GetClusterResponse, error) {
	rsp, err := c.GetCluster(ctx, spaceId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterResponse(rsp)
}

// UpdateClusterWithBodyWithResponse request with arbitrary body returning *UpdateClusterResponse
func (c *ClientWithResponses) UpdateClusterWithBodyWithResponse(ctx context.Context, spaceId SpaceId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error) {
	rsp, err := c.UpdateClusterWithBody(ctx, spaceId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClusterResponse(rsp)
}

func (c *ClientWithResponses) UpdateClusterWithResponse(ctx context.Context, spaceId SpaceId, clusterId ClusterId, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error) {
	rsp, err := c.UpdateCluster(ctx, spaceId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClusterResponse(rsp)
}

// ListNodepoolsWithResponse request returning *ListNodepoolsResponse
func (c *ClientWithResponses) ListNodepoolsWithResponse(ctx context.Context, spaceId SpaceId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*ListNodepoolsResponse, error) {
	rsp, err := c.ListNodepools(ctx, spaceId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListNodepoolsResponse(rsp)
}

// CreateNodePoolWithBodyWithResponse request with arbitrary body returning *CreateNodePoolResponse
func (c *ClientWithResponses) CreateNodePoolWithBodyWithResponse(ctx context.Context, spaceId SpaceId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNodePoolResponse, error) {
	rsp, err := c.CreateNodePoolWithBody(ctx, spaceId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNodePoolResponse(rsp)
}

func (c *ClientWithResponses) CreateNodePoolWithResponse(ctx context.Context, spaceId SpaceId, clusterId ClusterId, body CreateNodePoolJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNodePoolResponse, error) {
	rsp, err := c.CreateNodePool(ctx, spaceId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNodePoolResponse(rsp)
}

// DeleteNodePoolWithResponse request returning *DeleteNodePoolResponse
func (c *ClientWithResponses) DeleteNodePoolWithResponse(ctx context.Context, spaceId SpaceId, clusterId ClusterId, nodePoolName NodepoolName, reqEditors ...RequestEditorFn) (*DeleteNodePoolResponse, error) {
	rsp, err := c.DeleteNodePool(ctx, spaceId, clusterId, nodePoolName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNodePoolResponse(rsp)
}

// UpdateNodepoolWithBodyWithResponse request with arbitrary body returning *UpdateNodepoolResponse
func (c *ClientWithResponses) UpdateNodepoolWithBodyWithResponse(ctx context.Context, spaceId SpaceId, clusterId ClusterId, nodePoolName NodepoolName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNodepoolResponse, error) {
	rsp, err := c.UpdateNodepoolWithBody(ctx, spaceId, clusterId, nodePoolName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNodepoolResponse(rsp)
}

func (c *ClientWithResponses) UpdateNodepoolWithResponse(ctx context.Context, spaceId SpaceId, clusterId ClusterId, nodePoolName NodepoolName, body UpdateNodepoolJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNodepoolResponse, error) {
	rsp, err := c.UpdateNodepool(ctx, spaceId, clusterId, nodePoolName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNodepoolResponse(rsp)
}

// ListOperationsWithResponse request returning *ListOperationsResponse
func (c *ClientWithResponses) ListOperationsWithResponse(ctx context.Context, spaceId SpaceId, params *ListOperationsParams, reqEditors ...RequestEditorFn) (*ListOperationsResponse, error) {
	rsp, err := c.ListOperations(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListOperationsResponse(rsp)
}

// GetOperationWithResponse request returning *GetOperationResponse
func (c *ClientWithResponses) GetOperationWithResponse(ctx context.Context, spaceId SpaceId, id IdUuid, reqEditors ...RequestEditorFn) (*GetOperationResponse, error) {
	rsp, err := c.GetOperation(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOperationResponse(rsp)
}

// ListVersionsWithResponse request returning *ListVersionsResponse
func (c *ClientWithResponses) ListVersionsWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*ListVersionsResponse, error) {
	rsp, err := c.ListVersions(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVersionsResponse(rsp)
}

// DeleteSpaceWithResponse request returning *DeleteSpaceResponse
func (c *ClientWithResponses) DeleteSpaceWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*DeleteSpaceResponse, error) {
	rsp, err := c.DeleteSpace(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSpaceResponse(rsp)
}

// GetSpaceByIdWithResponse request returning *GetSpaceByIdResponse
func (c *ClientWithResponses) GetSpaceByIdWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*GetSpaceByIdResponse, error) {
	rsp, err := c.GetSpaceById(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpaceByIdResponse(rsp)
}

// UpdateSpaceWithBodyWithResponse request with arbitrary body returning *UpdateSpaceResponse
func (c *ClientWithResponses) UpdateSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSpaceResponse, error) {
	rsp, err := c.UpdateSpaceWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSpaceResponse(rsp)
}

func (c *ClientWithResponses) UpdateSpaceWithResponse(ctx context.Context, spaceId SpaceId, body UpdateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSpaceResponse, error) {
	rsp, err := c.UpdateSpace(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSpaceResponse(rsp)
}

// ListSpacesWithBodyWithResponse request with arbitrary body returning *ListSpacesResponse
func (c *ClientWithResponses) ListSpacesWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, params *ListSpacesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListSpacesResponse, error) {
	rsp, err := c.ListSpacesWithBody(ctx, organisationId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSpacesResponse(rsp)
}

func (c *ClientWithResponses) ListSpacesWithResponse(ctx context.Context, organisationId OrganisationId, params *ListSpacesParams, body ListSpacesJSONRequestBody, reqEditors ...RequestEditorFn) (*ListSpacesResponse, error) {
	rsp, err := c.ListSpaces(ctx, organisationId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSpacesResponse(rsp)
}

// CreateSpaceWithBodyWithResponse request with arbitrary body returning *CreateSpaceResponse
func (c *ClientWithResponses) CreateSpaceWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpaceResponse, error) {
	rsp, err := c.CreateSpaceWithBody(ctx, organisationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpaceResponse(rsp)
}

func (c *ClientWithResponses) CreateSpaceWithResponse(ctx context.Context, organisationId OrganisationId, body CreateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpaceResponse, error) {
	rsp, err := c.CreateSpace(ctx, organisationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpaceResponse(rsp)
}

// ParseJsonWebKeysResponse parses an HTTP response from a JsonWebKeysWithResponse call
func ParseJsonWebKeysResponse(rsp *http.Response) (*JsonWebKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JsonWebKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JsonWebKeysResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorOauth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorOauth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDiscoverOidcConfigurationResponse parses an HTTP response from a DiscoverOidcConfigurationWithResponse call
func ParseDiscoverOidcConfigurationResponse(rsp *http.Response) (*DiscoverOidcConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DiscoverOidcConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OidcConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorOauth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetWebAuthnJavaScriptResponse parses an HTTP response from a GetWebAuthnJavaScriptWithResponse call
func ParseGetWebAuthnJavaScriptResponse(rsp *http.Response) (*GetWebAuthnJavaScriptResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWebAuthnJavaScriptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebAuthnJavaScriptResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateAdminServiceAccountSpaceResponse parses an HTTP response from a CreateAdminServiceAccountSpaceWithResponse call
func ParseCreateAdminServiceAccountSpaceResponse(rsp *http.Response) (*CreateAdminServiceAccountSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAdminServiceAccountSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateServiceAccount201ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseAuthorizeResponse parses an HTTP response from a AuthorizeWithResponse call
func ParseAuthorizeResponse(rsp *http.Response) (*AuthorizeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthorizeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorOauth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorOauth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorOauth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorOauth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseConsentResponse parses an HTTP response from a ConsentWithResponse call
func ParseConsentResponse(rsp *http.Response) (*ConsentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConsentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetFlowErrorResponse parses an HTTP response from a GetFlowErrorWithResponse call
func ParseGetFlowErrorResponse(rsp *http.Response) (*GetFlowErrorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFlowErrorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FlowError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateLoginFlowResponse parses an HTTP response from a UpdateLoginFlowWithResponse call
func ParseUpdateLoginFlowResponse(rsp *http.Response) (*UpdateLoginFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateLoginFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessfulNativeLogin
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest LoginFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorBrowserLocationChangeRequired
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateNativeLoginFlowResponse parses an HTTP response from a CreateNativeLoginFlowWithResponse call
func ParseCreateNativeLoginFlowResponse(rsp *http.Response) (*CreateNativeLoginFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNativeLoginFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoginFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBrowserLoginFlowResponse parses an HTTP response from a CreateBrowserLoginFlowWithResponse call
func ParseCreateBrowserLoginFlowResponse(rsp *http.Response) (*CreateBrowserLoginFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBrowserLoginFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoginFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLoginFlowResponse parses an HTTP response from a GetLoginFlowWithResponse call
func ParseGetLoginFlowResponse(rsp *http.Response) (*GetLoginFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLoginFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoginFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateLogoutFlowResponse parses an HTTP response from a UpdateLogoutFlowWithResponse call
func ParseUpdateLogoutFlowResponse(rsp *http.Response) (*UpdateLogoutFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateLogoutFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePerformNativeLogoutResponse parses an HTTP response from a PerformNativeLogoutWithResponse call
func ParsePerformNativeLogoutResponse(rsp *http.Response) (*PerformNativeLogoutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PerformNativeLogoutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBrowserLogoutFlowResponse parses an HTTP response from a CreateBrowserLogoutFlowWithResponse call
func ParseCreateBrowserLogoutFlowResponse(rsp *http.Response) (*CreateBrowserLogoutFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBrowserLogoutFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogoutFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseInitRecoveryFlowResponse parses an HTTP response from a InitRecoveryFlowWithResponse call
func ParseInitRecoveryFlowResponse(rsp *http.Response) (*InitRecoveryFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InitRecoveryFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecoveryFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RecoveryFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorBrowserLocationChangeRequired
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateRecoveryFlowResponse parses an HTTP response from a UpdateRecoveryFlowWithResponse call
func ParseUpdateRecoveryFlowResponse(rsp *http.Response) (*UpdateRecoveryFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRecoveryFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecoveryFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RecoveryFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorBrowserLocationChangeRequired
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateNativeRecoveryFlowResponse parses an HTTP response from a CreateNativeRecoveryFlowWithResponse call
func ParseCreateNativeRecoveryFlowResponse(rsp *http.Response) (*CreateNativeRecoveryFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNativeRecoveryFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecoveryFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBrowserRecoveryFlowResponse parses an HTTP response from a CreateBrowserRecoveryFlowWithResponse call
func ParseCreateBrowserRecoveryFlowResponse(rsp *http.Response) (*CreateBrowserRecoveryFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBrowserRecoveryFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecoveryFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRecoveryFlowResponse parses an HTTP response from a GetRecoveryFlowWithResponse call
func ParseGetRecoveryFlowResponse(rsp *http.Response) (*GetRecoveryFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRecoveryFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecoveryFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateRegistrationFlowResponse parses an HTTP response from a UpdateRegistrationFlowWithResponse call
func ParseUpdateRegistrationFlowResponse(rsp *http.Response) (*UpdateRegistrationFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRegistrationFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessfulNativeRegistration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RegistrationFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorBrowserLocationChangeRequired
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateNativeRegistrationFlowResponse parses an HTTP response from a CreateNativeRegistrationFlowWithResponse call
func ParseCreateNativeRegistrationFlowResponse(rsp *http.Response) (*CreateNativeRegistrationFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNativeRegistrationFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RegistrationFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBrowserRegistrationFlowResponse parses an HTTP response from a CreateBrowserRegistrationFlowWithResponse call
func ParseCreateBrowserRegistrationFlowResponse(rsp *http.Response) (*CreateBrowserRegistrationFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBrowserRegistrationFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RegistrationFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRegistrationFlowResponse parses an HTTP response from a GetRegistrationFlowWithResponse call
func ParseGetRegistrationFlowResponse(rsp *http.Response) (*GetRegistrationFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRegistrationFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RegistrationFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateSettingsFloResponse parses an HTTP response from a UpdateSettingsFloWithResponse call
func ParseUpdateSettingsFloResponse(rsp *http.Response) (*UpdateSettingsFloResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSettingsFloResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SettingsFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest SettingsFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorBrowserLocationChangeRequired
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateNativeSettingsFlowResponse parses an HTTP response from a CreateNativeSettingsFlowWithResponse call
func ParseCreateNativeSettingsFlowResponse(rsp *http.Response) (*CreateNativeSettingsFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNativeSettingsFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SettingsFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBrowserSettingsFlowResponse parses an HTTP response from a CreateBrowserSettingsFlowWithResponse call
func ParseCreateBrowserSettingsFlowResponse(rsp *http.Response) (*CreateBrowserSettingsFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBrowserSettingsFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SettingsFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSettingsFlowResponse parses an HTTP response from a GetSettingsFlowWithResponse call
func ParseGetSettingsFlowResponse(rsp *http.Response) (*GetSettingsFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSettingsFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SettingsFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateVerificationFlowResponse parses an HTTP response from a UpdateVerificationFlowWithResponse call
func ParseUpdateVerificationFlowResponse(rsp *http.Response) (*UpdateVerificationFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVerificationFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VerificationFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest VerificationFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateNativeVerificationFlowResponse parses an HTTP response from a CreateNativeVerificationFlowWithResponse call
func ParseCreateNativeVerificationFlowResponse(rsp *http.Response) (*CreateNativeVerificationFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNativeVerificationFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VerificationFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBrowserVerificationFlowResponse parses an HTTP response from a CreateBrowserVerificationFlowWithResponse call
func ParseCreateBrowserVerificationFlowResponse(rsp *http.Response) (*CreateBrowserVerificationFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBrowserVerificationFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VerificationFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetVerificationFlowResponse parses an HTTP response from a GetVerificationFlowWithResponse call
func ParseGetVerificationFlowResponse(rsp *http.Response) (*GetVerificationFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVerificationFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VerificationFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDisableMyOtherSessionsResponse parses an HTTP response from a DisableMyOtherSessionsWithResponse call
func ParseDisableMyOtherSessionsResponse(rsp *http.Response) (*DisableMyOtherSessionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DisableMyOtherSessionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteMySessionsCount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListMySessionsResponse parses an HTTP response from a ListMySessionsWithResponse call
func ParseListMySessionsResponse(rsp *http.Response) (*ListMySessionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMySessionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListMySessionsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseExchangeSessionTokenResponse parses an HTTP response from a ExchangeSessionTokenWithResponse call
func ParseExchangeSessionTokenResponse(rsp *http.Response) (*ExchangeSessionTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExchangeSessionTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessfulNativeLogin
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseToSessionResponse parses an HTTP response from a ToSessionWithResponse call
func ParseToSessionResponse(rsp *http.Response) (*ToSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ToSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Session
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseIntrospectResponse parses an HTTP response from a IntrospectWithResponse call
func ParseIntrospectResponse(rsp *http.Response) (*IntrospectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IntrospectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IntrospectResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorOauth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListOrganisationsIdentityResponse parses an HTTP response from a ListOrganisationsIdentityWithResponse call
func ParseListOrganisationsIdentityResponse(rsp *http.Response) (*ListOrganisationsIdentityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListOrganisationsIdentityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListUserOrganisations200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetIAMGranularPolicyOrganisationResponse parses an HTTP response from a GetIAMGranularPolicyOrganisationWithResponse call
func ParseGetIAMGranularPolicyOrganisationResponse(rsp *http.Response) (*GetIAMGranularPolicyOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIAMGranularPolicyOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetIAMGranularPolicy200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseSetIAMGranularPolicyOrganisationResponse parses an HTTP response from a SetIAMGranularPolicyOrganisationWithResponse call
func ParseSetIAMGranularPolicyOrganisationResponse(rsp *http.Response) (*SetIAMGranularPolicyOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetIAMGranularPolicyOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetIAMPolicyOrganisationResponse parses an HTTP response from a GetIAMPolicyOrganisationWithResponse call
func ParseGetIAMPolicyOrganisationResponse(rsp *http.Response) (*GetIAMPolicyOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIAMPolicyOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetIAMPolicy200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseSetIAMPolicyOrganisationResponse parses an HTTP response from a SetIAMPolicyOrganisationWithResponse call
func ParseSetIAMPolicyOrganisationResponse(rsp *http.Response) (*SetIAMPolicyOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetIAMPolicyOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListPermissionsOrganisationResponse parses an HTTP response from a ListPermissionsOrganisationWithResponse call
func ParseListPermissionsOrganisationResponse(rsp *http.Response) (*ListPermissionsOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPermissionsOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPermissions200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetPermissionOrganisationResponse parses an HTTP response from a GetPermissionOrganisationWithResponse call
func ParseGetPermissionOrganisationResponse(rsp *http.Response) (*GetPermissionOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPermissionOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPermission200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListRolesOrganisationResponse parses an HTTP response from a ListRolesOrganisationWithResponse call
func ParseListRolesOrganisationResponse(rsp *http.Response) (*ListRolesOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRolesOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListRoles200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateRoleOrganisationResponse parses an HTTP response from a CreateRoleOrganisationWithResponse call
func ParseCreateRoleOrganisationResponse(rsp *http.Response) (*CreateRoleOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRoleOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateRole200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteRoleOrganisationResponse parses an HTTP response from a DeleteRoleOrganisationWithResponse call
func ParseDeleteRoleOrganisationResponse(rsp *http.Response) (*DeleteRoleOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRoleOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetRoleOrganisationResponse parses an HTTP response from a GetRoleOrganisationWithResponse call
func ParseGetRoleOrganisationResponse(rsp *http.Response) (*GetRoleOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRoleOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetRole200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateRoleOrganisationResponse parses an HTTP response from a UpdateRoleOrganisationWithResponse call
func ParseUpdateRoleOrganisationResponse(rsp *http.Response) (*UpdateRoleOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRoleOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseRemoveRolePermissionsOrganisationResponse parses an HTTP response from a RemoveRolePermissionsOrganisationWithResponse call
func ParseRemoveRolePermissionsOrganisationResponse(rsp *http.Response) (*RemoveRolePermissionsOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveRolePermissionsOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetRolePermissionsOrganisationResponse parses an HTTP response from a GetRolePermissionsOrganisationWithResponse call
func ParseGetRolePermissionsOrganisationResponse(rsp *http.Response) (*GetRolePermissionsOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRolePermissionsOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetRolePermissions200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseAddRolePermissionsOrganisationResponse parses an HTTP response from a AddRolePermissionsOrganisationWithResponse call
func ParseAddRolePermissionsOrganisationResponse(rsp *http.Response) (*AddRolePermissionsOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddRolePermissionsOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListServiceAccountOrganisationResponse parses an HTTP response from a ListServiceAccountOrganisationWithResponse call
func ParseListServiceAccountOrganisationResponse(rsp *http.Response) (*ListServiceAccountOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListServiceAccountOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListServiceAccount200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateServiceAccountOrganisationResponse parses an HTTP response from a CreateServiceAccountOrganisationWithResponse call
func ParseCreateServiceAccountOrganisationResponse(rsp *http.Response) (*CreateServiceAccountOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServiceAccountOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateServiceAccount201ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteServiceAccountOrganisationResponse parses an HTTP response from a DeleteServiceAccountOrganisationWithResponse call
func ParseDeleteServiceAccountOrganisationResponse(rsp *http.Response) (*DeleteServiceAccountOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServiceAccountOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetServiceAccountOrganisationResponse parses an HTTP response from a GetServiceAccountOrganisationWithResponse call
func ParseGetServiceAccountOrganisationResponse(rsp *http.Response) (*GetServiceAccountOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceAccountOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetServiceAccount200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateServiceAccountOrganisationResponse parses an HTTP response from a UpdateServiceAccountOrganisationWithResponse call
func ParseUpdateServiceAccountOrganisationResponse(rsp *http.Response) (*UpdateServiceAccountOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateServiceAccountOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateServiceAccount200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetACLServiceAccountOrganisationResponse parses an HTTP response from a GetACLServiceAccountOrganisationWithResponse call
func ParseGetACLServiceAccountOrganisationResponse(rsp *http.Response) (*GetACLServiceAccountOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetACLServiceAccountOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetACL200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteACLServiceAccountOrganisationBulkResponse parses an HTTP response from a DeleteACLServiceAccountOrganisationBulkWithResponse call
func ParseDeleteACLServiceAccountOrganisationBulkResponse(rsp *http.Response) (*DeleteACLServiceAccountOrganisationBulkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteACLServiceAccountOrganisationBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateACLServiceAccountOrganisationBulkResponse parses an HTTP response from a CreateACLServiceAccountOrganisationBulkWithResponse call
func ParseCreateACLServiceAccountOrganisationBulkResponse(rsp *http.Response) (*CreateACLServiceAccountOrganisationBulkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateACLServiceAccountOrganisationBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListSpacesOfServiceAccountResponse parses an HTTP response from a ListSpacesOfServiceAccountWithResponse call
func ParseListSpacesOfServiceAccountResponse(rsp *http.Response) (*ListSpacesOfServiceAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSpacesOfServiceAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListSpacesServiceAccount200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListSpacesIdentityResponse parses an HTTP response from a ListSpacesIdentityWithResponse call
func ParseListSpacesIdentityResponse(rsp *http.Response) (*ListSpacesIdentityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSpacesIdentityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListSpacesIdentity200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListUserOrganisationResponse parses an HTTP response from a ListUserOrganisationWithResponse call
func ParseListUserOrganisationResponse(rsp *http.Response) (*ListUserOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUserOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListUser200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateUserOrganisationResponse parses an HTTP response from a CreateUserOrganisationWithResponse call
func ParseCreateUserOrganisationResponse(rsp *http.Response) (*CreateUserOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateUser201ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteUserOrganisationResponse parses an HTTP response from a DeleteUserOrganisationWithResponse call
func ParseDeleteUserOrganisationResponse(rsp *http.Response) (*DeleteUserOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetUserOrganisationResponse parses an HTTP response from a GetUserOrganisationWithResponse call
func ParseGetUserOrganisationResponse(rsp *http.Response) (*GetUserOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetUser200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParsePatchUserStateOrganisationResponse parses an HTTP response from a PatchUserStateOrganisationWithResponse call
func ParsePatchUserStateOrganisationResponse(rsp *http.Response) (*PatchUserStateOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchUserStateOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PatchUserState200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateUserOrganisationResponse parses an HTTP response from a UpdateUserOrganisationWithResponse call
func ParseUpdateUserOrganisationResponse(rsp *http.Response) (*UpdateUserOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateUser200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetACLUserOrganisationResponse parses an HTTP response from a GetACLUserOrganisationWithResponse call
func ParseGetACLUserOrganisationResponse(rsp *http.Response) (*GetACLUserOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetACLUserOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetACL200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteACLUserOrganisationBulkResponse parses an HTTP response from a DeleteACLUserOrganisationBulkWithResponse call
func ParseDeleteACLUserOrganisationBulkResponse(rsp *http.Response) (*DeleteACLUserOrganisationBulkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteACLUserOrganisationBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateACLUserOrganisationBulkResponse parses an HTTP response from a CreateACLUserOrganisationBulkWithResponse call
func ParseCreateACLUserOrganisationBulkResponse(rsp *http.Response) (*CreateACLUserOrganisationBulkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateACLUserOrganisationBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseRecoverUserOrganisationResponse parses an HTTP response from a RecoverUserOrganisationWithResponse call
func ParseRecoverUserOrganisationResponse(rsp *http.Response) (*RecoverUserOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RecoverUserOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecoverUser200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListSpacesOfUserResponse parses an HTTP response from a ListSpacesOfUserWithResponse call
func ParseListSpacesOfUserResponse(rsp *http.Response) (*ListSpacesOfUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSpacesOfUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListSpacesUser200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseRevokeResponse parses an HTTP response from a RevokeWithResponse call
func ParseRevokeResponse(rsp *http.Response) (*RevokeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevokeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorOauth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorOauth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetIAMGranularPolicySpaceResponse parses an HTTP response from a GetIAMGranularPolicySpaceWithResponse call
func ParseGetIAMGranularPolicySpaceResponse(rsp *http.Response) (*GetIAMGranularPolicySpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIAMGranularPolicySpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetIAMGranularPolicy200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseSetIAMGranularPolicySpaceResponse parses an HTTP response from a SetIAMGranularPolicySpaceWithResponse call
func ParseSetIAMGranularPolicySpaceResponse(rsp *http.Response) (*SetIAMGranularPolicySpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetIAMGranularPolicySpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetIAMPolicySpaceResponse parses an HTTP response from a GetIAMPolicySpaceWithResponse call
func ParseGetIAMPolicySpaceResponse(rsp *http.Response) (*GetIAMPolicySpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIAMPolicySpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetIAMPolicy200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseSetIAMPolicySpaceResponse parses an HTTP response from a SetIAMPolicySpaceWithResponse call
func ParseSetIAMPolicySpaceResponse(rsp *http.Response) (*SetIAMPolicySpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetIAMPolicySpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListPermissionsSpaceResponse parses an HTTP response from a ListPermissionsSpaceWithResponse call
func ParseListPermissionsSpaceResponse(rsp *http.Response) (*ListPermissionsSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPermissionsSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPermissions200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetPermissionSpaceResponse parses an HTTP response from a GetPermissionSpaceWithResponse call
func ParseGetPermissionSpaceResponse(rsp *http.Response) (*GetPermissionSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPermissionSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPermission200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListRolesSpaceResponse parses an HTTP response from a ListRolesSpaceWithResponse call
func ParseListRolesSpaceResponse(rsp *http.Response) (*ListRolesSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRolesSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListRoles200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateRoleSpaceResponse parses an HTTP response from a CreateRoleSpaceWithResponse call
func ParseCreateRoleSpaceResponse(rsp *http.Response) (*CreateRoleSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRoleSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateRole200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteRoleSpaceResponse parses an HTTP response from a DeleteRoleSpaceWithResponse call
func ParseDeleteRoleSpaceResponse(rsp *http.Response) (*DeleteRoleSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRoleSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetRoleSpaceResponse parses an HTTP response from a GetRoleSpaceWithResponse call
func ParseGetRoleSpaceResponse(rsp *http.Response) (*GetRoleSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRoleSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetRole200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateRoleSpaceResponse parses an HTTP response from a UpdateRoleSpaceWithResponse call
func ParseUpdateRoleSpaceResponse(rsp *http.Response) (*UpdateRoleSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRoleSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseRemoveRolePermissionsSpaceResponse parses an HTTP response from a RemoveRolePermissionsSpaceWithResponse call
func ParseRemoveRolePermissionsSpaceResponse(rsp *http.Response) (*RemoveRolePermissionsSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveRolePermissionsSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetRolePermissionsSpaceResponse parses an HTTP response from a GetRolePermissionsSpaceWithResponse call
func ParseGetRolePermissionsSpaceResponse(rsp *http.Response) (*GetRolePermissionsSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRolePermissionsSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetRolePermissions200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseAddRolePermissionsSpaceResponse parses an HTTP response from a AddRolePermissionsSpaceWithResponse call
func ParseAddRolePermissionsSpaceResponse(rsp *http.Response) (*AddRolePermissionsSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddRolePermissionsSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListServiceAccountSpaceResponse parses an HTTP response from a ListServiceAccountSpaceWithResponse call
func ParseListServiceAccountSpaceResponse(rsp *http.Response) (*ListServiceAccountSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListServiceAccountSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListServiceAccount200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateServiceAccountSpaceResponse parses an HTTP response from a CreateServiceAccountSpaceWithResponse call
func ParseCreateServiceAccountSpaceResponse(rsp *http.Response) (*CreateServiceAccountSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServiceAccountSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateServiceAccount201ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteServiceAccountSpaceResponse parses an HTTP response from a DeleteServiceAccountSpaceWithResponse call
func ParseDeleteServiceAccountSpaceResponse(rsp *http.Response) (*DeleteServiceAccountSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServiceAccountSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetServiceAccountSpaceResponse parses an HTTP response from a GetServiceAccountSpaceWithResponse call
func ParseGetServiceAccountSpaceResponse(rsp *http.Response) (*GetServiceAccountSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceAccountSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetServiceAccount200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseAssignServiceAccountToSpaceResponse parses an HTTP response from a AssignServiceAccountToSpaceWithResponse call
func ParseAssignServiceAccountToSpaceResponse(rsp *http.Response) (*AssignServiceAccountToSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignServiceAccountToSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateServiceAccountSpaceResponse parses an HTTP response from a UpdateServiceAccountSpaceWithResponse call
func ParseUpdateServiceAccountSpaceResponse(rsp *http.Response) (*UpdateServiceAccountSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateServiceAccountSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateServiceAccount200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetACLServiceAccountSpaceResponse parses an HTTP response from a GetACLServiceAccountSpaceWithResponse call
func ParseGetACLServiceAccountSpaceResponse(rsp *http.Response) (*GetACLServiceAccountSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetACLServiceAccountSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetACL200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteACLServiceAccountSpaceBulkResponse parses an HTTP response from a DeleteACLServiceAccountSpaceBulkWithResponse call
func ParseDeleteACLServiceAccountSpaceBulkResponse(rsp *http.Response) (*DeleteACLServiceAccountSpaceBulkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteACLServiceAccountSpaceBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateACLServiceAccountSpaceBulkResponse parses an HTTP response from a CreateACLServiceAccountSpaceBulkWithResponse call
func ParseCreateACLServiceAccountSpaceBulkResponse(rsp *http.Response) (*CreateACLServiceAccountSpaceBulkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateACLServiceAccountSpaceBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListUserSpaceResponse parses an HTTP response from a ListUserSpaceWithResponse call
func ParseListUserSpaceResponse(rsp *http.Response) (*ListUserSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUserSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListUser200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateUserSpaceResponse parses an HTTP response from a CreateUserSpaceWithResponse call
func ParseCreateUserSpaceResponse(rsp *http.Response) (*CreateUserSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateUser201ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteUserSpaceResponse parses an HTTP response from a DeleteUserSpaceWithResponse call
func ParseDeleteUserSpaceResponse(rsp *http.Response) (*DeleteUserSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetUserSpaceResponse parses an HTTP response from a GetUserSpaceWithResponse call
func ParseGetUserSpaceResponse(rsp *http.Response) (*GetUserSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetUser200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParsePatchUserStateSpaceResponse parses an HTTP response from a PatchUserStateSpaceWithResponse call
func ParsePatchUserStateSpaceResponse(rsp *http.Response) (*PatchUserStateSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchUserStateSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PatchUserState200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseAssignUserToSpaceResponse parses an HTTP response from a AssignUserToSpaceWithResponse call
func ParseAssignUserToSpaceResponse(rsp *http.Response) (*AssignUserToSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignUserToSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateUserSpaceResponse parses an HTTP response from a UpdateUserSpaceWithResponse call
func ParseUpdateUserSpaceResponse(rsp *http.Response) (*UpdateUserSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateUser200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetACLUserSpaceResponse parses an HTTP response from a GetACLUserSpaceWithResponse call
func ParseGetACLUserSpaceResponse(rsp *http.Response) (*GetACLUserSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetACLUserSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetACL200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteACLUserSpaceBulkResponse parses an HTTP response from a DeleteACLUserSpaceBulkWithResponse call
func ParseDeleteACLUserSpaceBulkResponse(rsp *http.Response) (*DeleteACLUserSpaceBulkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteACLUserSpaceBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateACLUserSpaceBulkResponse parses an HTTP response from a CreateACLUserSpaceBulkWithResponse call
func ParseCreateACLUserSpaceBulkResponse(rsp *http.Response) (*CreateACLUserSpaceBulkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateACLUserSpaceBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseRecoverUserSpaceResponse parses an HTTP response from a RecoverUserSpaceWithResponse call
func ParseRecoverUserSpaceResponse(rsp *http.Response) (*RecoverUserSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RecoverUserSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecoverUser200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseTokenResponse parses an HTTP response from a TokenWithResponse call
func ParseTokenResponse(rsp *http.Response) (*TokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorOauth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorOauth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorOauth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserInfoResponse parses an HTTP response from a GetUserInfoWithResponse call
func ParseGetUserInfoResponse(rsp *http.Response) (*GetUserInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetUserInfo200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorOauth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListClustersResponse parses an HTTP response from a ListClustersWithResponse call
func ParseListClustersResponse(rsp *http.Response) (*ListClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClustersResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateClusterResponse parses an HTTP response from a CreateClusterWithResponse call
func ParseCreateClusterResponse(rsp *http.Response) (*CreateClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ClusterCreateResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteClusterResponse parses an HTTP response from a DeleteClusterWithResponse call
func ParseDeleteClusterResponse(rsp *http.Response) (*DeleteClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ClusterDeleteResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetClusterResponse parses an HTTP response from a GetClusterWithResponse call
func ParseGetClusterResponse(rsp *http.Response) (*GetClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterGetResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateClusterResponse parses an HTTP response from a UpdateClusterWithResponse call
func ParseUpdateClusterResponse(rsp *http.Response) (*UpdateClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterGetResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListNodepoolsResponse parses an HTTP response from a ListNodepoolsWithResponse call
func ParseListNodepoolsResponse(rsp *http.Response) (*ListNodepoolsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListNodepoolsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NodepoolsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateNodePoolResponse parses an HTTP response from a CreateNodePoolWithResponse call
func ParseCreateNodePoolResponse(rsp *http.Response) (*CreateNodePoolResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNodePoolResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest NodepoolCreateResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteNodePoolResponse parses an HTTP response from a DeleteNodePoolWithResponse call
func ParseDeleteNodePoolResponse(rsp *http.Response) (*DeleteNodePoolResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNodePoolResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest NodepoolDeleteResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateNodepoolResponse parses an HTTP response from a UpdateNodepoolWithResponse call
func ParseUpdateNodepoolResponse(rsp *http.Response) (*UpdateNodepoolResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateNodepoolResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest UpdateNodeCountResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListOperationsResponse parses an HTTP response from a ListOperationsWithResponse call
func ParseListOperationsResponse(rsp *http.Response) (*ListOperationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListOperationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OperationsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetOperationResponse parses an HTTP response from a GetOperationWithResponse call
func ParseGetOperationResponse(rsp *http.Response) (*GetOperationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOperationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OperationResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListVersionsResponse parses an HTTP response from a ListVersionsWithResponse call
func ParseListVersionsResponse(rsp *http.Response) (*ListVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VersionsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSpaceResponse parses an HTTP response from a DeleteSpaceWithResponse call
func ParseDeleteSpaceResponse(rsp *http.Response) (*DeleteSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetSpaceByIdResponse parses an HTTP response from a GetSpaceByIdWithResponse call
func ParseGetSpaceByIdResponse(rsp *http.Response) (*GetSpaceByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpaceByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetSpaceById200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateSpaceResponse parses an HTTP response from a UpdateSpaceWithResponse call
func ParseUpdateSpaceResponse(rsp *http.Response) (*UpdateSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListSpacesResponse parses an HTTP response from a ListSpacesWithResponse call
func ParseListSpacesResponse(rsp *http.Response) (*ListSpacesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSpacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListSpaces200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateSpaceResponse parses an HTTP response from a CreateSpaceWithResponse call
func ParseCreateSpaceResponse(rsp *http.Response) (*CreateSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateSpace200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}
