// Package numspot provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package numspot

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BasicAuthScopes  = "BasicAuth.Scopes"
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for AuthenticatorAssuranceLevel.
const (
	Aal0 AuthenticatorAssuranceLevel = "aal0"
	Aal1 AuthenticatorAssuranceLevel = "aal1"
	Aal2 AuthenticatorAssuranceLevel = "aal2"
	Aal3 AuthenticatorAssuranceLevel = "aal3"
)

// Defines values for ChecksumAlgorithm.
const (
	CRC32  ChecksumAlgorithm = "CRC32"
	CRC32C ChecksumAlgorithm = "CRC32C"
	SHA1   ChecksumAlgorithm = "SHA1"
	SHA256 ChecksumAlgorithm = "SHA256"
)

// Defines values for ContinueWithRecoveryUiAction.
const (
	ShowRecoveryUi ContinueWithRecoveryUiAction = "show_recovery_ui"
)

// Defines values for ContinueWithSetSessionTokenAction.
const (
	SetSessionToken ContinueWithSetSessionTokenAction = "set_session_token"
)

// Defines values for ContinueWithSettingsUiAction.
const (
	ShowSettingsUi ContinueWithSettingsUiAction = "show_settings_ui"
)

// Defines values for ContinueWithVerificationUiAction.
const (
	ShowVerificationUi ContinueWithVerificationUiAction = "show_verification_ui"
)

// Defines values for CreateVmsPerformance.
const (
	CreateVmsPerformanceHigh    CreateVmsPerformance = "high"
	CreateVmsPerformanceHighest CreateVmsPerformance = "highest"
	CreateVmsPerformanceMedium  CreateVmsPerformance = "medium"
)

// Defines values for EncodingType.
const (
	EncodingTypeUrl EncodingType = "url"
)

// Defines values for ErrorDocumentationUrl.
const (
	HttpsportalApiNumspotComerrorsAmbiguousGranularPermissionElements ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#ambiguous_granular_permission_elements"
	HttpsportalApiNumspotComerrorsAmbiguousPermissionElements         ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#ambiguous_permission_elements"
	HttpsportalApiNumspotComerrorsAmbiguousRoleElements               ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#ambiguous_role_elements"
	HttpsportalApiNumspotComerrorsDuplicateResource                   ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#duplicate_resource"
	HttpsportalApiNumspotComerrorsDuplicateRole                       ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#duplicate_role"
	HttpsportalApiNumspotComerrorsForbidden                           ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#forbidden"
	HttpsportalApiNumspotComerrorsForbiddenAccess                     ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#forbidden_access"
	HttpsportalApiNumspotComerrorsIdentityNotFound                    ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#identity_not_found"
	HttpsportalApiNumspotComerrorsInactiveToken                       ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#inactive_token"
	HttpsportalApiNumspotComerrorsInternalServerError                 ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#internal_server_error"
	HttpsportalApiNumspotComerrorsInvalidParameter                    ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#invalid_parameter"
	HttpsportalApiNumspotComerrorsMethodNotAllowed                    ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#method_not_allowed"
	HttpsportalApiNumspotComerrorsMissingRoles                        ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#missing_roles"
	HttpsportalApiNumspotComerrorsNamespaceNotFound                   ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#namespace_not_found"
	HttpsportalApiNumspotComerrorsNotInTenantRoles                    ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#not_in_tenant_roles"
	HttpsportalApiNumspotComerrorsPermissionNotFound                  ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#permission_not_found"
	HttpsportalApiNumspotComerrorsResourceNotFound                    ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#resource_not_found"
	HttpsportalApiNumspotComerrorsRoleNotFound                        ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#role_not_found"
	HttpsportalApiNumspotComerrorsUnauthenticatedAccess               ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#unauthenticated_access"
	HttpsportalApiNumspotComerrorsUnexpectedTokenUsage                ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#unexpected_token_usage"
	HttpsportalApiNumspotComerrorsUriTooLong                          ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#uri_too_long"
)

// Defines values for Gpu.
const (
	GpuA10080 Gpu = "A100-80"
	GpuP100   Gpu = "P100"
	GpuP6     Gpu = "P6"
	GpuV100   Gpu = "V100"
)

// Defines values for IdentityState.
const (
	Active   IdentityState = "active"
	Inactive IdentityState = "inactive"
)

// Defines values for IdentityCredentialsType.
const (
	IdentityCredentialsTypeCode         IdentityCredentialsType = "code"
	IdentityCredentialsTypeCodeRecovery IdentityCredentialsType = "code_recovery"
	IdentityCredentialsTypeLinkRecovery IdentityCredentialsType = "link_recovery"
	IdentityCredentialsTypeLookupSecret IdentityCredentialsType = "lookup_secret"
	IdentityCredentialsTypeOidc         IdentityCredentialsType = "oidc"
	IdentityCredentialsTypePassword     IdentityCredentialsType = "password"
	IdentityCredentialsTypeTotp         IdentityCredentialsType = "totp"
	IdentityCredentialsTypeWebauthn     IdentityCredentialsType = "webauthn"
)

// Defines values for ImmutableSpaceStatus.
const (
	ImmutableSpaceStatusFAILED  ImmutableSpaceStatus = "FAILED"
	ImmutableSpaceStatusQUEUED  ImmutableSpaceStatus = "QUEUED"
	ImmutableSpaceStatusREADY   ImmutableSpaceStatus = "READY"
	ImmutableSpaceStatusRUNNING ImmutableSpaceStatus = "RUNNING"
)

// Defines values for KubernetesClusterVersion.
const (
	KubernetesClusterVersionN12714 KubernetesClusterVersion = "1.27.14"
	KubernetesClusterVersionN12810 KubernetesClusterVersion = "1.28.10"
	KubernetesClusterVersionN1295  KubernetesClusterVersion = "1.29.5"
)

// Defines values for KubernetesClusterConfigurationVersion.
const (
	KubernetesClusterConfigurationVersionN12714 KubernetesClusterConfigurationVersion = "1.27.14"
	KubernetesClusterConfigurationVersionN12810 KubernetesClusterConfigurationVersion = "1.28.10"
	KubernetesClusterConfigurationVersionN1295  KubernetesClusterConfigurationVersion = "1.29.5"
)

// Defines values for KubernetesNodePoolGpuType.
const (
	KubernetesNodePoolGpuTypeA10080 KubernetesNodePoolGpuType = "A100-80"
	KubernetesNodePoolGpuTypeP100   KubernetesNodePoolGpuType = "P100"
	KubernetesNodePoolGpuTypeP6     KubernetesNodePoolGpuType = "P6"
	KubernetesNodePoolGpuTypeV100   KubernetesNodePoolGpuType = "V100"
)

// Defines values for KubernetesNodeProfileName.
const (
	KubernetesNodeProfileNameLarge     KubernetesNodeProfileName = "large"
	KubernetesNodeProfileNameMedium    KubernetesNodeProfileName = "medium"
	KubernetesNodeProfileNameMediumgpu KubernetesNodeProfileName = "mediumgpu"
	KubernetesNodeProfileNameSmall     KubernetesNodeProfileName = "small"
	KubernetesNodeProfileNameVerysmall KubernetesNodeProfileName = "verysmall"
)

// Defines values for KubernetesNodeRemovalNodeProfile.
const (
	KubernetesNodeRemovalNodeProfileLarge     KubernetesNodeRemovalNodeProfile = "large"
	KubernetesNodeRemovalNodeProfileMedium    KubernetesNodeRemovalNodeProfile = "medium"
	KubernetesNodeRemovalNodeProfileMediumgpu KubernetesNodeRemovalNodeProfile = "mediumgpu"
	KubernetesNodeRemovalNodeProfileSmall     KubernetesNodeRemovalNodeProfile = "small"
	KubernetesNodeRemovalNodeProfileVerysmall KubernetesNodeRemovalNodeProfile = "verysmall"
)

// Defines values for KubernetesNodeUpgradeVersion.
const (
	N12714 KubernetesNodeUpgradeVersion = "1.27.14"
	N12810 KubernetesNodeUpgradeVersion = "1.28.10"
	N1295  KubernetesNodeUpgradeVersion = "1.29.5"
)

// Defines values for KubernetesOperationStatus.
const (
	KubernetesOperationStatusDONE    KubernetesOperationStatus = "DONE"
	KubernetesOperationStatusFAILED  KubernetesOperationStatus = "FAILED"
	KubernetesOperationStatusPENDING KubernetesOperationStatus = "PENDING"
	KubernetesOperationStatusRUNNING KubernetesOperationStatus = "RUNNING"
)

// Defines values for KubernetesOperationType.
const (
	KubernetesOperationTypeAddWorker      KubernetesOperationType = "AddWorker"
	KubernetesOperationTypeCreateCluster  KubernetesOperationType = "CreateCluster"
	KubernetesOperationTypeDeleteCluster  KubernetesOperationType = "DeleteCluster"
	KubernetesOperationTypeRemoveWorker   KubernetesOperationType = "RemoveWorker"
	KubernetesOperationTypeUpdateWorker   KubernetesOperationType = "UpdateWorker"
	KubernetesOperationTypeUpgradeMasters KubernetesOperationType = "UpgradeMasters"
	KubernetesOperationTypeUpgradeWorkers KubernetesOperationType = "UpgradeWorkers"
)

// Defines values for KubernetesStatusStatus.
const (
	CONNECTED    KubernetesStatusStatus = "CONNECTED"
	DISCONNECTED KubernetesStatusStatus = "DISCONNECTED"
)

// Defines values for LoginFlowActive.
const (
	LoginFlowActiveCode         LoginFlowActive = "code"
	LoginFlowActiveCodeRecovery LoginFlowActive = "code_recovery"
	LoginFlowActiveLinkRecovery LoginFlowActive = "link_recovery"
	LoginFlowActiveLookupSecret LoginFlowActive = "lookup_secret"
	LoginFlowActiveOidc         LoginFlowActive = "oidc"
	LoginFlowActivePassword     LoginFlowActive = "password"
	LoginFlowActiveTotp         LoginFlowActive = "totp"
	LoginFlowActiveWebauthn     LoginFlowActive = "webauthn"
)

// Defines values for NodeProfile.
const (
	LARGE     NodeProfile = "LARGE"
	MEDIUM    NodeProfile = "MEDIUM"
	SMALL     NodeProfile = "SMALL"
	VERYLARGE NodeProfile = "VERY_LARGE"
)

// Defines values for ObjectStorageClass.
const (
	DEEPARCHIVE        ObjectStorageClass = "DEEP_ARCHIVE"
	GLACIER            ObjectStorageClass = "GLACIER"
	GLACIERIR          ObjectStorageClass = "GLACIER_IR"
	INTELLIGENTTIERING ObjectStorageClass = "INTELLIGENT_TIERING"
	ONEZONEIA          ObjectStorageClass = "ONEZONE_IA"
	OUTPOSTS           ObjectStorageClass = "OUTPOSTS"
	REDUCEDREDUNDANCY  ObjectStorageClass = "REDUCED_REDUNDANCY"
	SNOW               ObjectStorageClass = "SNOW"
	STANDARD           ObjectStorageClass = "STANDARD"
	STANDARDIA         ObjectStorageClass = "STANDARD_IA"
)

// Defines values for OperationStatus.
const (
	OperationStatusDONE    OperationStatus = "DONE"
	OperationStatusFAILED  OperationStatus = "FAILED"
	OperationStatusPENDING OperationStatus = "PENDING"
	OperationStatusRUNNING OperationStatus = "RUNNING"
)

// Defines values for RegistrationFlowActive.
const (
	RegistrationFlowActiveCode         RegistrationFlowActive = "code"
	RegistrationFlowActiveCodeRecovery RegistrationFlowActive = "code_recovery"
	RegistrationFlowActiveLinkRecovery RegistrationFlowActive = "link_recovery"
	RegistrationFlowActiveLookupSecret RegistrationFlowActive = "lookup_secret"
	RegistrationFlowActiveOidc         RegistrationFlowActive = "oidc"
	RegistrationFlowActivePassword     RegistrationFlowActive = "password"
	RegistrationFlowActiveTotp         RegistrationFlowActive = "totp"
	RegistrationFlowActiveWebauthn     RegistrationFlowActive = "webauthn"
)

// Defines values for SessionAuthenticationMethodMethod.
const (
	SessionAuthenticationMethodMethodCode             SessionAuthenticationMethodMethod = "code"
	SessionAuthenticationMethodMethodCodeRecovery     SessionAuthenticationMethodMethod = "code_recovery"
	SessionAuthenticationMethodMethodLinkRecovery     SessionAuthenticationMethodMethod = "link_recovery"
	SessionAuthenticationMethodMethodLookupSecret     SessionAuthenticationMethodMethod = "lookup_secret"
	SessionAuthenticationMethodMethodOidc             SessionAuthenticationMethodMethod = "oidc"
	SessionAuthenticationMethodMethodPassword         SessionAuthenticationMethodMethod = "password"
	SessionAuthenticationMethodMethodTotp             SessionAuthenticationMethodMethod = "totp"
	SessionAuthenticationMethodMethodV06LegacySession SessionAuthenticationMethodMethod = "v0.6_legacy_session"
	SessionAuthenticationMethodMethodWebauthn         SessionAuthenticationMethodMethod = "webauthn"
)

// Defines values for SpaceStatus.
const (
	SpaceStatusFAILED  SpaceStatus = "FAILED"
	SpaceStatusQUEUED  SpaceStatus = "QUEUED"
	SpaceStatusREADY   SpaceStatus = "READY"
	SpaceStatusRUNNING SpaceStatus = "RUNNING"
)

// Defines values for SubjectType.
const (
	ServiceAccounts SubjectType = "serviceAccounts"
	Users           SubjectType = "users"
)

// Defines values for UiNodeGroup.
const (
	UiNodeGroupCode         UiNodeGroup = "code"
	UiNodeGroupDefault      UiNodeGroup = "default"
	UiNodeGroupLink         UiNodeGroup = "link"
	UiNodeGroupLookupSecret UiNodeGroup = "lookup_secret"
	UiNodeGroupOidc         UiNodeGroup = "oidc"
	UiNodeGroupPassword     UiNodeGroup = "password"
	UiNodeGroupProfile      UiNodeGroup = "profile"
	UiNodeGroupTotp         UiNodeGroup = "totp"
	UiNodeGroupWebauthn     UiNodeGroup = "webauthn"
)

// Defines values for UiNodeType.
const (
	A      UiNodeType = "a"
	Img    UiNodeType = "img"
	Input  UiNodeType = "input"
	Script UiNodeType = "script"
	Text   UiNodeType = "text"
)

// Defines values for UiNodeInputAttributesAutocomplete.
const (
	UiNodeInputAttributesAutocompleteCurrentPassword UiNodeInputAttributesAutocomplete = "current-password"
	UiNodeInputAttributesAutocompleteEmail           UiNodeInputAttributesAutocomplete = "email"
	UiNodeInputAttributesAutocompleteNewPassword     UiNodeInputAttributesAutocomplete = "new-password"
	UiNodeInputAttributesAutocompleteOneTimeCode     UiNodeInputAttributesAutocomplete = "one-time-code"
	UiNodeInputAttributesAutocompleteTel             UiNodeInputAttributesAutocomplete = "tel"
	UiNodeInputAttributesAutocompleteUrl             UiNodeInputAttributesAutocomplete = "url"
)

// Defines values for UiNodeInputAttributesType.
const (
	UiNodeInputAttributesTypeButton        UiNodeInputAttributesType = "button"
	UiNodeInputAttributesTypeCheckbox      UiNodeInputAttributesType = "checkbox"
	UiNodeInputAttributesTypeDate          UiNodeInputAttributesType = "date"
	UiNodeInputAttributesTypeDatetimeLocal UiNodeInputAttributesType = "datetime-local"
	UiNodeInputAttributesTypeEmail         UiNodeInputAttributesType = "email"
	UiNodeInputAttributesTypeHidden        UiNodeInputAttributesType = "hidden"
	UiNodeInputAttributesTypeNumber        UiNodeInputAttributesType = "number"
	UiNodeInputAttributesTypePassword      UiNodeInputAttributesType = "password"
	UiNodeInputAttributesTypeSubmit        UiNodeInputAttributesType = "submit"
	UiNodeInputAttributesTypeTel           UiNodeInputAttributesType = "tel"
	UiNodeInputAttributesTypeText          UiNodeInputAttributesType = "text"
	UiNodeInputAttributesTypeUrl           UiNodeInputAttributesType = "url"
)

// Defines values for UiTextType.
const (
	UiTextTypeError   UiTextType = "error"
	UiTextTypeInfo    UiTextType = "info"
	UiTextTypeSuccess UiTextType = "success"
)

// Defines values for UpdateRecoveryFlowWithCodeMethodMethod.
const (
	UpdateRecoveryFlowWithCodeMethodMethodCode UpdateRecoveryFlowWithCodeMethodMethod = "code"
	UpdateRecoveryFlowWithCodeMethodMethodLink UpdateRecoveryFlowWithCodeMethodMethod = "link"
)

// Defines values for UpdateRecoveryFlowWithLinkMethodMethod.
const (
	UpdateRecoveryFlowWithLinkMethodMethodCode UpdateRecoveryFlowWithLinkMethodMethod = "code"
	UpdateRecoveryFlowWithLinkMethodMethodLink UpdateRecoveryFlowWithLinkMethodMethod = "link"
)

// Defines values for UpdateVerificationFlowWithCodeMethodMethod.
const (
	UpdateVerificationFlowWithCodeMethodMethodCode UpdateVerificationFlowWithCodeMethodMethod = "code"
	UpdateVerificationFlowWithCodeMethodMethodLink UpdateVerificationFlowWithCodeMethodMethod = "link"
)

// Defines values for UpdateVerificationFlowWithLinkMethodMethod.
const (
	UpdateVerificationFlowWithLinkMethodMethodCode UpdateVerificationFlowWithLinkMethodMethod = "code"
	UpdateVerificationFlowWithLinkMethodMethodLink UpdateVerificationFlowWithLinkMethodMethod = "link"
)

// Defines values for UpdateVmPerformance.
const (
	UpdateVmPerformanceHigh    UpdateVmPerformance = "high"
	UpdateVmPerformanceHighest UpdateVmPerformance = "highest"
	UpdateVmPerformanceMedium  UpdateVmPerformance = "medium"
)

// Defines values for VerifiableIdentityAddressVia.
const (
	VerifiableIdentityAddressViaEmail VerifiableIdentityAddressVia = "email"
	VerifiableIdentityAddressViaSms   VerifiableIdentityAddressVia = "sms"
)

// Defines values for CreateMultipartUploadParamsUploads.
const (
	True CreateMultipartUploadParamsUploads = true
)

// ACL defines model for ACL.
type ACL struct {
	// PermissionId id of the permission
	PermissionId openapi_types.UUID `json:"permissionId"`

	// Resource Type of the resource being accessed
	Resource string `json:"resource"`

	// ResourceId Unique identifier of a resource
	ResourceId string `json:"resourceId"`

	// Service Name of the service making the call
	Service string `json:"service"`

	// Subresource Specific type of the subresource within the main resource
	Subresource *string `json:"subresource,omitempty"`
}

// ACLList List of ACLs.
type ACLList struct {
	Items []ACL `json:"items"`
}

// ACLPaginatedList defines model for ACLPaginatedList.
type ACLPaginatedList struct {
	Items []ACL `json:"items"`

	// NextPageToken This token is used to retrieve the next page. If this field is omitted, there are no subsequent pages.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// TotalSize Equivalent to int32
	TotalSize *Int `json:"totalSize,omitempty"`
}

// AbortMultipartUploadOutput defines model for AbortMultipartUploadOutput.
type AbortMultipartUploadOutput = map[string]interface{}

// AcceptVpcPeering defines model for AcceptVpcPeering.
type AcceptVpcPeering struct {
	// VpcPeering Information about the Vpc peering.
	VpcPeering *VpcPeering `json:"vpcPeering,omitempty"`
}

// AccepterVpc Information about the accepter Vpc.
type AccepterVpc struct {
	// IpRange The IP range for the accepter Net, in CIDR notation (for example, `10.0.0.0/16`).
	IpRange *string `json:"ipRange,omitempty"`

	// VpcId The ID of the accepter Vpc.
	VpcId *string `json:"vpcId,omitempty"`
}

// Access Permissions for the resource.
type Access struct {
	// IsPublic A global permission for all accounts.<br />
	// (Request) Set this parameter to true to make the resource public (if the parent parameter is `Additions`) or to make the resource private (if the parent parameter is `Removals`).<br />
	// (Response) If true, the resource is public. If false, the resource is private.
	IsPublic *bool `json:"isPublic,omitempty"`
}

// AccessCreation Information about the permissions for the resource.<br />
// Specify either the `Additions` or the `Removals` parameter.
type AccessCreation struct {
	// Additions Permissions for the resource.
	Additions *Access `json:"additions,omitempty"`

	// Removals Permissions for the resource.
	Removals *Access `json:"removals,omitempty"`
}

// ApplicationStickyCookiePolicy Information about the stickiness policy.
type ApplicationStickyCookiePolicy struct {
	// CookieName The name of the application cookie used for stickiness.
	CookieName *string `json:"cookieName,omitempty"`

	// PolicyName The mnemonic name for the policy being created. The name must be unique within a set of policies for this load balancer.
	PolicyName *string `json:"policyName,omitempty"`
}

// AuthenticatorAssuranceLevel The authenticator assurance level can be one of "aal1", "aal2", or "aal3". A higher number means that it is harder
// for an attacker to compromise the account.
// Generally, "aal1" implies that one authentication factor was used while AAL2 implies that two factors (password + TOTP) have been used.
type AuthenticatorAssuranceLevel string

// BackendVmHealth Information about the health of a back-end VM.
type BackendVmHealth struct {
	// Description The description of the state of the back-end VM.
	Description *string `json:"description,omitempty"`

	// State The state of the back-end VM (`InService` \| `OutOfService` \| `Unknown`).
	State *string `json:"state,omitempty"`

	// StateReason Information about the cause of `OutOfService` VMs.<br />
	//  Specifically, whether the cause is Elastic Load Balancing or the VM (`ELB` \| `Instance` \| `N/A`).
	StateReason *string `json:"stateReason,omitempty"`

	// VmId The ID of the back-end VM.
	VmId *string `json:"vmId,omitempty"`
}

// BadRequestError defines model for BadRequestError.
type BadRequestError struct {
	// Detail Human-readable explanation specific to this occurrence of the problem.
	Detail   *string `json:"detail,omitempty"`
	Instance *Url    `json:"instance,omitempty"`

	// Title Human-readable summary of the problem type.
	Title string `json:"title"`

	// Type Documentation URL for the domain error
	Type ErrorDocumentationUrl `json:"type"`

	// Violations Array of violations to provide a per-field detail.
	Violations *[]Violation `json:"violations,omitempty"`
}

// BlockDeviceMappingCreated Information about the created block device mapping.
type BlockDeviceMappingCreated struct {
	// Bsu Information about the created BSU volume.
	Bsu *BsuCreated `json:"bsu,omitempty"`

	// DeviceName The name of the device.
	DeviceName *string `json:"deviceName,omitempty"`
}

// BlockDeviceMappingImage One or more parameters used to automatically set up volumes when the VM is created.
type BlockDeviceMappingImage struct {
	// Bsu Information about the BSU volume to create.
	Bsu *BsuToCreate `json:"bsu,omitempty"`

	// DeviceName The device name for the volume. For a root device, you must use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, and the second `X` is a letter between `a` and `z`).
	DeviceName *string `json:"deviceName,omitempty"`

	// VirtualDeviceName The name of the virtual device (`ephemeralN`).
	VirtualDeviceName *string `json:"virtualDeviceName,omitempty"`
}

// BlockDeviceMappingVmCreation Information about the block device mapping.
type BlockDeviceMappingVmCreation struct {
	// Bsu Information about the BSU volume to create.
	Bsu *BsuToCreate `json:"bsu,omitempty"`

	// DeviceName The device name for the volume. For a root device, you must use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, and the second `X` is a letter between `a` and `z`).
	DeviceName *string `json:"deviceName,omitempty"`

	// NoDevice Removes the device which is included in the block device mapping of the OMI.
	NoDevice *string `json:"noDevice,omitempty"`

	// VirtualDeviceName The name of the virtual device (`ephemeralN`).
	VirtualDeviceName *string `json:"virtualDeviceName,omitempty"`
}

// BlockDeviceMappingVmUpdate Information about the block device mapping.
type BlockDeviceMappingVmUpdate struct {
	// Bsu Information about the BSU volume.
	Bsu *BsuToUpdateVm `json:"bsu,omitempty"`

	// DeviceName The device name for the volume. For a root device, you must use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, and the second `X` is a letter between `a` and `z`).
	DeviceName *string `json:"deviceName,omitempty"`

	// NoDevice Removes the device which is included in the block device mapping of the OMI.
	NoDevice *string `json:"noDevice,omitempty"`

	// VirtualDeviceName The name of the virtual device (`ephemeralN`).
	VirtualDeviceName *string `json:"virtualDeviceName,omitempty"`
}

// Body defines model for Body.
type Body = string

// BsuCreated Information about the created BSU volume.
type BsuCreated struct {
	// DeleteOnVmDeletion If true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.
	DeleteOnVmDeletion *bool `json:"deleteOnVmDeletion,omitempty"`

	// LinkDate The date and time of attachment of the volume to the VM, in ISO 8601 date-time format.
	LinkDate *time.Time `json:"linkDate,omitempty"`

	// State The state of the volume.
	State *string `json:"state,omitempty"`

	// VolumeId The ID of the volume.
	VolumeId *string `json:"volumeId,omitempty"`
}

// BsuToCreate Information about the BSU volume to create.
type BsuToCreate struct {
	// DeleteOnVmDeletion By default or if set to true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.
	DeleteOnVmDeletion *bool `json:"deleteOnVmDeletion,omitempty"`

	// Iops The number of I/O operations per second (IOPS). This parameter must be specified only if you create an `io1` volume. The maximum number of IOPS allowed for `io1` volumes is `13000` with a maximum performance ratio of 300 IOPS per gibibyte.
	Iops *int `json:"iops,omitempty"`

	// SnapshotId The ID of the snapshot used to create the volume.
	SnapshotId *string `json:"snapshotId,omitempty"`

	// VolumeSize The size of the volume, in gibibytes (GiB).<br />
	// If you specify a snapshot ID, the volume size must be at least equal to the snapshot size.<br />
	// If you specify a snapshot ID but no volume size, the volume is created with a size similar to the snapshot one.
	VolumeSize *int `json:"volumeSize,omitempty"`

	// VolumeType The type of the volume (`standard` \| `io1` \| `gp2`). If not specified in the request, a `standard` volume is created.<br />
	VolumeType *string `json:"volumeType,omitempty"`
}

// BsuToUpdateVm Information about the BSU volume.
type BsuToUpdateVm struct {
	// DeleteOnVmDeletion If set to true, the volume is deleted when terminating the VM. If set to false, the volume is not deleted when terminating the VM.
	DeleteOnVmDeletion *bool `json:"deleteOnVmDeletion,omitempty"`

	// VolumeId The ID of the volume.
	VolumeId *string `json:"volumeId,omitempty"`
}

// Bucket defines model for Bucket.
type Bucket struct {
	CreationDate *CreationDate `json:"CreationDate,omitempty"`
	Name         *BucketName   `json:"Name,omitempty"`
}

// BucketAlreadyExists defines model for BucketAlreadyExists.
type BucketAlreadyExists = interface{}

// BucketAlreadyOwnedByYou defines model for BucketAlreadyOwnedByYou.
type BucketAlreadyOwnedByYou = interface{}

// BucketName defines model for BucketName.
type BucketName = string

// Buckets defines model for Buckets.
type Buckets = []struct {
	CreationDate *CreationDate `json:"CreationDate,omitempty"`
	Name         *BucketName   `json:"Name,omitempty"`
}

// ChecksumAlgorithm defines model for ChecksumAlgorithm.
type ChecksumAlgorithm string

// ChecksumAlgorithmList defines model for ChecksumAlgorithmList.
type ChecksumAlgorithmList = []ChecksumAlgorithm

// ChecksumCRC32 defines model for ChecksumCRC32.
type ChecksumCRC32 = string

// ChecksumCRC32C defines model for ChecksumCRC32C.
type ChecksumCRC32C = string

// ChecksumSHA1 defines model for ChecksumSHA1.
type ChecksumSHA1 = string

// ChecksumSHA256 defines model for ChecksumSHA256.
type ChecksumSHA256 = string

// ClientGateway Information about the client gateway.
type ClientGateway struct {
	// BgpAsn The Autonomous System Number (ASN) used by the Border Gateway Protocol (BGP) to find the path to your client gateway through the Internet.
	BgpAsn *int `json:"bgpAsn,omitempty"`

	// ConnectionType The type of communication tunnel used by the client gateway (only `ipsec.1` is supported).
	ConnectionType *string `json:"connectionType,omitempty"`

	// Id The ID of the client gateway.
	Id *string `json:"id,omitempty"`

	// PublicIp The public IPv4 address of the client gateway (must be a fixed address into a NATed network).
	PublicIp *string `json:"publicIp,omitempty"`

	// State The state of the client gateway (`pending` \| `available` \| `deleting` \| `deleted`).
	State *string `json:"state,omitempty"`

	// Tags One or more tags associated with the client gateway.
	Tags *[]ResourceTag `json:"tags,omitempty"`
}

// CommonPrefix defines model for CommonPrefix.
type CommonPrefix struct {
	Prefix *Prefix `json:"Prefix,omitempty"`
}

// CommonPrefixList defines model for CommonPrefixList.
type CommonPrefixList = []CommonPrefix

// CompleteMultipartInput defines model for CompleteMultipartInput.
type CompleteMultipartInput struct {
	CompleteMultipartUpload *struct {
		Parts *[]interface{} `json:"Parts,omitempty"`
	} `json:"CompleteMultipartUpload,omitempty"`
}

// CompleteMultipartUploadOutput defines model for CompleteMultipartUploadOutput.
type CompleteMultipartUploadOutput struct {
	Bucket         *BucketName     `json:"Bucket,omitempty"`
	ChecksumCRC32  *ChecksumCRC32  `json:"ChecksumCRC32,omitempty"`
	ChecksumCRC32C *ChecksumCRC32C `json:"ChecksumCRC32C,omitempty"`
	ChecksumSHA1   *ChecksumSHA1   `json:"ChecksumSHA1,omitempty"`
	ChecksumSHA256 *ChecksumSHA256 `json:"ChecksumSHA256,omitempty"`
	ETag           *ETag           `json:"ETag,omitempty"`
	Key            *ObjectKey      `json:"Key,omitempty"`
	Location       *ObjectLocation `json:"Location,omitempty"`
}

// CompletedPart defines model for CompletedPart.
type CompletedPart struct {
	ChecksumCRC32  *ChecksumCRC32  `json:"ChecksumCRC32,omitempty"`
	ChecksumCRC32C *ChecksumCRC32C `json:"ChecksumCRC32C,omitempty"`
	ChecksumSHA1   *ChecksumSHA1   `json:"ChecksumSHA1,omitempty"`
	ChecksumSHA256 *ChecksumSHA256 `json:"ChecksumSHA256,omitempty"`
	ETag           *ETag           `json:"ETag,omitempty"`
	PartNumber     *PartNumber     `json:"PartNumber,omitempty"`
}

// CompletedPartList defines model for CompletedPartList.
type CompletedPartList = []CompletedPart

// ContinueWith defines model for ContinueWith.
type ContinueWith struct {
	union json.RawMessage
}

// ContinueWithRecoveryUi Indicates, that the UI flow could be continued by showing a recovery ui
type ContinueWithRecoveryUi struct {
	// Action Action will always be `show_recovery_ui`
	// show_recovery_ui ContinueWithActionShowRecoveryUIString
	Action ContinueWithRecoveryUiAction `json:"action"`
	Flow   ContinueWithRecoveryUiFlow   `json:"flow"`
}

// ContinueWithRecoveryUiAction Action will always be `show_recovery_ui`
// show_recovery_ui ContinueWithActionShowRecoveryUIString
type ContinueWithRecoveryUiAction string

// ContinueWithRecoveryUiFlow defines model for ContinueWithRecoveryUiFlow.
type ContinueWithRecoveryUiFlow struct {
	// Id The ID of the recovery flow
	Id openapi_types.UUID `json:"id"`

	// Url The URL of the recovery flow
	Url *string `json:"url,omitempty"`
}

// ContinueWithSetSessionToken Indicates that a session was issued, and the application should use this token for authenticated requests
type ContinueWithSetSessionToken struct {
	// Action Action will always be `set_session_token`
	// set_session_token ContinueWithActionSetSessionTokenString
	Action ContinueWithSetSessionTokenAction `json:"action"`

	// SessionToken Token is the token of the session
	SessionToken string `json:"session_token"`
}

// ContinueWithSetSessionTokenAction Action will always be `set_session_token`
// set_session_token ContinueWithActionSetSessionTokenString
type ContinueWithSetSessionTokenAction string

// ContinueWithSettingsUi Indicates, that the UI flow could be continued by showing a settings ui
type ContinueWithSettingsUi struct {
	// Action Action will always be `show_settings_ui`
	// show_settings_ui ContinueWithActionShowSettingsUIString
	Action ContinueWithSettingsUiAction `json:"action"`
	Flow   ContinueWithSettingsUiFlow   `json:"flow"`
}

// ContinueWithSettingsUiAction Action will always be `show_settings_ui`
// show_settings_ui ContinueWithActionShowSettingsUIString
type ContinueWithSettingsUiAction string

// ContinueWithSettingsUiFlow defines model for ContinueWithSettingsUiFlow.
type ContinueWithSettingsUiFlow struct {
	// Id The ID of the settings flow
	Id openapi_types.UUID `json:"id"`
}

// ContinueWithVerificationUi Indicates, that the UI flow could be continued by showing a verification ui
type ContinueWithVerificationUi struct {
	// Action Action will always be `show_verification_ui`
	// show_verification_ui ContinueWithActionShowVerificationUIString
	Action ContinueWithVerificationUiAction `json:"action"`
	Flow   ContinueWithVerificationUiFlow   `json:"flow"`
}

// ContinueWithVerificationUiAction Action will always be `show_verification_ui`
// show_verification_ui ContinueWithActionShowVerificationUIString
type ContinueWithVerificationUiAction string

// ContinueWithVerificationUiFlow defines model for ContinueWithVerificationUiFlow.
type ContinueWithVerificationUiFlow struct {
	// Id The ID of the verification flow
	Id openapi_types.UUID `json:"id"`

	// Url The URL of the verification flow
	Url *string `json:"url,omitempty"`

	// VerifiableAddress The address that should be verified in this flow
	VerifiableAddress string `json:"verifiable_address"`
}

// CreateBucketOutput defines model for CreateBucketOutput.
type CreateBucketOutput = map[string]interface{}

// CreateClientGateway defines model for CreateClientGateway.
type CreateClientGateway struct {
	// BgpAsn The Autonomous System Number (ASN) used by the Border Gateway Protocol (BGP) to find the path to your client gateway through the Internet. <br/>
	// This number must be between `1` and `4294967295`. If you do not have an ASN, you can choose one between 64512 and 65534, or between 4200000000 and 4294967294.
	BgpAsn int `json:"bgpAsn"`

	// ConnectionType The communication protocol used to establish tunnel with your client gateway (only `ipsec.1` is supported).
	ConnectionType string `json:"connectionType"`

	// PublicIp The public fixed IPv4 address of your client gateway.
	PublicIp string `json:"publicIp"`
}

// CreateCluster defines model for CreateCluster.
type CreateCluster struct {
	// Cidr IP addresses in CIDR notation
	Cidr        string              `json:"cidr"`
	Description *string             `json:"description,omitempty"`
	Name        string              `json:"name"`
	NodePools   []OpenShiftNodepool `json:"nodePools"`
	Version     string              `json:"version"`
}

// CreateDhcpOptions defines model for CreateDhcpOptions.
type CreateDhcpOptions struct {
	// DomainName Specify a domain name (for example, `MyCompany.com`). You can specify only one domain name. You must specify at least one of the following parameters: `DomainName`, `DomainNameServers`, `LogServers`, or `NtpServers`.
	DomainName *string `json:"domainName,omitempty"`

	// DomainNameServers The IPs of domain name servers. You must specify at least one of the following parameters: `DomainName`, `DomainNameServers`, `LogServers`, or `NtpServers`.
	DomainNameServers *[]string `json:"domainNameServers,omitempty"`

	// LogServers The IPs of the log servers. You must specify at least one of the following parameters: `DomainName`, `DomainNameServers`, `LogServers`, or `NtpServers`.
	LogServers *[]string `json:"logServers,omitempty"`

	// NtpServers The IPs of the Network Time Protocol (NTP) servers. You must specify at least one of the following parameters: `DomainName`, `DomainNameServers`, `LogServers`, or `NtpServers`.
	NtpServers *[]string `json:"ntpServers,omitempty"`
}

// CreateFlexibleGpu defines model for CreateFlexibleGpu.
type CreateFlexibleGpu struct {
	// AvailabilityZoneName The Subregion in which you want to create the fGPU.
	AvailabilityZoneName string `json:"availabilityZoneName"`

	// DeleteOnVmDeletion If true, the fGPU is deleted when the VM is terminated.
	DeleteOnVmDeletion *bool `json:"deleteOnVmDeletion,omitempty"`

	// Generation The processor generation that the fGPU must be compatible with. If not specified, the oldest possible processor generation is selected (as provided by [ReadFlexibleGpuCatalog](#readflexiblegpucatalog) for the specified model of fGPU).
	Generation *string `json:"generation,omitempty"`

	// ModelName The model of fGPU you want to allocate.
	ModelName string `json:"modelName"`
}

// CreateImage defines model for CreateImage.
type CreateImage struct {
	// Architecture **(when registering from a snapshot, or from a bucket without using a manifest file)** The architecture of the OMI (`i386` or `x84_64`).
	Architecture *string `json:"architecture,omitempty"`

	// BlockDeviceMappings **(when registering from a snapshot, or from a bucket without using a manifest file)** One or more block device mappings.
	BlockDeviceMappings *[]BlockDeviceMappingImage `json:"blockDeviceMappings,omitempty"`

	// Description A description for the new OMI.
	Description *string `json:"description,omitempty"`

	// Name A unique name for the new OMI.<br />
	// Constraints: 3-128 alphanumeric characters, underscores (`_`), spaces (` `), parentheses (`()`), slashes (`/`), periods (`.`), or dashes (`-`).
	Name *string `json:"name,omitempty"`

	// NoReboot **(when creating from a VM)** If false, the VM shuts down before creating the OMI and then reboots. If true, the VM does not.
	NoReboot *bool `json:"noReboot,omitempty"`

	// ProductCodes The product codes associated with the OMI.
	ProductCodes *[]string `json:"productCodes,omitempty"`

	// RootDeviceName **(when registering from a snapshot, or from a bucket without using a manifest file)** The name of the root device for the new OMI.
	RootDeviceName *string `json:"rootDeviceName,omitempty"`

	// SourceImageId **(when copying an OMI)** The ID of the OMI you want to copy.
	SourceImageId *string `json:"sourceImageId,omitempty"`

	// SourceRegionName **(when copying an OMI)** The name of the source Region (always the same as the Region of your account).
	SourceRegionName *string `json:"sourceRegionName,omitempty"`

	// VmId **(when creating from a VM)** The ID of the VM from which you want to create the OMI.
	VmId *string `json:"vmId,omitempty"`
}

// CreateKeypair Information about the created keypair.
type CreateKeypair struct {
	// Fingerprint The MD5 public key fingerprint, as specified in section 4 of RFC 4716.
	Fingerprint *string `json:"fingerprint,omitempty"`

	// Name The name of the keypair.
	Name *string `json:"name,omitempty"`

	// PrivateKey The private key, returned only if you are creating a keypair (not if you are importing). When you save this private key in a .rsa file, make sure you replace the `\n` escape sequences with real line breaks.
	PrivateKey *string `json:"privateKey,omitempty"`

	// Type The type of the keypair (`ssh-rsa`, `ssh-ed25519`, `ecdsa-sha2-nistp256`, `ecdsa-sha2-nistp384`, or `ecdsa-sha2-nistp521`).
	Type *string `json:"type,omitempty"`
}

// CreateListenerRule defines model for CreateListenerRule.
type CreateListenerRule struct {
	// Listener Information about the load balancer.
	Listener LoadBalancerLight `json:"listener"`

	// ListenerRule Information about the listener rule.
	ListenerRule ListenerRuleForCreation `json:"listenerRule"`

	// VmIds The IDs of the backend VMs.
	VmIds []string `json:"vmIds"`
}

// CreateLoadBalancer defines model for CreateLoadBalancer.
type CreateLoadBalancer struct {
	// AvailabilityZoneNames (public Cloud only) The Subregion in which you want to create the load balancer. Regardless of this Subregion, the load balancer can distribute traffic to all Subregions. This parameter is required in the public Cloud.
	AvailabilityZoneNames *[]string `json:"availabilityZoneNames,omitempty"`

	// Listeners One or more listeners to create.
	Listeners []ListenerForCreation `json:"listeners"`

	// Name The unique name of the load balancer (32 alphanumeric or hyphen characters maximum, but cannot start or end with a hyphen).
	Name string `json:"name"`

	// PublicIp (internet-facing only) The public IP you want to associate with the load balancer. If not specified, a public IP owned by NumSpot is associated.
	PublicIp *string `json:"publicIp,omitempty"`

	// SecurityGroups (Vpc only) One or more IDs of security groups you want to assign to the load balancer. If not specified, the default security group of the Vpc is assigned to the load balancer.
	SecurityGroups *[]string `json:"securityGroups,omitempty"`

	// Subnets (Vpc only) The ID of the Subnet in which you want to create the load balancer. Regardless of this Subnet, the load balancer can distribute traffic to all Subnets. This parameter is required in a Vpc.
	Subnets []string `json:"subnets"`

	// Tags One or more tags assigned to the load balancer.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// Type The type of load balancer: `internet-facing` or `internal`. Use this parameter only for load balancers in a Vpc.
	Type *string `json:"type,omitempty"`
}

// CreateLoadBalancerListeners defines model for CreateLoadBalancerListeners.
type CreateLoadBalancerListeners struct {
	// Listeners One or more listeners for the load balancer.
	Listeners []ListenerForCreation `json:"listeners"`
}

// CreateLoadBalancerPolicy defines model for CreateLoadBalancerPolicy.
type CreateLoadBalancerPolicy struct {
	// CookieExpirationPeriod The lifetime of the cookie, in seconds. If not specified, the default value of this parameter is `1`, which means that the sticky session lasts for the duration of the browser session.
	CookieExpirationPeriod *int `json:"cookieExpirationPeriod,omitempty"`

	// CookieName The name of the application cookie used for stickiness. This parameter is required if you create a stickiness policy based on an application-generated cookie.
	CookieName *string `json:"cookieName,omitempty"`

	// PolicyName The name of the policy. This name must be unique and consist of alphanumeric characters and dashes (-).
	PolicyName string `json:"policyName"`

	// PolicyType The type of stickiness policy you want to create: `app` or `load_balancer`.
	PolicyType string `json:"policyType"`
}

// CreateLoadBalancerTags defines model for CreateLoadBalancerTags.
type CreateLoadBalancerTags struct {
	// Names One or more load balancer names.
	Names []string `json:"names"`

	// Tags One or more tags to add to the specified load balancers.
	Tags []ResourceTag `json:"tags"`
}

// CreateMultipartUploadOutput defines model for CreateMultipartUploadOutput.
type CreateMultipartUploadOutput struct {
	Bucket   *BucketName        `json:"Bucket,omitempty"`
	Key      *ObjectKey         `json:"Key,omitempty"`
	UploadId *MultipartUploadId `json:"UploadId,omitempty"`
}

// CreateNatGateway defines model for CreateNatGateway.
type CreateNatGateway struct {
	// PublicIpId The allocation ID of the public IP to associate with the NAT gateway.<br />
	// If the public IP is already associated with another resource, you must first disassociate it.
	PublicIpId string `json:"publicIpId"`

	// SubnetId The ID of the Subnet in which you want to create the NAT gateway.
	SubnetId string `json:"subnetId"`
}

// CreateNic defines model for CreateNic.
type CreateNic struct {
	// Description A description for the NIC.
	Description *string `json:"description,omitempty"`

	// PrivateIps The primary private IP for the NIC.<br />
	// This IP must be within the IP range of the Subnet that you specify with the `SubnetId` attribute.<br />
	// If you do not specify this attribute, a random private IP is selected within the IP range of the Subnet.
	PrivateIps *[]PrivateIpLight `json:"privateIps,omitempty"`

	// SecurityGroupIds One or more IDs of security groups for the NIC.
	SecurityGroupIds *[]string `json:"securityGroupIds,omitempty"`

	// SubnetId The ID of the Subnet in which you want to create the NIC.
	SubnetId string `json:"subnetId"`
}

// CreateNodepool defines model for CreateNodepool.
type CreateNodepool struct {
	Name      string `json:"name"`
	NodeCount int    `json:"nodeCount"`

	// NodeProfile Node profiles
	NodeProfile NodeProfile `json:"nodeProfile"`
}

// CreateRoute defines model for CreateRoute.
type CreateRoute struct {
	// DestinationIpRange The IP range used for the destination match, in CIDR notation (for example, `10.0.0.0/24`).
	DestinationIpRange string `json:"destinationIpRange"`

	// GatewayId The ID of an Internet gateway or virtual gateway attached to your Vpc.
	GatewayId *string `json:"gatewayId,omitempty"`

	// NatGatewayId The ID of a NAT gateway.
	NatGatewayId *string `json:"natGatewayId,omitempty"`

	// NicId The ID of a NIC.
	NicId *string `json:"nicId,omitempty"`

	// VmId The ID of a NAT VM in your Vpc (attached to exactly one NIC).
	VmId *string `json:"vmId,omitempty"`

	// VpcPeeringId The ID of a Vpc peering.
	VpcPeeringId *string `json:"vpcPeeringId,omitempty"`
}

// CreateRouteTable defines model for CreateRouteTable.
type CreateRouteTable struct {
	// VpcId The ID of the Vpc for which you want to create a route table.
	VpcId string `json:"vpcId"`
}

// CreateSecurityGroup defines model for CreateSecurityGroup.
type CreateSecurityGroup struct {
	// Description A description for the security group.<br />
	// This description can contain between 1 and 255 characters. Allowed characters are `a-z`, `A-Z`, `0-9`, accented letters, spaces, and `_.-:/()#,@[]+=&;{}!$*`.
	Description string `json:"description"`

	// Name The name of the security group.<br />
	// This name must not start with `sg-`.<br />
	// This name must be unique and contain between 1 and 255 characters. Allowed characters are `a-z`, `A-Z`, `0-9`, spaces, and `_.-:/()#,@[]+=&;{}!$*`.
	Name string `json:"name"`

	// VpcId The ID of the Vpc for the security group.
	VpcId string `json:"vpcId"`
}

// CreateSecurityGroupRule defines model for CreateSecurityGroupRule.
type CreateSecurityGroupRule struct {
	// Flow The direction of the flow: `Inbound` or `Outbound`. You can specify `Outbound` for Vpcs only.
	Flow string `json:"flow"`

	// FromPortRange The beginning of the port range for the TCP and UDP protocols, or an ICMP type number. If you specify this parameter, you cannot specify the `Rules` parameter and its subparameters.
	FromPortRange *int `json:"fromPortRange,omitempty"`

	// IpProtocol The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all protocols). By default, `-1`. In a Vpc, this can also be an IP protocol number. For more information, see the [IANA.org website](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml). If you specify this parameter, you cannot specify the `Rules` parameter and its subparameters.
	IpProtocol *string `json:"ipProtocol,omitempty"`

	// IpRange The IP range for the security group rule, in CIDR notation (for example, 10.0.0.0/16). If you specify this parameter, you cannot specify the `Rules` parameter and its subparameters.
	IpRange *string `json:"ipRange,omitempty"`

	// Rules Information about the security group rule to create. If you specify this parent parameter and its subparameters, you cannot specify the following parent parameters: `FromPortRange`, `IpProtocol`, `IpRange`, and `ToPortRange`.
	Rules *[]SecurityGroupRule `json:"rules,omitempty"`

	// SecurityGroupNameToLink The ID of a source or destination security group that you want to link to the security group of the rule.
	SecurityGroupNameToLink *string `json:"securityGroupNameToLink,omitempty"`

	// ToPortRange The end of the port range for the TCP and UDP protocols, or an ICMP code number. If you specify this parameter, you cannot specify the `Rules` parameter and its subparameters.
	ToPortRange *int `json:"toPortRange,omitempty"`
}

// CreateServerCertificate defines model for CreateServerCertificate.
type CreateServerCertificate struct {
	// Body The PEM-encoded X509 certificate.
	Body string `json:"body"`

	// Chain The PEM-encoded intermediate certification authorities.
	Chain *string `json:"chain,omitempty"`

	// Name A unique name for the certificate.
	Name string `json:"name"`

	// Path The path to the server certificate, set to a slash (/) if not specified.
	Path *string `json:"path,omitempty"`

	// PrivateKey The PEM-encoded private key matching the certificate.
	PrivateKey string `json:"privateKey"`
}

// CreateSnapshot defines model for CreateSnapshot.
type CreateSnapshot struct {
	// Description A description for the snapshot.
	Description *string `json:"description,omitempty"`

	// SourceRegionName **(when copying a snapshot)** The name of the source Region, which must be the same as the Region of your account.
	SourceRegionName *string `json:"sourceRegionName,omitempty"`

	// SourceSnapshotId **(when copying a snapshot)** The ID of the snapshot you want to copy.
	SourceSnapshotId *string `json:"sourceSnapshotId,omitempty"`

	// VolumeId **(when creating from a volume)** The ID of the volume you want to create a snapshot of.
	VolumeId *string `json:"volumeId,omitempty"`
}

// CreateSpace defines model for CreateSpace.
type CreateSpace struct {
	// Description Space description
	Description string `json:"description"`

	// Name Space name
	Name string `json:"name"`
}

// CreateSubnet defines model for CreateSubnet.
type CreateSubnet struct {
	// AvailabilityZoneName The name of the Subregion in which you want to create the Subnet.
	AvailabilityZoneName *string `json:"availabilityZoneName,omitempty"`

	// IpRange The IP range in the Subnet, in CIDR notation (for example, `10.0.0.0/16`).<br />
	// The IP range of the Subnet can be either the same as the Vpc one if you create only a single Subnet in this Net, or a subset of the Vpc one. In case of several Subnets in a Vpc, their IP ranges must not overlap. The smallest Subnet you can create uses a /29 netmask (eight IPs).
	IpRange string `json:"ipRange"`

	// VpcId The ID of the Vpc for which you want to create a Subnet.
	VpcId string `json:"vpcId"`
}

// CreateTags defines model for CreateTags.
type CreateTags struct {
	// ResourceIds One or more resource IDs.
	ResourceIds []string `json:"resourceIds"`

	// Tags One or more tags to add to the specified resources.
	Tags []ResourceTag `json:"tags"`
}

// CreateVirtualGateway defines model for CreateVirtualGateway.
type CreateVirtualGateway struct {
	// ConnectionType The type of VPN connection supported by the virtual gateway (only `ipsec.1` is supported).
	ConnectionType string `json:"connectionType"`
}

// CreateVms defines model for CreateVms.
type CreateVms struct {
	// BlockDeviceMappings One or more block device mappings.
	BlockDeviceMappings *[]BlockDeviceMappingVmCreation `json:"blockDeviceMappings,omitempty"`

	// BootOnCreation By default or if true, the VM is started on creation. If false, the VM is stopped on creation.
	BootOnCreation *bool `json:"bootOnCreation,omitempty"`

	// BsuOptimized This parameter is not available. It is present in our API for the sake of historical compatibility with AWS.
	BsuOptimized *bool `json:"bsuOptimized,omitempty"`

	// ClientToken A unique identifier which enables you to manage the idempotency.
	ClientToken *string `json:"clientToken,omitempty"`

	// DeletionProtection If true, you cannot delete the VM unless you change this parameter back to false.
	DeletionProtection *bool `json:"deletionProtection,omitempty"`

	// ImageId The ID of the OMI used to create the VM. You can find the list of OMIs by calling the [ReadImages](#readimages) method.
	ImageId string `json:"imageId"`

	// KeypairName The name of the keypair.
	KeypairName *string `json:"keypairName,omitempty"`

	// MaxVmsCount The maximum number of VMs you want to create. If all the VMs cannot be created, the largest possible number of VMs above MinVmsCount is created.
	MaxVmsCount *int `json:"maxVmsCount,omitempty"`

	// MinVmsCount The minimum number of VMs you want to create. If this number of VMs cannot be created, no VMs are created.
	MinVmsCount *int `json:"minVmsCount,omitempty"`

	// NestedVirtualization (dedicated tenancy only) If true, nested virtualization is enabled. If false, it is disabled.
	NestedVirtualization *bool `json:"nestedVirtualization,omitempty"`

	// Nics One or more NICs. If you specify this parameter, you must not specify the `SubnetId` and `SubregionName` parameters. You also must define one NIC as the primary network interface of the VM with `0` as its device number.
	Nics *[]NicForVmCreation `json:"nics,omitempty"`

	// Performance The performance of the VM (`medium` \| `high` \|  `highest`). By default, `high`. This parameter is ignored if you specify a performance flag directly in the `type` parameter.
	Performance *CreateVmsPerformance `json:"performance,omitempty"`

	// Placement Information about the placement of the VM.
	Placement *Placement `json:"placement,omitempty"`

	// PrivateIps One or more private IPs of the VM.
	PrivateIps *[]string `json:"privateIps,omitempty"`

	// SecurityGroupIds One or more IDs of security group for the VMs.
	SecurityGroupIds *[]string `json:"securityGroupIds,omitempty"`

	// SecurityGroups One or more names of security groups for the VMs.
	SecurityGroups *[]string `json:"securityGroups,omitempty"`

	// SubnetId The ID of the Subnet in which you want to create the VM. If you specify this parameter, you must not specify the `Nics` parameter.
	SubnetId string `json:"subnetId"`

	// Type The type of VM.
	Type *string `json:"type,omitempty"`

	// UserData Data or script used to add a specific configuration to the VM. It must be Base64-encoded and is limited to 500 kibibytes (KiB).
	UserData *string `json:"userData,omitempty"`

	// VmInitiatedShutdownBehavior The VM behavior when you stop it. By default or if set to `stop`, the VM stops. If set to `restart`, the VM stops then automatically restarts. If set to `terminate`, the VM stops and is terminated.
	VmInitiatedShutdownBehavior *string `json:"vmInitiatedShutdownBehavior,omitempty"`
}

// CreateVmsPerformance The performance of the VM (`medium` \| `high` \|  `highest`). By default, `high`. This parameter is ignored if you specify a performance flag directly in the `type` parameter.
type CreateVmsPerformance string

// CreateVolume defines model for CreateVolume.
type CreateVolume struct {
	// AvailabilityZoneName The Subregion in which you want to create the volume.
	AvailabilityZoneName string `json:"availabilityZoneName"`

	// Iops The number of I/O operations per second (IOPS). This parameter must be specified only if you create an `io1` volume. The maximum number of IOPS allowed for `io1` volumes is `13000` with a maximum performance ratio of 300 IOPS per gibibyte.
	Iops *int `json:"iops,omitempty"`

	// Size The size of the volume, in gibibytes (GiB). The maximum allowed size for a volume is 14901 GiB. This parameter is required if the volume is not created from a snapshot (`SnapshotId` unspecified).
	Size *int `json:"size,omitempty"`

	// SnapshotId The ID of the snapshot from which you want to create the volume.
	SnapshotId *string `json:"snapshotId,omitempty"`

	// Type The type of volume you want to create (`io1` \| `gp2` \ | `standard`). If not specified, a `standard` volume is created.<br />
	Type *string `json:"type,omitempty"`
}

// CreateVpc defines model for CreateVpc.
type CreateVpc struct {
	// IpRange The IP range for the Vpc, in CIDR notation (for example, `10.0.0.0/16`).
	IpRange string `json:"ipRange"`

	// Tenancy The tenancy options for the VMs:<br />
	// - `default` if a VM created in a Vpc can be launched with any tenancy.<br />
	// - `dedicated` if it can be launched with dedicated tenancy VMs running on single-tenant hardware.<br />
	// - `dedicated group ID`: if it can be launched in a dedicated group on single-tenant hardware.
	Tenancy *string `json:"tenancy,omitempty"`
}

// CreateVpcPeering defines model for CreateVpcPeering.
type CreateVpcPeering struct {
	// AccepterVpcId The ID of the Vpc you want to connect with.
	AccepterVpcId string `json:"accepterVpcId"`

	// SourceVpcId The ID of the Vpc you send the peering request from.
	SourceVpcId string `json:"sourceVpcId"`
}

// CreateVpnConnection defines model for CreateVpnConnection.
type CreateVpnConnection struct {
	// ClientGatewayId The ID of the client gateway.
	ClientGatewayId string `json:"clientGatewayId"`

	// ConnectionType The type of VPN connection (only `ipsec.1` is supported).
	ConnectionType string `json:"connectionType"`

	// StaticRoutesOnly By default or if false, the VPN connection uses dynamic routing with Border Gateway Protocol (BGP). If true, routing is controlled using static routes. For more information about how to create and delete static routes, see [CreateVpnConnectionRoute](#createvpnconnectionroute) and [DeleteVpnConnectionRoute](#deletevpnconnectionroute).
	StaticRoutesOnly *bool `json:"staticRoutesOnly,omitempty"`

	// VirtualGatewayId The ID of the virtual gateway.
	VirtualGatewayId string `json:"virtualGatewayId"`
}

// CreateVpnConnectionRoute defines model for CreateVpnConnectionRoute.
type CreateVpnConnectionRoute struct {
	// DestinationIpRange The network prefix of the route, in CIDR notation (for example, `10.12.0.0/16`).
	DestinationIpRange string `json:"destinationIpRange"`
}

// CreatedServiceAccount defines model for CreatedServiceAccount.
type CreatedServiceAccount struct {
	// Id Service account ID
	Id string `json:"id"`

	// Name Service Accounts name
	Name string `json:"name"`

	// Secret Service account secret.
	Secret string `json:"secret"`

	// TokenDuration Set access token duration
	TokenDuration *string `json:"tokenDuration,omitempty"`
}

// CreationDate defines model for CreationDate.
type CreationDate = time.Time

// CredentialSupportedDraft00 Includes information about the supported verifiable credentials.
type CredentialSupportedDraft00 struct {
	// CryptographicBindingMethodsSupported OpenID Connect Verifiable Credentials Cryptographic Binding Methods Supported
	//
	// Contains a list of cryptographic binding methods supported for signing the proof.
	CryptographicBindingMethodsSupported *[]string `json:"cryptographic_binding_methods_supported,omitempty"`

	// CryptographicSuitesSupported OpenID Connect Verifiable Credentials Cryptographic Suites Supported
	//
	// Contains a list of cryptographic suites methods supported for signing the proof.
	CryptographicSuitesSupported *[]string `json:"cryptographic_suites_supported,omitempty"`

	// Format OpenID Connect Verifiable Credentials Format
	//
	// Contains the format that is supported by this authorization server.
	Format *string `json:"format,omitempty"`

	// Types OpenID Connect Verifiable Credentials Types
	//
	// Contains the types of verifiable credentials supported.
	Types *[]string `json:"types,omitempty"`
}

// DateTime defines model for DateTime.
type DateTime = time.Time

// DeleteLoadBalancerListeners defines model for DeleteLoadBalancerListeners.
type DeleteLoadBalancerListeners struct {
	// LoadBalancerPorts One or more port numbers of the listeners you want to delete.
	LoadBalancerPorts []int `json:"loadBalancerPorts"`
}

// DeleteLoadBalancerPolicy defines model for DeleteLoadBalancerPolicy.
type DeleteLoadBalancerPolicy struct {
	// PolicyName The name of the policy you want to delete.
	PolicyName string `json:"policyName"`
}

// DeleteLoadBalancerTags defines model for DeleteLoadBalancerTags.
type DeleteLoadBalancerTags struct {
	// Names One or more load balancer names.
	Names []string `json:"names"`

	// Tags One or more tags to delete from the load balancers.
	Tags []ResourceLoadBalancerTag `json:"tags"`
}

// DeleteMySessionsCount Deleted Session Count
type DeleteMySessionsCount struct {
	// Count The number of sessions that were revoked.
	Count *int64 `json:"count,omitempty"`
}

// DeleteObjectOutput defines model for DeleteObjectOutput.
type DeleteObjectOutput = map[string]interface{}

// DeleteRoute defines model for DeleteRoute.
type DeleteRoute struct {
	// DestinationIpRange The exact IP range for the route.
	DestinationIpRange string `json:"destinationIpRange"`
}

// DeleteSecurityGroupRule defines model for DeleteSecurityGroupRule.
type DeleteSecurityGroupRule struct {
	// Flow The direction of the flow: `Inbound` or `Outbound`. You can specify `Outbound` for Vpcs only.
	Flow string `json:"flow"`

	// FromPortRange The beginning of the port range for the TCP and UDP protocols, or an ICMP type number.
	FromPortRange *int `json:"fromPortRange,omitempty"`

	// IpProtocol The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all protocols). By default, `-1`. In a Vpc, this can also be an IP protocol number. For more information, see the [IANA.org website](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
	IpProtocol *string `json:"ipProtocol,omitempty"`

	// IpRange The IP range for the security group rule, in CIDR notation (for example, `10.0.0.0/16`).
	IpRange *string `json:"ipRange,omitempty"`

	// Rules One or more rules you want to delete from the security group.
	Rules *[]SecurityGroupRule `json:"rules,omitempty"`

	// SecurityGroupNameToUnlink The ID of the source security group. If you are in the Public Cloud, you can also specify the name of the source security group.
	SecurityGroupNameToUnlink *string `json:"securityGroupNameToUnlink,omitempty"`

	// ToPortRange The end of the port range for the TCP and UDP protocols, or an ICMP code number.
	ToPortRange *int `json:"toPortRange,omitempty"`
}

// DeleteTags defines model for DeleteTags.
type DeleteTags struct {
	// ResourceIds One or more resource IDs.
	ResourceIds []string `json:"resourceIds"`

	// Tags One or more tags to delete (if you set a tag value, only the tags matching exactly this value are deleted).
	Tags []ResourceTag `json:"tags"`
}

// DeleteVpnConnectionRoute defines model for DeleteVpnConnectionRoute.
type DeleteVpnConnectionRoute struct {
	// DestinationIpRange The network prefix of the route to delete, in CIDR notation (for example, `10.12.0.0/16`).
	DestinationIpRange string `json:"destinationIpRange"`
}

// Delimiter defines model for Delimiter.
type Delimiter = string

// DhcpOptionsSet Information about the DHCP options set.
type DhcpOptionsSet struct {
	// Default If true, the DHCP options set is a default one. If false, it is not.
	Default *bool `json:"default,omitempty"`

	// DomainName The domain name.
	DomainName *string `json:"domainName,omitempty"`

	// DomainNameServers One or more IPs for the domain name servers.
	DomainNameServers *[]string `json:"domainNameServers,omitempty"`

	// Id The ID of the DHCP options set.
	Id *string `json:"id,omitempty"`

	// LogServers One or more IPs for the log servers.
	LogServers *[]string `json:"logServers,omitempty"`

	// NtpServers One or more IPs for the NTP servers.
	NtpServers *[]string `json:"ntpServers,omitempty"`

	// Tags One or more tags associated with the DHCP options set.
	Tags *[]ResourceTag `json:"tags,omitempty"`
}

// DisplayName defines model for DisplayName.
type DisplayName = string

// ETag defines model for ETag.
type ETag = string

// Email defines model for Email.
type Email = openapi_types.Email

// EncodingType defines model for EncodingType.
type EncodingType string

// Error For HTTP errors, we implement the https://datatracker.ietf.org/doc/html/rfc9457
type Error struct {
	// Detail Human-readable explanation specific to this occurrence of the problem.
	Detail   *string `json:"detail,omitempty"`
	Instance *Url    `json:"instance,omitempty"`

	// Title Human-readable summary of the problem type.
	Title string `json:"title"`

	// Type Documentation URL for the domain error
	Type ErrorDocumentationUrl `json:"type"`
}

// ErrorBrowserLocationChangeRequired defines model for ErrorBrowserLocationChangeRequired.
type ErrorBrowserLocationChangeRequired struct {
	// Error The standard  JSON API error format.
	Error *ErrorGeneric `json:"error,omitempty"`

	// RedirectBrowserTo Points to where to redirect the user to next.
	RedirectBrowserTo *string `json:"redirect_browser_to,omitempty"`
}

// ErrorDocumentationUrl Documentation URL for the domain error
type ErrorDocumentationUrl string

// ErrorGeneric The standard  JSON API error format.
type ErrorGeneric struct {
	Error GenericError `json:"error"`
}

// ErrorOauth2 defines model for ErrorOauth2.
type ErrorOauth2 struct {
	// Error The error type.
	Error string `json:"error"`

	// ErrorDescription A human-readable explanation specific to this occurrence of the problem.
	ErrorDescription *string `json:"error_description,omitempty"`
}

// FlexibleGpu Information about the flexible GPU (fGPU).
type FlexibleGpu struct {
	// AvailabilityZoneName The Subregion where the fGPU is located.
	AvailabilityZoneName *string `json:"availabilityZoneName,omitempty"`

	// DeleteOnVmDeletion If true, the fGPU is deleted when the VM is terminated.
	DeleteOnVmDeletion *bool `json:"deleteOnVmDeletion,omitempty"`

	// Generation The compatible processor generation.
	Generation *string `json:"generation,omitempty"`

	// Id The ID of the fGPU.
	Id *string `json:"id,omitempty"`

	// ModelName The model of fGPU.
	ModelName *string `json:"modelName,omitempty"`

	// State The state of the fGPU (`allocated` \| `attaching` \| `attached` \| `detaching`).
	State *string `json:"state,omitempty"`

	// VmId The ID of the VM the fGPU is attached to, if any.
	VmId *string `json:"vmId,omitempty"`
}

// FlowError defines model for FlowError.
type FlowError struct {
	// CreatedAt CreatedAt is a helper struct field for gobuffalo.pop.
	CreatedAt *time.Time              `json:"created_at,omitempty"`
	Error     *map[string]interface{} `json:"error,omitempty"`

	// Id ID of the error container.
	Id openapi_types.UUID `json:"id"`

	// UpdatedAt UpdatedAt is a helper struct field for gobuffalo.pop.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// GenericError defines model for GenericError.
type GenericError struct {
	// Code The status code
	Code *int64 `json:"code,omitempty"`

	// Debug Debug information
	//
	// This field is often not exposed to protect against leaking
	// sensitive information.
	Debug *string `json:"debug,omitempty"`

	// Details Further error details
	Details *map[string]interface{} `json:"details,omitempty"`

	// Id The error ID
	//
	// Useful when trying to identify various errors in application logic.
	Id *string `json:"id,omitempty"`

	// Message Error message
	//
	// The error's message.
	Message string `json:"message"`

	// Reason A human-readable reason for the error
	Reason *string `json:"reason,omitempty"`

	// Request The request ID
	//
	// The request ID is often exposed internally in order to trace
	// errors across service architectures. This is often a UUID.
	Request *string `json:"request,omitempty"`

	// Status The status description
	Status *string `json:"status,omitempty"`
}

// GetObjectOutput defines model for GetObjectOutput.
type GetObjectOutput struct {
	Body     *Body                     `json:"Body,omitempty"`
	Metadata *map[string]MetadataValue `json:"Metadata,omitempty"`
}

// Gpu GPU values
type Gpu string

// GranularPermission defines model for GranularPermission.
type GranularPermission struct {
	// Action Type of action (e.g., owners, editors, getters)
	Action string `json:"action"`

	// ObjectId ID of the object
	ObjectId string `json:"objectId"`
}

// GranularPolicyList defines model for GranularPolicyList.
type GranularPolicyList = []GranularPermission

// HealthCheck Information about the health check configuration.
type HealthCheck struct {
	// CheckInterval The number of seconds between two requests (between `5` and `600` both included).
	CheckInterval int `json:"checkInterval"`

	// HealthyThreshold The number of consecutive successful requests before considering the VM as healthy (between `2` and `10` both included).
	HealthyThreshold int `json:"healthyThreshold"`

	// Path If you use the HTTP or HTTPS protocols, the request URL path.
	Path *string `json:"path,omitempty"`

	// Port The port number (between `1` and `65535`, both included).
	Port int `json:"port"`

	// Protocol The protocol for the URL of the VM (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
	Protocol string `json:"protocol"`

	// Timeout The maximum waiting time for a response before considering the VM as unhealthy, in seconds (between `2` and `60` both included).
	Timeout int `json:"timeout"`

	// UnhealthyThreshold The number of consecutive failed requests before considering the VM as unhealthy (between `2` and `10` both included).
	UnhealthyThreshold int `json:"unhealthyThreshold"`
}

// IAMGranularPolicyList defines model for IAMGranularPolicyList.
type IAMGranularPolicyList struct {
	Items []GranularPermission `json:"items"`

	// NextPageToken This token is used to retrieve the next page. If this field is omitted, there are no subsequent pages.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// TotalSize Equivalent to int32
	TotalSize *Int `json:"totalSize,omitempty"`
}

// IAMPolicy defines model for IAMPolicy.
type IAMPolicy struct {
	// Permissions List of permission UUIDs
	Permissions *[]openapi_types.UUID `json:"permissions,omitempty"`

	// Roles List of role UUIDs
	Roles *[]openapi_types.UUID `json:"roles,omitempty"`
}

// ID defines model for ID.
type ID = int64

// IdentitiesIdsList defines model for IdentitiesIdsList.
type IdentitiesIdsList struct {
	Items []openapi_types.UUID `json:"items"`
}

// Identity An identity represents a (human) user.
type Identity struct {
	// CreatedAt CreatedAt is a helper struct field for gobuffalo.pop.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Credentials Credentials represents all credentials that can be used for authenticating this identity.
	Credentials *map[string]IdentityCredentials `json:"credentials,omitempty"`

	// Id ID is the identity's unique identifier.
	// The Identity ID can not be changed and can not be chosen. This ensures future
	// compatibility and optimization for distributed stores such as CockroachDB.
	Id             openapi_types.UUID  `json:"id"`
	MetadataAdmin  *NullJsonRawMessage `json:"metadata_admin"`
	MetadataPublic *NullJsonRawMessage `json:"metadata_public"`
	OrganizationId *NullUUID           `json:"organization_id"`

	// RecoveryAddresses RecoveryAddresses contains all the addresses that can be used to recover an identity.
	RecoveryAddresses *[]RecoveryIdentityAddress `json:"recovery_addresses,omitempty"`

	// SchemaId SchemaID is the ID of the JSON Schema to be used for validating the identity's traits.
	SchemaId string `json:"schema_id"`

	// SchemaUrl SchemaURL is the URL of the endpoint where the identity's traits schema can be fetched from.
	SchemaUrl string `json:"schema_url"`

	// State State is the identity's state.
	//
	// This value has currently no effect.
	// active StateActive
	// inactive StateInactive
	State          *IdentityState `json:"state,omitempty"`
	StateChangedAt *NullTime      `json:"state_changed_at"`

	// Traits Traits represent an identity's traits. The identity is able to create, modify, and delete traits in a self-service manner. The input will always be validated against the JSON Schema defined in `schema_url`.
	Traits IdentityTraits `json:"traits"`

	// UpdatedAt UpdatedAt is a helper struct field for gobuffalo.pop.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// VerifiableAddresses VerifiableAddresses contains all the addresses that can be verified by the user.
	VerifiableAddresses *[]VerifiableIdentityAddress `json:"verifiable_addresses,omitempty"`
}

// IdentityState State is the identity's state.
//
// This value has currently no effect.
// active StateActive
// inactive StateInactive
type IdentityState string

// IdentityCredentials Credentials represents a specific credential type
type IdentityCredentials struct {
	// Config JSONRawMessage represents a json.RawMessage that works well with JSON, SQL, and Swagger.
	Config *JSONRawMessage `json:"config,omitempty"`

	// CreatedAt CreatedAt is a helper struct field for gobuffalo.pop.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Identifiers Identifiers represents a list of unique identifiers this credential type matches.
	Identifiers *[]string `json:"identifiers,omitempty"`

	// Type Type discriminates between different types of credentials.
	// password CredentialsTypePassword
	// oidc CredentialsTypeOIDC
	// totp CredentialsTypeTOTP
	// lookup_secret CredentialsTypeLookup
	// webauthn CredentialsTypeWebAuthn
	// code CredentialsTypeCodeAuth
	// link_recovery CredentialsTypeRecoveryLink  CredentialsTypeRecoveryLink is a special credential type linked to the link strategy (recovery flow).  It is not used within the credentials object itself.
	// code_recovery CredentialsTypeRecoveryCode
	Type *IdentityCredentialsType `json:"type,omitempty"`

	// UpdatedAt UpdatedAt is a helper struct field for gobuffalo.pop.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Version Version refers to the version of the credential. Useful when changing the config schema.
	Version *int64 `json:"version,omitempty"`
}

// IdentityCredentialsType Type discriminates between different types of credentials.
// password CredentialsTypePassword
// oidc CredentialsTypeOIDC
// totp CredentialsTypeTOTP
// lookup_secret CredentialsTypeLookup
// webauthn CredentialsTypeWebAuthn
// code CredentialsTypeCodeAuth
// link_recovery CredentialsTypeRecoveryLink  CredentialsTypeRecoveryLink is a special credential type linked to the link strategy (recovery flow).  It is not used within the credentials object itself.
// code_recovery CredentialsTypeRecoveryCode
type IdentityCredentialsType string

// IdentityTraits Traits represent an identity's traits. The identity is able to create, modify, and delete traits in a self-service manner. The input will always be validated against the JSON Schema defined in `schema_url`.
type IdentityTraits = interface{}

// IdentityVerifiableAddressStatus VerifiableAddressStatus must not exceed 16 characters as that is the limitation in the SQL Schema
type IdentityVerifiableAddressStatus = string

// Image Information about the OMI.
type Image struct {
	// Access Permissions for the resource.
	Access *Access `json:"access,omitempty"`

	// Architecture The architecture of the OMI.
	Architecture *string `json:"architecture,omitempty"`

	// BlockDeviceMappings One or more block device mappings.
	BlockDeviceMappings *[]BlockDeviceMappingImage `json:"blockDeviceMappings,omitempty"`

	// CreationDate The date and time of creation of the OMI, in ISO 8601 date-time format.
	CreationDate *time.Time `json:"creationDate,omitempty"`

	// Description The description of the OMI.
	Description *string `json:"description,omitempty"`

	// Id The ID of the OMI.
	Id *string `json:"id,omitempty"`

	// Name The name of the OMI.
	Name *string `json:"name,omitempty"`

	// ProductCodes The product codes associated with the OMI.
	ProductCodes *[]string `json:"productCodes,omitempty"`

	// RootDeviceName The name of the root device.
	RootDeviceName *string `json:"rootDeviceName,omitempty"`

	// RootDeviceType The type of root device used by the OMI (always `bsu`).
	RootDeviceType *string `json:"rootDeviceType,omitempty"`

	// State The state of the OMI (`pending` \| `available` \| `failed`).
	State *string `json:"state,omitempty"`

	// StateComment Information about the change of state.
	StateComment *StateComment `json:"stateComment,omitempty"`

	// Tags One or more tags associated with the OMI.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// Type The type of the OMI.
	Type *string `json:"type,omitempty"`
}

// ImmutableSpace defines model for ImmutableSpace.
type ImmutableSpace struct {
	CreatedOn DateTime `json:"createdOn"`

	// Id Internal ID
	Id openapi_types.UUID `json:"id"`

	// OrganisationId Organisation_id
	OrganisationId openapi_types.UUID `json:"organisationId"`

	// Status status of the space, the space can only be used when the status is ready.
	Status    ImmutableSpaceStatus `json:"status"`
	UpdatedOn DateTime             `json:"updatedOn"`
}

// ImmutableSpaceStatus status of the space, the space can only be used when the status is ready.
type ImmutableSpaceStatus string

// Int Equivalent to int32
type Int = int32

// InternetGateway Information about the Internet gateway.
type InternetGateway struct {
	// Id The ID of the Internet gateway.
	Id *string `json:"id,omitempty"`

	// State The state of the attachment of the Internet gateway to the Vpc (always `available`).
	State *string `json:"state,omitempty"`

	// Tags One or more tags associated with the Internet gateway.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// VpcId The ID of the Vpc attached to the Internet gateway.
	VpcId *string `json:"vpcId,omitempty"`
}

// IntrospectResp defines model for IntrospectResp.
type IntrospectResp struct {
	// Active A boolean value indicating whether the token is active or not.
	Active bool `json:"active"`

	// Aud The intended audience of the token, specifying who the token is intended for.
	Aud *[]string `json:"aud,omitempty"`

	// ClientId The unique identifier of the client application that requested the token.
	ClientId *string `json:"client_id,omitempty"`

	// Exp The expiration time of the token in seconds since the Unix epoch.
	Exp *int `json:"exp,omitempty"`

	// Iat The issued-at time of the token in seconds since the Unix epoch.
	Iat *int `json:"iat,omitempty"`

	// Iss The issuer of the token, identify the authorization server that issued the token.
	Iss *string `json:"iss,omitempty"`

	// Nbf The not-before time of the token in seconds since the Unix epoch, indicating the earliest time the token can be used.
	Nbf *int `json:"nbf,omitempty"`

	// Scope The scope of the token, defining the permissions it grants.
	Scope *string `json:"scope,omitempty"`

	// Sub The subject of the token, typically the user or resource the token is issued for.
	Sub *string `json:"sub,omitempty"`

	// TokenType Indicate the type of the token, such as "Bearer".
	TokenType *string `json:"token_type,omitempty"`

	// TokenUse Specify the intended use of the token, such as "access" or "refresh".
	TokenUse *string `json:"token_use,omitempty"`
}

// InvalidObjectState defines model for InvalidObjectState.
type InvalidObjectState = interface{}

// IsRestoreInProgress defines model for IsRestoreInProgress.
type IsRestoreInProgress = bool

// IsTruncated defines model for IsTruncated.
type IsTruncated = bool

// JSONRawMessage JSONRawMessage represents a json.RawMessage that works well with JSON, SQL, and Swagger.
type JSONRawMessage = map[string]interface{}

// JsonWebKey defines model for JsonWebKey.
type JsonWebKey struct {
	// Alg The "alg" (algorithm) parameter identifies the algorithm intended for use with the key.  The values used should either be registered in the IANA "JSON Web Signature and Encryption Algorithms" registry established by [JWA] or be a value that contains a Collision-Resistant Name.
	Alg string  `json:"alg"`
	Crv *string `json:"crv,omitempty"`
	D   *string `json:"d,omitempty"`
	Dp  *string `json:"dp,omitempty"`
	Dq  *string `json:"dq,omitempty"`
	E   *string `json:"e,omitempty"`
	K   *string `json:"k,omitempty"`

	// Kid The "kid" (key ID) parameter is used to match a specific key. This is used, for instance, to choose among a set of keys within a JWK Set during key rollover.  The structure of the "kid" value is unspecified. When "kid" values are used within a JWK Set, different keys within the JWK Set SHOULD use distinct "kid" values. (One example in which different keys might use the same "kid" value is if they have different "kty" (key type) values but are considered to be equivalent alternatives by the application using them.)  The "kid" value is a case-sensitive string.
	Kid string `json:"kid"`

	// Kty The "kty" parameter in JSON Web Keys (JWK) specifies the cryptographic algorithm family,such as "RSA" or "EC". It must be a case-sensitive string and is required in a JWK. The value should be registered in the IANA "JSON Web Key Types" registry or be a Collision-Resistant Name
	Kty string  `json:"kty"`
	N   *string `json:"n,omitempty"`
	P   *string `json:"p,omitempty"`
	Q   *string `json:"q,omitempty"`
	Qi  *string `json:"qi,omitempty"`

	// Use Use ("public key use") identifies the intended use of the public key. The "use" parameter is employed to indicate whether a public key is used for encrypting data or verifying the signature on data. Values are commonly "sig" (signature) or "enc" (encryption).
	Use string  `json:"use"`
	X   *string `json:"x,omitempty"`

	// X5c The "x5c" parameter in JSON Web Keys (JWK) includes a chain of one or more PKIX certificates, represented as a JSON array of base64-encoded DER certificate values. The first certificate must contain the key value and must match the public key represented by other JWK members. Additional certificates can follow, with each certifying the previous one. This parameter is optional.
	X5c *[]string `json:"x5c,omitempty"`
	Y   *string   `json:"y,omitempty"`
}

// JsonWebKeySet JSON Web Key Set
type JsonWebKeySet struct {
	// Keys List of JSON Web Keys The value of the "keys" parameter is an array of JSON Web Key (JWK) values. By default, the order of the JWK values within the array does not imply an order of preference among them, although applications  of JWK Sets can choose to assign a meaning to the order for their  purposes, if desired.
	Keys *[]JsonWebKey `json:"keys,omitempty"`
}

// Keypair Information about the keypair.
type Keypair struct {
	// Fingerprint The MD5 public key fingerprint as specified in section 4 of RFC 4716.
	Fingerprint *string `json:"fingerprint,omitempty"`

	// Name The name of the keypair.
	Name *string `json:"name,omitempty"`

	// Type The type of the keypair (`ssh-rsa`, `ssh-ed25519`, `ecdsa-sha2-nistp256`, `ecdsa-sha2-nistp384`, or `ecdsa-sha2-nistp521`).
	Type *string `json:"type,omitempty"`
}

// KubernetesBinaryContent defines model for KubernetesBinaryContent.
type KubernetesBinaryContent = openapi_types.File

// KubernetesCluster defines model for KubernetesCluster.
type KubernetesCluster struct {
	// AdminBastionPublicIP admin bastion public ip
	AdminBastionPublicIP string `json:"adminBastionPublicIP"`

	// Cidr The IP network mask handling by the cluster
	Cidr string `json:"cidr"`

	// ClientBastionPublicIP client bastion public ip
	ClientBastionPublicIP string    `json:"clientBastionPublicIP"`
	CreatedAt             time.Time `json:"createdAt"`

	// Description Sample description of the cluster given by the user
	Description string `json:"description"`

	// Id the name of the cluster
	Id openapi_types.UUID `json:"id"`

	// IngressPublicURL ingress public url
	IngressPublicURL string `json:"ingressPublicURL"`

	// Name the name of the cluster
	Name      string               `json:"name"`
	NodePools []KubernetesNodePool `json:"nodePools"`

	// OperationId Identifier of the given operation
	OperationId openapi_types.UUID `json:"operationId"`

	// SelfLink the URL that allow you to retrieve cluster information
	SelfLink string `json:"selfLink"`

	// SpaceId the spaceID of the cluster
	SpaceId   *openapi_types.UUID `json:"spaceId,omitempty"`
	Status    *string             `json:"status,omitempty"`
	Tags      []KubernetesTag     `json:"tags"`
	UpdatedAt time.Time           `json:"updatedAt"`

	// Urls the available urls for the current cluster
	Urls []KubernetesUrl `json:"urls"`

	// Version Kubernetes version want on all nodes
	Version KubernetesClusterVersion `json:"version"`
}

// KubernetesClusterVersion Kubernetes version want on all nodes
type KubernetesClusterVersion string

// KubernetesClusterConfiguration defines model for KubernetesClusterConfiguration.
type KubernetesClusterConfiguration struct {
	Cidr string `json:"cidr"`

	// Name the name of the cluster
	Name string `json:"name"`

	// NodeCount The number of worker with given profile you want in your cluster initialization
	NodeCount int `json:"nodeCount"`

	// NodeProfile The profile defined the size and caracteristic the created worker will be
	NodeProfile KubernetesNodeProfileName             `json:"nodeProfile"`
	Version     KubernetesClusterConfigurationVersion `json:"version"`
}

// KubernetesClusterConfigurationVersion defines model for KubernetesClusterConfiguration.Version.
type KubernetesClusterConfigurationVersion string

// KubernetesListClusters defines model for KubernetesListClusters.
type KubernetesListClusters struct {
	Instances []KubernetesCluster `json:"instances"`

	// NextPageToken token used to retrieve the next page
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// SelfLink the URL that allow you to retrieve cluster information
	SelfLink *string `json:"selfLink,omitempty"`

	// TotalSize total number of items
	TotalSize *int `json:"totalSize,omitempty"`
}

// KubernetesNodeOrder defines model for KubernetesNodeOrder.
type KubernetesNodeOrder struct {
	// NodeCount the number of worker you want add in your cluster when was correctly setup
	NodeCount int `json:"nodeCount"`

	// NodeProfile The profile defined the size and caracteristic the created worker will be
	NodeProfile KubernetesNodeProfileName `json:"nodeProfile"`

	// Target Identity the URL that allow to get information of the processing resource
	Target string `json:"target"`

	// Version The version of the node to add
	Version string `json:"version"`
}

// KubernetesNodePool defines model for KubernetesNodePool.
type KubernetesNodePool struct {
	// GpuType if node profile contains gpu, it indicate which specific GPU is instanciated
	GpuType *KubernetesNodePoolGpuType `json:"gpuType,omitempty"`

	// KubernetesVersion Kubernetes version want on all nodes into this node pool
	KubernetesVersion string `json:"kubernetesVersion"`

	// Name the name of the node pool
	Name string `json:"name"`

	// NodeCount number of node/worker containing into this node pool
	NodeCount   int                   `json:"nodeCount"`
	NodeProfile KubernetesNodeProfile `json:"nodeProfile"`
}

// KubernetesNodePoolGpuType if node profile contains gpu, it indicate which specific GPU is instanciated
type KubernetesNodePoolGpuType string

// KubernetesNodeProfile defines model for KubernetesNodeProfile.
type KubernetesNodeProfile struct {
	// Cpu amount of vCPU allocated
	Cpu int `json:"cpu"`

	// Memory amount of memory (RAM) allocated, express in Gio
	Memory int `json:"memory"`

	// Name the name of the node profile
	Name string `json:"name"`
}

// KubernetesNodeProfileName The profile defined the size and caracteristic the created worker will be
type KubernetesNodeProfileName string

// KubernetesNodeRemoval defines model for KubernetesNodeRemoval.
type KubernetesNodeRemoval struct {
	// NodeProfile type of node profile wanted to remove
	NodeProfile KubernetesNodeRemovalNodeProfile `json:"nodeProfile"`
}

// KubernetesNodeRemovalNodeProfile type of node profile wanted to remove
type KubernetesNodeRemovalNodeProfile string

// KubernetesNodeUpgrade defines model for KubernetesNodeUpgrade.
type KubernetesNodeUpgrade struct {
	// Target Identity the URL that allow to get information of the processing resource
	Target string `json:"target"`

	// Version Targeted Kubernetes version to upgrade
	Version KubernetesNodeUpgradeVersion `json:"version"`
}

// KubernetesNodeUpgradeVersion Targeted Kubernetes version to upgrade
type KubernetesNodeUpgradeVersion string

// KubernetesOperation defines model for KubernetesOperation.
type KubernetesOperation struct {
	// Clusterid unique id of a cluster
	Clusterid *openapi_types.UUID `json:"clusterid,omitempty"`

	// CreatedAt The date when the operation was accepted to be treated
	CreatedAt time.Time `json:"createdAt"`

	// EndedAt The date operation was terminated as DONE or FAILED status
	EndedAt *time.Time `json:"endedAt,omitempty"`

	// Error error description that the operation encounter if the operation FAIL
	Error *string `json:"error,omitempty"`

	// Id Identifier of the given operation
	Id openapi_types.UUID `json:"id"`

	// OperationType The type of operation, refer to the domain action involve changes on targeted resources
	OperationType KubernetesOperationType `json:"operationType"`

	// Progress The progression of the current operation
	Progress string `json:"progress"`

	// SelfLink URL that identified the current operation
	SelfLink string `json:"selfLink"`

	// StartedAt The date time that the operation was handle by a runner and then have status operation at least `RUNNING` state
	StartedAt *time.Time `json:"startedAt,omitempty"`

	// Status Current state of the operation
	Status KubernetesOperationStatus `json:"status"`

	// Target Identity the URL that allow to get information of the processing resource
	Target string `json:"target"`

	// TargetName The name of the cluster
	TargetName *string `json:"targetName,omitempty"`
}

// KubernetesOperationStatus Current state of the operation
type KubernetesOperationStatus string

// KubernetesOperationType The type of operation, refer to the domain action involve changes on targeted resources
type KubernetesOperationType string

// KubernetesStatus defines model for KubernetesStatus.
type KubernetesStatus struct {
	// Name The name of the cluster
	Name string `json:"name"`

	// Status Current status of the cluster
	Status KubernetesStatusStatus `json:"status"`
}

// KubernetesStatusStatus Current status of the cluster
type KubernetesStatusStatus string

// KubernetesTag defines model for KubernetesTag.
type KubernetesTag struct {
	// Key key of the tag
	Key string `json:"key"`

	// Value value of the tag
	Value string `json:"value"`
}

// KubernetesUrl defines model for KubernetesUrl.
type KubernetesUrl struct {
	// Api the corresponding url api
	Api string `json:"api"`
}

// LastModified defines model for LastModified.
type LastModified = time.Time

// LinkFlexibleGpu defines model for LinkFlexibleGpu.
type LinkFlexibleGpu struct {
	// VmId The ID of the VM you want to attach the fGPU to.
	VmId string `json:"vmId"`
}

// LinkInternetGateway defines model for LinkInternetGateway.
type LinkInternetGateway struct {
	// VpcId The ID of the Vpc to which you want to attach the Internet gateway.
	VpcId string `json:"vpcId"`
}

// LinkLoadBalancerBackendMachines defines model for LinkLoadBalancerBackendMachines.
type LinkLoadBalancerBackendMachines struct {
	// BackendIps  One or more public IPs of back-end VMs.
	BackendIps *[]string `json:"backendIps,omitempty"`

	// BackendVmIds  One or more IDs of back-end VMs.
	BackendVmIds *[]string `json:"backendVmIds,omitempty"`
}

// LinkNic Information about the NIC attachment.
type LinkNic struct {
	// DeleteOnVmDeletion If true, the NIC is deleted when the VM is terminated.
	DeleteOnVmDeletion *bool `json:"deleteOnVmDeletion,omitempty"`

	// DeviceNumber The device index for the NIC attachment (between `1` and `7`, both included).
	DeviceNumber *int `json:"deviceNumber,omitempty"`

	// Id The ID of the NIC to attach.
	Id *string `json:"id,omitempty"`

	// State The state of the attachment (`attaching` \| `attached` \| `detaching` \| `detached`).
	State *string `json:"state,omitempty"`

	// VmId The ID of the VM.
	VmId *string `json:"vmId,omitempty"`
}

// LinkNicLight Information about the network interface card (NIC).
type LinkNicLight struct {
	// DeleteOnVmDeletion If true, the NIC is deleted when the VM is terminated.
	DeleteOnVmDeletion *bool `json:"deleteOnVmDeletion,omitempty"`

	// DeviceNumber The device index for the NIC attachment (between `1` and `7`, both included).
	DeviceNumber *int `json:"deviceNumber,omitempty"`

	// LinkNicId The ID of the NIC to attach.
	LinkNicId *string `json:"linkNicId,omitempty"`

	// State The state of the attachment (`attaching` \| `attached` \| `detaching` \| `detached`).
	State *string `json:"state,omitempty"`
}

// LinkNicToUpdate Information about the NIC attachment. If you are modifying the `DeleteOnVmDeletion` attribute, you must specify the ID of the NIC attachment.
type LinkNicToUpdate struct {
	// DeleteOnVmDeletion If true, the NIC is deleted when the VM is terminated. If false, the NIC is detached from the VM.
	DeleteOnVmDeletion *bool `json:"deleteOnVmDeletion,omitempty"`

	// LinkNicId The ID of the NIC attachment.
	LinkNicId *string `json:"linkNicId,omitempty"`
}

// LinkPrivateIps defines model for LinkPrivateIps.
type LinkPrivateIps struct {
	// AllowRelink If true, allows an IP that is already assigned to another NIC in the same Subnet to be assigned to the NIC you specified.
	AllowRelink *bool `json:"allowRelink,omitempty"`

	// PrivateIps The secondary private IP or IPs you want to assign to the NIC within the IP range of the Subnet.
	PrivateIps *[]string `json:"privateIps,omitempty"`

	// SecondaryPrivateIpCount The number of secondary private IPs to assign to the NIC.
	SecondaryPrivateIpCount *int `json:"secondaryPrivateIpCount,omitempty"`
}

// LinkPublicIp Information about the public IP association.
type LinkPublicIp struct {
	// Id (Required in a Vpc) The ID representing the association of the public IP with the VM or the NIC.
	Id *string `json:"id,omitempty"`

	// PublicDnsName The name of the public DNS.
	PublicDnsName *string `json:"publicDnsName,omitempty"`

	// PublicIp The public IP associated with the NIC.
	PublicIp *string `json:"publicIp,omitempty"`

	// PublicIpId The allocation ID of the public IP.
	PublicIpId *string `json:"publicIpId,omitempty"`
}

// LinkPublicIpLightForVm Information about the public IP associated with the NIC.
type LinkPublicIpLightForVm struct {
	// PublicDnsName The name of the public DNS.
	PublicDnsName *string `json:"publicDnsName,omitempty"`

	// PublicIp The public IP associated with the NIC.
	PublicIp *string `json:"publicIp,omitempty"`
}

// LinkRouteTable One or more associations between the route table and the Subnets.
type LinkRouteTable struct {
	// Id The ID of the association between the route table and the Subnet.
	Id *string `json:"id,omitempty"`

	// Main If true, the route table is the main one.
	Main *bool `json:"main,omitempty"`

	// RouteTableId The ID of the route table.
	RouteTableId *string `json:"routeTableId,omitempty"`

	// SubnetId The ID of the Subnet.
	SubnetId *string `json:"subnetId,omitempty"`

	// VpcId The ID of the Vpc.
	VpcId *string `json:"vpcId,omitempty"`
}

// LinkVirtualGatewayToVpc defines model for LinkVirtualGatewayToVpc.
type LinkVirtualGatewayToVpc struct {
	// VpcToVirtualGatewayLink Information about the attachment.
	VpcToVirtualGatewayLink *VpcToVirtualGatewayLink `json:"vpcToVirtualGatewayLink,omitempty"`
}

// LinkVolume defines model for LinkVolume.
type LinkVolume struct {
	// DeviceName The name of the device. For a root device, you must use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, and the second `X` is a letter between `a` and `z`).
	DeviceName string `json:"deviceName"`

	// VmId The ID of the VM you want to attach the volume to.
	VmId string `json:"vmId"`
}

// LinkedVolume Information about volume attachment.
type LinkedVolume struct {
	// DeleteOnVmDeletion If true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.
	DeleteOnVmDeletion *bool `json:"deleteOnVmDeletion,omitempty"`

	// DeviceName The name of the device.
	DeviceName *string `json:"deviceName,omitempty"`

	// Id The ID of the volume.
	Id *string `json:"id,omitempty"`

	// State The state of the attachment of the volume (`attaching` \| `detaching` \| `attached` \| `detached`).
	State *string `json:"state,omitempty"`

	// VmId The ID of the VM.
	VmId *string `json:"vmId,omitempty"`
}

// ListBucketsOutput defines model for ListBucketsOutput.
type ListBucketsOutput struct {
	Buckets *Buckets `json:"Buckets,omitempty"`
	Owner   *Owner   `json:"Owner,omitempty"`
}

// ListClusters defines model for ListClusters.
type ListClusters struct {
	Items     *[]OpenShiftCluster `json:"items,omitempty"`
	TotalSize *int                `json:"totalSize,omitempty"`
}

// ListNodepools defines model for ListNodepools.
type ListNodepools struct {
	Items     *[]OpenShiftNodepool `json:"items,omitempty"`
	TotalSize *int                 `json:"totalSize,omitempty"`
}

// ListObjectsOutput defines model for ListObjectsOutput.
type ListObjectsOutput struct {
	CommonPrefixes *CommonPrefixList `json:"CommonPrefixes,omitempty"`
	Contents       *ObjectList       `json:"Contents,omitempty"`
	Delimiter      *Delimiter        `json:"Delimiter,omitempty"`
	EncodingType   *EncodingType     `json:"EncodingType,omitempty"`
	IsTruncated    *IsTruncated      `json:"IsTruncated,omitempty"`
	Marker         *Marker           `json:"Marker,omitempty"`
	MaxKeys        *MaxKeys          `json:"MaxKeys,omitempty"`
	Name           *BucketName       `json:"Name,omitempty"`
	NextMarker     *NextMarker       `json:"NextMarker,omitempty"`
	Prefix         *Prefix           `json:"Prefix,omitempty"`
}

// ListVersions defines model for ListVersions.
type ListVersions struct {
	Items     *[]OpenShiftVersion `json:"items,omitempty"`
	TotalSize *int                `json:"totalSize,omitempty"`
}

// Listener Information about the listener.
type Listener struct {
	// BackendPort The port on which the back-end VM is listening (between `1` and `65535`, both included).
	BackendPort *int `json:"backendPort,omitempty"`

	// BackendProtocol The protocol for routing traffic to back-end VMs (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
	BackendProtocol *string `json:"backendProtocol,omitempty"`

	// LoadBalancerPort The port on which the load balancer is listening (between `1` and `65535`, both included).
	LoadBalancerPort *int `json:"loadBalancerPort,omitempty"`

	// LoadBalancerProtocol The routing protocol (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
	LoadBalancerProtocol *string `json:"loadBalancerProtocol,omitempty"`

	// PolicyNames The names of the policies. If there are no policies enabled, the list is empty.
	PolicyNames *[]string `json:"policyNames,omitempty"`

	// ServerCertificateId The NumSpot Resource Name of the server certificate.
	ServerCertificateId *string `json:"serverCertificateId,omitempty"`
}

// ListenerForCreation Information about the listener to create.
type ListenerForCreation struct {
	// BackendPort The port on which the back-end VM is listening (between `1` and `65535`, both included).
	BackendPort int `json:"backendPort"`

	// BackendProtocol The protocol for routing traffic to back-end VMs (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
	BackendProtocol *string `json:"backendProtocol,omitempty"`

	// LoadBalancerPort The port on which the load balancer is listening (between `1` and `65535`, both included).
	LoadBalancerPort int `json:"loadBalancerPort"`

	// LoadBalancerProtocol The routing protocol (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
	LoadBalancerProtocol string `json:"loadBalancerProtocol"`

	// ServerCertificateId The server certificate orn
	ServerCertificateId *string `json:"serverCertificateId,omitempty"`
}

// ListenerRule Information about the listener rule.
type ListenerRule struct {
	// Action The type of action for the rule (always `forward`).
	Action *string `json:"action,omitempty"`

	// HostNamePattern A host-name pattern for the rule, with a maximum length of 128 characters. This host-name pattern supports maximum three wildcards, and must not contain any special characters except [-.?].
	HostNamePattern *string `json:"hostNamePattern,omitempty"`

	// Id The ID of the listener rule.
	Id *int `json:"id,omitempty"`

	// ListenerId The ID of the listener.
	ListenerId *int `json:"listenerId,omitempty"`

	// Name A human-readable name for the listener rule.
	Name *string `json:"name,omitempty"`

	// PathPattern A path pattern for the rule, with a maximum length of 128 characters. This path pattern supports maximum three wildcards, and must not contain any special characters except [_-.$/~&quot;'@:+?].
	PathPattern *string `json:"pathPattern,omitempty"`

	// Priority The priority level of the listener rule, between `1` and `19999` both included. Each rule must have a unique priority level. Otherwise, an error is returned.
	Priority *int `json:"priority,omitempty"`

	// VmIds The IDs of the backend VMs.
	VmIds *[]string `json:"vmIds,omitempty"`
}

// ListenerRuleForCreation Information about the listener rule.
type ListenerRuleForCreation struct {
	// Action The type of action for the rule (always `forward`).
	Action *string `json:"action,omitempty"`

	// HostNamePattern A host-name pattern for the rule, with a maximum length of 128 characters. This host-name pattern supports maximum three wildcards, and must not contain any special characters except [-.?].
	HostNamePattern *string `json:"hostNamePattern,omitempty"`

	// ListenerRuleName A human-readable name for the listener rule.
	ListenerRuleName string `json:"listenerRuleName"`

	// PathPattern A path pattern for the rule, with a maximum length of 128 characters. This path pattern supports maximum three wildcards, and must not contain any special characters except [_-.$/~&quot;'@:+?].
	PathPattern *string `json:"pathPattern,omitempty"`

	// Priority The priority level of the listener rule, between `1` and `19999` both included. Each rule must have a unique priority level. Otherwise, an error is returned.
	Priority int `json:"priority"`
}

// LoadBalancer Information about the load balancer.
type LoadBalancer struct {
	// ApplicationStickyCookiePolicies The stickiness policies defined for the load balancer.
	ApplicationStickyCookiePolicies *[]ApplicationStickyCookiePolicy `json:"applicationStickyCookiePolicies,omitempty"`

	// AvailabilityZoneNames The ID of the Subregion in which the load balancer was created.
	AvailabilityZoneNames *[]string `json:"availabilityZoneNames,omitempty"`

	// BackendIps One or more public IPs of back-end VMs.
	BackendIps *[]string `json:"backendIps,omitempty"`

	// BackendVmIds One or more IDs of back-end VMs for the load balancer.
	BackendVmIds *[]string `json:"backendVmIds,omitempty"`

	// DnsName The DNS name of the load balancer.
	DnsName *string `json:"dnsName,omitempty"`

	// HealthCheck Information about the health check configuration.
	HealthCheck *HealthCheck `json:"healthCheck,omitempty"`

	// Listeners The listeners for the load balancer.
	Listeners *[]Listener `json:"listeners,omitempty"`

	// Name The name of the load balancer.
	Name *string `json:"name,omitempty"`

	// PublicIp (internet-facing only) The public IP associated with the load balancer.
	PublicIp *string `json:"publicIp,omitempty"`

	// SecuredCookies Whether secure cookies are enabled for the load balancer.
	SecuredCookies *bool `json:"securedCookies,omitempty"`

	// SecurityGroups One or more IDs of security groups for the load balancers. Valid only for load balancers in a Vpc.
	SecurityGroups *[]string `json:"securityGroups,omitempty"`

	// SourceSecurityGroup Information about the source security group of the load balancer, which you can use as part of your inbound rules for your registered VMs.<br />
	// To only allow traffic from load balancers, add a security group rule that specifies this source security group as the inbound source.
	SourceSecurityGroup *SourceSecurityGroup `json:"sourceSecurityGroup,omitempty"`

	// StickyCookiePolicies The policies defined for the load balancer.
	StickyCookiePolicies *[]LoadBalancerStickyCookiePolicy `json:"stickyCookiePolicies,omitempty"`

	// Subnets The ID of the Subnet in which the load balancer was created.
	Subnets *[]string `json:"subnets,omitempty"`

	// Tags One or more tags associated with the load balancer.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// Type The type of load balancer. Valid only for load balancers in a Vpc.<br />
	// If `LoadBalancerType` is `internet-facing`, the load balancer has a public DNS name that resolves to a public IP.<br />
	// If `LoadBalancerType` is `internal`, the load balancer has a public DNS name that resolves to a private IP.
	Type *string `json:"type,omitempty"`

	// VpcId The ID of the Vpc for the load balancer.
	VpcId *string `json:"vpcId,omitempty"`
}

// LoadBalancerLight Information about the load balancer.
type LoadBalancerLight struct {
	// LoadBalancerName The name of the load balancer to which the listener is attached.
	LoadBalancerName string `json:"loadBalancerName"`

	// LoadBalancerPort The port of load balancer on which the load balancer is listening (between `1` and `65535` both included).
	LoadBalancerPort int `json:"loadBalancerPort"`
}

// LoadBalancerStickyCookiePolicy Information about the stickiness policy.
type LoadBalancerStickyCookiePolicy struct {
	// CookieExpirationPeriod The time period, in seconds, after which the cookie should be considered stale.<br />
	// If `1`, the stickiness session lasts for the duration of the browser session.
	CookieExpirationPeriod *int `json:"cookieExpirationPeriod,omitempty"`

	// PolicyName The name of the stickiness policy.
	PolicyName *string `json:"policyName,omitempty"`
}

// LoadBalancerTag Information about the load balancer tag.
type LoadBalancerTag struct {
	// Key The key of the tag.
	Key *string `json:"key,omitempty"`

	// Name The name of the load balancer.
	Name *string `json:"name,omitempty"`

	// Value The value of the tag.
	Value *string `json:"value,omitempty"`
}

// LoginFlow This object represents a login flow. A login flow is initiated at the "Initiate Login API / Browser Flow"
// endpoint by a client.
//
// Once a login flow is completed successfully, a session cookie or session token will be issued.
type LoginFlow struct {
	// Active The active login method
	//
	// If set contains the login method used. If the flow is new, it is unset.
	// password CredentialsTypePassword
	// oidc CredentialsTypeOIDC
	// totp CredentialsTypeTOTP
	// lookup_secret CredentialsTypeLookup
	// webauthn CredentialsTypeWebAuthn
	// code CredentialsTypeCodeAuth
	// link_recovery CredentialsTypeRecoveryLink  CredentialsTypeRecoveryLink is a special credential type linked to the link strategy (recovery flow).  It is not used within the credentials object itself.
	// code_recovery CredentialsTypeRecoveryCode
	Active *LoginFlowActive `json:"active,omitempty"`

	// CreatedAt CreatedAt is a helper struct field for gobuffalo.pop.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// ExpiresAt ExpiresAt is the time (UTC) when the flow expires. If the user still wishes to log in,
	// a new flow has to be initiated.
	ExpiresAt time.Time `json:"expires_at"`

	// Id ID represents the flow's unique ID. When performing the login flow, this
	// represents the id in the login UI's query parameter: http://<selfservice.flows.login.ui_url>/?flow=<flow_id>
	Id openapi_types.UUID `json:"id"`

	// IssuedAt IssuedAt is the time (UTC) when the flow started.
	IssuedAt             time.Time `json:"issued_at"`
	Oauth2LoginChallenge *string   `json:"oauth2_login_challenge,omitempty"`

	// Oauth2LoginRequest OAuth2LoginRequest struct for OAuth2LoginRequest
	Oauth2LoginRequest *OAuth2LoginRequest `json:"oauth2_login_request,omitempty"`
	OrganizationId     *NullUUID           `json:"organization_id"`

	// Refresh Refresh stores whether this login flow should enforce re-authentication.
	Refresh *bool `json:"refresh,omitempty"`

	// RequestUrl RequestURL is the initial URL that was requested. It can be used
	// to forward information contained in the URL's path or query for example.
	RequestUrl string `json:"request_url"`

	// RequestedAal The authenticator assurance level can be one of "aal1", "aal2", or "aal3". A higher number means that it is harder
	// for an attacker to compromise the account.
	// Generally, "aal1" implies that one authentication factor was used while AAL2 implies that two factors (password + TOTP) have been used.
	RequestedAal *AuthenticatorAssuranceLevel `json:"requested_aal,omitempty"`

	// ReturnTo ReturnTo contains the requested return_to URL.
	ReturnTo *string `json:"return_to,omitempty"`

	// SessionTokenExchangeCode SessionTokenExchangeCode holds the secret code that the client can use to retrieve a session token after the login flow has been completed.
	// This is only set if the client has requested a session token exchange code, and if the flow is of type "api",
	// and only on creating the login flow.
	SessionTokenExchangeCode *string `json:"session_token_exchange_code,omitempty"`

	// State State represents the state of this request:
	//
	// choose_method: ask the user to choose a method to sign in with
	// sent_email: the email has been sent to the user
	// passed_challenge: the request was successful and the login challenge was passed.
	State interface{} `json:"state"`

	// Type The flow type can either be `api` or `browser`.
	Type SelfServiceFlowType `json:"type"`

	// Ui Container represents a HTML Form. The container can work with both HTTP Form and JSON requests.
	Ui UiContainer `json:"ui"`

	// UpdatedAt UpdatedAt is a helper struct field for gobuffalo.pop.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// LoginFlowActive The active login method
//
// If set contains the login method used. If the flow is new, it is unset.
// password CredentialsTypePassword
// oidc CredentialsTypeOIDC
// totp CredentialsTypeTOTP
// lookup_secret CredentialsTypeLookup
// webauthn CredentialsTypeWebAuthn
// code CredentialsTypeCodeAuth
// link_recovery CredentialsTypeRecoveryLink  CredentialsTypeRecoveryLink is a special credential type linked to the link strategy (recovery flow).  It is not used within the credentials object itself.
// code_recovery CredentialsTypeRecoveryCode
type LoginFlowActive string

// LogoutFlow Logout Flow
type LogoutFlow struct {
	// LogoutToken LogoutToken can be used to perform logout using AJAX.
	LogoutToken string `json:"logout_token"`

	// LogoutUrl LogoutURL can be opened in a browser to sign the user out.
	//
	// format: uri
	LogoutUrl string `json:"logout_url"`
}

// MaintenanceEvent Information about the maintenance event.
type MaintenanceEvent struct {
	// Code The code of the event (`system-reboot` \| `system-maintenance`).
	Code *string `json:"code,omitempty"`

	// Description The description of the event.
	Description *string `json:"description,omitempty"`

	// NotAfter The latest scheduled end time for the event.
	NotAfter *openapi_types.Date `json:"notAfter,omitempty"`

	// NotBefore The earliest scheduled start time for the event.
	NotBefore *openapi_types.Date `json:"notBefore,omitempty"`
}

// Marker defines model for Marker.
type Marker = string

// MaxKeys defines model for MaxKeys.
type MaxKeys = int

// Metadata defines model for Metadata.
type Metadata map[string]MetadataValue

// MetadataValue defines model for MetadataValue.
type MetadataValue = string

// MultipartUploadId defines model for MultipartUploadId.
type MultipartUploadId = string

// MutableSpace defines model for MutableSpace.
type MutableSpace struct {
	// Description Space description
	Description *string `json:"description,omitempty"`

	// Name Space name
	Name *string `json:"name,omitempty"`
}

// NatGateway Information about the NAT gateway.
type NatGateway struct {
	// Id The ID of the NAT gateway.
	Id *string `json:"id,omitempty"`

	// PublicIps Information about the public IP or IPs associated with the NAT gateway.
	PublicIps *[]PublicIpLight `json:"publicIps,omitempty"`

	// State The state of the NAT gateway (`pending` \| `available` \| `deleting` \| `deleted`).
	State *string `json:"state,omitempty"`

	// SubnetId The ID of the Subnet in which the NAT gateway is.
	SubnetId *string `json:"subnetId,omitempty"`

	// Tags One or more tags associated with the NAT gateway.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// VpcId The ID of the Vpc in which the NAT gateway is.
	VpcId *string `json:"vpcId,omitempty"`
}

// NextMarker defines model for NextMarker.
type NextMarker = string

// Nic Information about the NIC.
type Nic struct {
	// AvailabilityZoneName The Subregion in which the NIC is located.
	AvailabilityZoneName *string `json:"availabilityZoneName,omitempty"`

	// Description The description of the NIC.
	Description *string `json:"description,omitempty"`

	// Id The ID of the NIC.
	Id *string `json:"id,omitempty"`

	// IsSourceDestChecked (Vpc only) If true, the source/destination check is enabled. If false, it is disabled. This value must be false for a NAT VM to perform network address translation (NAT) in a Vpc.
	IsSourceDestChecked *bool `json:"isSourceDestChecked,omitempty"`

	// LinkNic Information about the NIC attachment.
	LinkNic *LinkNic `json:"linkNic,omitempty"`

	// LinkPublicIp Information about the public IP association.
	LinkPublicIp *LinkPublicIp `json:"linkPublicIp,omitempty"`

	// MacAddress The Media Access Control (MAC) address of the NIC.
	MacAddress *string `json:"macAddress,omitempty"`

	// PrivateDnsName The name of the private DNS.
	PrivateDnsName *string `json:"privateDnsName,omitempty"`

	// PrivateIps The private IPs of the NIC.
	PrivateIps *[]PrivateIp `json:"privateIps,omitempty"`

	// SecurityGroups One or more IDs of security groups for the NIC.
	SecurityGroups *[]SecurityGroupLight `json:"securityGroups,omitempty"`

	// State The state of the NIC (`available` \| `attaching` \| `in-use` \| `detaching`).
	State *string `json:"state,omitempty"`

	// SubnetId The ID of the Subnet.
	SubnetId *string `json:"subnetId,omitempty"`

	// Tags One or more tags associated with the NIC.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// VpcId The ID of the Vpc for the NIC.
	VpcId *string `json:"vpcId,omitempty"`
}

// NicForVmCreation Information about the network interface card (NIC) when creating a virtual machine (VM).
type NicForVmCreation struct {
	// DeleteOnVmDeletion If true, the NIC is deleted when the VM is terminated. You can specify this parameter only for a new NIC. To modify this value for an existing NIC, see [UpdateNic](#updatenic).
	DeleteOnVmDeletion *bool `json:"deleteOnVmDeletion,omitempty"`

	// Description The description of the NIC, if you are creating a NIC when creating the VM.
	Description *string `json:"description,omitempty"`

	// DeviceNumber The index of the VM device for the NIC attachment (between `0` and `7`, both included). This parameter is required if you create a NIC when creating the VM.
	DeviceNumber *int `json:"deviceNumber,omitempty"`

	// NicId The ID of the NIC, if you are attaching an existing NIC when creating a VM.
	NicId *string `json:"nicId,omitempty"`

	// PrivateIps One or more private IPs to assign to the NIC, if you create a NIC when creating a VM. Only one private IP can be the primary private IP.
	PrivateIps *[]PrivateIpLight `json:"privateIps,omitempty"`

	// SecondaryPrivateIpCount The number of secondary private IPs, if you create a NIC when creating a VM. This parameter cannot be specified if you specified more than one private IP in the `PrivateIps` parameter.
	SecondaryPrivateIpCount *int `json:"secondaryPrivateIpCount,omitempty"`

	// SecurityGroupIds One or more IDs of security groups for the NIC, if you create a NIC when creating a VM.
	SecurityGroupIds *[]string `json:"securityGroupIds,omitempty"`

	// SubnetId The ID of the Subnet for the NIC, if you create a NIC when creating a VM. This parameter is required if you create a NIC when creating the VM.
	SubnetId *string `json:"subnetId,omitempty"`
}

// NicLight Information about the network interface card (NIC).
type NicLight struct {
	// Description The description of the NIC.
	Description *string `json:"description,omitempty"`

	// IsSourceDestChecked (Vpc only) If true, the source/destination check is enabled. If false, it is disabled. This value must be false for a NAT VM to perform network address translation (NAT) in a Vpc.
	IsSourceDestChecked *bool `json:"isSourceDestChecked,omitempty"`

	// LinkNic Information about the network interface card (NIC).
	LinkNic *LinkNicLight `json:"linkNic,omitempty"`

	// LinkPublicIp Information about the public IP associated with the NIC.
	LinkPublicIp *LinkPublicIpLightForVm `json:"linkPublicIp,omitempty"`

	// MacAddress The Media Access Control (MAC) address of the NIC.
	MacAddress *string `json:"macAddress,omitempty"`

	// NicId The ID of the NIC.
	NicId *string `json:"nicId,omitempty"`

	// PrivateDnsName The name of the private DNS.
	PrivateDnsName *string `json:"privateDnsName,omitempty"`

	// PrivateIps The private IP or IPs of the NIC.
	PrivateIps *[]PrivateIpLightForVm `json:"privateIps,omitempty"`

	// SecurityGroups One or more IDs of security groups for the NIC.
	SecurityGroups *[]SecurityGroupLight `json:"securityGroups,omitempty"`

	// State The state of the NIC (`available` \| `attaching` \| `in-use` \| `detaching`).
	State *string `json:"state,omitempty"`

	// SubnetId The ID of the Subnet for the NIC.
	SubnetId *string `json:"subnetId,omitempty"`

	// VpcId The ID of the Vpc for the NIC.
	VpcId *string `json:"vpcId,omitempty"`
}

// NoSuchBucket defines model for NoSuchBucket.
type NoSuchBucket = interface{}

// NoSuchKey defines model for NoSuchKey.
type NoSuchKey = interface{}

// NoSuchUpload defines model for NoSuchUpload.
type NoSuchUpload = interface{}

// NodeProfile Node profiles
type NodeProfile string

// NullJsonRawMessage defines model for NullJsonRawMessage.
type NullJsonRawMessage = interface{}

// NullTime defines model for NullTime.
type NullTime = time.Time

// NullUUID defines model for NullUUID.
type NullUUID = string

// OAuth2Client OAuth2Client OAuth 2.0 Clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
type OAuth2Client struct {
	// AccessTokenStrategy OAuth 2.0 Access Token Strategy  AccessTokenStrategy is the strategy used to generate access tokens. Valid options are `jwt` and `opaque`. `jwt` is a bad idea.
	AccessTokenStrategy *string   `json:"access_token_strategy,omitempty"`
	AllowedCorsOrigins  *[]string `json:"allowed_cors_origins,omitempty"`
	Audience            *[]string `json:"audience,omitempty"`

	// AuthorizationCodeGrantAccessTokenLifespan Specify a time duration in milliseconds, seconds, minutes, hours.
	AuthorizationCodeGrantAccessTokenLifespan *string `json:"authorization_code_grant_access_token_lifespan,omitempty"`

	// AuthorizationCodeGrantIdTokenLifespan Specify a time duration in milliseconds, seconds, minutes, hours.
	AuthorizationCodeGrantIdTokenLifespan *string `json:"authorization_code_grant_id_token_lifespan,omitempty"`

	// AuthorizationCodeGrantRefreshTokenLifespan Specify a time duration in milliseconds, seconds, minutes, hours.
	AuthorizationCodeGrantRefreshTokenLifespan *string `json:"authorization_code_grant_refresh_token_lifespan,omitempty"`

	// BackchannelLogoutSessionRequired OpenID Connect Back-Channel Logout Session Required  Boolean value specifying whether the RP requires that a sid (session ID) Claim be included in the Logout Token to identify the RP session with the OP when the backchannel_logout_uri is used. If omitted, the default value is false.
	BackchannelLogoutSessionRequired *bool `json:"backchannel_logout_session_required,omitempty"`

	// BackchannelLogoutUri OpenID Connect Back-Channel Logout URI  RP URL that will cause the RP to log itself out when sent a Logout Token by the OP.
	BackchannelLogoutUri *string `json:"backchannel_logout_uri,omitempty"`

	// ClientCredentialsGrantAccessTokenLifespan Specify a time duration in milliseconds, seconds, minutes, hours.
	ClientCredentialsGrantAccessTokenLifespan *string `json:"client_credentials_grant_access_token_lifespan,omitempty"`

	// ClientId OAuth 2.0 Client ID  The ID is immutable. If no ID is provided, a UUID4 will be generated.
	ClientId *string `json:"client_id,omitempty"`

	// ClientName OAuth 2.0 Client Name  The human-readable name of the client to be presented to the end-user during authorization.
	ClientName *string `json:"client_name,omitempty"`

	// ClientSecret OAuth 2.0 Client Secret  The secret will be included in the create request as cleartext, and then never again. The secret is kept in hashed format and is not recoverable once lost.
	ClientSecret *string `json:"client_secret,omitempty"`

	// ClientSecretExpiresAt OAuth 2.0 Client Secret Expires At  The field is currently not supported and its value is always 0.
	ClientSecretExpiresAt *int64 `json:"client_secret_expires_at,omitempty"`

	// ClientUri OAuth 2.0 Client URI  ClientURI is a URL string of a web page providing information about the client. If present, the server SHOULD display this URL to the end-user in a clickable fashion.
	ClientUri *string   `json:"client_uri,omitempty"`
	Contacts  *[]string `json:"contacts,omitempty"`

	// CreatedAt OAuth 2.0 Client Creation Date  CreatedAt returns the timestamp of the client's creation.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// FrontchannelLogoutSessionRequired OpenID Connect Front-Channel Logout Session Required  Boolean value specifying whether the RP requires that iss (issuer) and sid (session ID) query parameters be included to identify the RP session with the OP when the frontchannel_logout_uri is used. If omitted, the default value is false.
	FrontchannelLogoutSessionRequired *bool `json:"frontchannel_logout_session_required,omitempty"`

	// FrontchannelLogoutUri OpenID Connect Front-Channel Logout URI  RP URL that will cause the RP to log itself out when rendered in an iframe by the OP. An iss (issuer) query parameter and a sid (session ID) query parameter MAY be included by the OP to enable the RP to validate the request and to determine which of the potentially multiple sessions is to be logged out; if either is included, both MUST be.
	FrontchannelLogoutUri *string   `json:"frontchannel_logout_uri,omitempty"`
	GrantTypes            *[]string `json:"grant_types,omitempty"`

	// ImplicitGrantAccessTokenLifespan Specify a time duration in milliseconds, seconds, minutes, hours.
	ImplicitGrantAccessTokenLifespan *string `json:"implicit_grant_access_token_lifespan,omitempty"`

	// ImplicitGrantIdTokenLifespan Specify a time duration in milliseconds, seconds, minutes, hours.
	ImplicitGrantIdTokenLifespan *string `json:"implicit_grant_id_token_lifespan,omitempty"`

	// Jwks OAuth 2.0 Client JSON Web Key Set  Client's JSON Web Key Set [JWK] document, passed by value. The semantics of the jwks parameter are the same as the jwks_uri parameter, other than that the JWK Set is passed by value, rather than by reference. This parameter is intended only to be used by Clients that, for some reason, are unable to use the jwks_uri parameter, for instance, by native applications that might not have a location to host the contents of the JWK Set. If a Client can use jwks_uri, it MUST NOT use jwks. One significant downside of jwks is that it does not enable key rotation (which jwks_uri does, as described in Section 10 of OpenID Connect Core 1.0 [OpenID.Core]). The jwks_uri and jwks parameters MUST NOT be used together.
	Jwks *interface{} `json:"jwks,omitempty"`

	// JwksUri OAuth 2.0 Client JSON Web Key Set URL  URL for the Client's JSON Web Key Set [JWK] document. If the Client signs requests to the Server, it contains the signing key(s) the Server uses to validate signatures from the Client. The JWK Set MAY also contain the Client's encryption keys(s), which are used by the Server to encrypt responses to the Client. When both signing and encryption keys are made available, a use (Key Use) parameter value is REQUIRED for all keys in the referenced JWK Set to indicate each key's intended usage. Although some algorithms allow the same key to be used for both signatures and encryption, doing so is NOT RECOMMENDED, as it is less secure. The JWK x5c parameter MAY be used to provide X.509 representations of keys provided. When used, the bare key values MUST still be present and MUST match those in the certificate.
	JwksUri *string `json:"jwks_uri,omitempty"`

	// JwtBearerGrantAccessTokenLifespan Specify a time duration in milliseconds, seconds, minutes, hours.
	JwtBearerGrantAccessTokenLifespan *string `json:"jwt_bearer_grant_access_token_lifespan,omitempty"`

	// LogoUri OAuth 2.0 Client Logo URI  A URL string referencing the client's logo.
	LogoUri *string `json:"logo_uri,omitempty"`

	// Owner OAuth 2.0 Client Owner  Owner is a string identifying the owner of the OAuth 2.0 Client.
	Owner *string `json:"owner,omitempty"`

	// PolicyUri OAuth 2.0 Client Policy URI  PolicyURI is a URL string that points to a human-readable privacy policy document that describes how the deployment organization collects, uses, retains, and discloses personal data.
	PolicyUri              *string   `json:"policy_uri,omitempty"`
	PostLogoutRedirectUris *[]string `json:"post_logout_redirect_uris,omitempty"`
	RedirectUris           *[]string `json:"redirect_uris,omitempty"`

	// RefreshTokenGrantAccessTokenLifespan Specify a time duration in milliseconds, seconds, minutes, hours.
	RefreshTokenGrantAccessTokenLifespan *string `json:"refresh_token_grant_access_token_lifespan,omitempty"`

	// RefreshTokenGrantIdTokenLifespan Specify a time duration in milliseconds, seconds, minutes, hours.
	RefreshTokenGrantIdTokenLifespan *string `json:"refresh_token_grant_id_token_lifespan,omitempty"`

	// RefreshTokenGrantRefreshTokenLifespan Specify a time duration in milliseconds, seconds, minutes, hours.
	RefreshTokenGrantRefreshTokenLifespan *string `json:"refresh_token_grant_refresh_token_lifespan,omitempty"`

	// RegistrationAccessToken OpenID Connect Dynamic Client Registration Access Token  RegistrationAccessToken can be used to update, get, or delete the OAuth2 Client. It is sent when creating a client using Dynamic Client Registration.
	RegistrationAccessToken *string `json:"registration_access_token,omitempty"`

	// RegistrationClientUri OpenID Connect Dynamic Client Registration URL  RegistrationClientURI is the URL used to update, get, or delete the OAuth2 Client.
	RegistrationClientUri *string `json:"registration_client_uri,omitempty"`

	// RequestObjectSigningAlg OpenID Connect Request Object Signing Algorithm  JWS [JWS] alg algorithm [JWA] that MUST be used for signing Request Objects sent to the OP. All Request Objects from this Client MUST be rejected, if not signed with this algorithm.
	RequestObjectSigningAlg *string   `json:"request_object_signing_alg,omitempty"`
	RequestUris             *[]string `json:"request_uris,omitempty"`
	ResponseTypes           *[]string `json:"response_types,omitempty"`

	// Scope OAuth 2.0 Client Scope  Scope is a string containing a space-separated list of scope values (as described in Section 3.3 of OAuth 2.0 [RFC6749]) that the client can use when requesting access tokens.
	Scope *string `json:"scope,omitempty"`

	// SectorIdentifierUri OpenID Connect Sector Identifier URI  URL using the https scheme to be used in calculating Pseudonymous Identifiers by the OP. The URL references a file with a single JSON array of redirect_uri values.
	SectorIdentifierUri *string `json:"sector_identifier_uri,omitempty"`

	// SkipConsent SkipConsent skips the consent screen for this client. This field can only be set from the admin API.
	SkipConsent *bool `json:"skip_consent,omitempty"`

	// SkipLogoutConsent SkipLogoutConsent skips the logout consent screen for this client. This field can only be set from the admin API.
	SkipLogoutConsent *bool `json:"skip_logout_consent,omitempty"`

	// SubjectType OpenID Connect Subject Type  The `subject_types_supported` Discovery parameter contains a list of the supported subject_type values for this server. Valid types include `pairwise` and `public`.
	SubjectType *string `json:"subject_type,omitempty"`

	// TokenEndpointAuthMethod OAuth 2.0 Token Endpoint Authentication Method  Requested Client Authentication method for the Token Endpoint. The options are:  `client_secret_basic`: (default) Send `client_id` and `client_secret` as `application/x-www-form-urlencoded` encoded in the HTTP Authorization header. `client_secret_post`: Send `client_id` and `client_secret` as `application/x-www-form-urlencoded` in the HTTP body. `private_key_jwt`: Use JSON Web Tokens to authenticate the client. `none`: Used for public clients (native apps, mobile apps) which can not have secrets.
	TokenEndpointAuthMethod *string `json:"token_endpoint_auth_method,omitempty"`

	// TokenEndpointAuthSigningAlg OAuth 2.0 Token Endpoint Signing Algorithm  Requested Client Authentication signing algorithm for the Token Endpoint.
	TokenEndpointAuthSigningAlg *string `json:"token_endpoint_auth_signing_alg,omitempty"`

	// TosUri OAuth 2.0 Client Terms of Service URI  A URL string pointing to a human-readable terms of service document for the client that describes a contractual relationship between the end-user and the client that the end-user accepts when authorizing the client.
	TosUri *string `json:"tos_uri,omitempty"`

	// UpdatedAt OAuth 2.0 Client Last Update Date  UpdatedAt returns the timestamp of the last update.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// UserinfoSignedResponseAlg OpenID Connect Request Userinfo Signed Response Algorithm  JWS alg algorithm [JWA] REQUIRED for signing UserInfo Responses. If this is specified, the response will be JWT [JWT] serialized, and signed using JWS. The default, if omitted, is for the UserInfo Response to return the Claims as a UTF-8 encoded JSON object using the application/json content-type.
	UserinfoSignedResponseAlg *string `json:"userinfo_signed_response_alg,omitempty"`
}

// OAuth2ConsentRequestOpenIDConnectContext OAuth2ConsentRequestOpenIDConnectContext struct
type OAuth2ConsentRequestOpenIDConnectContext struct {
	// AcrValues ACRValues is the Authentication AuthorizationContext Class Reference requested in the OAuth 2.0 Authorization request. It is a parameter defined by OpenID Connect and expresses which level of authentication (e.g. 2FA) is required.  OpenID Connect defines it as follows: > Requested Authentication AuthorizationContext Class Reference values. Space-separated string that specifies the acr values that the Authorization Server is being requested to use for processing this Authentication Request, with the values appearing in order of preference. The Authentication AuthorizationContext Class satisfied by the authentication performed is returned as the acr Claim Value, as specified in Section 2. The acr Claim is requested as a Voluntary Claim by this parameter.
	AcrValues *[]string `json:"acr_values,omitempty"`

	// Display Display is a string value that specifies how the Authorization Server displays the authentication and consent user interface pages to the End-User. The defined values are: page: The Authorization Server SHOULD display the authentication and consent UI consistent with a full User Agent page view. If the display parameter is not specified, this is the default display mode. popup: The Authorization Server SHOULD display the authentication and consent UI consistent with a popup User Agent window. The popup User Agent window should be of an appropriate size for a login-focused dialog and should not obscure the entire window that it is popping up over. touch: The Authorization Server SHOULD display the authentication and consent UI consistent with a device that leverages a touch interface. wap: The Authorization Server SHOULD display the authentication and consent UI consistent with a \"feature phone\" type display.  The Authorization Server MAY also attempt to detect the capabilities of the User Agent and present an appropriate display.
	Display *string `json:"display,omitempty"`

	// IdTokenHintClaims IDTokenHintClaims are the claims of the ID Token previously issued by the Authorization Server being passed as a hint about the End-User's current or past authenticated session with the Client.
	IdTokenHintClaims *map[string]interface{} `json:"id_token_hint_claims,omitempty"`

	// LoginHint LoginHint hints about the login identifier the End-User might use to log in (if necessary). This hint can be used by an RP if it first asks the End-User for their e-mail address (or other identifier) and then wants to pass that value as a hint to the discovered authorization service. This value MAY also be a phone number in the format specified for the phone_number Claim. The use of this parameter is optional.
	LoginHint *string `json:"login_hint,omitempty"`

	// UiLocales UILocales is the End-User'id preferred languages and scripts for the user interface, represented as a space-separated list of BCP47 [RFC5646] language tag values, ordered by preference. For instance, the value \"fr-CA fr en\" represents a preference for French as spoken in Canada, then French (without a region designation), followed by English (without a region designation). An error SHOULD NOT result if some or all of the requested locales are not supported by the OpenID Provider.
	UiLocales *[]string `json:"ui_locales,omitempty"`
}

// OAuth2LoginRequest OAuth2LoginRequest struct for OAuth2LoginRequest
type OAuth2LoginRequest struct {
	// Challenge ID is the identifier (\"login challenge\") of the login request. It is used to identify the session.
	Challenge *string `json:"challenge,omitempty"`

	// Client OAuth2Client OAuth 2.0 Clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
	Client *OAuth2Client `json:"client,omitempty"`

	// OidcContext OAuth2ConsentRequestOpenIDConnectContext struct
	OidcContext *OAuth2ConsentRequestOpenIDConnectContext `json:"oidc_context,omitempty"`

	// RequestUrl RequestURL is the original OAuth 2.0 Authorization URL requested by the OAuth 2.0 client. It is the URL which initiates the OAuth 2.0 Authorization Code or OAuth 2.0 Implicit flow. This URL is typically not needed, but might come in handy if you want to deal with additional request parameters.
	RequestUrl                   *string   `json:"request_url,omitempty"`
	RequestedAccessTokenAudience *[]string `json:"requested_access_token_audience,omitempty"`
	RequestedScope               *[]string `json:"requested_scope,omitempty"`

	// SessionId SessionID is the login session ID. If the user-agent reuses a login session (via cookie / remember flag) this ID will remain the same. If the user-agent did not have an existing authentication session (e.g. remember is false) this will be a new random value. This value is used as the \"sid\" parameter in the ID Token and in OIDC Front-/Back- channel logout. It's value can generally be used to associate consecutive login requests by a certain user.
	SessionId *string `json:"session_id,omitempty"`

	// Skip Skip, if true, implies that the client has requested the same scopes from the same user previously. If true, you can skip asking the user to grant the requested scopes, and simply forward the user to the redirect URL.  This feature allows you to update / set session information.
	Skip *bool `json:"skip,omitempty"`

	// Subject Subject is the user ID of the end-user that authenticated. Now, that end user needs to grant or deny the scope requested by the OAuth 2.0 client. If this value is set and `skip` is true, you MUST include this subject type when accepting the login request, or the request will fail.
	Subject *string `json:"subject,omitempty"`
}

// Object defines model for Object.
type Object struct {
	ChecksumAlgorithm *ChecksumAlgorithmList `json:"ChecksumAlgorithm,omitempty"`
	ETag              *ETag                  `json:"ETag,omitempty"`
	Key               *ObjectKey             `json:"Key,omitempty"`
	LastModified      *LastModified          `json:"LastModified,omitempty"`
	Owner             *Owner                 `json:"Owner,omitempty"`
	RestoreStatus     *RestoreStatus         `json:"RestoreStatus,omitempty"`
	Size              *Size                  `json:"Size,omitempty"`
	StorageClass      *ObjectStorageClass    `json:"StorageClass,omitempty"`
}

// ObjectKey defines model for ObjectKey.
type ObjectKey = string

// ObjectList defines model for ObjectList.
type ObjectList = []Object

// ObjectLocation defines model for ObjectLocation.
type ObjectLocation = string

// ObjectStorageClass defines model for ObjectStorageClass.
type ObjectStorageClass string

// OidcConfiguration Includes links to several endpoints and exposes information on supported signature algorithms among others.
type OidcConfiguration struct {
	// AuthorizationEndpoint OAuth 2.0 Authorization Endpoint URL
	AuthorizationEndpoint string `json:"authorization_endpoint"`

	// BackchannelLogoutSessionSupported OpenID Connect Back-Channel Logout Session Required
	// Boolean value specifying whether the OP can pass a sid (session ID) Claim in the Logout Token to identify the RP session with the OP. If supported, the sid Claim is also included in ID Tokens issued by the OP.
	BackchannelLogoutSessionSupported *bool `json:"backchannel_logout_session_supported,omitempty"`

	// BackchannelLogoutSupported OpenID Connect Back-Channel Logout Supported
	// Boolean value specifying whether the OP supports back-channel logout, with true indicating support.
	BackchannelLogoutSupported *bool `json:"backchannel_logout_supported,omitempty"`

	// ClaimsParameterSupported OpenID Connect Claims Parameter Parameter Supported
	// Boolean value specifying whether the OP supports use of the claims parameter, with true indicating support.
	ClaimsParameterSupported *bool `json:"claims_parameter_supported,omitempty"`

	// ClaimsSupported OpenID Connect Supported Claims
	// JSON array containing a list of the Claim Names of the Claims that the OpenID Provider MAY be able to supply values for. Note that for privacy or other reasons, this might not be an exhaustive list.
	ClaimsSupported *[]string `json:"claims_supported,omitempty"`

	// CodeChallengeMethodsSupported OAuth 2.0 PKCE Supported Code Challenge Methods
	// JSON array containing a list of Proof Key for Code Exchange (PKCE) [RFC7636] code challenge methods supported by this authorization server.
	CodeChallengeMethodsSupported *[]string `json:"code_challenge_methods_supported,omitempty"`

	// CredentialsEndpointDraft00 OpenID Connect Verifiable Credentials Endpoint
	//
	// Contains the URL of the Verifiable Credentials Endpoint.
	CredentialsEndpointDraft00 *string `json:"credentials_endpoint_draft_00,omitempty"`

	// CredentialsSupportedDraft00 OpenID Connect Verifiable Credentials Supported
	// JSON array containing a list of the Verifiable Credentials supported by this authorization server.
	CredentialsSupportedDraft00 *[]CredentialSupportedDraft00 `json:"credentials_supported_draft_00,omitempty"`

	// EndSessionEndpoint OpenID Connect End-Session Endpoint
	// An URL provided by the OpenID Provider (OP) that a Relying Party (RP) can redirect to, to initiate a logout process for the End-User at the OP. This is part of the OpenID Connect session management functionality,  allowing for single sign-out across applications.
	EndSessionEndpoint *string `json:"end_session_endpoint,omitempty"`

	// FrontchannelLogoutSessionSupported OpenID Connect Front-Channel Logout Session Required
	// The boolean indicates if the OpenID Provider (OP) can use issuer (iss) and session ID (sid) parameters to identify the Relying Party (RP) session during logout via the  frontchannel_logout_uri. If this is supported, the sid claim is also included in ID Tokens issued by the OP.
	FrontchannelLogoutSessionSupported *bool `json:"frontchannel_logout_session_supported,omitempty"`

	// FrontchannelLogoutSupported OpenID Connect Front-Channel Logout Supported
	// Boolean value specifying whether the OP supports HTTP-based logout, with true indicating support.
	FrontchannelLogoutSupported *bool `json:"frontchannel_logout_supported,omitempty"`

	// GrantTypesSupported OAuth 2.0 Supported Grant Types
	// JSON array containing a list of the OAuth 2.0 Grant Type values that this OP supports.
	GrantTypesSupported *[]string `json:"grant_types_supported,omitempty"`

	// IdTokenSignedResponseAlg OpenID Connect Default ID Token Signing Algorithms
	//
	// Algorithm used to sign OpenID Connect ID Tokens.
	IdTokenSignedResponseAlg []string `json:"id_token_signed_response_alg"`

	// IdTokenSigningAlgValuesSupported OpenID Connect Supported ID Token Signing Algorithms
	//
	// JSON array containing a list of the JWS signing algorithms (alg values) supported by the OP for the ID Token to encode the Claims in a JWT.
	IdTokenSigningAlgValuesSupported []string `json:"id_token_signing_alg_values_supported"`

	// Issuer OpenID Connect Issuer URL
	// An URL using the https scheme with no query or fragment component that the OP asserts as its IssuerURL Identifier. If IssuerURL discovery is supported, this value MUST be identical to the issuer value returned by WebFinger. This also MUST be identical to the iss Claim value in ID Tokens issued from this IssuerURL.
	Issuer string `json:"issuer"`

	// JwksUri OpenID Connect Well-Known JSON Web Keys URL
	// The jwks_uri is the URL for the OpenID Provider's (OP) JSON Web Key Set (JWK) document, which contains the keys used by the Relying Party (RP) to validate the OP's signatures and, optionally, encrypt requests. Each key must specify its use (signing or encryption) for security purposes. The JWK set may include X.509  representations of keys via the x5c parameter, but the bare key values must still be present and match those in the certificate.
	JwksUri string `json:"jwks_uri"`

	// RegistrationEndpoint OpenID Connect Dynamic Client Registration Endpoint URL
	RegistrationEndpoint *string `json:"registration_endpoint,omitempty"`

	// RequestObjectSigningAlgValuesSupported OpenID Connect Supported Request Object Signing Algorithms
	// JSON array containing a list of the JWS signing algorithms (alg values) supported by the OP for Request Objects, which are described in Section 6.1 of OpenID Connect Core 1.0 [OpenID.Core]. These algorithms are used both when the Request Object is passed by value (using the request parameter) and when it is passed by reference (using the request_uri parameter).
	RequestObjectSigningAlgValuesSupported *[]string `json:"request_object_signing_alg_values_supported,omitempty"`

	// RequestParameterSupported OpenID Connect Request Parameter Supported
	// Boolean value specifying whether the OP supports use of the request parameter, with true indicating support.
	RequestParameterSupported *bool `json:"request_parameter_supported,omitempty"`

	// RequestUriParameterSupported OpenID Connect Request URI Parameter Supported
	// Boolean value specifying whether the OP supports use of the request_uri parameter, with true indicating support.
	RequestUriParameterSupported *bool `json:"request_uri_parameter_supported,omitempty"`

	// RequireRequestUriRegistration OpenID Connect Requires Request URI Registration
	// Boolean value specifying whether the OP requires any request_uri values used to be pre-registered using the request_uris registration parameter.
	RequireRequestUriRegistration *bool `json:"require_request_uri_registration,omitempty"`

	// ResponseModesSupported OAuth 2.0 Supported Response Modes
	// JSON array containing a list of the OAuth 2.0 response_mode values that this OP supports.
	ResponseModesSupported *[]string `json:"response_modes_supported,omitempty"`

	// ResponseTypesSupported OAuth 2.0 Supported Response Types
	// JSON array containing a list of the OAuth 2.0 response_type values that this OP supports. Dynamic OpenID Providers MUST support the code, id_token, and the token id_token Response Type values.
	ResponseTypesSupported []string `json:"response_types_supported"`

	// RevocationEndpoint OAuth 2.0 Token Revocation URL
	//
	// URL of the authorization server's OAuth 2.0 revocation endpoint.
	RevocationEndpoint *string `json:"revocation_endpoint,omitempty"`

	// ScopesSupported OAuth 2.0 Supported Scope Values
	// JSON array containing a list of the OAuth 2.0 [RFC6749] scope values that this server supports. The server MUST support the openid scope value. Servers MAY choose not to advertise some supported scope values even when this parameter is used
	ScopesSupported *[]string `json:"scopes_supported,omitempty"`

	// SubjectTypesSupported OpenID Connect Supported Subject Types
	// JSON array containing a list of the Subject Identifier types that this OP supports. Valid types include pairwise and public.
	SubjectTypesSupported []string `json:"subject_types_supported"`

	// TokenEndpoint OAuth 2.0 Token Endpoint URL
	TokenEndpoint string `json:"token_endpoint"`

	// TokenEndpointAuthMethodsSupported OAuth 2.0 Supported Client Authentication Methods
	//
	// JSON array containing a list of Client Authentication methods supported by this Token Endpoint. The options are client_secret_post, client_secret_basic, client_secret_jwt, and private_key_jwt, as described in Section 9 of OpenID Connect Core 1.0
	TokenEndpointAuthMethodsSupported *[]string `json:"token_endpoint_auth_methods_supported,omitempty"`

	// UserinfoEndpoint OpenID Connect Userinfo URL
	//
	// URL of the OP's UserInfo Endpoint.
	UserinfoEndpoint *string `json:"userinfo_endpoint,omitempty"`

	// UserinfoSignedResponseAlg OpenID Connect User Userinfo Signing Algorithm
	//
	// Algorithm used to sign OpenID Connect Userinfo Responses.
	UserinfoSignedResponseAlg []string `json:"userinfo_signed_response_alg"`

	// UserinfoSigningAlgValuesSupported OpenID Connect Supported Userinfo Signing Algorithm
	// JSON array containing a list of the JWS [JWS] signing algorithms (alg values) [JWA] supported by the UserInfo Endpoint to encode the Claims in a JWT [JWT].
	UserinfoSigningAlgValuesSupported *[]string `json:"userinfo_signing_alg_values_supported,omitempty"`
}

// OpenShiftCluster defines model for OpenShiftCluster.
type OpenShiftCluster struct {
	Cidr        *string               `json:"cidr,omitempty"`
	Description *string               `json:"description,omitempty"`
	Id          *openapi_types.UUID   `json:"id,omitempty"`
	Name        *string               `json:"name,omitempty"`
	NodePools   *[]OpenShiftNodepool  `json:"nodePools,omitempty"`
	Urls        *OpenShiftClusterUrls `json:"urls,omitempty"`
	Version     *string               `json:"version,omitempty"`
}

// OpenShiftClusterUrls defines model for OpenShiftClusterUrls.
type OpenShiftClusterUrls struct {
	Api     *string `json:"api,omitempty"`
	Console *string `json:"console,omitempty"`
}

// OpenShiftNodepool defines model for OpenShiftNodepool.
type OpenShiftNodepool struct {
	// Gpu GPU values
	Gpu       *Gpu   `json:"gpu,omitempty"`
	Name      string `json:"name"`
	NodeCount int    `json:"nodeCount"`

	// NodeProfile Node profiles
	NodeProfile NodeProfile `json:"nodeProfile"`
	Tina        *string     `json:"tina,omitempty"`
}

// OpenShiftVersion defines model for OpenShiftVersion.
type OpenShiftVersion struct {
	Name    *string `json:"name,omitempty"`
	Version string  `json:"version"`
}

// Operation defines model for Operation.
type Operation struct {
	CreateTime *time.Time          `json:"createTime,omitempty"`
	Data       *Operation_Data     `json:"data,omitempty"`
	EndTime    *time.Time          `json:"endTime,omitempty"`
	Error      *Operation_Error    `json:"error,omitempty"`
	Id         *openapi_types.UUID `json:"id,omitempty"`
	Progress   *Operation_Progress `json:"progress,omitempty"`
	Result     *Operation_Result   `json:"result,omitempty"`
	SelfLink   *string             `json:"selfLink,omitempty"`
	StartTime  *time.Time          `json:"startTime,omitempty"`

	// Status Operation status
	Status     *OperationStatus `json:"status,omitempty"`
	TargetLink *string          `json:"targetLink,omitempty"`
	Type       *string          `json:"type,omitempty"`
}

// OperationData0 defines model for .
type OperationData0 = string

// OperationData1 defines model for .
type OperationData1 map[string]interface{}

// Operation_Data defines model for Operation.Data.
type Operation_Data struct {
	union json.RawMessage
}

// OperationError0 defines model for .
type OperationError0 = string

// OperationError1 defines model for .
type OperationError1 map[string]interface{}

// Operation_Error defines model for Operation.Error.
type Operation_Error struct {
	union json.RawMessage
}

// OperationProgress0 defines model for .
type OperationProgress0 = string

// OperationProgress1 defines model for .
type OperationProgress1 map[string]interface{}

// Operation_Progress defines model for Operation.Progress.
type Operation_Progress struct {
	union json.RawMessage
}

// OperationResult0 defines model for .
type OperationResult0 = string

// OperationResult1 defines model for .
type OperationResult1 map[string]interface{}

// Operation_Result defines model for Operation.Result.
type Operation_Result struct {
	union json.RawMessage
}

// OperationStatus Operation status
type OperationStatus string

// Operations defines model for Operations.
type Operations struct {
	Items     *[]Operation `json:"items,omitempty"`
	TotalSize *int         `json:"totalSize,omitempty"`
}

// OrganisationSimple defines model for OrganisationSimple.
type OrganisationSimple struct {
	// Id Organisation identifier
	Id openapi_types.UUID `json:"id"`
}

// OrganisationSimplePaginatedList defines model for OrganisationSimplePaginatedList.
type OrganisationSimplePaginatedList struct {
	Items []OrganisationSimple `json:"items"`

	// NextPageToken This token is used to retrieve the next page. If this field is omitted, there are no subsequent pages.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// TotalSize Equivalent to int32
	TotalSize *Int `json:"totalSize,omitempty"`
}

// Owner defines model for Owner.
type Owner struct {
	DisplayName *DisplayName `json:"DisplayName,omitempty"`
	ID          *OwnerID     `json:"ID,omitempty"`
}

// OwnerID defines model for OwnerID.
type OwnerID = string

// PaginatedList Represent the common attributes of a paginated list, to be used in an allOf with the specific items attribute of the desired type.
type PaginatedList struct {
	// NextPageToken This token is used to retrieve the next page. If this field is omitted, there are no subsequent pages.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// TotalSize Equivalent to int32
	TotalSize *Int `json:"totalSize,omitempty"`
}

// PartNumber defines model for PartNumber.
type PartNumber = int

// PerformNativeLogoutBody Perform Native Logout Request Body
type PerformNativeLogoutBody struct {
	// SessionToken The Session Token
	//
	// Invalidate this session token.
	SessionToken string `json:"session_token"`
}

// Permission A permission in the <service>[.<resource>.[<subResource>](0,1)](0,1).<action> form
type Permission struct {
	// Action Allowed operation type
	Action string `json:"action"`

	// Description Human-readable description
	Description string `json:"description"`

	// Name Human-readable name
	Name     string  `json:"name"`
	Resource *string `json:"resource,omitempty"`

	// Service Service name
	Service     string  `json:"service"`
	SubResource *string `json:"subResource,omitempty"`
}

// PermissionsPaginatedList defines model for PermissionsPaginatedList.
type PermissionsPaginatedList struct {
	Items []RegisteredPermission `json:"items"`

	// NextPageToken This token is used to retrieve the next page. If this field is omitted, there are no subsequent pages.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// TotalSize Equivalent to int32
	TotalSize *Int `json:"totalSize,omitempty"`
}

// Phase1Options Information about Phase 1 of the Internet Key Exchange (IKE) negotiation. When Phase 1 finishes successfully, peers proceed to Phase 2 negotiations.
type Phase1Options struct {
	// DpdTimeoutAction The action to carry out after a Dead Peer Detection (DPD) timeout occurs.
	DpdTimeoutAction *string `json:"dpdTimeoutAction,omitempty"`

	// DpdTimeoutSeconds The maximum waiting time for a Dead Peer Detection (DPD) response before considering the peer as dead, in seconds.
	DpdTimeoutSeconds *int `json:"dpdTimeoutSeconds,omitempty"`

	// IkeVersions The Internet Key Exchange (IKE) versions allowed for the VPN tunnel.
	IkeVersions *[]string `json:"ikeVersions,omitempty"`

	// Phase1DhGroupNumbers The Diffie-Hellman (DH) group numbers allowed for the VPN tunnel for phase 1.
	Phase1DhGroupNumbers *[]int `json:"phase1DhGroupNumbers,omitempty"`

	// Phase1EncryptionAlgorithms The encryption algorithms allowed for the VPN tunnel for phase 1.
	Phase1EncryptionAlgorithms *[]string `json:"phase1EncryptionAlgorithms,omitempty"`

	// Phase1IntegrityAlgorithms The integrity algorithms allowed for the VPN tunnel for phase 1.
	Phase1IntegrityAlgorithms *[]string `json:"phase1IntegrityAlgorithms,omitempty"`

	// Phase1LifetimeSeconds The lifetime for phase 1 of the IKE negotiation process, in seconds.
	Phase1LifetimeSeconds *int `json:"phase1LifetimeSeconds,omitempty"`

	// ReplayWindowSize The number of packets in an IKE replay window.
	ReplayWindowSize *int `json:"replayWindowSize,omitempty"`

	// StartupAction The action to carry out when establishing tunnels for a VPN connection.
	StartupAction *string `json:"startupAction,omitempty"`
}

// Phase2Options Information about Phase 2 of the Internet Key Exchange (IKE) negotiation.
type Phase2Options struct {
	// Phase2DhGroupNumbers The Diffie-Hellman (DH) group numbers allowed for the VPN tunnel for phase 2.
	Phase2DhGroupNumbers *[]int `json:"phase2DhGroupNumbers,omitempty"`

	// Phase2EncryptionAlgorithms The encryption algorithms allowed for the VPN tunnel for phase 2.
	Phase2EncryptionAlgorithms *[]string `json:"phase2EncryptionAlgorithms,omitempty"`

	// Phase2IntegrityAlgorithms The integrity algorithms allowed for the VPN tunnel for phase 2.
	Phase2IntegrityAlgorithms *[]string `json:"phase2IntegrityAlgorithms,omitempty"`

	// Phase2LifetimeSeconds The lifetime for phase 2 of the Internet Key Exchange (IKE) negociation process, in seconds.
	Phase2LifetimeSeconds *int `json:"phase2LifetimeSeconds,omitempty"`

	// PreSharedKey The pre-shared key to establish the initial authentication between the client gateway and the virtual gateway. This key can contain any character except line breaks and double quotes (&quot;).
	PreSharedKey *string `json:"preSharedKey,omitempty"`
}

// Phase2OptionsToUpdate Information about Phase 2 of the Internet Key Exchange (IKE) negotiation.
type Phase2OptionsToUpdate struct {
	// PreSharedKey The pre-shared key to establish the initial authentication between the client gateway and the virtual gateway. This key can contain any character except line breaks and double quotes (&quot;).
	PreSharedKey *string `json:"preSharedKey,omitempty"`
}

// Placement Information about the placement of the VM.
type Placement struct {
	// AvailabilityZoneName The name of the Subregion. If you specify this parameter, you must not specify the `Nics` parameter.
	AvailabilityZoneName *string `json:"availabilityZoneName,omitempty"`

	// Tenancy The tenancy of the VM (`default`, `dedicated`, or a dedicated group ID).
	Tenancy *string `json:"tenancy,omitempty"`
}

// Prefix defines model for Prefix.
type Prefix = string

// PrivateIp Information about the private IP.
type PrivateIp struct {
	// IsPrimary If true, the IP is the primary private IP of the NIC.
	IsPrimary *bool `json:"isPrimary,omitempty"`

	// LinkPublicIp Information about the public IP association.
	LinkPublicIp *LinkPublicIp `json:"linkPublicIp,omitempty"`

	// PrivateDnsName The name of the private DNS.
	PrivateDnsName *string `json:"privateDnsName,omitempty"`

	// PrivateIp The private IP of the NIC.
	PrivateIp *string `json:"privateIp,omitempty"`
}

// PrivateIpLight Information about the private IP.
type PrivateIpLight struct {
	// IsPrimary If true, the IP is the primary private IP of the NIC.
	IsPrimary *bool `json:"isPrimary,omitempty"`

	// PrivateIp The private IP of the NIC.
	PrivateIp *string `json:"privateIp,omitempty"`
}

// PrivateIpLightForVm Information about the private IP of the NIC.
type PrivateIpLightForVm struct {
	// IsPrimary If true, the IP is the primary private IP of the NIC.
	IsPrimary *bool `json:"isPrimary,omitempty"`

	// LinkPublicIp Information about the public IP associated with the NIC.
	LinkPublicIp *LinkPublicIpLightForVm `json:"linkPublicIp,omitempty"`

	// PrivateDnsName The name of the private DNS.
	PrivateDnsName *string `json:"privateDnsName,omitempty"`

	// PrivateIp The private IP.
	PrivateIp *string `json:"privateIp,omitempty"`
}

// PublicIp Information about the public IP.
type PublicIp struct {
	// Id The allocation ID of the public IP.
	Id *string `json:"id,omitempty"`

	// LinkPublicIpId (Required in a Vpc) The ID representing the association of the public IP with the VM or the NIC.
	LinkPublicIpId *string `json:"linkPublicIpId,omitempty"`

	// NicId The ID of the NIC the public IP is associated with (if any).
	NicId *string `json:"nicId,omitempty"`

	// PrivateIp The private IP associated with the public IP.
	PrivateIp *string `json:"privateIp,omitempty"`

	// PublicIp The public IP.
	PublicIp *string `json:"publicIp,omitempty"`

	// Tags One or more tags associated with the public IP.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// VmId The ID of the VM the public IP is associated with (if any).
	VmId *string `json:"vmId,omitempty"`
}

// PublicIpLight Information about the public IP.
type PublicIpLight struct {
	// PublicIp The public IP associated with the NAT gateway.
	PublicIp *string `json:"publicIp,omitempty"`

	// PublicIpId The allocation ID of the public IP associated with the NAT gateway.
	PublicIpId *string `json:"publicIpId,omitempty"`
}

// PutObjectOutput defines model for PutObjectOutput.
type PutObjectOutput = map[string]interface{}

// ReadAdminPassword defines model for ReadAdminPassword.
type ReadAdminPassword struct {
	// AdminPassword The password of the VM. After the first boot, returns an empty string.
	AdminPassword *string `json:"adminPassword,omitempty"`

	// VmId The ID of the VM.
	VmId *string `json:"vmId,omitempty"`
}

// ReadClientGateways defines model for ReadClientGateways.
type ReadClientGateways struct {
	// Items Information about one or more client gateways.
	Items *[]ClientGateway `json:"items,omitempty"`
}

// ReadConsoleOutput defines model for ReadConsoleOutput.
type ReadConsoleOutput struct {
	// ConsoleOutput The Base64-encoded output of the console. If a command line tool is used, the output is decoded by the tool.
	ConsoleOutput *string `json:"consoleOutput,omitempty"`

	// VmId The ID of the VM.
	VmId *string `json:"vmId,omitempty"`
}

// ReadDhcpOptions defines model for ReadDhcpOptions.
type ReadDhcpOptions struct {
	// Items Information about one or more DHCP options sets.
	Items *[]DhcpOptionsSet `json:"items,omitempty"`
}

// ReadFlexibleGpus defines model for ReadFlexibleGpus.
type ReadFlexibleGpus struct {
	// Items Information about one or more fGPUs.
	Items *[]FlexibleGpu `json:"items,omitempty"`
}

// ReadImages defines model for ReadImages.
type ReadImages struct {
	// Items Information about one or more OMIs.
	Items *[]Image `json:"items,omitempty"`
}

// ReadInternetGateways defines model for ReadInternetGateways.
type ReadInternetGateways struct {
	// Items Information about one or more Internet gateways.
	Items *[]InternetGateway `json:"items,omitempty"`
}

// ReadKeypairs defines model for ReadKeypairs.
type ReadKeypairs struct {
	// Items Information about one or more keypairs.
	Items *[]Keypair `json:"items,omitempty"`
}

// ReadKeypairsById Information about the keypair.
type ReadKeypairsById struct {
	// Fingerprint The MD5 public key fingerprint as specified in section 4 of RFC 4716.
	Fingerprint *string `json:"fingerprint,omitempty"`

	// Name The name of the keypair.
	Name *string `json:"name,omitempty"`

	// Type The type of the keypair (`ssh-rsa`, `ssh-ed25519`, `ecdsa-sha2-nistp256`, `ecdsa-sha2-nistp384`, or `ecdsa-sha2-nistp521`).
	Type *string `json:"type,omitempty"`
}

// ReadListenerRules defines model for ReadListenerRules.
type ReadListenerRules struct {
	// Items The list of the rules to describe.
	Items *[]ListenerRule `json:"items,omitempty"`
}

// ReadLoadBalancerTags defines model for ReadLoadBalancerTags.
type ReadLoadBalancerTags struct {
	// Items Information about one or more load balancer tags.
	Items *[]LoadBalancerTag `json:"items,omitempty"`
}

// ReadLoadBalancers defines model for ReadLoadBalancers.
type ReadLoadBalancers struct {
	// Items Information about one or more load balancers.
	Items *[]LoadBalancer `json:"items,omitempty"`
}

// ReadNatGateway defines model for ReadNatGateway.
type ReadNatGateway struct {
	// Items Information about one or more NAT gateways.
	Items *[]NatGateway `json:"items,omitempty"`
}

// ReadNics defines model for ReadNics.
type ReadNics struct {
	// Items Information about one or more NICs.
	Items *[]Nic `json:"items,omitempty"`
}

// ReadPublicIpRanges defines model for ReadPublicIpRanges.
type ReadPublicIpRanges struct {
	// Items The list of public IPv4 addresses used in the Region, in CIDR notation.
	Items *[]string `json:"items,omitempty"`
}

// ReadPublicIps defines model for ReadPublicIps.
type ReadPublicIps struct {
	// Items Information about one or more public IPs.
	Items *[]PublicIp `json:"items,omitempty"`
}

// ReadRouteTables defines model for ReadRouteTables.
type ReadRouteTables struct {
	// Items Information about one or more route tables.
	Items *[]RouteTable `json:"items,omitempty"`
}

// ReadSecurityGroups defines model for ReadSecurityGroups.
type ReadSecurityGroups struct {
	// Items Information about one or more security groups.
	Items *[]SecurityGroup `json:"items,omitempty"`
}

// ReadServerCertificates defines model for ReadServerCertificates.
type ReadServerCertificates struct {
	// Items Information about one or more Server certificates.
	Items *[]ServerCertificate `json:"items,omitempty"`
}

// ReadSnapshots defines model for ReadSnapshots.
type ReadSnapshots struct {
	// Items Information about one or more snapshots and their permissions.
	Items *[]Snapshot `json:"items,omitempty"`
}

// ReadSubnets defines model for ReadSubnets.
type ReadSubnets struct {
	// Items Information about one or more Subnets.
	Items *[]Subnet `json:"items,omitempty"`
}

// ReadTags defines model for ReadTags.
type ReadTags struct {
	// Items Information about one or more tags.
	Items *[]Tag `json:"items,omitempty"`
}

// ReadVirtualGateways defines model for ReadVirtualGateways.
type ReadVirtualGateways struct {
	// Items Information about one or more virtual gateways.
	Items *[]VirtualGateway `json:"items,omitempty"`
}

// ReadVms defines model for ReadVms.
type ReadVms struct {
	// Items Information about one or more VMs.
	Items *[]Vm `json:"items,omitempty"`
}

// ReadVmsHealth defines model for ReadVmsHealth.
type ReadVmsHealth struct {
	// BackendVmHealth Information about the health of one or more back-end VMs.
	BackendVmHealth *[]BackendVmHealth `json:"backendVmHealth,omitempty"`
}

// ReadVmsState defines model for ReadVmsState.
type ReadVmsState struct {
	// Items Information about one or more VM states.
	Items *[]VmStates `json:"items,omitempty"`
}

// ReadVolumes defines model for ReadVolumes.
type ReadVolumes struct {
	// Items Information about one or more volumes.
	Items *[]Volume `json:"items,omitempty"`
}

// ReadVpcPeerings defines model for ReadVpcPeerings.
type ReadVpcPeerings struct {
	// Items Information about one or more Vpc peerings.
	Items *[]VpcPeering `json:"items,omitempty"`
}

// ReadVpcs defines model for ReadVpcs.
type ReadVpcs struct {
	// Items Information about the described Vpcs.
	Items *[]Vpc `json:"items,omitempty"`
}

// ReadVpnConnections defines model for ReadVpnConnections.
type ReadVpnConnections struct {
	// Items Information about one or more VPN connections.
	Items *[]VpnConnection `json:"items,omitempty"`
}

// RecoveryAddressType RecoveryAddressType must not exceed 16 characters as that is the limitation in the SQL Schema.
type RecoveryAddressType = string

// RecoveryFlow This request is used when an identity wants to recover their account.
type RecoveryFlow struct {
	// Active Active, if set, contains the recovery method that is being used. It is initially not set.
	Active *string `json:"active,omitempty"`

	// ContinueWith Contains possible actions that could follow this flow
	ContinueWith *[]ContinueWith `json:"continue_with,omitempty"`

	// ExpiresAt ExpiresAt is the time (UTC) when the request expires. If the user still wishes to update the setting, a new request has to be initiated.
	ExpiresAt time.Time `json:"expires_at"`

	// Id ID represents the request's unique ID.
	Id openapi_types.UUID `json:"id"`

	// IssuedAt IssuedAt is the time (UTC) when the request occurred.
	IssuedAt time.Time `json:"issued_at"`

	// RequestUrl RequestURL is the initial URL that was requested. It can be used
	// to forward information contained in the URL's path or query for example.
	RequestUrl string `json:"request_url"`

	// ReturnTo ReturnTo contains the requested return_to URL.
	ReturnTo *string `json:"return_to,omitempty"`

	// State State represents the state of this request:
	// choose_method: ask the user to choose a method (e.g. recover account via email)
	// sent_email: the email has been sent to the user
	// passed_challenge: the request was successful and the recovery challenge was passed.
	State interface{} `json:"state"`

	// Type The flow type can either be `api` or `browser`.
	Type SelfServiceFlowType `json:"type"`

	// Ui Container represents a HTML Form. The container can work with both HTTP Form and JSON requests.
	Ui UiContainer `json:"ui"`
}

// RecoveryIdentityAddress defines model for RecoveryIdentityAddress.
type RecoveryIdentityAddress struct {
	// CreatedAt CreatedAt is a helper struct field for gobuffalo.pop.
	CreatedAt *time.Time         `json:"created_at,omitempty"`
	Id        openapi_types.UUID `json:"id"`

	// UpdatedAt UpdatedAt is a helper struct field for gobuffalo.pop.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
	Value     string     `json:"value"`

	// Via RecoveryAddressType must not exceed 16 characters as that is the limitation in the SQL Schema.
	Via RecoveryAddressType `json:"via"`
}

// RecoveryLink defines model for RecoveryLink.
type RecoveryLink struct {
	Expiration DateTime `json:"expiration"`

	// Link Recovery link correctly generated
	Link string `json:"link"`
}

// Registered defines model for Registered.
type Registered struct {
	// CreatedOn creation date
	CreatedOn time.Time `json:"createdOn"`

	// UpdatedOn last update
	UpdatedOn time.Time `json:"updatedOn"`

	// Uuid Internal ID
	Uuid openapi_types.UUID `json:"uuid"`
}

// RegisteredPermission defines model for RegisteredPermission.
type RegisteredPermission struct {
	// Action Allowed operation type
	Action string `json:"action"`

	// CreatedOn creation date
	CreatedOn time.Time `json:"createdOn"`

	// Description Human-readable description
	Description string `json:"description"`

	// Name Human-readable name
	Name     string  `json:"name"`
	Resource *string `json:"resource,omitempty"`

	// Service Service name
	Service     string  `json:"service"`
	SubResource *string `json:"subResource,omitempty"`

	// UpdatedOn last update
	UpdatedOn time.Time `json:"updatedOn"`

	// Uuid Internal ID
	Uuid openapi_types.UUID `json:"uuid"`
}

// RegisteredRole defines model for RegisteredRole.
type RegisteredRole struct {
	// CreatedOn creation date
	CreatedOn time.Time `json:"createdOn"`

	// Description Human-readable description
	Description string `json:"description"`

	// Name Human-readable name
	Name string `json:"name"`

	// UpdatedOn last update
	UpdatedOn time.Time `json:"updatedOn"`

	// Uuid Internal ID
	Uuid openapi_types.UUID `json:"uuid"`
}

// RegistrationFlow defines model for RegistrationFlow.
type RegistrationFlow struct {
	// Active Active, if set, contains the registration method that is being used. It is initially
	// not set.
	// password CredentialsTypePassword
	// oidc CredentialsTypeOIDC
	// totp CredentialsTypeTOTP
	// lookup_secret CredentialsTypeLookup
	// webauthn CredentialsTypeWebAuthn
	// code CredentialsTypeCodeAuth
	// link_recovery CredentialsTypeRecoveryLink  CredentialsTypeRecoveryLink is a special credential type linked to the link strategy (recovery flow).  It is not used within the credentials object itself.
	// code_recovery CredentialsTypeRecoveryCode
	Active *RegistrationFlowActive `json:"active,omitempty"`

	// ExpiresAt ExpiresAt is the time (UTC) when the flow expires. If the user still wishes to log in,
	// a new flow has to be initiated.
	ExpiresAt time.Time `json:"expires_at"`

	// Id ID represents the flow's unique ID. When performing the registration flow, this
	// represents the id in the registration ui's query parameter: http://<selfservice.flows.registration.ui_url>/?flow=<id>
	Id openapi_types.UUID `json:"id"`

	// IssuedAt IssuedAt is the time (UTC) when the flow occurred.
	IssuedAt             time.Time `json:"issued_at"`
	Oauth2LoginChallenge *string   `json:"oauth2_login_challenge,omitempty"`

	// Oauth2LoginRequest OAuth2LoginRequest struct for OAuth2LoginRequest
	Oauth2LoginRequest *OAuth2LoginRequest `json:"oauth2_login_request,omitempty"`
	OrganizationId     *NullUUID           `json:"organization_id"`

	// RequestUrl RequestURL is the initial URL that was requested. It can be used
	// to forward information contained in the URL's path or query for example.
	RequestUrl string `json:"request_url"`

	// ReturnTo ReturnTo contains the requested return_to URL.
	ReturnTo *string `json:"return_to,omitempty"`

	// SessionTokenExchangeCode SessionTokenExchangeCode holds the secret code that the client can use to retrieve a session token after the flow has been completed.
	// This is only set if the client has requested a session token exchange code, and if the flow is of type "api",
	// and only on creating the flow.
	SessionTokenExchangeCode *string `json:"session_token_exchange_code,omitempty"`

	// State State represents the state of this request:
	// choose_method: ask the user to choose a method (e.g. registration with email)
	// sent_email: the email has been sent to the user
	// passed_challenge: the request was successful and the registration challenge was passed.
	State interface{} `json:"state"`

	// TransientPayload TransientPayload is used to pass data from the registration to a webhook
	TransientPayload *map[string]interface{} `json:"transient_payload,omitempty"`

	// Type The flow type can either be `api` or `browser`.
	Type SelfServiceFlowType `json:"type"`

	// Ui Container represents a HTML Form. The container can work with both HTTP Form and JSON requests.
	Ui UiContainer `json:"ui"`
}

// RegistrationFlowActive Active, if set, contains the registration method that is being used. It is initially
// not set.
// password CredentialsTypePassword
// oidc CredentialsTypeOIDC
// totp CredentialsTypeTOTP
// lookup_secret CredentialsTypeLookup
// webauthn CredentialsTypeWebAuthn
// code CredentialsTypeCodeAuth
// link_recovery CredentialsTypeRecoveryLink  CredentialsTypeRecoveryLink is a special credential type linked to the link strategy (recovery flow).  It is not used within the credentials object itself.
// code_recovery CredentialsTypeRecoveryCode
type RegistrationFlowActive string

// ReqUpdateNodepool defines model for ReqUpdateNodepool.
type ReqUpdateNodepool struct {
	Count int `json:"count"`
}

// ResCreateCluster defines model for ResCreateCluster.
type ResCreateCluster struct {
	Id        *openapi_types.UUID `json:"id,omitempty"`
	Name      *string             `json:"name,omitempty"`
	Operation *Operation          `json:"operation,omitempty"`
}

// ResCreateNodepool defines model for ResCreateNodepool.
type ResCreateNodepool struct {
	ClusterId    *string    `json:"clusterId,omitempty"`
	NodePoolName *string    `json:"nodePoolName,omitempty"`
	Operation    *Operation `json:"operation,omitempty"`
}

// ResDeleteCluster defines model for ResDeleteCluster.
type ResDeleteCluster struct {
	Name      *string    `json:"name,omitempty"`
	Operation *Operation `json:"operation,omitempty"`
}

// ResourceLoadBalancerTag Information about the tag.
type ResourceLoadBalancerTag struct {
	// Key The key of the tag, with a minimum of 1 character.
	Key *string `json:"key,omitempty"`
}

// ResourceTag Information about the tag.
type ResourceTag struct {
	// Key The key of the tag, with a minimum of 1 character.
	Key string `json:"key"`

	// Value The value of the tag, between 0 and 255 characters.
	Value string `json:"value"`
}

// RespUpdateNodepool defines model for RespUpdateNodepool.
type RespUpdateNodepool struct {
	ClusterId    *string    `json:"clusterId,omitempty"`
	NodePoolName *string    `json:"nodePoolName,omitempty"`
	Operation    *Operation `json:"operation,omitempty"`
}

// RestoreExpiryDate defines model for RestoreExpiryDate.
type RestoreExpiryDate = time.Time

// RestoreStatus defines model for RestoreStatus.
type RestoreStatus struct {
	IsRestoreInProgress *IsRestoreInProgress `json:"IsRestoreInProgress,omitempty"`
	RestoreExpiryDate   *RestoreExpiryDate   `json:"RestoreExpiryDate,omitempty"`
}

// Role A role, linked to 1 or more permissions
type Role struct {
	// Description Human-readable description
	Description string `json:"description"`

	// Name Human-readable name
	Name string `json:"name"`
}

// RolePermission defines model for RolePermission.
type RolePermission struct {
	// Permissions List of permissions UUIDs
	Permissions []openapi_types.UUID `json:"permissions"`
}

// RolesPaginatedList defines model for RolesPaginatedList.
type RolesPaginatedList struct {
	Items []RegisteredRole `json:"items"`

	// NextPageToken This token is used to retrieve the next page. If this field is omitted, there are no subsequent pages.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// TotalSize Equivalent to int32
	TotalSize *Int `json:"totalSize,omitempty"`
}

// Route Information about the route.
type Route struct {
	// CreationMethod The method used to create the route.
	CreationMethod *string `json:"creationMethod,omitempty"`

	// DestinationIpRange The IP range used for the destination match, in CIDR notation (for example, `10.0.0.0/24`).
	DestinationIpRange *string `json:"destinationIpRange,omitempty"`

	// DestinationServiceId The ID of the NumSpot service.
	DestinationServiceId *string `json:"destinationServiceId,omitempty"`

	// GatewayId The ID of the Internet gateway or virtual gateway attached to the Vpc.
	GatewayId *string `json:"gatewayId,omitempty"`

	// NatGatewayId The ID of a NAT gateway attached to the Vpc.
	NatGatewayId *string `json:"natGatewayId,omitempty"`

	// NicId The ID of the NIC.
	NicId *string `json:"nicId,omitempty"`

	// State The state of a route in the route table (always `active`).
	State *string `json:"state,omitempty"`

	// VmId The ID of a VM specified in a route in the table.
	VmId *string `json:"vmId,omitempty"`

	// VpcPeeringId The ID of the Vpc peering.
	VpcPeeringId *string `json:"vpcPeeringId,omitempty"`
}

// RouteLight Information about the route.
type RouteLight struct {
	// DestinationIpRange The IP range used for the destination match, in CIDR notation (for example, `10.0.0.0/24`).
	DestinationIpRange *string `json:"destinationIpRange,omitempty"`

	// RouteType The type of route (always `static`).
	RouteType *string `json:"routeType,omitempty"`

	// State The current state of the static route (`pending` \| `available` \| `deleting` \| `deleted`).
	State *string `json:"state,omitempty"`
}

// RoutePropagatingVirtualGateway Information about the route propagating virtual gateway.
type RoutePropagatingVirtualGateway struct {
	// VirtualGatewayId The ID of the virtual gateway.
	VirtualGatewayId *string `json:"virtualGatewayId,omitempty"`
}

// RouteTable Information about the route table.
type RouteTable struct {
	// Id The ID of the route table.
	Id *string `json:"id,omitempty"`

	// LinkRouteTables One or more associations between the route table and Subnets.
	LinkRouteTables *[]LinkRouteTable `json:"linkRouteTables,omitempty"`

	// RoutePropagatingVirtualGateways Information about virtual gateways propagating routes.
	RoutePropagatingVirtualGateways *[]RoutePropagatingVirtualGateway `json:"routePropagatingVirtualGateways,omitempty"`

	// Routes One or more routes in the route table.
	Routes *[]Route `json:"routes,omitempty"`

	// Tags One or more tags associated with the route table.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// VpcId The ID of the Vpc for the route table.
	VpcId *string `json:"vpcId,omitempty"`
}

// SecurityGroup Information about the security group.
type SecurityGroup struct {
	// Description The description of the security group.
	Description *string `json:"description,omitempty"`

	// Id The ID of the security group.
	Id *string `json:"id,omitempty"`

	// InboundRules The inbound rules associated with the security group.
	InboundRules *[]SecurityGroupRule `json:"inboundRules,omitempty"`

	// Name The name of the security group.
	Name *string `json:"name,omitempty"`

	// OutboundRules The outbound rules associated with the security group.
	OutboundRules *[]SecurityGroupRule `json:"outboundRules,omitempty"`

	// Tags One or more tags associated with the security group.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// VpcId The ID of the Vpc for the security group.
	VpcId *string `json:"vpcId,omitempty"`
}

// SecurityGroupLight Information about the security group.
type SecurityGroupLight struct {
	// SecurityGroupId The ID of the security group.
	SecurityGroupId *string `json:"securityGroupId,omitempty"`

	// SecurityGroupName The name of the security group.
	SecurityGroupName *string `json:"securityGroupName,omitempty"`
}

// SecurityGroupRule Information about the security group rule.
type SecurityGroupRule struct {
	// FromPortRange The beginning of the port range for the TCP and UDP protocols, or an ICMP type number.
	FromPortRange *int `json:"fromPortRange,omitempty"`

	// IpProtocol The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all protocols). By default, `-1`. In a Vpc, this can also be an IP protocol number. For more information, see the [IANA.org website](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
	IpProtocol *string `json:"ipProtocol,omitempty"`

	// IpRanges One or more IP ranges for the security group rules, in CIDR notation (for example, `10.0.0.0/16`).
	IpRanges *[]string `json:"ipRanges,omitempty"`

	// SecurityGroupsMembers Information about one or more source or destination security groups.
	SecurityGroupsMembers *[]SecurityGroupsMember `json:"securityGroupsMembers,omitempty"`

	// ServiceIds One or more service IDs to allow traffic from a Vpc to access the corresponding NumSpot services.
	ServiceIds *[]string `json:"serviceIds,omitempty"`

	// ToPortRange The end of the port range for the TCP and UDP protocols, or an ICMP code number.
	ToPortRange *int `json:"toPortRange,omitempty"`
}

// SecurityGroupsMember Information about a source or destination security group.
type SecurityGroupsMember struct {
	// SecurityGroupId The ID of a source or destination security group that you want to link to the security group of the rule.
	SecurityGroupId *string `json:"securityGroupId,omitempty"`

	// SecurityGroupName (Public Cloud only) The name of a source or destination security group that you want to link to the security group of the rule.
	SecurityGroupName *string `json:"securityGroupName,omitempty"`
}

// SelfServiceFlowType The flow type can either be `api` or `browser`.
type SelfServiceFlowType = string

// ServerCertificate Information about the VPN options.
type ServerCertificate struct {
	// ExpirationDate The date on which the server certificate expires.
	ExpirationDate *string `json:"expirationDate,omitempty"`

	// Id The ID of the server certificate.
	Id *string `json:"id,omitempty"`

	// Name The name of the server certificate.
	Name *string `json:"name,omitempty"`

	// Orn The OUTSCALE Resource Name (ORN) of the server certificate
	Orn *string `json:"orn,omitempty"`

	// Path The path to the server certificate.
	Path *string `json:"path,omitempty"`

	// UploadDate The date on which the server certificate has been uploaded.
	UploadDate *string `json:"uploadDate,omitempty"`
}

// ServiceAccount defines model for ServiceAccount.
type ServiceAccount struct {
	// Name Service account name
	Name string `json:"name"`

	// TokenDuration Token duration in ISO 8601 format. Default is 24 hours (PT24H). Must be between 1 second (PT1S) and 48 hours (PT48H).
	TokenDuration *string `json:"tokenDuration,omitempty"`
}

// ServiceAccountEdited defines model for ServiceAccountEdited.
type ServiceAccountEdited struct {
	// Id Service account ID
	Id string `json:"id"`

	// Name Service Accounts name
	Name string `json:"name"`

	// TokenDuration Set access token duration
	TokenDuration *string `json:"tokenDuration,omitempty"`
}

// ServiceAccountPaginatedList defines model for ServiceAccountPaginatedList.
type ServiceAccountPaginatedList struct {
	Items []ServiceAccountEdited `json:"items"`

	// NextPageToken This token is used to retrieve the next page. If this field is omitted, there are no subsequent pages.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// TotalSize Equivalent to int32
	TotalSize *Int `json:"totalSize,omitempty"`
}

// Session A Session
type Session struct {
	// Active Active state. If false the session is no longer active.
	Active *bool `json:"active,omitempty"`

	// AuthenticatedAt The Session Authentication Timestamp
	//
	// When this session was authenticated at. If multi-factor authentication was used this
	// is the time when the last factor was authenticated (e.g. the TOTP code challenge was completed).
	AuthenticatedAt *time.Time `json:"authenticated_at,omitempty"`

	// AuthenticationMethods A list of authenticators which were used to authenticate the session.
	AuthenticationMethods *SessionAuthenticationMethods `json:"authentication_methods,omitempty"`

	// AuthenticatorAssuranceLevel The authenticator assurance level can be one of "aal1", "aal2", or "aal3". A higher number means that it is harder
	// for an attacker to compromise the account.
	// Generally, "aal1" implies that one authentication factor was used while AAL2 implies that two factors (password + TOTP) have been used.
	AuthenticatorAssuranceLevel *AuthenticatorAssuranceLevel `json:"authenticator_assurance_level,omitempty"`

	// Devices Devices has history of all endpoints where the session was used
	Devices *[]SessionDevice `json:"devices,omitempty"`

	// ExpiresAt The Session Expiry
	//
	// When this session expires at.
	ExpiresAt *time.Time `json:"expires_at,omitempty"`

	// Id Session ID
	Id openapi_types.UUID `json:"id"`

	// Identity An identity represents a (human) user.
	Identity *Identity `json:"identity,omitempty"`

	// IssuedAt The Session Issuance Timestamp
	//
	// When this session was issued at. Usually equal or close to `authenticated_at`.
	IssuedAt *time.Time `json:"issued_at,omitempty"`

	// Tokenized Tokenized is the tokenized (e.g. JWT) version of the session.
	//
	// It is only set when the `tokenize` query parameter was set to a valid tokenize template during calls to `/session/whoami`.
	Tokenized *string `json:"tokenized,omitempty"`
}

// SessionAuthenticationMethod A singular authenticator used during authentication / login.
type SessionAuthenticationMethod struct {
	// Aal The authenticator assurance level can be one of "aal1", "aal2", or "aal3". A higher number means that it is harder
	// for an attacker to compromise the account.
	// Generally, "aal1" implies that one authentication factor was used while AAL2 implies that two factors (password + TOTP) have been used.
	Aal *AuthenticatorAssuranceLevel `json:"aal,omitempty"`

	// CompletedAt When the authentication challenge was completed.
	CompletedAt *time.Time                         `json:"completed_at,omitempty"`
	Method      *SessionAuthenticationMethodMethod `json:"method,omitempty"`

	// Organization The Organization id used for authentication
	Organization *string `json:"organization,omitempty"`

	// Provider OIDC or SAML provider id used for authentication
	Provider *string `json:"provider,omitempty"`
}

// SessionAuthenticationMethodMethod defines model for SessionAuthenticationMethod.Method.
type SessionAuthenticationMethodMethod string

// SessionAuthenticationMethods A list of authenticators which were used to authenticate the session.
type SessionAuthenticationMethods = []SessionAuthenticationMethod

// SessionDevice Device corresponding to a Session
type SessionDevice struct {
	// Id Device record ID
	Id openapi_types.UUID `json:"id"`

	// IpAddress IPAddress of the client
	IpAddress *string `json:"ip_address,omitempty"`

	// Location Geo Location corresponding to the IP Address
	Location *string `json:"location,omitempty"`

	// UserAgent UserAgent of the client
	UserAgent *string `json:"user_agent,omitempty"`
}

// SettingsFlow This flow is used when an identity wants to update settings
type SettingsFlow struct {
	// Active Active, if set, contains the registration method that is being used. It is initially
	// not set.
	Active *string `json:"active,omitempty"`

	// ContinueWith Contains a list of actions, that could follow this flow
	//
	// It can, for example, contain a reference to the verification flow, created as part of the user's
	// registration.
	ContinueWith *[]ContinueWith `json:"continue_with,omitempty"`

	// ExpiresAt ExpiresAt is the time (UTC) when the flow expires. If the user still wishes to update the setting,
	// a new flow has to be initiated.
	ExpiresAt time.Time `json:"expires_at"`

	// Id ID represents the flow's unique ID. When performing the settings flow, this
	// represents the id in the settings ui's query parameter: http://<selfservice.flows.settings.ui_url>?flow=<id>
	Id openapi_types.UUID `json:"id"`

	// Identity An identity represents a (human) user.
	Identity Identity `json:"identity"`

	// IssuedAt IssuedAt is the time (UTC) when the flow occurred.
	IssuedAt time.Time `json:"issued_at"`

	// RequestUrl RequestURL is the initial URL that was requested. It can be used to forward information contained in the URL's path or query for example.
	RequestUrl string `json:"request_url"`

	// ReturnTo ReturnTo contains the requested return_to URL.
	ReturnTo *string `json:"return_to,omitempty"`

	// State State represents the state of this flow. It knows two states:
	// show_form: No user data has been collected, or it is invalid, and thus the form should be shown.
	// success: Indicates that the settings flow has been updated successfully with the provided data.
	// Done will stay true when repeatedly checking. If set to true, done will revert back to false only
	// when a flow with invalid (e.g. "please use a valid phone number") data was sent.
	State interface{} `json:"state"`

	// Type The flow type can either be `api` or `browser`.
	Type SelfServiceFlowType `json:"type"`

	// Ui Container represents a HTML Form. The container can work with both HTTP Form and JSON requests.
	Ui UiContainer `json:"ui"`
}

// Size defines model for Size.
type Size = int

// Snapshot Information about the snapshot.
type Snapshot struct {
	// Access Permissions for the resource.
	Access *Access `json:"access,omitempty"`

	// CreationDate The date and time of creation of the snapshot.
	CreationDate *time.Time `json:"creationDate,omitempty"`

	// Description The description of the snapshot.
	Description *string `json:"description,omitempty"`

	// Id The ID of the snapshot.
	Id *string `json:"id,omitempty"`

	// Progress The progress of the snapshot, as a percentage.
	Progress *int `json:"progress,omitempty"`

	// State The state of the snapshot (`in-queue` \| `completed` \| `error`).
	State *string `json:"state,omitempty"`

	// Tags One or more tags associated with the snapshot.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// VolumeId The ID of the volume used to create the snapshot.
	VolumeId *string `json:"volumeId,omitempty"`

	// VolumeSize The size of the volume used to create the snapshot, in gibibytes (GiB).
	VolumeSize *int `json:"volumeSize,omitempty"`
}

// SourceSecurityGroup Information about the source security group of the load balancer, which you can use as part of your inbound rules for your registered VMs.<br />
// To only allow traffic from load balancers, add a security group rule that specifies this source security group as the inbound source.
type SourceSecurityGroup struct {
	// SecurityGroupName The name of the security group.
	SecurityGroupName *string `json:"securityGroupName,omitempty"`
}

// SourceVpc Information about the source Vpc.
type SourceVpc struct {
	// IpRange The IP range for the source Net, in CIDR notation (for example, `10.0.0.0/16`).
	IpRange *string `json:"ipRange,omitempty"`

	// VpcId The ID of the source Vpc.
	VpcId *string `json:"vpcId,omitempty"`
}

// Space defines model for Space.
type Space struct {
	CreatedOn DateTime `json:"createdOn"`

	// Description Space description
	Description string `json:"description"`

	// Id Internal ID
	Id openapi_types.UUID `json:"id"`

	// Name Space name
	Name string `json:"name"`

	// OrganisationId Organisation_id
	OrganisationId openapi_types.UUID `json:"organisationId"`

	// Status status of the space, the space can only be used when the status is ready.
	Status    SpaceStatus `json:"status"`
	UpdatedOn DateTime    `json:"updatedOn"`
}

// SpaceStatus status of the space, the space can only be used when the status is ready.
type SpaceStatus string

// SpaceIdsList defines model for SpaceIdsList.
type SpaceIdsList struct {
	Items []openapi_types.UUID `json:"items"`
}

// SpacePaginatedList defines model for SpacePaginatedList.
type SpacePaginatedList struct {
	Items []Space `json:"items"`

	// NextPageToken This token is used to retrieve the next page. If this field is omitted, there are no subsequent pages.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// TotalSize Equivalent to int32
	TotalSize *Int `json:"totalSize,omitempty"`
}

// SpaceSimple defines model for SpaceSimple.
type SpaceSimple struct {
	// Id Space identifier
	Id openapi_types.UUID `json:"id"`
}

// SpaceSimplePaginatedList defines model for SpaceSimplePaginatedList.
type SpaceSimplePaginatedList struct {
	Items []SpaceSimple `json:"items"`

	// NextPageToken This token is used to retrieve the next page. If this field is omitted, there are no subsequent pages.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// TotalSize Equivalent to int32
	TotalSize *Int `json:"totalSize,omitempty"`
}

// StateComment Information about the change of state.
type StateComment struct {
	// StateCode The code of the change of state.
	StateCode *string `json:"stateCode,omitempty"`

	// StateMessage A message explaining the change of state.
	StateMessage *string `json:"stateMessage,omitempty"`
}

// StopVm defines model for StopVm.
type StopVm struct {
	// ForceStop Forces the VM to stop.
	ForceStop *bool `json:"forceStop,omitempty"`
}

// SubjectType defines model for SubjectType.
type SubjectType string

// Subnet Information about the Subnet.
type Subnet struct {
	// AvailabilityZoneName The name of the Subregion in which the Subnet is located.
	AvailabilityZoneName *string `json:"availabilityZoneName,omitempty"`

	// AvailableIpsCount The number of available IPs in the Subnets.
	AvailableIpsCount *int `json:"availableIpsCount,omitempty"`

	// Id The ID of the Subnet.
	Id *string `json:"id,omitempty"`

	// IpRange The IP range in the Subnet, in CIDR notation (for example, `10.0.0.0/16`).
	IpRange *string `json:"ipRange,omitempty"`

	// MapPublicIpOnLaunch If true, a public IP is assigned to the network interface cards (NICs) created in the specified Subnet.
	MapPublicIpOnLaunch *bool `json:"mapPublicIpOnLaunch,omitempty"`

	// State The state of the Subnet (`pending` \| `available` \| `deleted`).
	State *string `json:"state,omitempty"`

	// Tags One or more tags associated with the Subnet.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// VpcId The ID of the Vpc in which the Subnet is.
	VpcId *string `json:"vpcId,omitempty"`
}

// SuccessfulNativeLogin The Response for Login Flows via API
type SuccessfulNativeLogin struct {
	// Session A Session
	Session Session `json:"session"`

	// SessionToken The Session Token
	// A session token is equivalent to a session cookie, but it can be sent in the HTTP Authorization
	// Header:
	// Authorization: bearer ${session-token}
	// The session token is only issued for API flows, not for Browser flows!
	SessionToken *string `json:"session_token,omitempty"`
}

// SuccessfulNativeRegistration The Response for Registration Flows via API
type SuccessfulNativeRegistration struct {
	// ContinueWith Contains a list of actions, that could follow this flow
	//
	// It can, for example, this will contain a reference to the verification flow, created as part of the user's
	// registration or the token of the session.
	ContinueWith *[]ContinueWith `json:"continue_with,omitempty"`

	// Identity An identity represents a (human) user.
	Identity Identity `json:"identity"`

	// Session A Session
	Session *Session `json:"session,omitempty"`

	// SessionToken The Session Token
	//
	// This field is only set when the session hook is configured as a post-registration hook.
	//
	// A session token is equivalent to a session cookie, but it can be sent in the HTTP Authorization
	// Header:
	//
	// Authorization: bearer ${session-token}
	//
	// The session token is only issued for API flows, not for Browser flows!
	SessionToken *string `json:"session_token,omitempty"`
}

// Tag Information about the tag.
type Tag struct {
	// Key The key of the tag, with a minimum of 1 character.
	Key *string `json:"key,omitempty"`

	// ResourceId The ID of the resource.
	ResourceId *string `json:"resourceId,omitempty"`

	// ResourceType The type of the resource.
	ResourceType *string `json:"resourceType,omitempty"`

	// Value The value of the tag, between 0 and 255 characters.
	Value *string `json:"value,omitempty"`
}

// TokenBody defines model for TokenBody.
type TokenBody struct {
	// Token The token to provide.
	Token string `json:"token"`
}

// TokenReq defines model for TokenReq.
type TokenReq struct {
	// ClientId The client id.
	ClientId *openapi_types.UUID `json:"client_id,omitempty"`

	// ClientSecret The client secret.
	ClientSecret *string `json:"client_secret,omitempty"`

	// Code The code authorization.
	Code *string `json:"code,omitempty"`

	// GrantType The grant type.
	GrantType string `json:"grant_type"`

	// RedirectUri The URLs redirection
	RedirectUri *string `json:"redirect_uri,omitempty"`

	// RefreshToken The refresh Token
	RefreshToken *string `json:"refresh_token,omitempty"`
}

// TokenResp defines model for TokenResp.
type TokenResp struct {
	// AccessToken The access token.
	AccessToken string `json:"access_token"`

	// ExpiresIn The lifetime in seconds of the access token.
	ExpiresIn int `json:"expires_in"`

	// IdToken The id token.
	IdToken *string `json:"id_token,omitempty"`

	// RefreshToken The refresh token.
	RefreshToken *string `json:"refresh_token,omitempty"`

	// TokenType The type of the token issued.
	TokenType string `json:"token_type"`
}

// UiContainer Container represents a HTML Form. The container can work with both HTTP Form and JSON requests.
type UiContainer struct {
	// Action Action should be used as the form action URL `<form action="{{.Action }}" method="post">`.
	Action   string   `json:"action"`
	Messages *UiTexts `json:"messages,omitempty"`

	// Method Method is the form method (e.g. POST)
	Method string  `json:"method"`
	Nodes  UiNodes `json:"nodes"`
}

// UiNode Nodes are represented as HTML elements or their native UI equivalents. For example,
// a node can be an `<img>` tag, or an `<input element>` but also `some plain text`.
type UiNode struct {
	Attributes UiNodeAttributes `json:"attributes"`

	// Group Group specifies which group (e.g. password authenticator) this node belongs to.
	// default DefaultGroup
	// password PasswordGroup
	// oidc OpenIDConnectGroup
	// profile ProfileGroup
	// link LinkGroup
	// code CodeGroup
	// totp TOTPGroup
	// lookup_secret LookupGroup
	// webauthn WebAuthnGroup
	Group    UiNodeGroup `json:"group"`
	Messages UiTexts     `json:"messages"`

	// Meta This might include a label and other information that can optionally
	// be used to render UIs.
	Meta UiNodeMeta `json:"meta"`

	// Type The node's type
	// text Text
	// input Input
	// img Image
	// a Anchor
	// script Script
	Type UiNodeType `json:"type"`
}

// UiNodeGroup Group specifies which group (e.g. password authenticator) this node belongs to.
// default DefaultGroup
// password PasswordGroup
// oidc OpenIDConnectGroup
// profile ProfileGroup
// link LinkGroup
// code CodeGroup
// totp TOTPGroup
// lookup_secret LookupGroup
// webauthn WebAuthnGroup
type UiNodeGroup string

// UiNodeType The node's type
// text Text
// input Input
// img Image
// a Anchor
// script Script
type UiNodeType string

// UiNodeAnchorAttributes defines model for UiNodeAnchorAttributes.
type UiNodeAnchorAttributes struct {
	// Href The link's href (destination) URL.
	//
	// format: uri
	Href string `json:"href"`

	// Id A unique identifier
	Id string `json:"id"`

	// NodeType NodeType represents this node's types. It is a mirror of `node.type` and
	// is primarily used to allow compatibility with OpenAPI 3.0.  In this struct it technically always is "a".
	NodeType string `json:"node_type"`
	Title    UiText `json:"title"`
}

// UiNodeAttributes defines model for UiNodeAttributes.
type UiNodeAttributes struct {
	union json.RawMessage
}

// UiNodeImageAttributes defines model for UiNodeImageAttributes.
type UiNodeImageAttributes struct {
	// Height Height of the image
	Height int64 `json:"height"`

	// Id A unique identifier
	Id string `json:"id"`

	// NodeType NodeType represents this node's types. It is a mirror of `node.type` and
	// is primarily used to allow compatibility with OpenAPI 3.0.  In this struct it technically always is "img".
	NodeType string `json:"node_type"`

	// Src The image's source URL.
	//
	// format: uri
	Src string `json:"src"`

	// Width Width of the image
	Width int64 `json:"width"`
}

// UiNodeInputAttributes InputAttributes represents the attributes of an input node
type UiNodeInputAttributes struct {
	// Autocomplete The autocomplete attribute for the input.
	// email InputAttributeAutocompleteEmail
	// tel InputAttributeAutocompleteTel
	// url InputAttributeAutocompleteUrl
	// current-password InputAttributeAutocompleteCurrentPassword
	// new-password InputAttributeAutocompleteNewPassword
	// one-time-code InputAttributeAutocompleteOneTimeCode
	Autocomplete *UiNodeInputAttributesAutocomplete `json:"autocomplete,omitempty"`

	// Disabled Sets the input's disabled field to true or false.
	Disabled bool    `json:"disabled"`
	Label    *UiText `json:"label,omitempty"`

	// Name The input's element name.
	Name string `json:"name"`

	// NodeType NodeType represents this node's types. It is a mirror of `node.type` and
	// is primarily used to allow compatibility with OpenAPI 3.0.  In this struct it technically always is "input".
	NodeType string `json:"node_type"`

	// Onclick OnClick may contain javascript which should be executed on click. This is primarily
	// used for WebAuthn.
	Onclick *string `json:"onclick,omitempty"`

	// Pattern The input's pattern.
	Pattern *string `json:"pattern,omitempty"`

	// Required Mark this input field as required.
	Required *bool `json:"required,omitempty"`

	// Type The input's element type.
	// text InputAttributeTypeText
	// password InputAttributeTypePassword
	// number InputAttributeTypeNumber
	// checkbox InputAttributeTypeCheckbox
	// hidden InputAttributeTypeHidden
	// email InputAttributeTypeEmail
	// tel InputAttributeTypeTel
	// submit InputAttributeTypeSubmit
	// button InputAttributeTypeButton
	// datetime-local InputAttributeTypeDateTimeLocal
	// date InputAttributeTypeDate
	// url InputAttributeTypeURI
	Type UiNodeInputAttributesType `json:"type"`

	// Value The input's value.
	Value *interface{} `json:"value"`
}

// UiNodeInputAttributesAutocomplete The autocomplete attribute for the input.
// email InputAttributeAutocompleteEmail
// tel InputAttributeAutocompleteTel
// url InputAttributeAutocompleteUrl
// current-password InputAttributeAutocompleteCurrentPassword
// new-password InputAttributeAutocompleteNewPassword
// one-time-code InputAttributeAutocompleteOneTimeCode
type UiNodeInputAttributesAutocomplete string

// UiNodeInputAttributesType The input's element type.
// text InputAttributeTypeText
// password InputAttributeTypePassword
// number InputAttributeTypeNumber
// checkbox InputAttributeTypeCheckbox
// hidden InputAttributeTypeHidden
// email InputAttributeTypeEmail
// tel InputAttributeTypeTel
// submit InputAttributeTypeSubmit
// button InputAttributeTypeButton
// datetime-local InputAttributeTypeDateTimeLocal
// date InputAttributeTypeDate
// url InputAttributeTypeURI
type UiNodeInputAttributesType string

// UiNodeMeta This might include a label and other information that can optionally
// be used to render UIs.
type UiNodeMeta struct {
	Label *UiText `json:"label,omitempty"`
}

// UiNodeScriptAttributes defines model for UiNodeScriptAttributes.
type UiNodeScriptAttributes struct {
	// Async The script async type
	Async bool `json:"async"`

	// Crossorigin The script cross origin policy
	Crossorigin string `json:"crossorigin"`

	// Id A unique identifier
	Id string `json:"id"`

	// Integrity The script's integrity hash
	Integrity string `json:"integrity"`

	// NodeType NodeType represents this node's types. It is a mirror of `node.type` and
	// is primarily used to allow compatibility with OpenAPI 3.0. In this struct it technically always is "script".
	NodeType string `json:"node_type"`

	// Nonce Nonce for CSP
	//
	// A nonce you may want to use to improve your Content Security Policy.
	// You do not have to use this value but if you want to improve your CSP
	// policies you may use it. You can also choose to use your own nonce value!
	Nonce string `json:"nonce"`

	// Referrerpolicy The script referrer policy
	Referrerpolicy string `json:"referrerpolicy"`

	// Src The script source
	Src string `json:"src"`

	// Type The script MIME type
	Type string `json:"type"`
}

// UiNodeTextAttributes defines model for UiNodeTextAttributes.
type UiNodeTextAttributes struct {
	// Id A unique identifier
	Id string `json:"id"`

	// NodeType NodeType represents this node's types. It is a mirror of `node.type` and
	// is primarily used to allow compatibility with OpenAPI 3.0.  In this struct it technically always is "text".
	NodeType string `json:"node_type"`
	Text     UiText `json:"text"`
}

// UiNodes defines model for UiNodes.
type UiNodes = []UiNode

// UiText defines model for UiText.
type UiText struct {
	// Context The message's context. Useful when customizing messages.
	Context *map[string]interface{} `json:"context,omitempty"`
	Id      ID                      `json:"id"`

	// Text The message text. Written in american english.
	Text string `json:"text"`

	// Type The message type.
	// info Info
	// error Error
	// success Success
	Type UiTextType `json:"type"`
}

// UiTextType The message type.
// info Info
// error Error
// success Success
type UiTextType string

// UiTexts defines model for UiTexts.
type UiTexts = []UiText

// UnlinkInternetGateway defines model for UnlinkInternetGateway.
type UnlinkInternetGateway struct {
	// VpcId The ID of the Vpc from which you want to detach the Internet gateway.
	VpcId string `json:"vpcId"`
}

// UnlinkLoadBalancerBackendMachines defines model for UnlinkLoadBalancerBackendMachines.
type UnlinkLoadBalancerBackendMachines struct {
	// BackendIps  One or more public IPs of back-end VMs.
	BackendIps *[]string `json:"backendIps,omitempty"`

	// BackendVmIds  One or more IDs of back-end VMs.
	BackendVmIds *[]string `json:"backendVmIds,omitempty"`
}

// UnlinkNic defines model for UnlinkNic.
type UnlinkNic struct {
	// LinkNicId The ID of the attachment operation.
	LinkNicId string `json:"linkNicId"`
}

// UnlinkPrivateIps defines model for UnlinkPrivateIps.
type UnlinkPrivateIps struct {
	// PrivateIps One or more secondary private IPs you want to unassign from the NIC.
	PrivateIps []string `json:"privateIps"`
}

// UnlinkPublicIp defines model for UnlinkPublicIp.
type UnlinkPublicIp struct {
	// LinkPublicIpId The ID representing the association of the public IP with the VM or the NIC. This parameter is required unless you use the `PublicIp` parameter.
	LinkPublicIpId *string `json:"linkPublicIpId,omitempty"`
}

// UnlinkRouteTable defines model for UnlinkRouteTable.
type UnlinkRouteTable struct {
	// LinkRouteTableId The ID of the association between the route table and the Subnet.
	LinkRouteTableId string `json:"linkRouteTableId"`
}

// UnlinkVirtualGatewayToVpc defines model for UnlinkVirtualGatewayToVpc.
type UnlinkVirtualGatewayToVpc struct {
	// VpcId The ID of the Vpc from which you want to detach the virtual gateway.
	VpcId string `json:"vpcId"`
}

// UnlinkVolume defines model for UnlinkVolume.
type UnlinkVolume struct {
	// ForceUnlink Forces the detachment of the volume in case of previous failure. Important: This action may damage your data or file systems.
	ForceUnlink *bool `json:"forceUnlink,omitempty"`
}

// UpdateCluster defines model for UpdateCluster.
type UpdateCluster struct {
	Description *string `json:"description,omitempty"`
	Name        *string `json:"name,omitempty"`
}

// UpdateFlexibleGpu defines model for UpdateFlexibleGpu.
type UpdateFlexibleGpu struct {
	// DeleteOnVmDeletion If true, the fGPU is deleted when the VM is terminated.
	DeleteOnVmDeletion *bool `json:"deleteOnVmDeletion,omitempty"`
}

// UpdateImage defines model for UpdateImage.
type UpdateImage struct {
	// AccessCreation Information about the permissions for the resource.<br />
	// Specify either the `Additions` or the `Removals` parameter.
	AccessCreation AccessCreation `json:"accessCreation"`
}

// UpdateListenerRule defines model for UpdateListenerRule.
type UpdateListenerRule struct {
	// HostPattern A host-name pattern for the rule, with a maximum length of 128 characters. This host-name pattern supports maximum three wildcards, and must not contain any special characters except [-.?].
	HostPattern *string `json:"hostPattern"`

	// PathPattern A path pattern for the rule, with a maximum length of 128 characters. This path pattern supports maximum three wildcards, and must not contain any special characters except [_-.$/~&quot;'@:+?].
	PathPattern *string `json:"pathPattern"`
}

// UpdateLoadBalancer defines model for UpdateLoadBalancer.
type UpdateLoadBalancer struct {
	// HealthCheck Information about the health check configuration.
	HealthCheck *HealthCheck `json:"healthCheck,omitempty"`

	// LoadBalancerPort The port on which the load balancer is listening (between `1` and `65535`, both included). This parameter is required if you want to update the server certificate.
	LoadBalancerPort *int `json:"loadBalancerPort,omitempty"`

	// PolicyNames The name of the policy you want to enable for the listener.
	PolicyNames *[]string `json:"policyNames,omitempty"`

	// PublicIp (internet-facing only) The public IP you want to associate with the load balancer. The former public IP of the load balancer is then disassociated. If you specify an empty string and the former public IP belonged to you, it is disassociated and replaced by a public IP owned by NumSpot.
	PublicIp *string `json:"publicIp,omitempty"`

	// SecuredCookies If true, secure cookies are enabled for the load balancer.
	SecuredCookies *bool `json:"securedCookies,omitempty"`

	// SecurityGroups (Vpc only) One or more IDs of security groups you want to assign to the load balancer. You need to specify the already assigned security groups that you want to keep along with the new ones you are assigning. If the list is empty, the default security group of the Vpc is assigned to the load balancer.
	SecurityGroups *[]string `json:"securityGroups,omitempty"`
}

// UpdateLoginFlowBody defines model for UpdateLoginFlowBody.
type UpdateLoginFlowBody struct {
	union json.RawMessage
}

// UpdateLoginFlowWithCodeMethod Update Login flow using the code method
type UpdateLoginFlowWithCodeMethod struct {
	// Code Code is the 6 digits code sent to the user
	Code *string `json:"code,omitempty"`

	// CsrfToken CSRFToken is the anti-CSRF token
	CsrfToken string `json:"csrf_token"`

	// Identifier Identifier is the code identifier
	// The identifier requires that the user has already completed the registration or settings with code flow.
	Identifier *string `json:"identifier,omitempty"`

	// Method Method should be set to "code" when logging in using the code strategy.
	Method string `json:"method"`

	// Resend Resend is set when the user wants to resend the code
	Resend *string `json:"resend,omitempty"`
}

// UpdateLoginFlowWithLookupSecretMethod Update Login Flow with Lookup Secret Method
type UpdateLoginFlowWithLookupSecretMethod struct {
	// CsrfToken Sending the anti-csrf token is only required for browser login flows.
	CsrfToken *string `json:"csrf_token,omitempty"`

	// LookupSecret The lookup secret.
	LookupSecret string `json:"lookup_secret"`

	// Method Method should be set to "lookup_secret" when logging in using the lookup_secret strategy.
	Method string `json:"method"`
}

// UpdateLoginFlowWithOidcMethod Update Login Flow with OpenID Connect Method
type UpdateLoginFlowWithOidcMethod struct {
	// CsrfToken The CSRF Token
	CsrfToken *string `json:"csrf_token,omitempty"`

	// IdToken IDToken is an optional id token provided by an OIDC provider
	//
	// If submitted, it is verified using the OIDC provider's public key set and the claims are used to populate
	// the OIDC credentials of the identity.
	// If the OIDC provider does not store additional claims (such as name, etc.) in the IDToken itself, you can use
	// the `traits` field to populate the identity's traits. Note, that Apple only includes the users email in the IDToken.
	//
	// Supported providers are
	// Apple
	IdToken *string `json:"id_token,omitempty"`

	// IdTokenNonce IDTokenNonce is the nonce, used when generating the IDToken.
	// If the provider supports nonce validation, the nonce will be validated against this value and required.
	IdTokenNonce *string `json:"id_token_nonce,omitempty"`

	// Method Method to use
	//
	// This field must be set to `oidc` when using the oidc method.
	Method string `json:"method"`

	// Provider The provider to register with
	Provider string `json:"provider"`

	// Traits The identity traits. This is a placeholder for the registration flow.
	Traits *map[string]interface{} `json:"traits,omitempty"`

	// UpstreamParameters UpstreamParameters are the parameters that are passed to the upstream identity provider.
	//
	// These parameters are optional and depend on what the upstream identity provider supports.
	// Supported parameters are:
	// `login_hint` (string): The `login_hint` parameter suppresses the account chooser and either pre-fills the email box on the sign-in form, or selects the proper session.
	// `hd` (string): The `hd` parameter limits the login/registration process to a Google Organization, e.g. `mycollege.edu`.
	// `prompt` (string): The `prompt` specifies whether the Authorization Server prompts the End-User for reauthentication and consent, e.g. `select_account`.
	UpstreamParameters *map[string]interface{} `json:"upstream_parameters,omitempty"`
}

// UpdateLoginFlowWithPasswordMethod Update Login Flow with Password Method
type UpdateLoginFlowWithPasswordMethod struct {
	// CsrfToken Sending the anti-csrf token is only required for browser login flows.
	CsrfToken *string `json:"csrf_token,omitempty"`

	// Identifier Identifier is the email or username of the user trying to log in.
	Identifier string `json:"identifier"`

	// Method Method should be set to "password" when logging in using the identifier and password strategy.
	Method string `json:"method"`

	// Password The user's password.
	Password string `json:"password"`

	// PasswordIdentifier Identifier is the email or username of the user trying to log in.
	// This field is deprecated!
	PasswordIdentifier *string `json:"password_identifier,omitempty"`
}

// UpdateLoginFlowWithTotpMethod Update Login Flow with TOTP Method
type UpdateLoginFlowWithTotpMethod struct {
	// CsrfToken Sending the anti-csrf token is only required for browser login flows.
	CsrfToken *string `json:"csrf_token,omitempty"`

	// Method Method should be set to "totp" when logging in using the TOTP strategy.
	Method string `json:"method"`

	// TotpCode The TOTP code.
	TotpCode string `json:"totp_code"`
}

// UpdateLoginFlowWithWebAuthnMethod Update Login Flow with WebAuthn Method
type UpdateLoginFlowWithWebAuthnMethod struct {
	// CsrfToken Sending the anti-csrf token is only required for browser login flows.
	CsrfToken *string `json:"csrf_token,omitempty"`

	// Identifier Identifier is the email or username of the user trying to log in.
	Identifier string `json:"identifier"`

	// Method Method should be set to "webAuthn" when logging in using the WebAuthn strategy.
	Method string `json:"method"`

	// WebauthnLogin Login a WebAuthn Security Key
	//
	// This must contain the ID of the WebAuthN connection.
	WebauthnLogin *string `json:"webauthn_login,omitempty"`
}

// UpdateNic defines model for UpdateNic.
type UpdateNic struct {
	// Description A new description for the NIC.
	Description *string `json:"description,omitempty"`

	// LinkNic Information about the NIC attachment. If you are modifying the `DeleteOnVmDeletion` attribute, you must specify the ID of the NIC attachment.
	LinkNic *LinkNicToUpdate `json:"linkNic,omitempty"`

	// SecurityGroupIds One or more IDs of security groups for the NIC.<br />
	// You must specify at least one group, even if you use the default security group in the Vpc.
	SecurityGroupIds *[]string `json:"securityGroupIds,omitempty"`
}

// UpdateRecoveryFlowBody Update Recovery Flow Request Body
type UpdateRecoveryFlowBody struct {
	union json.RawMessage
}

// UpdateRecoveryFlowWithCodeMethod Update Recovery Flow with Code Method
type UpdateRecoveryFlowWithCodeMethod struct {
	// Code Code from the recovery email
	//
	// If you want to submit a code, use this field, but make sure to _not_ include the email field, as well.
	Code *string `json:"code,omitempty"`

	// CsrfToken Sending the anti-csrf token is only required for browser login flows.
	CsrfToken *string `json:"csrf_token,omitempty"`

	// Email If the email belongs to a valid account, a recovery email will be sent.
	Email *string `json:"email,omitempty"`

	// Method Method is the method that should be used for this recovery flow
	//
	// Allowed values are `link` and `code`.
	// link RecoveryStrategyLink
	// code RecoveryStrategyCode
	Method UpdateRecoveryFlowWithCodeMethodMethod `json:"method"`
}

// UpdateRecoveryFlowWithCodeMethodMethod Method is the method that should be used for this recovery flow
//
// Allowed values are `link` and `code`.
// link RecoveryStrategyLink
// code RecoveryStrategyCode
type UpdateRecoveryFlowWithCodeMethodMethod string

// UpdateRecoveryFlowWithLinkMethod Update Recovery Flow with Link Method
type UpdateRecoveryFlowWithLinkMethod struct {
	// CsrfToken Sending the anti-csrf token is only required for browser login flows.
	CsrfToken *string `json:"csrf_token,omitempty"`

	// Email Email to Recover
	// Needs to be set when initiating the flow. If the email is a registered recovery email, a recovery link will be sent. If the email is not known,a email with details on what happened will be sent instead.
	Email openapi_types.Email `json:"email"`

	// Method Method is the method that should be used for this recovery flow
	//
	// Allowed values are `link` and `code`
	// link RecoveryStrategyLink
	// code RecoveryStrategyCode
	Method UpdateRecoveryFlowWithLinkMethodMethod `json:"method"`
}

// UpdateRecoveryFlowWithLinkMethodMethod Method is the method that should be used for this recovery flow
//
// Allowed values are `link` and `code`
// link RecoveryStrategyLink
// code RecoveryStrategyCode
type UpdateRecoveryFlowWithLinkMethodMethod string

// UpdateRegistrationFlowBody Update Registration Request Body
type UpdateRegistrationFlowBody struct {
	union json.RawMessage
}

// UpdateRegistrationFlowWithCodeMethod Update Registration Flow with Code Method
type UpdateRegistrationFlowWithCodeMethod struct {
	// Code The OTP Code sent to the user
	Code *string `json:"code,omitempty"`

	// CsrfToken The CSRF Token
	CsrfToken *string `json:"csrf_token,omitempty"`

	// Method Method to use
	//
	// This field must be set to `code` when using the code method.
	Method string `json:"method"`

	// Resend Resend restarts the flow with a new code
	Resend *string `json:"resend,omitempty"`

	// Traits The identity's traits
	Traits map[string]interface{} `json:"traits"`

	// TransientPayload Transient data to pass along to any webhooks
	TransientPayload *map[string]interface{} `json:"transient_payload,omitempty"`
}

// UpdateRegistrationFlowWithOidcMethod Update Registration Flow with OpenID Connect Method
type UpdateRegistrationFlowWithOidcMethod struct {
	// CsrfToken The CSRF Token
	CsrfToken *string `json:"csrf_token,omitempty"`

	// IdToken IDToken is an optional id token provided by an OIDC provider
	//
	// If submitted, it is verified using the OIDC provider's public key set and the claims are used to populate
	// the OIDC credentials of the identity.
	// If the OIDC provider does not store additional claims (such as name, etc.) in the IDToken itself, you can use
	// the `traits` field to populate the identity's traits. Note, that Apple only includes the users email in the IDToken.
	//
	// Supported providers are
	// Apple
	IdToken *string `json:"id_token,omitempty"`

	// IdTokenNonce IDTokenNonce is the nonce, used when generating the IDToken.
	// If the provider supports nonce validation, the nonce will be validated against this value and is required.
	IdTokenNonce *string `json:"id_token_nonce,omitempty"`

	// Method Method to use
	//
	// This field must be set to `oidc` when using the oidc method.
	Method string `json:"method"`

	// Provider The provider to register with
	Provider string `json:"provider"`

	// Traits The identity traits
	Traits *map[string]interface{} `json:"traits,omitempty"`

	// TransientPayload Transient data to pass along to any webhooks
	TransientPayload *map[string]interface{} `json:"transient_payload,omitempty"`

	// UpstreamParameters UpstreamParameters are the parameters that are passed to the upstream identity provider.
	//
	// These parameters are optional and depend on what the upstream identity provider supports.
	// Supported parameters are:
	// `login_hint` (string): The `login_hint` parameter suppresses the account chooser and either pre-fills the email box on the sign-in form, or selects the proper session.
	// `hd` (string): The `hd` parameter limits the login/registration process to a Google Organization, e.g. `mycollege.edu`.
	// `prompt` (string): The `prompt` specifies whether the Authorization Server prompts the End-User for reauthentication and consent, e.g. `select_account`.
	UpstreamParameters *map[string]interface{} `json:"upstream_parameters,omitempty"`
}

// UpdateRegistrationFlowWithPasswordMethod Update Registration Flow with Password Method
type UpdateRegistrationFlowWithPasswordMethod struct {
	// CsrfToken The CSRF Token
	CsrfToken *string `json:"csrf_token,omitempty"`

	// Method Method to use
	//
	// This field must be set to `password` when using the password method.
	Method string `json:"method"`

	// Password Password to sign the user up with
	Password string `json:"password"`

	// Traits The identity's traits
	Traits map[string]interface{} `json:"traits"`

	// TransientPayload Transient data to pass along to any webhooks
	TransientPayload *map[string]interface{} `json:"transient_payload,omitempty"`
}

// UpdateRegistrationFlowWithWebAuthnMethod Update Registration Flow with WebAuthn Method
type UpdateRegistrationFlowWithWebAuthnMethod struct {
	// CsrfToken CSRFToken is the anti-CSRF token
	CsrfToken *string `json:"csrf_token,omitempty"`

	// Method Method
	//
	// Should be set to "webauthn" when trying to add, update, or remove a webAuthn pairing.
	Method string `json:"method"`

	// Traits The identity's traits
	Traits map[string]interface{} `json:"traits"`

	// TransientPayload Transient data to pass along to any webhooks
	TransientPayload *map[string]interface{} `json:"transient_payload,omitempty"`

	// WebauthnRegister Register a WebAuthn Security Key
	//
	// It is expected that the JSON returned by the WebAuthn registration process
	// is included here.
	WebauthnRegister *string `json:"webauthn_register,omitempty"`

	// WebauthnRegisterDisplayname Name of the WebAuthn Security Key to be Added
	//
	// A human-readable name for the security key which will be added.
	WebauthnRegisterDisplayname *string `json:"webauthn_register_displayname,omitempty"`
}

// UpdateRoute defines model for UpdateRoute.
type UpdateRoute struct {
	// DestinationIpRange The IP range used for the destination match, in CIDR notation (for example, `10.0.0.0/24`).
	DestinationIpRange string `json:"destinationIpRange"`

	// GatewayId The ID of an Internet gateway or virtual gateway attached to your Vpc.
	GatewayId *string `json:"gatewayId,omitempty"`

	// NatGatewayId The ID of a NAT gateway.
	NatGatewayId *string `json:"natGatewayId,omitempty"`

	// NicId The ID of a network interface card (NIC).
	NicId *string `json:"nicId,omitempty"`

	// VmId The ID of a NAT VM in your Vpc.
	VmId *string `json:"vmId,omitempty"`

	// VpcPeeringId The ID of a Vpc peering.
	VpcPeeringId *string `json:"vpcPeeringId,omitempty"`
}

// UpdateRouteTableRoutePropagation defines model for UpdateRouteTableRoutePropagation.
type UpdateRouteTableRoutePropagation struct {
	// Enable If true, a virtual gateway can propagate routes to a specified route table of a Vpc. If false, the propagation is disabled.
	Enable bool `json:"enable"`

	// VirtualGatewayId The ID of the virtual gateway.
	VirtualGatewayId string `json:"virtualGatewayId"`
}

// UpdateServerCertificate defines model for UpdateServerCertificate.
type UpdateServerCertificate struct {
	// NewName A new name for the server certificate.
	NewName *string `json:"newName,omitempty"`

	// NewPath A new path for the server certificate.
	NewPath *string `json:"newPath,omitempty"`
}

// UpdateSettingsFlowBody defines model for UpdateSettingsFlowBody.
type UpdateSettingsFlowBody struct {
	union json.RawMessage
}

// UpdateSettingsFlowMethod defines model for UpdateSettingsFlowMethod.
type UpdateSettingsFlowMethod struct {
	// Method Method
	//
	// Should be set to password when trying to update a password.
	Method string `json:"method"`
}

// UpdateSettingsFlowWithPasswordMethod defines model for UpdateSettingsFlowWithPasswordMethod.
type UpdateSettingsFlowWithPasswordMethod struct {
	// CsrfToken CSRFToken is the anti-CSRF token
	CsrfToken *string     `json:"csrf_token,omitempty"`
	Method    interface{} `json:"method"`

	// Password Password is the updated password
	Password string `json:"password"`
}

// UpdateSettingsFlowWithTotpMethod defines model for UpdateSettingsFlowWithTotpMethod.
type UpdateSettingsFlowWithTotpMethod struct {
	// CsrfToken CSRFToken is the anti-CSRF token
	CsrfToken *string     `json:"csrf_token,omitempty"`
	Method    interface{} `json:"method"`

	// TotpCode ValidationTOTP must contain a valid TOTP based on the
	TotpCode *string `json:"totp_code,omitempty"`

	// TotpUnlink UnlinkTOTP if true will remove the TOTP pairing,
	// effectively removing the credential. This can be used
	// to set up a new TOTP device.
	TotpUnlink *bool `json:"totp_unlink,omitempty"`
}

// UpdateSubnet defines model for UpdateSubnet.
type UpdateSubnet struct {
	// MapPublicIpOnLaunch If true, a public IP is assigned to the network interface cards (NICs) created in the specified Subnet.
	MapPublicIpOnLaunch bool `json:"mapPublicIpOnLaunch"`
}

// UpdateVerificationFlowBody Update Verification Flow Request Body
type UpdateVerificationFlowBody struct {
	union json.RawMessage
}

// UpdateVerificationFlowWithCodeMethod defines model for UpdateVerificationFlowWithCodeMethod.
type UpdateVerificationFlowWithCodeMethod struct {
	// Code Code from the recovery email
	//
	// If you want to submit a code, use this field, but make sure to _not_ include the email field, as well.
	Code *string `json:"code,omitempty"`

	// CsrfToken Sending the anti-csrf token is only required for browser login flows.
	CsrfToken *string `json:"csrf_token,omitempty"`

	// Email If the email belongs to a valid account, a verifiation email will be sent.
	Email *string `json:"email,omitempty"`

	// Method Method is the method that should be used for this verification flow
	//
	// Allowed values are `link` and `code`.
	// link VerificationStrategyLink
	// code VerificationStrategyCode
	Method UpdateVerificationFlowWithCodeMethodMethod `json:"method"`
}

// UpdateVerificationFlowWithCodeMethodMethod Method is the method that should be used for this verification flow
//
// Allowed values are `link` and `code`.
// link VerificationStrategyLink
// code VerificationStrategyCode
type UpdateVerificationFlowWithCodeMethodMethod string

// UpdateVerificationFlowWithLinkMethod Update Verification Flow with Link Method
type UpdateVerificationFlowWithLinkMethod struct {
	// CsrfToken Sending the anti-csrf token is only required for browser login flows.
	CsrfToken *string `json:"csrf_token,omitempty"`

	// Email Email to Verify
	//
	// Needs to be set when initiating the flow. If the email is a registered
	// verification email, a verification link will be sent. If the email is not known,
	// a email with details on what happened will be sent instead.
	//
	// format: email
	Email string `json:"email"`

	// Method Method is the method that should be used for this verification flow
	//
	// Allowed values are `link` and `code`
	// link VerificationStrategyLink
	// code VerificationStrategyCode
	Method UpdateVerificationFlowWithLinkMethodMethod `json:"method"`
}

// UpdateVerificationFlowWithLinkMethodMethod Method is the method that should be used for this verification flow
//
// Allowed values are `link` and `code`
// link VerificationStrategyLink
// code VerificationStrategyCode
type UpdateVerificationFlowWithLinkMethodMethod string

// UpdateVm defines model for UpdateVm.
type UpdateVm struct {
	// BlockDeviceMappings One or more block device mappings of the VM.
	BlockDeviceMappings *[]BlockDeviceMappingVmUpdate `json:"blockDeviceMappings,omitempty"`

	// BsuOptimized This parameter is not available. It is present in our API for the sake of historical compatibility with AWS.
	BsuOptimized *bool `json:"bsuOptimized,omitempty"`

	// DeletionProtection If true, you cannot delete the VM unless you change this parameter back to false.
	DeletionProtection *bool `json:"deletionProtection,omitempty"`

	// IsSourceDestChecked (Vpc only) If true, the source/destination check is enabled. If false, it is disabled. This value must be false for a NAT VM to perform network address translation (NAT) in a Vpc.
	IsSourceDestChecked *bool `json:"isSourceDestChecked,omitempty"`

	// KeypairName The name of a keypair you want to associate with the VM.<br />
	// When you replace the keypair of a VM with another one, the metadata of the VM is modified to reflect the new public key, but the replacement is still not effective in the operating system of the VM. To complete the replacement and effectively apply the new keypair, you need to perform other actions inside the VM.
	KeypairName *string `json:"keypairName,omitempty"`

	// NestedVirtualization (dedicated tenancy only) If true, nested virtualization is enabled. If false, it is disabled.
	NestedVirtualization *bool `json:"nestedVirtualization,omitempty"`

	// Performance The performance of the VM (`medium` \| `high` \|  `highest`).
	Performance *UpdateVmPerformance `json:"performance,omitempty"`

	// SecurityGroupIds One or more IDs of security groups for the VM.
	SecurityGroupIds *[]string `json:"securityGroupIds,omitempty"`

	// Type The type of VM.
	Type *string `json:"type,omitempty"`

	// UserData The Base64-encoded MIME user data, limited to 500 kibibytes (KiB).
	UserData *string `json:"userData,omitempty"`

	// VmInitiatedShutdownBehavior The VM behavior when you stop it. If set to `stop`, the VM stops. If set to `restart`, the VM stops then automatically restarts. If set to `terminate`, the VM stops and is terminated.
	VmInitiatedShutdownBehavior *string `json:"vmInitiatedShutdownBehavior,omitempty"`
}

// UpdateVmPerformance The performance of the VM (`medium` \| `high` \|  `highest`).
type UpdateVmPerformance string

// UpdateVolume defines model for UpdateVolume.
type UpdateVolume struct {
	// Iops **Cold volume**: the new number of I/O operations per second (IOPS). This parameter can be specified only if you update an `io1` volume or if you change the type of the volume for an `io1`. This modification is instantaneous. <br />
	// **Hot volume**: the new number of I/O operations per second (IOPS). This parameter can be specified only if you update an `io1` volume. This modification is not instantaneous. <br /><br />
	//  The maximum number of IOPS allowed for `io1` volumes is `13000` with a maximum performance ratio of 300 IOPS per gibibyte.
	Iops *int `json:"iops,omitempty"`

	// Size **Cold volume**: the new size of the volume, in gibibytes (GiB). This value must be equal to or greater than the current size of the volume. This modification is not instantaneous. <br />
	// **Hot volume**: you cannot change the size of a hot volume.
	Size *int `json:"size,omitempty"`

	// VolumeType **Cold volume**: the new type of the volume (`standard` \ | `io1` \| `gp2`). This modification is instantaneous. If you update to an `io1` volume, you must also specify the `Iops` parameter.<br />
	//  **Hot volume**: you cannot change the type of a hot volume.
	VolumeType *string `json:"volumeType,omitempty"`
}

// UpdateVpc defines model for UpdateVpc.
type UpdateVpc struct {
	// DhcpOptionsSetId The ID of the DHCP options set (or `default` if you want to associate the default one).
	DhcpOptionsSetId string `json:"dhcpOptionsSetId"`
}

// UpdateVpnConnection defines model for UpdateVpnConnection.
type UpdateVpnConnection struct {
	// ClientGatewayId The ID of the client gateway.
	ClientGatewayId *string `json:"clientGatewayId,omitempty"`

	// VirtualGatewayId The ID of the virtual gateway.
	VirtualGatewayId *string `json:"virtualGatewayId,omitempty"`

	// VpnOptions Information about the VPN options.
	VpnOptions *VpnOptionsToUpdate `json:"vpnOptions,omitempty"`
}

// UploadPartOutput defines model for UploadPartOutput.
type UploadPartOutput = map[string]interface{}

// Url defines model for Url.
type Url = string

// User defines model for User.
type User struct {
	Email Email `json:"email"`

	// Firstname Firstname
	Firstname string `json:"firstname"`

	// Lastname Lastname
	Lastname string `json:"lastname"`
}

// UserCreated defines model for UserCreated.
type UserCreated struct {
	// Active Account activation/deactivation state
	Active    bool     `json:"active"`
	CreatedOn DateTime `json:"createdOn"`
	Email     Email    `json:"email"`

	// Firstname Firstname
	Firstname string `json:"firstname"`

	// Id User ID
	Id openapi_types.UUID `json:"id"`

	// Lastname Lastname
	Lastname string `json:"lastname"`
}

// UserCreation defines model for UserCreation.
type UserCreation struct {
	// Active Account activation/deactivation state
	Active    bool     `json:"active"`
	CreatedOn DateTime `json:"createdOn"`

	// Id User ID
	Id openapi_types.UUID `json:"id"`
}

// UserEdited defines model for UserEdited.
type UserEdited struct {
	// Active Account activation/deactivation state
	Active    bool     `json:"active"`
	CreatedOn DateTime `json:"createdOn"`

	// Id User ID
	Id        openapi_types.UUID `json:"id"`
	UpdatedOn DateTime           `json:"updatedOn"`
}

// UserInfo defines model for UserInfo.
type UserInfo struct {
	Email     *string `json:"email,omitempty"`
	Firstname *string `json:"firstname,omitempty"`
	Lastname  *string `json:"lastname,omitempty"`
	Sub       string  `json:"sub"`
}

// UserModified defines model for UserModified.
type UserModified struct {
	// Active Account activation/deactivation state
	Active    bool     `json:"active"`
	CreatedOn DateTime `json:"createdOn"`
	Email     Email    `json:"email"`

	// Firstname Firstname
	Firstname string `json:"firstname"`

	// Id User ID
	Id openapi_types.UUID `json:"id"`

	// Lastname Lastname
	Lastname  string   `json:"lastname"`
	UpdatedOn DateTime `json:"updatedOn"`
}

// UserPaginatedList defines model for UserPaginatedList.
type UserPaginatedList struct {
	Items []UserModified `json:"items"`

	// NextPageToken This token is used to retrieve the next page. If this field is omitted, there are no subsequent pages.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// TotalSize Equivalent to int32
	TotalSize *Int `json:"totalSize,omitempty"`
}

// UserState defines model for UserState.
type UserState struct {
	// Active Account activation/deactivation state
	Active bool `json:"active"`
}

// UserUpdate defines model for UserUpdate.
type UserUpdate struct {
	// Active Account activation/deactivation state
	Active bool  `json:"active"`
	Email  Email `json:"email"`

	// Firstname Firstname
	Firstname string `json:"firstname"`

	// Lastname Lastname
	Lastname string `json:"lastname"`
}

// VerifiableIdentityAddress VerifiableAddress is an identity's verifiable address
type VerifiableIdentityAddress struct {
	// CreatedAt When this entry was created
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Id The ID
	Id *openapi_types.UUID `json:"id,omitempty"`

	// Status VerifiableAddressStatus must not exceed 16 characters as that is the limitation in the SQL Schema
	Status IdentityVerifiableAddressStatus `json:"status"`

	// UpdatedAt When this entry was last updated
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Value The address value
	//
	// example foo@user.com
	Value string `json:"value"`

	// Verified Indicates if the address has already been verified
	Verified   bool      `json:"verified"`
	VerifiedAt *NullTime `json:"verified_at"`

	// Via The delivery method
	Via VerifiableIdentityAddressVia `json:"via"`
}

// VerifiableIdentityAddressVia The delivery method
type VerifiableIdentityAddressVia string

// VerificationFlow Used to verify an out-of-band communication channel such as an email address or a phone number.
type VerificationFlow struct {
	// Active Active, if set, contains the registration method that is being used. It is initially
	// not set.
	Active *string `json:"active,omitempty"`

	// ExpiresAt ExpiresAt is the time (UTC) when the request expires. If the user still wishes to verify the address,
	// a new request has to be initiated.
	ExpiresAt *time.Time `json:"expires_at,omitempty"`

	// Id ID represents the request's unique ID.
	Id openapi_types.UUID `json:"id"`

	// IssuedAt IssuedAt is the time (UTC) when the request occurred.
	IssuedAt *time.Time `json:"issued_at,omitempty"`

	// RequestUrl RequestURL is the initial URL that was requested. It can be used to forward information contained in the URL's path or query for example.
	RequestUrl *string `json:"request_url,omitempty"`

	// ReturnTo ReturnTo contains the requested return_to URL.
	ReturnTo *string `json:"return_to,omitempty"`

	// State State represents the state of this request:
	//
	// choose_method: ask the user to choose a method (e.g. verify your email)
	// sent_email: the email has been sent to the user
	// passed_challenge: the request was successful and the verification challenge was passed.
	State interface{} `json:"state"`

	// Type The flow type can either be `api` or `browser`.
	Type SelfServiceFlowType `json:"type"`

	// Ui Container represents a HTML Form. The container can work with both HTTP Form and JSON requests.
	Ui UiContainer `json:"ui"`
}

// VgwTelemetry Information about the current state of a VPN tunnel.
type VgwTelemetry struct {
	// AcceptedRouteCount The number of routes accepted through BGP (Border Gateway Protocol) route exchanges.
	AcceptedRouteCount *int `json:"acceptedRouteCount,omitempty"`

	// LastStateChangeDate The date and time (UTC) of the latest state update.
	LastStateChangeDate *time.Time `json:"lastStateChangeDate,omitempty"`

	// OutsideIpAddress The IP on the NumSpot side of the tunnel.
	OutsideIpAddress *string `json:"outsideIpAddress,omitempty"`

	// State The state of the IPSEC tunnel (`UP` \| `DOWN`).
	State *string `json:"state,omitempty"`

	// StateDescription A description of the current state of the tunnel.
	StateDescription *string `json:"stateDescription,omitempty"`
}

// Violation defines model for Violation.
type Violation struct {
	// Description A description of why the field is violated.
	Description string `json:"description"`

	// Field The field impacted by the violation.
	Field string `json:"field"`
}

// VirtualGateway Information about the virtual gateway.
type VirtualGateway struct {
	// ConnectionType The type of VPN connection supported by the virtual gateway (only `ipsec.1` is supported).
	ConnectionType *string `json:"connectionType,omitempty"`

	// Id The ID of the virtual gateway.
	Id *string `json:"id,omitempty"`

	// State The state of the virtual gateway (`pending` \| `available` \| `deleting` \| `deleted`).
	State *string `json:"state,omitempty"`

	// Tags One or more tags associated with the virtual gateway.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// VpcToVirtualGatewayLinks the Vpc to which the virtual gateway is attached.
	VpcToVirtualGatewayLinks *[]VpcToVirtualGatewayLink `json:"vpcToVirtualGatewayLinks,omitempty"`
}

// Vm Information about the VM.
type Vm struct {
	// Architecture The architecture of the VM (`i386` \| `x86_64`).
	Architecture *string `json:"architecture,omitempty"`

	// BlockDeviceMappings The block device mapping of the VM.
	BlockDeviceMappings *[]BlockDeviceMappingCreated `json:"blockDeviceMappings,omitempty"`

	// BsuOptimized This parameter is not available. It is present in our API for the sake of historical compatibility with AWS.
	BsuOptimized *bool `json:"bsuOptimized,omitempty"`

	// ClientToken The idempotency token provided when launching the VM.
	ClientToken *string `json:"clientToken,omitempty"`

	// CreationDate The date and time of creation of the VM.
	CreationDate *time.Time `json:"creationDate,omitempty"`

	// DeletionProtection If true, you cannot delete the VM unless you change this parameter back to false.
	DeletionProtection *bool `json:"deletionProtection,omitempty"`

	// Hypervisor The hypervisor type of the VMs (`ovm` \| `xen`).
	Hypervisor *string `json:"hypervisor,omitempty"`

	// Id The ID of the VM.
	Id *string `json:"id,omitempty"`

	// ImageId The ID of the OMI used to create the VM.
	ImageId *string `json:"imageId,omitempty"`

	// InitiatedShutdownBehavior The VM behavior when you stop it. If set to `stop`, the VM stops. If set to `restart`, the VM stops then automatically restarts. If set to `terminate`, the VM stops and is deleted.
	InitiatedShutdownBehavior *string `json:"initiatedShutdownBehavior,omitempty"`

	// IsSourceDestChecked (Vpc only) If true, the source/destination check is enabled. If false, it is disabled. This value must be false for a NAT VM to perform network address translation (NAT) in a Vpc.
	IsSourceDestChecked *bool `json:"isSourceDestChecked,omitempty"`

	// KeypairName The name of the keypair used when launching the VM.
	KeypairName *string `json:"keypairName,omitempty"`

	// LaunchNumber The number for the VM when launching a group of several VMs (for example, `0`, `1`, `2`, and so on).
	LaunchNumber *int `json:"launchNumber,omitempty"`

	// NestedVirtualization If true, nested virtualization is enabled. If false, it is disabled.
	NestedVirtualization *bool `json:"nestedVirtualization,omitempty"`

	// Nics (Vpc only) The network interface cards (NICs) the VMs are attached to.
	Nics *[]NicLight `json:"nics,omitempty"`

	// OsFamily Indicates the operating system (OS) of the VM.
	OsFamily *string `json:"osFamily,omitempty"`

	// Performance The performance of the VM (`medium` \| `high` \|  `highest`).
	Performance *string `json:"performance,omitempty"`

	// Placement Information about the placement of the VM.
	Placement *Placement `json:"placement,omitempty"`

	// PrivateDnsName The name of the private DNS.
	PrivateDnsName *string `json:"privateDnsName,omitempty"`

	// PrivateIp The primary private IP of the VM.
	PrivateIp *string `json:"privateIp,omitempty"`

	// ProductCodes The product codes associated with the OMI used to create the VM.
	ProductCodes *[]string `json:"productCodes,omitempty"`

	// PublicDnsName The name of the public DNS.
	PublicDnsName *string `json:"publicDnsName,omitempty"`

	// PublicIp The public IP of the VM.
	PublicIp *string `json:"publicIp,omitempty"`

	// ReservationId The reservation ID of the VM.
	ReservationId *string `json:"reservationId,omitempty"`

	// RootDeviceName The name of the root device for the VM (for example, `/dev/sda1`).
	RootDeviceName *string `json:"rootDeviceName,omitempty"`

	// RootDeviceType The type of root device used by the VM (always `bsu`).
	RootDeviceType *string `json:"rootDeviceType,omitempty"`

	// SecurityGroups One or more security groups associated with the VM.
	SecurityGroups *[]SecurityGroupLight `json:"securityGroups,omitempty"`

	// State The state of the VM (`pending` \| `running` \| `stopping` \| `stopped` \| `shutting-down` \| `terminated` \| `quarantine`).
	State *string `json:"state,omitempty"`

	// StateReason The reason explaining the current state of the VM.
	StateReason *string `json:"stateReason,omitempty"`

	// SubnetId The ID of the Subnet for the VM.
	SubnetId *string `json:"subnetId,omitempty"`

	// Tags One or more tags associated with the VM.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// Type The type of VM.
	Type *string `json:"type,omitempty"`

	// UserData The Base64-encoded MIME user data.
	UserData *string `json:"userData,omitempty"`

	// VpcId The ID of the Vpc in which the VM is running.
	VpcId *string `json:"vpcId,omitempty"`
}

// VmState Information about the state of the VM.
type VmState struct {
	// CurrentState The current state of the VM (`InService` \| `OutOfService` \| `Unknown`).
	CurrentState *string `json:"currentState,omitempty"`

	// Id The ID of the VM.
	Id *string `json:"id,omitempty"`

	// PreviousState The previous state of the VM (`InService` \| `OutOfService` \| `Unknown`).
	PreviousState *string `json:"previousState,omitempty"`
}

// VmStates Information about the states of the VMs.
type VmStates struct {
	// AvailabilityZoneName The name of the Subregion of the VM.
	AvailabilityZoneName *string `json:"availabilityZoneName,omitempty"`

	// Id The ID of the VM.
	Id *string `json:"id,omitempty"`

	// MaintenanceEvents One or more scheduled events associated with the VM.
	MaintenanceEvents *[]MaintenanceEvent `json:"maintenanceEvents,omitempty"`

	// VmState The state of the VM (`pending` \| `running` \| `stopping` \| `stopped` \| `shutting-down` \| `terminated` \| `quarantine`).
	VmState *string `json:"vmState,omitempty"`
}

// Volume Information about the volume.
type Volume struct {
	// AvailabilityZoneName The Subregion in which the volume was created.
	AvailabilityZoneName *string `json:"availabilityZoneName,omitempty"`

	// CreationDate The date and time of creation of the volume.
	CreationDate *time.Time `json:"creationDate,omitempty"`

	// Id The ID of the volume.
	Id *string `json:"id,omitempty"`

	// Iops The number of I/O operations per second (IOPS):<br />
	// - For `io1` volumes, the number of provisioned IOPS<br />
	// - For `gp2` volumes, the baseline performance of the volume
	Iops *int `json:"iops,omitempty"`

	// LinkedVolumes Information about your volume attachment.
	LinkedVolumes *[]LinkedVolume `json:"linkedVolumes,omitempty"`

	// Size The size of the volume, in gibibytes (GiB).
	Size *int `json:"size,omitempty"`

	// SnapshotId The snapshot from which the volume was created.
	SnapshotId *string `json:"snapshotId,omitempty"`

	// State The state of the volume (`creating` \| `available` \| `in-use` \| `updating` \| `deleting` \| `error`).
	State *string `json:"state,omitempty"`

	// Tags One or more tags associated with the volume.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// Type The type of the volume (`standard` \| `gp2` \| `io1`).
	Type *string `json:"type,omitempty"`
}

// Vpc Information about the Vpc.
type Vpc struct {
	// DhcpOptionsSetId The ID of the DHCP options set (or `default` if you want to associate the default one).
	DhcpOptionsSetId *string `json:"dhcpOptionsSetId,omitempty"`

	// Id The ID of the Vpc.
	Id *string `json:"id,omitempty"`

	// IpRange The IP range for the Vpc, in CIDR notation (for example, `10.0.0.0/16`).
	IpRange *string `json:"ipRange,omitempty"`

	// State The state of the Vpc (`pending` \| `available` \| `deleting`).
	State *string `json:"state,omitempty"`

	// Tags One or more tags associated with the Vpc.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// Tenancy The VM tenancy in a Vpc.
	Tenancy *string `json:"tenancy,omitempty"`
}

// VpcPeering Information about the Vpc peering.
type VpcPeering struct {
	// AccepterVpc Information about the accepter Vpc.
	AccepterVpc *AccepterVpc `json:"accepterVpc,omitempty"`

	// ExpirationDate The date and time at which the Vpc peerings expire.
	ExpirationDate *time.Time `json:"expirationDate"`

	// Id The ID of the Vpc peering.
	Id *string `json:"id,omitempty"`

	// SourceVpc Information about the source Vpc.
	SourceVpc *SourceVpc `json:"sourceVpc,omitempty"`

	// State Information about the state of the Vpc peering.
	State *VpcPeeringState `json:"state,omitempty"`

	// Tags One or more tags associated with the Vpc peering.
	Tags *[]ResourceTag `json:"tags,omitempty"`
}

// VpcPeeringState Information about the state of the Vpc peering.
type VpcPeeringState struct {
	// Message Additional information about the state of the Vpc peering.
	Message *string `json:"message,omitempty"`

	// Name The state of the Vpc peering (`pending-acceptance` \| `active` \| `rejected` \| `failed` \| `expired` \| `deleted`).
	Name *string `json:"name,omitempty"`
}

// VpcToVirtualGatewayLink Information about the attachment.
type VpcToVirtualGatewayLink struct {
	// State The state of the attachment (`attaching` \| `attached` \| `detaching` \| `detached`).
	State *string `json:"state,omitempty"`

	// VpcId The ID of the Vpc to which the virtual gateway is attached.
	VpcId *string `json:"vpcId,omitempty"`
}

// VpnConnection Information about a VPN connection.
type VpnConnection struct {
	// ClientGatewayConfiguration Example configuration for the client gateway.
	ClientGatewayConfiguration *string `json:"clientGatewayConfiguration,omitempty"`

	// ClientGatewayId The ID of the client gateway used on the client end of the connection.
	ClientGatewayId *string `json:"clientGatewayId,omitempty"`

	// ConnectionType The type of VPN connection (always `ipsec.1`).
	ConnectionType *string `json:"connectionType,omitempty"`

	// Id The ID of the VPN connection.
	Id *string `json:"id,omitempty"`

	// Routes Information about one or more static routes associated with the VPN connection, if any.
	Routes *[]RouteLight `json:"routes,omitempty"`

	// State The state of the VPN connection (`pending` \| `available` \| `deleting` \| `deleted`).
	State *string `json:"state,omitempty"`

	// StaticRoutesOnly If false, the VPN connection uses dynamic routing with Border Gateway Protocol (BGP). If true, routing is controlled using static routes. For more information about how to create and delete static routes, see [CreateVpnConnectionRoute](#createvpnconnectionroute) and [DeleteVpnConnectionRoute](#deletevpnconnectionroute).
	StaticRoutesOnly *bool `json:"staticRoutesOnly,omitempty"`

	// Tags One or more tags associated with the VPN connection.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// VgwTelemetries Information about the current state of one or more of the VPN tunnels.
	VgwTelemetries *[]VgwTelemetry `json:"vgwTelemetries,omitempty"`

	// VirtualGatewayId The ID of the virtual gateway used on the NumSpot end of the connection.
	VirtualGatewayId *string `json:"virtualGatewayId,omitempty"`

	// VpnOptions Information about the VPN options.
	VpnOptions *VpnOptions `json:"vpnOptions,omitempty"`
}

// VpnOptions Information about the VPN options.
type VpnOptions struct {
	// Phase1Options Information about Phase 1 of the Internet Key Exchange (IKE) negotiation. When Phase 1 finishes successfully, peers proceed to Phase 2 negotiations.
	Phase1Options *Phase1Options `json:"phase1Options,omitempty"`

	// Phase2Options Information about Phase 2 of the Internet Key Exchange (IKE) negotiation.
	Phase2Options *Phase2Options `json:"phase2Options,omitempty"`

	// TunnelInsideIpRange The range of inside IPs for the tunnel. This must be a /30 CIDR block from the 169.254.254.0/24 range.
	TunnelInsideIpRange *string `json:"tunnelInsideIpRange,omitempty"`
}

// VpnOptionsToUpdate Information about the VPN options.
type VpnOptionsToUpdate struct {
	// Phase2Options Information about Phase 2 of the Internet Key Exchange (IKE) negotiation.
	Phase2Options *Phase2OptionsToUpdate `json:"phase2Options,omitempty"`

	// TunnelInsideIpRange The range of inside IPs for the tunnel. This must be a /30 CIDR block from the 169.254.254.0/24 range.
	TunnelInsideIpRange *string `json:"tunnelInsideIpRange,omitempty"`
}

// WebAuthnJavaScript defines model for WebAuthnJavaScript.
type WebAuthnJavaScript struct {
	CreatedAt      time.Time          `json:"created_at"`
	Id             openapi_types.UUID `json:"id"`
	Name           string             `json:"name"`
	SubscriptionId *NullUUID          `json:"subscription_id"`
	UpdatedAt      time.Time          `json:"updated_at"`
}

// Action defines model for Action.
type Action = string

// Authorization defines model for Authorization.
type Authorization = string

// ClientId defines model for ClientId.
type ClientId = openapi_types.UUID

// ClusterId defines model for ClusterId.
type ClusterId = string

// ConsentChallenge defines model for ConsentChallenge.
type ConsentChallenge = string

// IdUuid defines model for IdUuid.
type IdUuid = openapi_types.UUID

// KubernetesClusterId defines model for KubernetesClusterId.
type KubernetesClusterId = openapi_types.UUID

// ListPermissionsPage defines model for ListPermissionsPage.
type ListPermissionsPage struct {
	// NextToken A page token received from a previous call. Provide this to retrieve the subsequent page.
	NextToken *string `json:"nextToken"`

	// Size The maximum number of items to return. The service may return fewer than this value.
	Size *int32 `json:"size"`
}

// ListPolicyPage defines model for ListPolicyPage.
type ListPolicyPage struct {
	// NextToken A page token received from a previous call. Provide this to retrieve the subsequent page.
	NextToken *string `json:"nextToken,omitempty"`

	// Size The maximum number of items to return. The service may return fewer than this value.
	Size *int32 `json:"size,omitempty"`
}

// ListRolesPage defines model for ListRolesPage.
type ListRolesPage struct {
	// NextToken A page token received from a previous call. Provide this to retrieve the subsequent page.
	NextToken *string `json:"nextToken"`

	// Size The maximum number of items to return. The service may return fewer than this value.
	Size *int32 `json:"size"`
}

// ListServiceAccounts defines model for ListServiceAccounts.
type ListServiceAccounts struct {
	// NextToken A page token received from a previous call. Provide this to retrieve the subsequent page.
	NextToken *string `json:"nextToken,omitempty"`

	// Size The maximum number of items to return. The service may return fewer than this value.
	Size *int32 `json:"size,omitempty"`
}

// ListSpacesIdentity defines model for ListSpacesIdentity.
type ListSpacesIdentity struct {
	// NextToken A page token received from a previous call. Provide this to retrieve the subsequent page.
	NextToken *string `json:"nextToken,omitempty"`

	// Size The maximum number of items to return. The service may return fewer than this value.
	Size *int32 `json:"size,omitempty"`
}

// ListSpacesOfServiceAccount defines model for ListSpacesOfServiceAccount.
type ListSpacesOfServiceAccount struct {
	// NextToken A page token received from a previous call. Provide this to retrieve the subsequent page.
	NextToken *string `json:"nextToken,omitempty"`

	// Size The maximum number of items to return. The service may return fewer than this value.
	Size *int32 `json:"size,omitempty"`
}

// ListSpacesOfUser defines model for ListSpacesOfUser.
type ListSpacesOfUser struct {
	// NextToken A page token received from a previous call. Provide this to retrieve the subsequent page.
	NextToken *string `json:"nextToken,omitempty"`

	// Size The maximum number of items to return. The service may return fewer than this value.
	Size *int32 `json:"size,omitempty"`
}

// ListSpacesPage defines model for ListSpacesPage.
type ListSpacesPage struct {
	// NextToken A page token received from a previous call. Provide this to retrieve the subsequent page.
	NextToken *string `json:"nextToken,omitempty"`

	// Size The maximum number of items to return. The service may return fewer than this value.
	Size *int32 `json:"size,omitempty"`
}

// ListUser defines model for ListUser.
type ListUser struct {
	// NextToken A page token received from a previous call. Provide this to retrieve the subsequent page.
	NextToken *string `json:"nextToken,omitempty"`

	// Size The maximum number of items to return. The service may return fewer than this value.
	Size *int32 `json:"size,omitempty"`
}

// ListUserOrganisations defines model for ListUserOrganisations.
type ListUserOrganisations struct {
	// NextToken A page token received from a previous call. Provide this to retrieve the subsequent page.
	NextToken *string `json:"nextToken,omitempty"`

	// Size The maximum number of items to return. The service may return fewer than this value.
	Size *int32 `json:"size,omitempty"`
}

// NodepoolName defines model for NodepoolName.
type NodepoolName = string

// ObjectType defines model for ObjectType.
type ObjectType = string

// OperationId defines model for OperationId.
type OperationId = openapi_types.UUID

// OperationStatuses defines model for OperationStatuses.
type OperationStatuses = []OperationStatus

// OrganisationId defines model for OrganisationId.
type OrganisationId = openapi_types.UUID

// PermissionUuid defines model for PermissionUuid.
type PermissionUuid = openapi_types.UUID

// QueryClusterId defines model for QueryClusterId.
type QueryClusterId = string

// RedirectUri defines model for RedirectUri.
type RedirectUri = string

// Resource defines model for Resource.
type Resource = string

// ResponseType defines model for ResponseType.
type ResponseType = string

// RoleName defines model for RoleName.
type RoleName = string

// RoleUuid defines model for RoleUuid.
type RoleUuid = openapi_types.UUID

// Scope defines model for Scope.
type Scope = string

// Service defines model for Service.
type Service = string

// ServiceAccountId defines model for ServiceAccountId.
type ServiceAccountId = openapi_types.UUID

// SpaceId defines model for SpaceId.
type SpaceId = openapi_types.UUID

// State defines model for State.
type State = string

// SubResource defines model for SubResource.
type SubResource = string

// SubjectId defines model for SubjectId.
type SubjectId = openapi_types.UUID

// SubjectTypeParam defines model for SubjectTypeParam.
type SubjectTypeParam = SubjectType

// TokenJwt defines model for TokenJwt.
type TokenJwt = string

// UserEmail defines model for UserEmail.
type UserEmail = openapi_types.Email

// UserId defines model for UserId.
type UserId = openapi_types.UUID

// AcceptVpcPeeringResponseSchema defines model for AcceptVpcPeeringResponse.
type AcceptVpcPeeringResponseSchema = AcceptVpcPeering

// Cluster200ResponseSchema defines model for Cluster200Response.
type Cluster200ResponseSchema = KubernetesCluster

// ClusterCreateResponseSchema defines model for ClusterCreateResponse.
type ClusterCreateResponseSchema = ResCreateCluster

// ClusterDeleteResponseSchema defines model for ClusterDeleteResponse.
type ClusterDeleteResponseSchema = ResDeleteCluster

// ClusterGetResponseSchema defines model for ClusterGetResponse.
type ClusterGetResponseSchema = OpenShiftCluster

// ClusterList200ResponseSchema defines model for ClusterList200Response.
type ClusterList200ResponseSchema = KubernetesListClusters

// ClusterStatusResponseSchema defines model for ClusterStatusResponse.
type ClusterStatusResponseSchema = KubernetesStatus

// ClustersResponseSchema defines model for ClustersResponse.
type ClustersResponseSchema = ListClusters

// CreateClientGatewayResponseSchema Information about the client gateway.
type CreateClientGatewayResponseSchema = ClientGateway

// CreateDhcpOptionsResponseSchema Information about the DHCP options set.
type CreateDhcpOptionsResponseSchema = DhcpOptionsSet

// CreateFlexibleGpuResponseSchema Information about the flexible GPU (fGPU).
type CreateFlexibleGpuResponseSchema = FlexibleGpu

// CreateImageResponseSchema Information about the OMI.
type CreateImageResponseSchema = Image

// CreateInternetGatewayResponseSchema Information about the Internet gateway.
type CreateInternetGatewayResponseSchema = InternetGateway

// CreateKeypairResponseSchema Information about the created keypair.
type CreateKeypairResponseSchema = CreateKeypair

// CreateListenerRuleResponseSchema Information about the listener rule.
type CreateListenerRuleResponseSchema = ListenerRule

// CreateLoadBalancerListenersResponseSchema Information about the load balancer.
type CreateLoadBalancerListenersResponseSchema = LoadBalancer

// CreateLoadBalancerPolicyResponseSchema Information about the load balancer.
type CreateLoadBalancerPolicyResponseSchema = LoadBalancer

// CreateLoadBalancerResponseSchema Information about the load balancer.
type CreateLoadBalancerResponseSchema = LoadBalancer

// CreateNatGatewayResponseSchema Information about the NAT gateway.
type CreateNatGatewayResponseSchema = NatGateway

// CreateNicResponseSchema Information about the NIC.
type CreateNicResponseSchema = Nic

// CreatePublicIpResponseSchema Information about the public IP.
type CreatePublicIpResponseSchema = PublicIp

// CreateRole200ResponseSchema defines model for CreateRole200Response.
type CreateRole200ResponseSchema = RegisteredRole

// CreateRouteResponseSchema Information about the route table.
type CreateRouteResponseSchema = RouteTable

// CreateRouteTableResponseSchema Information about the route table.
type CreateRouteTableResponseSchema = RouteTable

// CreateSecurityGroupResponseSchema Information about the security group.
type CreateSecurityGroupResponseSchema = SecurityGroup

// CreateSecurityGroupRuleResponseSchema Information about the security group.
type CreateSecurityGroupRuleResponseSchema = SecurityGroup

// CreateServerCertificateResponseSchema Information about the VPN options.
type CreateServerCertificateResponseSchema = ServerCertificate

// CreateServiceAccount201ResponseSchema defines model for CreateServiceAccount201Response.
type CreateServiceAccount201ResponseSchema = CreatedServiceAccount

// CreateSnapshotResponseSchema Information about the snapshot.
type CreateSnapshotResponseSchema = Snapshot

// CreateSpace200ResponseSchema defines model for CreateSpace200Response.
type CreateSpace200ResponseSchema = Space

// CreateSubnetResponseSchema Information about the Subnet.
type CreateSubnetResponseSchema = Subnet

// CreateUser201ResponseSchema defines model for CreateUser201Response.
type CreateUser201ResponseSchema = UserCreated

// CreateVirtualGatewayResponseSchema Information about the virtual gateway.
type CreateVirtualGatewayResponseSchema = VirtualGateway

// CreateVmsResponseSchema Information about the VM.
type CreateVmsResponseSchema = Vm

// CreateVolumeResponseSchema Information about the volume.
type CreateVolumeResponseSchema = Volume

// CreateVpcPeeringResponseSchema Information about the Vpc peering.
type CreateVpcPeeringResponseSchema = VpcPeering

// CreateVpcResponseSchema Information about the Vpc.
type CreateVpcResponseSchema = Vpc

// CreateVpnConnectionResponseSchema Information about a VPN connection.
type CreateVpnConnectionResponseSchema = VpnConnection

// Error400Schema For HTTP 400 bad request errors, we implement the https://datatracker.ietf.org/doc/html/rfc9457
type Error400Schema = BadRequestError

// Error404Schema For HTTP errors, we implement the https://datatracker.ietf.org/doc/html/rfc9457
type Error404Schema = Error

// Error500Schema For HTTP errors, we implement the https://datatracker.ietf.org/doc/html/rfc9457
type Error500Schema = Error

// ErrorResponseSchema For HTTP errors, we implement the https://datatracker.ietf.org/doc/html/rfc9457
type ErrorResponseSchema = Error

// GetACL200ResponseSchema defines model for GetACL200Response.
type GetACL200ResponseSchema = ACLPaginatedList

// GetIAMGranularPolicy200ResponseSchema defines model for GetIAMGranularPolicy200Response.
type GetIAMGranularPolicy200ResponseSchema = IAMGranularPolicyList

// GetIAMPolicy200ResponseSchema defines model for GetIAMPolicy200Response.
type GetIAMPolicy200ResponseSchema = IAMPolicy

// GetPermission200ResponseSchema defines model for GetPermission200Response.
type GetPermission200ResponseSchema = RegisteredPermission

// GetRole200ResponseSchema defines model for GetRole200Response.
type GetRole200ResponseSchema = RegisteredRole

// GetRolePermissions200ResponseSchema defines model for GetRolePermissions200Response.
type GetRolePermissions200ResponseSchema = PermissionsPaginatedList

// GetServiceAccount200ResponseSchema defines model for GetServiceAccount200Response.
type GetServiceAccount200ResponseSchema = ServiceAccountEdited

// GetSpaceById200ResponseSchema defines model for GetSpaceById200Response.
type GetSpaceById200ResponseSchema = Space

// GetUser200ResponseSchema defines model for GetUser200Response.
type GetUser200ResponseSchema = UserModified

// GetUserInfo200ResponseSchema defines model for GetUserInfo200Response.
type GetUserInfo200ResponseSchema = UserInfo

// IntrospectResponseSchema defines model for IntrospectResponse.
type IntrospectResponseSchema = IntrospectResp

// JsonWebKeysResponseSchema JSON Web Key Set
type JsonWebKeysResponseSchema = JsonWebKeySet

// LinkNicResponseSchema defines model for LinkNicResponse.
type LinkNicResponseSchema struct {
	// LinkNicId The ID of the NIC attachment.
	LinkNicId *string `json:"linkNicId,omitempty"`
}

// LinkPublicIpResponseSchema defines model for LinkPublicIpResponse.
type LinkPublicIpResponseSchema struct {
	// LinkPublicIpId (Vpc only) The ID representing the association of the public IP with the VM or the NIC.
	LinkPublicIpId *string `json:"linkPublicIpId,omitempty"`
}

// LinkRouteTableResponseSchema defines model for LinkRouteTableResponse.
type LinkRouteTableResponseSchema struct {
	// LinkRouteTableId The ID of the association between the route table and the Subnet.
	LinkRouteTableId *string `json:"linkRouteTableId,omitempty"`
}

// LinkVirtualGatewayToVpcResponseSchema defines model for LinkVirtualGatewayToVpcResponse.
type LinkVirtualGatewayToVpcResponseSchema = LinkVirtualGatewayToVpc

// ListMySessionsResponseSchema defines model for ListMySessionsResponse.
type ListMySessionsResponseSchema = []Session

// ListPermissions200ResponseSchema defines model for ListPermissions200Response.
type ListPermissions200ResponseSchema = PermissionsPaginatedList

// ListRoles200ResponseSchema defines model for ListRoles200Response.
type ListRoles200ResponseSchema = RolesPaginatedList

// ListServiceAccount200ResponseSchema defines model for ListServiceAccount200Response.
type ListServiceAccount200ResponseSchema = ServiceAccountPaginatedList

// ListSpaces200ResponseSchema defines model for ListSpaces200Response.
type ListSpaces200ResponseSchema = SpacePaginatedList

// ListSpacesIdentity200ResponseSchema defines model for ListSpacesIdentity200Response.
type ListSpacesIdentity200ResponseSchema = SpaceSimplePaginatedList

// ListSpacesServiceAccount200ResponseSchema defines model for ListSpacesServiceAccount200Response.
type ListSpacesServiceAccount200ResponseSchema = SpaceSimplePaginatedList

// ListSpacesUser200ResponseSchema defines model for ListSpacesUser200Response.
type ListSpacesUser200ResponseSchema = SpaceSimplePaginatedList

// ListUser200ResponseSchema defines model for ListUser200Response.
type ListUser200ResponseSchema = UserPaginatedList

// ListUserOrganisations200ResponseSchema defines model for ListUserOrganisations200Response.
type ListUserOrganisations200ResponseSchema = OrganisationSimplePaginatedList

// NodepoolCreateResponseSchema defines model for NodepoolCreateResponse.
type NodepoolCreateResponseSchema = ResCreateNodepool

// NodepoolDeleteResponseSchema defines model for NodepoolDeleteResponse.
type NodepoolDeleteResponseSchema = ResDeleteCluster

// NodepoolsResponseSchema defines model for NodepoolsResponse.
type NodepoolsResponseSchema = ListNodepools

// Operation200ResponseSchema defines model for Operation200Response.
type Operation200ResponseSchema = KubernetesOperation

// Operation202ResponseSchema defines model for Operation202Response.
type Operation202ResponseSchema = KubernetesOperation

// OperationList200ResponseSchema defines model for OperationList200Response.
type OperationList200ResponseSchema struct {
	Operations *[]KubernetesOperation `json:"operations,omitempty"`
}

// OperationResponseSchema defines model for OperationResponse.
type OperationResponseSchema = Operation

// OperationsResponseSchema defines model for OperationsResponse.
type OperationsResponseSchema = Operations

// PatchUserState200ResponseSchema defines model for PatchUserState200Response.
type PatchUserState200ResponseSchema = UserEdited

// ReadAdminPasswordResponseSchema defines model for ReadAdminPasswordResponse.
type ReadAdminPasswordResponseSchema = ReadAdminPassword

// ReadClientGatewaysByIdResponseSchema Information about the client gateway.
type ReadClientGatewaysByIdResponseSchema = ClientGateway

// ReadClientGatewaysResponseSchema defines model for ReadClientGatewaysResponse.
type ReadClientGatewaysResponseSchema = ReadClientGateways

// ReadConsoleOutputResponseSchema defines model for ReadConsoleOutputResponse.
type ReadConsoleOutputResponseSchema = ReadConsoleOutput

// ReadDhcpOptionsByIdResponseSchema Information about the DHCP options set.
type ReadDhcpOptionsByIdResponseSchema = DhcpOptionsSet

// ReadDhcpOptionsResponseSchema defines model for ReadDhcpOptionsResponse.
type ReadDhcpOptionsResponseSchema = ReadDhcpOptions

// ReadFlexibleGpusByIdResponseSchema Information about the flexible GPU (fGPU).
type ReadFlexibleGpusByIdResponseSchema = FlexibleGpu

// ReadFlexibleGpusResponseSchema defines model for ReadFlexibleGpusResponse.
type ReadFlexibleGpusResponseSchema = ReadFlexibleGpus

// ReadImagesByIdResponseSchema Information about the OMI.
type ReadImagesByIdResponseSchema = Image

// ReadImagesResponseSchema defines model for ReadImagesResponse.
type ReadImagesResponseSchema = ReadImages

// ReadInternetGatewaysByIdResponseSchema Information about the Internet gateway.
type ReadInternetGatewaysByIdResponseSchema = InternetGateway

// ReadInternetGatewaysResponseSchema defines model for ReadInternetGatewaysResponse.
type ReadInternetGatewaysResponseSchema = ReadInternetGateways

// ReadKeypairsByIdResponseSchema Information about the keypair.
type ReadKeypairsByIdResponseSchema = ReadKeypairsById

// ReadKeypairsResponseSchema defines model for ReadKeypairsResponse.
type ReadKeypairsResponseSchema = ReadKeypairs

// ReadListenerRulesByIdResponseSchema Information about the listener rule.
type ReadListenerRulesByIdResponseSchema = ListenerRule

// ReadListenerRulesResponseSchema defines model for ReadListenerRulesResponse.
type ReadListenerRulesResponseSchema = ReadListenerRules

// ReadLoadBalancerTagsResponseSchema defines model for ReadLoadBalancerTagsResponse.
type ReadLoadBalancerTagsResponseSchema = ReadLoadBalancerTags

// ReadLoadBalancersByIdResponseSchema Information about the load balancer.
type ReadLoadBalancersByIdResponseSchema = LoadBalancer

// ReadLoadBalancersResponseSchema defines model for ReadLoadBalancersResponse.
type ReadLoadBalancersResponseSchema = ReadLoadBalancers

// ReadNatGatewayByIdResponseSchema Information about the NAT gateway.
type ReadNatGatewayByIdResponseSchema = NatGateway

// ReadNatGatewayResponseSchema defines model for ReadNatGatewayResponse.
type ReadNatGatewayResponseSchema = ReadNatGateway

// ReadNicsByIdResponseSchema Information about the NIC.
type ReadNicsByIdResponseSchema = Nic

// ReadNicsResponseSchema defines model for ReadNicsResponse.
type ReadNicsResponseSchema = ReadNics

// ReadPublicIpRangesResponseSchema defines model for ReadPublicIpRangesResponse.
type ReadPublicIpRangesResponseSchema = ReadPublicIpRanges

// ReadPublicIpsByIdResponseSchema Information about the public IP.
type ReadPublicIpsByIdResponseSchema = PublicIp

// ReadPublicIpsResponseSchema defines model for ReadPublicIpsResponse.
type ReadPublicIpsResponseSchema = ReadPublicIps

// ReadRouteTablesByIdResponseSchema Information about the route table.
type ReadRouteTablesByIdResponseSchema = RouteTable

// ReadRouteTablesResponseSchema defines model for ReadRouteTablesResponse.
type ReadRouteTablesResponseSchema = ReadRouteTables

// ReadSecurityGroupsByIdResponseSchema Information about the security group.
type ReadSecurityGroupsByIdResponseSchema = SecurityGroup

// ReadSecurityGroupsResponseSchema defines model for ReadSecurityGroupsResponse.
type ReadSecurityGroupsResponseSchema = ReadSecurityGroups

// ReadServerCertificatesResponseSchema defines model for ReadServerCertificatesResponse.
type ReadServerCertificatesResponseSchema = ReadServerCertificates

// ReadSnapshotsByIdResponseSchema Information about the snapshot.
type ReadSnapshotsByIdResponseSchema = Snapshot

// ReadSnapshotsResponseSchema defines model for ReadSnapshotsResponse.
type ReadSnapshotsResponseSchema = ReadSnapshots

// ReadSubnetsByIdResponseSchema Information about the Subnet.
type ReadSubnetsByIdResponseSchema = Subnet

// ReadSubnetsResponseSchema defines model for ReadSubnetsResponse.
type ReadSubnetsResponseSchema = ReadSubnets

// ReadTagsResponseSchema defines model for ReadTagsResponse.
type ReadTagsResponseSchema = ReadTags

// ReadVirtualGatewaysByIdResponseSchema Information about the virtual gateway.
type ReadVirtualGatewaysByIdResponseSchema = VirtualGateway

// ReadVirtualGatewaysResponseSchema defines model for ReadVirtualGatewaysResponse.
type ReadVirtualGatewaysResponseSchema = ReadVirtualGateways

// ReadVmsByIdResponseSchema Information about the VM.
type ReadVmsByIdResponseSchema = Vm

// ReadVmsHealthResponseSchema defines model for ReadVmsHealthResponse.
type ReadVmsHealthResponseSchema = ReadVmsHealth

// ReadVmsResponseSchema defines model for ReadVmsResponse.
type ReadVmsResponseSchema = ReadVms

// ReadVmsStateResponseSchema defines model for ReadVmsStateResponse.
type ReadVmsStateResponseSchema = ReadVmsState

// ReadVolumesByIdResponseSchema Information about the volume.
type ReadVolumesByIdResponseSchema = Volume

// ReadVolumesResponseSchema defines model for ReadVolumesResponse.
type ReadVolumesResponseSchema = ReadVolumes

// ReadVpcPeeringsByIdResponseSchema Information about the Vpc peering.
type ReadVpcPeeringsByIdResponseSchema = VpcPeering

// ReadVpcPeeringsResponseSchema defines model for ReadVpcPeeringsResponse.
type ReadVpcPeeringsResponseSchema = ReadVpcPeerings

// ReadVpcsByIdResponseSchema Information about the Vpc.
type ReadVpcsByIdResponseSchema = Vpc

// ReadVpcsResponseSchema defines model for ReadVpcsResponse.
type ReadVpcsResponseSchema = ReadVpcs

// ReadVpnConnectionsByIdResponseSchema Information about a VPN connection.
type ReadVpnConnectionsByIdResponseSchema = VpnConnection

// ReadVpnConnectionsResponseSchema defines model for ReadVpnConnectionsResponse.
type ReadVpnConnectionsResponseSchema = ReadVpnConnections

// RecoverUser200ResponseSchema defines model for RecoverUser200Response.
type RecoverUser200ResponseSchema = RecoveryLink

// StartVmResponseSchema Information about the state of the VM.
type StartVmResponseSchema = VmState

// StopVmResponseSchema Information about the state of the VM.
type StopVmResponseSchema = VmState

// TokenResponseSchema defines model for TokenResponse.
type TokenResponseSchema = TokenResp

// UpdateFlexibleGpuResponseSchema Information about the flexible GPU (fGPU).
type UpdateFlexibleGpuResponseSchema = FlexibleGpu

// UpdateImageResponseSchema Information about the OMI.
type UpdateImageResponseSchema = Image

// UpdateListenerRuleResponseSchema Information about the listener rule.
type UpdateListenerRuleResponseSchema = ListenerRule

// UpdateLoadBalancerResponseSchema Information about the load balancer.
type UpdateLoadBalancerResponseSchema = LoadBalancer

// UpdateNicResponseSchema Information about the NIC.
type UpdateNicResponseSchema = Nic

// UpdateNodeCountResponseSchema defines model for UpdateNodeCountResponse.
type UpdateNodeCountResponseSchema = RespUpdateNodepool

// UpdateRouteResponseSchema Information about the route table.
type UpdateRouteResponseSchema = RouteTable

// UpdateRouteTableRoutePropagationResponseSchema Information about the route table.
type UpdateRouteTableRoutePropagationResponseSchema = RouteTable

// UpdateServerCertificateResponseSchema Information about the VPN options.
type UpdateServerCertificateResponseSchema = ServerCertificate

// UpdateServiceAccount200ResponseSchema defines model for UpdateServiceAccount200Response.
type UpdateServiceAccount200ResponseSchema = ServiceAccountEdited

// UpdateSubnetResponseSchema Information about the Subnet.
type UpdateSubnetResponseSchema = Subnet

// UpdateUser200ResponseSchema defines model for UpdateUser200Response.
type UpdateUser200ResponseSchema = UserModified

// UpdateVmResponseSchema Information about the VM.
type UpdateVmResponseSchema = Vm

// UpdateVolumeResponseSchema Information about the volume.
type UpdateVolumeResponseSchema = Volume

// UpdateVpcResponseSchema Information about the Vpc.
type UpdateVpcResponseSchema = Vpc

// UpdateVpnConnectionResponseSchema Information about a VPN connection.
type UpdateVpnConnectionResponseSchema = VpnConnection

// VersionsResponseSchema defines model for VersionsResponse.
type VersionsResponseSchema = ListVersions

// WebAuthnJavaScriptResponseSchema defines model for WebAuthnJavaScriptResponse.
type WebAuthnJavaScriptResponseSchema = WebAuthnJavaScript

// AddRolePermissionsRequest defines model for AddRolePermissionsRequest.
type AddRolePermissionsRequest = RolePermission

// ClusterConfigurationRequest defines model for ClusterConfigurationRequest.
type ClusterConfigurationRequest = KubernetesClusterConfiguration

// CreateClientGatewayRequest defines model for CreateClientGatewayRequest.
type CreateClientGatewayRequest = CreateClientGateway

// CreateClusterRequest defines model for CreateClusterRequest.
type CreateClusterRequest = CreateCluster

// CreateDhcpOptionsRequest defines model for CreateDhcpOptionsRequest.
type CreateDhcpOptionsRequest = CreateDhcpOptions

// CreateFlexibleGpuRequest defines model for CreateFlexibleGpuRequest.
type CreateFlexibleGpuRequest = CreateFlexibleGpu

// CreateImageRequest defines model for CreateImageRequest.
type CreateImageRequest = CreateImage

// CreateKeypairRequest defines model for CreateKeypairRequest.
type CreateKeypairRequest struct {
	// Name A unique name for the keypair, with a maximum length of 255 [ASCII printable characters](https://en.wikipedia.org/wiki/ASCII#Printable_characters).
	Name string `json:"name"`

	// PublicKey The public key to import in your account, if you are importing an existing keypair. This value must be Base64-encoded.
	PublicKey *string `json:"publicKey,omitempty"`
}

// CreateListenerRuleRequest defines model for CreateListenerRuleRequest.
type CreateListenerRuleRequest = CreateListenerRule

// CreateLoadBalancerListenersRequest defines model for CreateLoadBalancerListenersRequest.
type CreateLoadBalancerListenersRequest = CreateLoadBalancerListeners

// CreateLoadBalancerPolicyRequest defines model for CreateLoadBalancerPolicyRequest.
type CreateLoadBalancerPolicyRequest = CreateLoadBalancerPolicy

// CreateLoadBalancerRequest defines model for CreateLoadBalancerRequest.
type CreateLoadBalancerRequest = CreateLoadBalancer

// CreateLoadBalancerTagsRequest defines model for CreateLoadBalancerTagsRequest.
type CreateLoadBalancerTagsRequest = CreateLoadBalancerTags

// CreateNatGatewayRequest defines model for CreateNatGatewayRequest.
type CreateNatGatewayRequest = CreateNatGateway

// CreateNicRequest defines model for CreateNicRequest.
type CreateNicRequest = CreateNic

// CreateNodepoolRequest defines model for CreateNodepoolRequest.
type CreateNodepoolRequest = CreateNodepool

// CreateRoleRequest A role, linked to 1 or more permissions
type CreateRoleRequest = Role

// CreateRouteRequest defines model for CreateRouteRequest.
type CreateRouteRequest = CreateRoute

// CreateRouteTableRequest defines model for CreateRouteTableRequest.
type CreateRouteTableRequest = CreateRouteTable

// CreateSecurityGroupRequest defines model for CreateSecurityGroupRequest.
type CreateSecurityGroupRequest = CreateSecurityGroup

// CreateSecurityGroupRuleRequest defines model for CreateSecurityGroupRuleRequest.
type CreateSecurityGroupRuleRequest = CreateSecurityGroupRule

// CreateServerCertificateRequest defines model for CreateServerCertificateRequest.
type CreateServerCertificateRequest = CreateServerCertificate

// CreateServiceAccountRequest defines model for CreateServiceAccountRequest.
type CreateServiceAccountRequest = ServiceAccount

// CreateSnapshotRequest defines model for CreateSnapshotRequest.
type CreateSnapshotRequest = CreateSnapshot

// CreateSpaceRequest defines model for CreateSpaceRequest.
type CreateSpaceRequest = CreateSpace

// CreateSubnetRequest defines model for CreateSubnetRequest.
type CreateSubnetRequest = CreateSubnet

// CreateTagsRequest defines model for CreateTagsRequest.
type CreateTagsRequest = CreateTags

// CreateUserRequest defines model for CreateUserRequest.
type CreateUserRequest = User

// CreateVirtualGatewayRequest defines model for CreateVirtualGatewayRequest.
type CreateVirtualGatewayRequest = CreateVirtualGateway

// CreateVmsRequest defines model for CreateVmsRequest.
type CreateVmsRequest = CreateVms

// CreateVolumeRequest defines model for CreateVolumeRequest.
type CreateVolumeRequest = CreateVolume

// CreateVpcPeeringRequest defines model for CreateVpcPeeringRequest.
type CreateVpcPeeringRequest = CreateVpcPeering

// CreateVpcRequest defines model for CreateVpcRequest.
type CreateVpcRequest = CreateVpc

// CreateVpnConnectionRequest defines model for CreateVpnConnectionRequest.
type CreateVpnConnectionRequest = CreateVpnConnection

// CreateVpnConnectionRouteRequest defines model for CreateVpnConnectionRouteRequest.
type CreateVpnConnectionRouteRequest = CreateVpnConnectionRoute

// DeleteACLRequest List of ACLs.
type DeleteACLRequest = ACLList

// DeleteLoadBalancerListenersRequest defines model for DeleteLoadBalancerListenersRequest.
type DeleteLoadBalancerListenersRequest = DeleteLoadBalancerListeners

// DeleteLoadBalancerPolicyRequest defines model for DeleteLoadBalancerPolicyRequest.
type DeleteLoadBalancerPolicyRequest = DeleteLoadBalancerPolicy

// DeleteLoadBalancerTagsRequest defines model for DeleteLoadBalancerTagsRequest.
type DeleteLoadBalancerTagsRequest = DeleteLoadBalancerTags

// DeleteRouteRequest defines model for DeleteRouteRequest.
type DeleteRouteRequest = DeleteRoute

// DeleteSecurityGroupRuleRequest defines model for DeleteSecurityGroupRuleRequest.
type DeleteSecurityGroupRuleRequest = DeleteSecurityGroupRule

// DeleteTagsRequest defines model for DeleteTagsRequest.
type DeleteTagsRequest = DeleteTags

// DeleteVpnConnectionRouteRequest defines model for DeleteVpnConnectionRouteRequest.
type DeleteVpnConnectionRouteRequest = DeleteVpnConnectionRoute

// LinkFlexibleGpuRequest defines model for LinkFlexibleGpuRequest.
type LinkFlexibleGpuRequest = LinkFlexibleGpu

// LinkInternetGatewayRequest defines model for LinkInternetGatewayRequest.
type LinkInternetGatewayRequest = LinkInternetGateway

// LinkLoadBalancerBackendMachinesRequest defines model for LinkLoadBalancerBackendMachinesRequest.
type LinkLoadBalancerBackendMachinesRequest = LinkLoadBalancerBackendMachines

// LinkNicRequest defines model for LinkNicRequest.
type LinkNicRequest struct {
	// DeviceNumber The index of the VM device for the NIC attachment (between `1` and `7`, both included).
	DeviceNumber int `json:"deviceNumber"`

	// VmId The ID of the VM to which you want to attach the NIC.
	VmId string `json:"vmId"`
}

// LinkPrivateIpsRequest defines model for LinkPrivateIpsRequest.
type LinkPrivateIpsRequest = LinkPrivateIps

// LinkPublicIpRequest defines model for LinkPublicIpRequest.
type LinkPublicIpRequest struct {
	// AllowRelink If true, allows the public IP to be associated with the VM or NIC that you specify even if it is already associated with another VM or NIC. If false, prevents the public IP from being associated with the VM or NIC that you specify if it is already associated with another VM or NIC. (By default, true in the public Cloud, false in a Vpc.)
	AllowRelink *bool `json:"allowRelink,omitempty"`

	// NicId (Vpc only) The ID of the NIC. This parameter is required if the VM has more than one NIC attached. Otherwise, you need to specify the `VmId` parameter instead. You cannot specify both parameters at the same time.
	NicId *string `json:"nicId,omitempty"`

	// PrivateIp (Vpc only) The primary or secondary private IP of the specified NIC. By default, the primary private IP.
	PrivateIp *string `json:"privateIp,omitempty"`

	// VmId The ID of the VM.<br />
	// - In the public Cloud, this parameter is required.<br />
	// - In a Vpc, this parameter is required if the VM has only one NIC. Otherwise, you need to specify the `NicId` parameter instead. You cannot specify both parameters at the same time.
	VmId *string `json:"vmId,omitempty"`
}

// LinkRouteTableRequest defines model for LinkRouteTableRequest.
type LinkRouteTableRequest struct {
	// SubnetId The ID of the Subnet.
	SubnetId string `json:"subnetId"`
}

// LinkVirtualGatewayToVpcRequest defines model for LinkVirtualGatewayToVpcRequest.
type LinkVirtualGatewayToVpcRequest struct {
	// VpcId The ID of the Vpc to which you want to attach the virtual gateway.
	VpcId string `json:"vpcId"`
}

// LinkVolumeRequest defines model for LinkVolumeRequest.
type LinkVolumeRequest = LinkVolume

// ListIdentitiesByAccessRequest defines model for ListIdentitiesByAccessRequest.
type ListIdentitiesByAccessRequest = IdentitiesIdsList

// ListSpaceIdsRequest defines model for ListSpaceIdsRequest.
type ListSpaceIdsRequest = SpaceIdsList

// NodeOrderRequest defines model for NodeOrderRequest.
type NodeOrderRequest = KubernetesNodeOrder

// NodeRemoveRequest defines model for NodeRemoveRequest.
type NodeRemoveRequest = KubernetesNodeRemoval

// NodeUpgradeRequest defines model for NodeUpgradeRequest.
type NodeUpgradeRequest = KubernetesNodeUpgrade

// PatchUserStateRequest defines model for PatchUserStateRequest.
type PatchUserStateRequest = UserState

// ReadLoadBalancerTagsRequest defines model for ReadLoadBalancerTagsRequest.
type ReadLoadBalancerTagsRequest struct {
	// Names One or more load balancer names.
	Names []string `json:"names"`
}

// ReadVmsHealthRequest defines model for ReadVmsHealthRequest.
type ReadVmsHealthRequest struct {
	// BackendVmIds One or more IDs of back-end VMs.
	BackendVmIds *[]string `json:"backendVmIds,omitempty"`
}

// RemoveRolePermissionsRequest defines model for RemoveRolePermissionsRequest.
type RemoveRolePermissionsRequest = RolePermission

// SetACLRequest List of ACLs.
type SetACLRequest = ACLList

// SetIAMGranularPolicyRequest Defines the structure for modification instructions for roles and permissions
type SetIAMGranularPolicyRequest struct {
	Add    *GranularPolicyList `json:"add,omitempty"`
	Delete *GranularPolicyList `json:"delete,omitempty"`
}

// SetIAMPolicyRequest Defines the structure for modification instructions for roles and permissions
type SetIAMPolicyRequest struct {
	Add    *IAMPolicy `json:"add,omitempty"`
	Delete *IAMPolicy `json:"delete,omitempty"`
}

// StopVmRequest defines model for StopVmRequest.
type StopVmRequest = StopVm

// UnlinkInternetGatewayRequest defines model for UnlinkInternetGatewayRequest.
type UnlinkInternetGatewayRequest = UnlinkInternetGateway

// UnlinkLoadBalancerBackendMachinesRequest defines model for UnlinkLoadBalancerBackendMachinesRequest.
type UnlinkLoadBalancerBackendMachinesRequest = UnlinkLoadBalancerBackendMachines

// UnlinkNicRequest defines model for UnlinkNicRequest.
type UnlinkNicRequest = UnlinkNic

// UnlinkPrivateIpsRequest defines model for UnlinkPrivateIpsRequest.
type UnlinkPrivateIpsRequest = UnlinkPrivateIps

// UnlinkPublicIpRequest defines model for UnlinkPublicIpRequest.
type UnlinkPublicIpRequest = UnlinkPublicIp

// UnlinkRouteTableRequest defines model for UnlinkRouteTableRequest.
type UnlinkRouteTableRequest = UnlinkRouteTable

// UnlinkVirtualGatewayToVpcRequest defines model for UnlinkVirtualGatewayToVpcRequest.
type UnlinkVirtualGatewayToVpcRequest = UnlinkVirtualGatewayToVpc

// UnlinkVolumeRequest defines model for UnlinkVolumeRequest.
type UnlinkVolumeRequest = UnlinkVolume

// UpdateClusterRequest defines model for UpdateClusterRequest.
type UpdateClusterRequest = UpdateCluster

// UpdateFlexibleGpuRequest defines model for UpdateFlexibleGpuRequest.
type UpdateFlexibleGpuRequest = UpdateFlexibleGpu

// UpdateImageRequest defines model for UpdateImageRequest.
type UpdateImageRequest = UpdateImage

// UpdateListenerRuleRequest defines model for UpdateListenerRuleRequest.
type UpdateListenerRuleRequest = UpdateListenerRule

// UpdateLoadBalancerRequest defines model for UpdateLoadBalancerRequest.
type UpdateLoadBalancerRequest = UpdateLoadBalancer

// UpdateNicRequest defines model for UpdateNicRequest.
type UpdateNicRequest = UpdateNic

// UpdateNodepoolRequest defines model for UpdateNodepoolRequest.
type UpdateNodepoolRequest = ReqUpdateNodepool

// UpdateRoleRequest defines model for UpdateRoleRequest.
type UpdateRoleRequest struct {
	// Description Human-readable description
	Description *string `json:"description,omitempty"`

	// Name Human-readable name
	Name *string `json:"name,omitempty"`
}

// UpdateRouteRequest defines model for UpdateRouteRequest.
type UpdateRouteRequest = UpdateRoute

// UpdateRouteTableRoutePropagationRequest defines model for UpdateRouteTableRoutePropagationRequest.
type UpdateRouteTableRoutePropagationRequest = UpdateRouteTableRoutePropagation

// UpdateServerCertificateRequest defines model for UpdateServerCertificateRequest.
type UpdateServerCertificateRequest = UpdateServerCertificate

// UpdateServiceAccountRequest defines model for UpdateServiceAccountRequest.
type UpdateServiceAccountRequest = ServiceAccount

// UpdateSpaceRequest defines model for UpdateSpaceRequest.
type UpdateSpaceRequest = MutableSpace

// UpdateSubnetRequest defines model for UpdateSubnetRequest.
type UpdateSubnetRequest = UpdateSubnet

// UpdateUserRequest defines model for UpdateUserRequest.
type UpdateUserRequest = UserUpdate

// UpdateVmRequest defines model for UpdateVmRequest.
type UpdateVmRequest = UpdateVm

// UpdateVolumeRequest defines model for UpdateVolumeRequest.
type UpdateVolumeRequest = UpdateVolume

// UpdateVpcRequest defines model for UpdateVpcRequest.
type UpdateVpcRequest = UpdateVpc

// UpdateVpnConnectionRequest defines model for UpdateVpnConnectionRequest.
type UpdateVpnConnectionRequest = UpdateVpnConnection

// ReadClientGatewaysParams defines parameters for ReadClientGateways.
type ReadClientGatewaysParams struct {
	// BgpAsns The Border Gateway Protocol (BGP) Autonomous System Numbers (ASNs) of the connections.
	BgpAsns *[]int `form:"bgpAsns,omitempty" json:"bgpAsns,omitempty"`

	// ConnectionTypes The types of communication tunnels used by the client gateways (only `ipsec.1` is supported).
	ConnectionTypes *[]string `form:"connectionTypes,omitempty" json:"connectionTypes,omitempty"`

	// PublicIps The public IPv4 addresses of the client gateways.
	PublicIps *[]string `form:"publicIps,omitempty" json:"publicIps,omitempty"`

	// States The states of the client gateways (`pending` \| `available` \| `deleting` \| `deleted`).
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// TagKeys The keys of the tags associated with the client gateways.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the client gateways.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the client gateways, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// Ids The IDs of the client gateways.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`
}

// ReadDhcpOptionsParams defines parameters for ReadDhcpOptions.
type ReadDhcpOptionsParams struct {
	// Default If true, lists all default DHCP options set. If false, lists all non-default DHCP options set.
	Default *bool `form:"default,omitempty" json:"default,omitempty"`

	// DomainNameServers The IPs of the domain name servers used for the DHCP options sets.
	DomainNameServers *[]string `form:"domainNameServers,omitempty" json:"domainNameServers,omitempty"`

	// DomainNames The domain names used for the DHCP options sets.
	DomainNames *[]string `form:"domainNames,omitempty" json:"domainNames,omitempty"`

	// LogServers The IPs of the log servers used for the DHCP options sets.
	LogServers *[]string `form:"logServers,omitempty" json:"logServers,omitempty"`

	// NtpServers The IPs of the Network Time Protocol (NTP) servers used for the DHCP options sets.
	NtpServers *[]string `form:"ntpServers,omitempty" json:"ntpServers,omitempty"`

	// TagKeys The keys of the tags associated with the DHCP options sets.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the DHCP options sets.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the DHCP options sets, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// Ids The IDs of the DHCP options sets.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`
}

// ReadFlexibleGpusParams defines parameters for ReadFlexibleGpus.
type ReadFlexibleGpusParams struct {
	// DeleteOnVmDeletion Indicates whether the fGPU is deleted when terminating the VM.
	DeleteOnVmDeletion *bool `form:"deleteOnVmDeletion,omitempty" json:"deleteOnVmDeletion,omitempty"`

	// Generations The processor generations that the fGPUs are compatible with.
	Generations *[]string `form:"generations,omitempty" json:"generations,omitempty"`

	// ModelNames One or more models of fGPUs.
	ModelNames *[]string `form:"modelNames,omitempty" json:"modelNames,omitempty"`

	// States The states of the fGPUs (`allocated` \| `attaching` \| `attached` \| `detaching`).
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// VmIds One or more IDs of VMs.
	VmIds *[]string `form:"vmIds,omitempty" json:"vmIds,omitempty"`

	// AvailabilityZoneNames The Subregions where the fGPUs are located.
	AvailabilityZoneNames *[]string `form:"availabilityZoneNames,omitempty" json:"availabilityZoneNames,omitempty"`

	// Ids One or more IDs of fGPUs.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`
}

// ReadImagesParams defines parameters for ReadImages.
type ReadImagesParams struct {
	// AccountAliases The account aliases of the owners of the OMIs.
	AccountAliases *[]string `form:"accountAliases,omitempty" json:"accountAliases,omitempty"`

	// Architectures The architectures of the OMIs (`i386` \| `x86_64`).
	Architectures *[]string `form:"architectures,omitempty" json:"architectures,omitempty"`

	// BlockDeviceMappingDeleteOnVmDeletion Whether the volumes are deleted or not when terminating the VM.
	BlockDeviceMappingDeleteOnVmDeletion *bool `form:"blockDeviceMappingDeleteOnVmDeletion,omitempty" json:"blockDeviceMappingDeleteOnVmDeletion,omitempty"`

	// BlockDeviceMappingDeviceNames The device names for the volumes.
	BlockDeviceMappingDeviceNames *[]string `form:"blockDeviceMappingDeviceNames,omitempty" json:"blockDeviceMappingDeviceNames,omitempty"`

	// BlockDeviceMappingSnapshotIds The IDs of the snapshots used to create the volumes.
	BlockDeviceMappingSnapshotIds *[]string `form:"blockDeviceMappingSnapshotIds,omitempty" json:"blockDeviceMappingSnapshotIds,omitempty"`

	// BlockDeviceMappingVolumeSizes The sizes of the volumes, in gibibytes (GiB).
	BlockDeviceMappingVolumeSizes *[]int `form:"blockDeviceMappingVolumeSizes,omitempty" json:"blockDeviceMappingVolumeSizes,omitempty"`

	// BlockDeviceMappingVolumeTypes The types of volumes (`standard` \| `gp2` \| `io1`).
	BlockDeviceMappingVolumeTypes *[]string `form:"blockDeviceMappingVolumeTypes,omitempty" json:"blockDeviceMappingVolumeTypes,omitempty"`

	// Descriptions The descriptions of the OMIs, provided when they were created.
	Descriptions *[]string `form:"descriptions,omitempty" json:"descriptions,omitempty"`

	// FileLocations The locations of the buckets where the OMI files are stored.
	FileLocations *[]string `form:"fileLocations,omitempty" json:"fileLocations,omitempty"`

	// Hypervisors The hypervisor type of the OMI (always `xen`).
	Hypervisors *[]string `form:"hypervisors,omitempty" json:"hypervisors,omitempty"`

	// ImageNames The names of the OMIs, provided when they were created.
	ImageNames *[]string `form:"imageNames,omitempty" json:"imageNames,omitempty"`

	// ProductCodeNames The names of the product codes associated with the OMI.
	ProductCodeNames *[]string `form:"productCodeNames,omitempty" json:"productCodeNames,omitempty"`

	// ProductCodes The product codes associated with the OMI.
	ProductCodes *[]string `form:"productCodes,omitempty" json:"productCodes,omitempty"`

	// RootDeviceNames The name of the root device. This value must be /dev/sda1.
	RootDeviceNames *[]string `form:"rootDeviceNames,omitempty" json:"rootDeviceNames,omitempty"`

	// RootDeviceTypes The types of root device used by the OMIs (`bsu` or `ebs`).
	RootDeviceTypes *[]string `form:"rootDeviceTypes,omitempty" json:"rootDeviceTypes,omitempty"`

	// States The states of the OMIs (`pending` \| `available` \| `failed`).
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// TagKeys The keys of the tags associated with the OMIs.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the OMIs.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the OMIs, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// VirtualizationTypes The virtualization types (always `hvm`).
	VirtualizationTypes *[]string `form:"virtualizationTypes,omitempty" json:"virtualizationTypes,omitempty"`

	// Ids The IDs of the OMIs.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`

	// IsPublic If true, lists all public OMIs. If false, lists all private OMIs.
	IsPublic *bool `form:"isPublic,omitempty" json:"isPublic,omitempty"`
}

// ReadInternetGatewaysParams defines parameters for ReadInternetGateways.
type ReadInternetGatewaysParams struct {
	// LinkStates The current states of the attachments between the Internet gateways and the Vpcs (only `available`, if the Internet gateway is attached to a Vpc).
	LinkStates *[]string `form:"linkStates,omitempty" json:"linkStates,omitempty"`

	// TagKeys The keys of the tags associated with the Internet gateways.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the Internet gateways.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the Internet gateways, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// LinkVpcIds The IDs of the Vpcs the Internet gateways are attached to.
	LinkVpcIds *[]string `form:"linkVpcIds,omitempty" json:"linkVpcIds,omitempty"`

	// Ids The IDs of the Internet gateways.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`
}

// ReadKeypairsParams defines parameters for ReadKeypairs.
type ReadKeypairsParams struct {
	// KeypairFingerprints The fingerprints of the keypairs.
	KeypairFingerprints *[]string `form:"keypairFingerprints,omitempty" json:"keypairFingerprints,omitempty"`

	// KeypairNames The names of the keypairs.
	KeypairNames *[]string `form:"keypairNames,omitempty" json:"keypairNames,omitempty"`

	// KeypairTypes The types of the keypairs (`ssh-rsa`, `ssh-ed25519`, `ecdsa-sha2-nistp256`, `ecdsa-sha2-nistp384`, or `ecdsa-sha2-nistp521`).
	KeypairTypes *[]string `form:"keypairTypes,omitempty" json:"keypairTypes,omitempty"`
}

// CreateKeypairJSONBody defines parameters for CreateKeypair.
type CreateKeypairJSONBody struct {
	// Name A unique name for the keypair, with a maximum length of 255 [ASCII printable characters](https://en.wikipedia.org/wiki/ASCII#Printable_characters).
	Name string `json:"name"`

	// PublicKey The public key to import in your account, if you are importing an existing keypair. This value must be Base64-encoded.
	PublicKey *string `json:"publicKey,omitempty"`
}

// ReadListenerRulesParams defines parameters for ReadListenerRules.
type ReadListenerRulesParams struct {
	// ListenerRuleNames The names of the listener rules.
	ListenerRuleNames *[]string `form:"listenerRuleNames,omitempty" json:"listenerRuleNames,omitempty"`
}

// ReadLoadBalancersParams defines parameters for ReadLoadBalancers.
type ReadLoadBalancersParams struct {
	// LoadBalancerNames The names of the load balancers.
	LoadBalancerNames *[]string `form:"loadBalancerNames,omitempty" json:"loadBalancerNames,omitempty"`
}

// ReadVmsHealthJSONBody defines parameters for ReadVmsHealth.
type ReadVmsHealthJSONBody struct {
	// BackendVmIds One or more IDs of back-end VMs.
	BackendVmIds *[]string `json:"backendVmIds,omitempty"`
}

// ReadLoadBalancerTagsJSONBody defines parameters for ReadLoadBalancerTags.
type ReadLoadBalancerTagsJSONBody struct {
	// Names One or more load balancer names.
	Names []string `json:"names"`
}

// ReadNatGatewayParams defines parameters for ReadNatGateway.
type ReadNatGatewayParams struct {
	// States The states of the NAT gateways (`pending` \| `available` \| `deleting` \| `deleted`).
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// SubnetIds The IDs of the Subnets in which the NAT gateways are.
	SubnetIds *[]string `form:"subnetIds,omitempty" json:"subnetIds,omitempty"`

	// TagKeys The keys of the tags associated with the NAT gateways.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the NAT gateways.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the NAT gateways, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// Ids The IDs of the NAT gateways.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`

	// VpcIds The IDs of the Vpcs in which the NAT gateways are.
	VpcIds *[]string `form:"vpcIds,omitempty" json:"vpcIds,omitempty"`
}

// ReadNicsParams defines parameters for ReadNics.
type ReadNicsParams struct {
	// Descriptions The descriptions of the NICs.
	Descriptions *[]string `form:"descriptions,omitempty" json:"descriptions,omitempty"`

	// IsSourceDestCheck Whether the source/destination checking is enabled (true) or disabled (false).
	IsSourceDestCheck *bool `form:"isSourceDestCheck,omitempty" json:"isSourceDestCheck,omitempty"`

	// LinkNicDeleteOnVmDeletion Whether the NICs are deleted when the VMs they are attached to are terminated.
	LinkNicDeleteOnVmDeletion *bool `form:"linkNicDeleteOnVmDeletion,omitempty" json:"linkNicDeleteOnVmDeletion,omitempty"`

	// LinkNicDeviceNumbers The device numbers the NICs are attached to.
	LinkNicDeviceNumbers *[]int `form:"linkNicDeviceNumbers,omitempty" json:"linkNicDeviceNumbers,omitempty"`

	// LinkNicLinkNicIds The attachment IDs of the NICs.
	LinkNicLinkNicIds *[]string `form:"linkNicLinkNicIds,omitempty" json:"linkNicLinkNicIds,omitempty"`

	// LinkNicStates The states of the attachments.
	LinkNicStates *[]string `form:"linkNicStates,omitempty" json:"linkNicStates,omitempty"`

	// LinkNicVmIds The IDs of the VMs the NICs are attached to.
	LinkNicVmIds *[]string `form:"linkNicVmIds,omitempty" json:"linkNicVmIds,omitempty"`

	// LinkPublicIpLinkPublicIpIds The association IDs returned when the public IPs were associated with the NICs.
	LinkPublicIpLinkPublicIpIds *[]string `form:"linkPublicIpLinkPublicIpIds,omitempty" json:"linkPublicIpLinkPublicIpIds,omitempty"`

	// LinkPublicIpPublicIpIds The allocation IDs returned when the public IPs were allocated to their accounts.
	LinkPublicIpPublicIpIds *[]string `form:"linkPublicIpPublicIpIds,omitempty" json:"linkPublicIpPublicIpIds,omitempty"`

	// LinkPublicIpPublicIps The public IPs associated with the NICs.
	LinkPublicIpPublicIps *[]string `form:"linkPublicIpPublicIps,omitempty" json:"linkPublicIpPublicIps,omitempty"`

	// MacAddresses The Media Access Control (MAC) addresses of the NICs.
	MacAddresses *[]string `form:"macAddresses,omitempty" json:"macAddresses,omitempty"`

	// PrivateDnsNames The private DNS names associated with the primary private IPs.
	PrivateDnsNames *[]string `form:"privateDnsNames,omitempty" json:"privateDnsNames,omitempty"`

	// PrivateIpsLinkPublicIpPublicIps The public IPs associated with the private IPs.
	PrivateIpsLinkPublicIpPublicIps *[]string `form:"privateIpsLinkPublicIpPublicIps,omitempty" json:"privateIpsLinkPublicIpPublicIps,omitempty"`

	// PrivateIpsPrimaryIp Whether the private IP is the primary IP associated with the NIC.
	PrivateIpsPrimaryIp *bool `form:"privateIpsPrimaryIp,omitempty" json:"privateIpsPrimaryIp,omitempty"`

	// PrivateIpsPrivateIps The private IPs of the NICs.
	PrivateIpsPrivateIps *[]string `form:"privateIpsPrivateIps,omitempty" json:"privateIpsPrivateIps,omitempty"`

	// SecurityGroupIds The IDs of the security groups associated with the NICs.
	SecurityGroupIds *[]string `form:"securityGroupIds,omitempty" json:"securityGroupIds,omitempty"`

	// SecurityGroupNames The names of the security groups associated with the NICs.
	SecurityGroupNames *[]string `form:"securityGroupNames,omitempty" json:"securityGroupNames,omitempty"`

	// States The states of the NICs.
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// SubnetIds The IDs of the Subnets for the NICs.
	SubnetIds *[]string `form:"subnetIds,omitempty" json:"subnetIds,omitempty"`

	// TagKeys The keys of the tags associated with the NICs.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the NICs.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the NICs, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// VpcIds The IDs of the Vpcs where the NICs are located.
	VpcIds *[]string `form:"vpcIds,omitempty" json:"vpcIds,omitempty"`

	// Ids The IDs of the NICs.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`

	// AvailabilityZoneNames The Subregions where the NICs are located.
	AvailabilityZoneNames *[]string `form:"availabilityZoneNames,omitempty" json:"availabilityZoneNames,omitempty"`
}

// LinkNicJSONBody defines parameters for LinkNic.
type LinkNicJSONBody struct {
	// DeviceNumber The index of the VM device for the NIC attachment (between `1` and `7`, both included).
	DeviceNumber int `json:"deviceNumber"`

	// VmId The ID of the VM to which you want to attach the NIC.
	VmId string `json:"vmId"`
}

// ReadPublicIpsParams defines parameters for ReadPublicIps.
type ReadPublicIpsParams struct {
	// LinkPublicIpIds The IDs representing the associations of public IPs with VMs or NICs.
	LinkPublicIpIds *[]string `form:"linkPublicIpIds,omitempty" json:"linkPublicIpIds,omitempty"`

	// NicIds The IDs of the NICs.
	NicIds *[]string `form:"nicIds,omitempty" json:"nicIds,omitempty"`

	// PrivateIps The private IPs associated with the public IPs.
	PrivateIps *[]string `form:"privateIps,omitempty" json:"privateIps,omitempty"`

	// TagKeys The keys of the tags associated with the public IPs.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the public IPs.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the public IPs, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// VmIds The IDs of the VMs.
	VmIds *[]string `form:"vmIds,omitempty" json:"vmIds,omitempty"`

	// Ids The IDs of the public IPs.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`
}

// LinkPublicIpJSONBody defines parameters for LinkPublicIp.
type LinkPublicIpJSONBody struct {
	// AllowRelink If true, allows the public IP to be associated with the VM or NIC that you specify even if it is already associated with another VM or NIC. If false, prevents the public IP from being associated with the VM or NIC that you specify if it is already associated with another VM or NIC. (By default, true in the public Cloud, false in a Vpc.)
	AllowRelink *bool `json:"allowRelink,omitempty"`

	// NicId (Vpc only) The ID of the NIC. This parameter is required if the VM has more than one NIC attached. Otherwise, you need to specify the `VmId` parameter instead. You cannot specify both parameters at the same time.
	NicId *string `json:"nicId,omitempty"`

	// PrivateIp (Vpc only) The primary or secondary private IP of the specified NIC. By default, the primary private IP.
	PrivateIp *string `json:"privateIp,omitempty"`

	// VmId The ID of the VM.<br />
	// - In the public Cloud, this parameter is required.<br />
	// - In a Vpc, this parameter is required if the VM has only one NIC. Otherwise, you need to specify the `NicId` parameter instead. You cannot specify both parameters at the same time.
	VmId *string `json:"vmId,omitempty"`
}

// ReadRouteTablesParams defines parameters for ReadRouteTables.
type ReadRouteTablesParams struct {
	// LinkRouteTableIds The IDs of the route tables involved in the associations.
	LinkRouteTableIds *[]string `form:"linkRouteTableIds,omitempty" json:"linkRouteTableIds,omitempty"`

	// LinkRouteTableLinkRouteTableIds The IDs of the associations between the route tables and the Subnets.
	LinkRouteTableLinkRouteTableIds *[]string `form:"linkRouteTableLinkRouteTableIds,omitempty" json:"linkRouteTableLinkRouteTableIds,omitempty"`

	// LinkRouteTableMain If true, the route tables are the main ones for their Vpcs.
	LinkRouteTableMain *bool `form:"linkRouteTableMain,omitempty" json:"linkRouteTableMain,omitempty"`

	// LinkSubnetIds The IDs of the Subnets involved in the associations.
	LinkSubnetIds *[]string `form:"linkSubnetIds,omitempty" json:"linkSubnetIds,omitempty"`

	// RouteCreationMethods The methods used to create a route.
	RouteCreationMethods *[]string `form:"routeCreationMethods,omitempty" json:"routeCreationMethods,omitempty"`

	// RouteDestinationIpRanges The IP ranges specified in routes in the tables.
	RouteDestinationIpRanges *[]string `form:"routeDestinationIpRanges,omitempty" json:"routeDestinationIpRanges,omitempty"`

	// RouteDestinationServiceIds The service IDs specified in routes in the tables.
	RouteDestinationServiceIds *[]string `form:"routeDestinationServiceIds,omitempty" json:"routeDestinationServiceIds,omitempty"`

	// RouteGatewayIds The IDs of the gateways specified in routes in the tables.
	RouteGatewayIds *[]string `form:"routeGatewayIds,omitempty" json:"routeGatewayIds,omitempty"`

	// RouteStates The states of routes in the route tables (always `active`).
	RouteStates *[]string `form:"routeStates,omitempty" json:"routeStates,omitempty"`

	// RouteVmIds The IDs of the VMs specified in routes in the tables.
	RouteVmIds *[]string `form:"routeVmIds,omitempty" json:"routeVmIds,omitempty"`

	// TagKeys The keys of the tags associated with the route tables.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the route tables.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the route tables, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// VpcIds The IDs of the Vpcs for the route tables.
	VpcIds *[]string `form:"vpcIds,omitempty" json:"vpcIds,omitempty"`

	// RouteNatGatewayIds The IDs of the NAT gateways specified in routes in the tables.
	RouteNatGatewayIds *[]string `form:"routeNatGatewayIds,omitempty" json:"routeNatGatewayIds,omitempty"`

	// RouteVpcPeeringIds The IDs of the Vpc peerings specified in routes in the tables.
	RouteVpcPeeringIds *[]string `form:"routeVpcPeeringIds,omitempty" json:"routeVpcPeeringIds,omitempty"`

	// Ids The IDs of the route tables.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`
}

// LinkRouteTableJSONBody defines parameters for LinkRouteTable.
type LinkRouteTableJSONBody struct {
	// SubnetId The ID of the Subnet.
	SubnetId string `json:"subnetId"`
}

// ReadSecurityGroupsParams defines parameters for ReadSecurityGroups.
type ReadSecurityGroupsParams struct {
	// Descriptions The descriptions of the security groups.
	Descriptions *[]string `form:"descriptions,omitempty" json:"descriptions,omitempty"`

	// InboundRuleFromPortRanges The beginnings of the port ranges for the TCP and UDP protocols, or the ICMP type numbers.
	InboundRuleFromPortRanges *[]int `form:"inboundRuleFromPortRanges,omitempty" json:"inboundRuleFromPortRanges,omitempty"`

	// InboundRuleIpRanges The IP ranges that have been granted permissions, in CIDR notation (for example, `10.0.0.0/24`).
	InboundRuleIpRanges *[]string `form:"inboundRuleIpRanges,omitempty" json:"inboundRuleIpRanges,omitempty"`

	// InboundRuleProtocols The IP protocols for the permissions (`tcp` \| `udp` \| `icmp`, or a protocol number, or `-1` for all protocols).
	InboundRuleProtocols *[]string `form:"inboundRuleProtocols,omitempty" json:"inboundRuleProtocols,omitempty"`

	// InboundRuleSecurityGroupIds The IDs of the security groups that have been granted permissions.
	InboundRuleSecurityGroupIds *[]string `form:"inboundRuleSecurityGroupIds,omitempty" json:"inboundRuleSecurityGroupIds,omitempty"`

	// InboundRuleSecurityGroupNames The names of the security groups that have been granted permissions.
	InboundRuleSecurityGroupNames *[]string `form:"inboundRuleSecurityGroupNames,omitempty" json:"inboundRuleSecurityGroupNames,omitempty"`

	// InboundRuleToPortRanges The ends of the port ranges for the TCP and UDP protocols, or the ICMP code numbers.
	InboundRuleToPortRanges *[]int `form:"inboundRuleToPortRanges,omitempty" json:"inboundRuleToPortRanges,omitempty"`

	// OutboundRuleFromPortRanges The beginnings of the port ranges for the TCP and UDP protocols, or the ICMP type numbers.
	OutboundRuleFromPortRanges *[]int `form:"outboundRuleFromPortRanges,omitempty" json:"outboundRuleFromPortRanges,omitempty"`

	// OutboundRuleIpRanges The IP ranges that have been granted permissions, in CIDR notation (for example, `10.0.0.0/24`).
	OutboundRuleIpRanges *[]string `form:"outboundRuleIpRanges,omitempty" json:"outboundRuleIpRanges,omitempty"`

	// OutboundRuleProtocols The IP protocols for the permissions (`tcp` \| `udp` \| `icmp`, or a protocol number, or `-1` for all protocols).
	OutboundRuleProtocols *[]string `form:"outboundRuleProtocols,omitempty" json:"outboundRuleProtocols,omitempty"`

	// OutboundRuleSecurityGroupIds The IDs of the security groups that have been granted permissions.
	OutboundRuleSecurityGroupIds *[]string `form:"outboundRuleSecurityGroupIds,omitempty" json:"outboundRuleSecurityGroupIds,omitempty"`

	// OutboundRuleSecurityGroupNames The names of the security groups that have been granted permissions.
	OutboundRuleSecurityGroupNames *[]string `form:"outboundRuleSecurityGroupNames,omitempty" json:"outboundRuleSecurityGroupNames,omitempty"`

	// OutboundRuleToPortRanges The ends of the port ranges for the TCP and UDP protocols, or the ICMP code numbers.
	OutboundRuleToPortRanges *[]int `form:"outboundRuleToPortRanges,omitempty" json:"outboundRuleToPortRanges,omitempty"`

	// SecurityGroupIds The IDs of the security groups.
	SecurityGroupIds *[]string `form:"securityGroupIds,omitempty" json:"securityGroupIds,omitempty"`

	// SecurityGroupNames The names of the security groups.
	SecurityGroupNames *[]string `form:"securityGroupNames,omitempty" json:"securityGroupNames,omitempty"`

	// TagKeys The keys of the tags associated with the security groups.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the security groups.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the security groups, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// VpcIds The IDs of the Vpcs specified when the security groups were created.
	VpcIds *[]string `form:"vpcIds,omitempty" json:"vpcIds,omitempty"`
}

// ReadServerCertificatesParams defines parameters for ReadServerCertificates.
type ReadServerCertificatesParams struct {
	// Paths The paths to the server certificates.
	Paths *[]string `form:"paths,omitempty" json:"paths,omitempty"`
}

// ReadSnapshotsParams defines parameters for ReadSnapshots.
type ReadSnapshotsParams struct {
	// Descriptions The descriptions of the snapshots.
	Descriptions *[]string `form:"descriptions,omitempty" json:"descriptions,omitempty"`

	// FromCreationDate The beginning of the time period, in ISO 8601 date-time format (for example, `2020-06-14T00:00:00.000Z`).
	FromCreationDate *string `form:"fromCreationDate,omitempty" json:"fromCreationDate,omitempty"`

	// Progresses The progresses of the snapshots, as a percentage.
	Progresses *[]int `form:"progresses,omitempty" json:"progresses,omitempty"`

	// States The states of the snapshots (`in-queue` \| `completed` \| `error`).
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// TagKeys The keys of the tags associated with the snapshots.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the snapshots.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the snapshots, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// ToCreationDate The end of the time period, in ISO 8601 date-time format (for example, `2020-06-30T00:00:00.000Z`).
	ToCreationDate *string `form:"toCreationDate,omitempty" json:"toCreationDate,omitempty"`

	// VolumeIds The IDs of the volumes used to create the snapshots.
	VolumeIds *[]string `form:"volumeIds,omitempty" json:"volumeIds,omitempty"`

	// VolumeSizes The sizes of the volumes used to create the snapshots, in gibibytes (GiB).
	VolumeSizes *[]int `form:"volumeSizes,omitempty" json:"volumeSizes,omitempty"`

	// IsPublic If true, lists all public volumes. If false, lists all private volumes.
	IsPublic *bool `form:"isPublic,omitempty" json:"isPublic,omitempty"`

	// Ids The IDs of the snapshots.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`
}

// ReadSubnetsParams defines parameters for ReadSubnets.
type ReadSubnetsParams struct {
	// AvailableIpsCounts The number of available IPs.
	AvailableIpsCounts *[]int `form:"availableIpsCounts,omitempty" json:"availableIpsCounts,omitempty"`

	// IpRanges The IP ranges in the Subnets, in CIDR notation (for example, `10.0.0.0/16`).
	IpRanges *[]string `form:"ipRanges,omitempty" json:"ipRanges,omitempty"`

	// States The states of the Subnets (`pending` \| `available` \| `deleted`).
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// TagKeys The keys of the tags associated with the Subnets.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the Subnets.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the Subnets, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// VpcIds The IDs of the Vpcs in which the Subnets are.
	VpcIds *[]string `form:"vpcIds,omitempty" json:"vpcIds,omitempty"`

	// Ids The IDs of the Subnets.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`

	// AvailabilityZoneNames The names of the Subregions in which the Subnets are located.
	AvailabilityZoneNames *[]string `form:"availabilityZoneNames,omitempty" json:"availabilityZoneNames,omitempty"`
}

// ReadTagsParams defines parameters for ReadTags.
type ReadTagsParams struct {
	// Keys The keys of the tags that are assigned to the resources. You can use this filter alongside the `Values` filter. In that case, you filter the resources corresponding to each tag, regardless of the other filter.
	Keys *[]string `form:"keys,omitempty" json:"keys,omitempty"`

	// ResourceIds The IDs of the resources with which the tags are associated.
	ResourceIds *[]string `form:"resourceIds,omitempty" json:"resourceIds,omitempty"`

	// ResourceTypes The resource type (`vm` \| `image` \| `volume` \| `snapshot` \| `public-ip` \| `security-group` \| `route-table` \| `nic` \| `vpc` \| `subnet` \| `vpc-peering` \| `vpc-access-point` \| `nat-gateway` \| `internet-gateway` \| `client-gateway` \| `virtual-gateway` \| `vpn-connection` \| `dhcp-options` \| `task`).
	ResourceTypes *[]string `form:"resourceTypes,omitempty" json:"resourceTypes,omitempty"`

	// Values The values of the tags that are assigned to the resources. You can use this filter alongside the `TagKeys` filter. In that case, you filter the resources corresponding to each tag, regardless of the other filter.
	Values *[]string `form:"values,omitempty" json:"values,omitempty"`
}

// ReadVirtualGatewaysParams defines parameters for ReadVirtualGateways.
type ReadVirtualGatewaysParams struct {
	// ConnectionTypes The types of the virtual gateways (only `ipsec.1` is supported).
	ConnectionTypes *[]string `form:"connectionTypes,omitempty" json:"connectionTypes,omitempty"`

	// LinkStates The current states of the attachments between the virtual gateways and the Vpcs (`attaching` \| `attached` \| `detaching` \| `detached`).
	LinkStates *[]string `form:"linkStates,omitempty" json:"linkStates,omitempty"`

	// States The states of the virtual gateways (`pending` \| `available` \| `deleting` \| `deleted`).
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// TagKeys The keys of the tags associated with the virtual gateways.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the virtual gateways.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the virtual gateways, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// LinkVpcIds The IDs of the Vpcs the virtual gateways are attached to.
	LinkVpcIds *[]string `form:"linkVpcIds,omitempty" json:"linkVpcIds,omitempty"`

	// Ids The IDs of the virtual gateways.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`
}

// LinkVirtualGatewayToVpcJSONBody defines parameters for LinkVirtualGatewayToVpc.
type LinkVirtualGatewayToVpcJSONBody struct {
	// VpcId The ID of the Vpc to which you want to attach the virtual gateway.
	VpcId string `json:"vpcId"`
}

// ReadVmsParams defines parameters for ReadVms.
type ReadVmsParams struct {
	// Architectures The architectures of the VMs (`i386` \| `x86_64`).
	Architectures *[]string `form:"architectures,omitempty" json:"architectures,omitempty"`

	// BlockDeviceMappingDeleteOnVmDeletion Whether the BSU volumes are deleted when terminating the VMs.
	BlockDeviceMappingDeleteOnVmDeletion *bool `form:"blockDeviceMappingDeleteOnVmDeletion,omitempty" json:"blockDeviceMappingDeleteOnVmDeletion,omitempty"`

	// BlockDeviceMappingDeviceNames The device names for the BSU volumes (in the format `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX`).
	BlockDeviceMappingDeviceNames *[]string `form:"blockDeviceMappingDeviceNames,omitempty" json:"blockDeviceMappingDeviceNames,omitempty"`

	// BlockDeviceMappingLinkDates The link dates for the BSU volumes mapped to the VMs (for example, `2016-01-23T18:45:30.000Z`).
	BlockDeviceMappingLinkDates *[]ReadVmsParams_BlockDeviceMappingLinkDates_Item `form:"blockDeviceMappingLinkDates,omitempty" json:"blockDeviceMappingLinkDates,omitempty"`

	// BlockDeviceMappingStates The states for the BSU volumes (`attaching` \| `attached` \| `detaching` \| `detached`).
	BlockDeviceMappingStates *[]string `form:"blockDeviceMappingStates,omitempty" json:"blockDeviceMappingStates,omitempty"`

	// BlockDeviceMappingVolumeIds The volume IDs of the BSU volumes.
	BlockDeviceMappingVolumeIds *[]string `form:"blockDeviceMappingVolumeIds,omitempty" json:"blockDeviceMappingVolumeIds,omitempty"`

	// ClientTokens The idempotency tokens provided when launching the VMs.
	ClientTokens *[]string `form:"clientTokens,omitempty" json:"clientTokens,omitempty"`

	// CreationDates The dates when the VMs were launched.
	CreationDates *[]ReadVmsParams_CreationDates_Item `form:"creationDates,omitempty" json:"creationDates,omitempty"`

	// ImageIds The IDs of the OMIs used to launch the VMs.
	ImageIds *[]string `form:"imageIds,omitempty" json:"imageIds,omitempty"`

	// IsSourceDestChecked Whether the source/destination checking is enabled (true) or disabled (false).
	IsSourceDestChecked *bool `form:"isSourceDestChecked,omitempty" json:"isSourceDestChecked,omitempty"`

	// KeypairNames The names of the keypairs used when launching the VMs.
	KeypairNames *[]string `form:"keypairNames,omitempty" json:"keypairNames,omitempty"`

	// LaunchNumbers The numbers for the VMs when launching a group of several VMs (for example, `0`, `1`, `2`, and so on).
	LaunchNumbers *[]int `form:"launchNumbers,omitempty" json:"launchNumbers,omitempty"`

	// Lifecycles Whether the VMs are Spot Instances (spot).
	Lifecycles *[]string `form:"lifecycles,omitempty" json:"lifecycles,omitempty"`

	// NicDescriptions The descriptions of the NICs.
	NicDescriptions *[]string `form:"nicDescriptions,omitempty" json:"nicDescriptions,omitempty"`

	// NicIsSourceDestChecked Whether the source/destination checking is enabled (true) or disabled (false).
	NicIsSourceDestChecked *bool `form:"nicIsSourceDestChecked,omitempty" json:"nicIsSourceDestChecked,omitempty"`

	// NicLinkNicDeleteOnVmDeletion Whether the NICs are deleted when the VMs they are attached to are deleted.
	NicLinkNicDeleteOnVmDeletion *bool `form:"nicLinkNicDeleteOnVmDeletion,omitempty" json:"nicLinkNicDeleteOnVmDeletion,omitempty"`

	// NicLinkNicDeviceNumbers The device numbers the NICs are attached to.
	NicLinkNicDeviceNumbers *[]int `form:"nicLinkNicDeviceNumbers,omitempty" json:"nicLinkNicDeviceNumbers,omitempty"`

	// NicLinkNicLinkNicDates The dates and time when the NICs were attached to the VMs.
	NicLinkNicLinkNicDates *[]ReadVmsParams_NicLinkNicLinkNicDates_Item `form:"nicLinkNicLinkNicDates,omitempty" json:"nicLinkNicLinkNicDates,omitempty"`

	// NicLinkNicLinkNicIds The IDs of the NIC attachments.
	NicLinkNicLinkNicIds *[]string `form:"nicLinkNicLinkNicIds,omitempty" json:"nicLinkNicLinkNicIds,omitempty"`

	// NicLinkNicStates The states of the attachments.
	NicLinkNicStates *[]string `form:"nicLinkNicStates,omitempty" json:"nicLinkNicStates,omitempty"`

	// NicLinkNicVmIds The IDs of the VMs the NICs are attached to.
	NicLinkNicVmIds *[]string `form:"nicLinkNicVmIds,omitempty" json:"nicLinkNicVmIds,omitempty"`

	// NicLinkPublicIpLinkPublicIpIds The association IDs returned when the public IPs were associated with the NICs.
	NicLinkPublicIpLinkPublicIpIds *[]string `form:"nicLinkPublicIpLinkPublicIpIds,omitempty" json:"nicLinkPublicIpLinkPublicIpIds,omitempty"`

	// NicLinkPublicIpPublicIpIds The allocation IDs returned when the public IPs were allocated to their accounts.
	NicLinkPublicIpPublicIpIds *[]string `form:"nicLinkPublicIpPublicIpIds,omitempty" json:"nicLinkPublicIpPublicIpIds,omitempty"`

	// NicLinkPublicIpPublicIps The public IPs associated with the NICs.
	NicLinkPublicIpPublicIps *[]string `form:"nicLinkPublicIpPublicIps,omitempty" json:"nicLinkPublicIpPublicIps,omitempty"`

	// NicMacAddresses The Media Access Control (MAC) addresses of the NICs.
	NicMacAddresses *[]string `form:"nicMacAddresses,omitempty" json:"nicMacAddresses,omitempty"`

	// NicNicIds The IDs of the NICs.
	NicNicIds *[]string `form:"nicNicIds,omitempty" json:"nicNicIds,omitempty"`

	// NicPrivateIpsLinkPublicIpIds The public IPs associated with the private IPs.
	NicPrivateIpsLinkPublicIpIds *[]string `form:"nicPrivateIpsLinkPublicIpIds,omitempty" json:"nicPrivateIpsLinkPublicIpIds,omitempty"`

	// NicPrivateIpsPrimaryIp Whether the private IPs are the primary IPs associated with the NICs.
	NicPrivateIpsPrimaryIp *bool `form:"nicPrivateIpsPrimaryIp,omitempty" json:"nicPrivateIpsPrimaryIp,omitempty"`

	// NicPrivateIpsPrivateIps The private IPs of the NICs.
	NicPrivateIpsPrivateIps *[]string `form:"nicPrivateIpsPrivateIps,omitempty" json:"nicPrivateIpsPrivateIps,omitempty"`

	// NicSecurityGroupIds The IDs of the security groups associated with the NICs.
	NicSecurityGroupIds *[]string `form:"nicSecurityGroupIds,omitempty" json:"nicSecurityGroupIds,omitempty"`

	// NicSecurityGroupNames The names of the security groups associated with the NICs.
	NicSecurityGroupNames *[]string `form:"nicSecurityGroupNames,omitempty" json:"nicSecurityGroupNames,omitempty"`

	// NicStates The states of the NICs (`available` \| `in-use`).
	NicStates *[]string `form:"nicStates,omitempty" json:"nicStates,omitempty"`

	// NicSubnetIds The IDs of the Subnets for the NICs.
	NicSubnetIds *[]string `form:"nicSubnetIds,omitempty" json:"nicSubnetIds,omitempty"`

	// Platforms The platforms. Use windows if you have Windows VMs. Otherwise, leave this filter blank.
	Platforms *[]string `form:"platforms,omitempty" json:"platforms,omitempty"`

	// PrivateIps The private IPs of the VMs.
	PrivateIps *[]string `form:"privateIps,omitempty" json:"privateIps,omitempty"`

	// ProductCodes The product codes associated with the OMI used to create the VMs.
	ProductCodes *[]string `form:"productCodes,omitempty" json:"productCodes,omitempty"`

	// PublicIps The public IPs of the VMs.
	PublicIps *[]string `form:"publicIps,omitempty" json:"publicIps,omitempty"`

	// ReservationIds The IDs of the reservation of the VMs, created every time you launch VMs. These reservation IDs can be associated with several VMs when you lauch a group of VMs using the same launch request.
	ReservationIds *[]string `form:"reservationIds,omitempty" json:"reservationIds,omitempty"`

	// RootDeviceNames The names of the root devices for the VMs (for example, `/dev/sda1`)
	RootDeviceNames *[]string `form:"rootDeviceNames,omitempty" json:"rootDeviceNames,omitempty"`

	// RootDeviceTypes The root devices types used by the VMs (always `ebs`)
	RootDeviceTypes *[]string `form:"rootDeviceTypes,omitempty" json:"rootDeviceTypes,omitempty"`

	// SecurityGroupIds The IDs of the security groups for the VMs (only in the public Cloud).
	SecurityGroupIds *[]string `form:"securityGroupIds,omitempty" json:"securityGroupIds,omitempty"`

	// SecurityGroupNames The names of the security groups for the VMs (only in the public Cloud).
	SecurityGroupNames *[]string `form:"securityGroupNames,omitempty" json:"securityGroupNames,omitempty"`

	// StateReasonCodes The reason codes for the state changes.
	StateReasonCodes *[]int `form:"stateReasonCodes,omitempty" json:"stateReasonCodes,omitempty"`

	// StateReasonMessages The messages describing the state changes.
	StateReasonMessages *[]string `form:"stateReasonMessages,omitempty" json:"stateReasonMessages,omitempty"`

	// StateReasons The reasons explaining the current states of the VMs. This filter is like the `StateReasonCodes` one.
	StateReasons *[]string `form:"stateReasons,omitempty" json:"stateReasons,omitempty"`

	// SubnetIds The IDs of the Subnets for the VMs.
	SubnetIds *[]string `form:"subnetIds,omitempty" json:"subnetIds,omitempty"`

	// TagKeys The keys of the tags associated with the VMs.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the VMs.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the VMs, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// Tenancies The tenancies of the VMs (`dedicated` \| `default` \| `host`).
	Tenancies *[]string `form:"tenancies,omitempty" json:"tenancies,omitempty"`

	// VmSecurityGroupIds The IDs of the security groups for the VMs.
	VmSecurityGroupIds *[]string `form:"vmSecurityGroupIds,omitempty" json:"vmSecurityGroupIds,omitempty"`

	// VmSecurityGroupNames The names of the security group for the VMs.
	VmSecurityGroupNames *[]string `form:"vmSecurityGroupNames,omitempty" json:"vmSecurityGroupNames,omitempty"`

	// VmStateCodes The state codes of the VMs: `-1` (quarantine), `0` (pending), `16` (running), `32` (shutting-down), `48` (terminated), `64` (stopping), and `80` (stopped).
	VmStateCodes *[]int `form:"vmStateCodes,omitempty" json:"vmStateCodes,omitempty"`

	// VmStateNames The state names of the VMs (`pending` \| `running` \| `stopping` \| `stopped` \| `shutting-down` \| `terminated` \| `quarantine`).
	VmStateNames *[]string `form:"vmStateNames,omitempty" json:"vmStateNames,omitempty"`

	// Types The NumSpot VM types.
	Types *[]string `form:"types,omitempty" json:"types,omitempty"`

	// VpcIds The IDs of the Vpcs in which the VMs are running.
	VpcIds *[]string `form:"vpcIds,omitempty" json:"vpcIds,omitempty"`

	// NicVpcIds The IDs of the Vpcs where the NICs are located.
	NicVpcIds *[]string `form:"nicVpcIds,omitempty" json:"nicVpcIds,omitempty"`

	// NicAvailabilityZoneNames The Subregions where the NICs are located.
	NicAvailabilityZoneNames *[]string `form:"nicAvailabilityZoneNames,omitempty" json:"nicAvailabilityZoneNames,omitempty"`

	// AvailabilityZoneNames The names of the Subregions of the VMs.
	AvailabilityZoneNames *[]string `form:"availabilityZoneNames,omitempty" json:"availabilityZoneNames,omitempty"`

	// Ids One or more IDs of VMs.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`
}

// ReadVmsParamsBlockDeviceMappingLinkDates0 defines parameters for ReadVms.
type ReadVmsParamsBlockDeviceMappingLinkDates0 = openapi_types.Date

// ReadVmsParamsBlockDeviceMappingLinkDates1 defines parameters for ReadVms.
type ReadVmsParamsBlockDeviceMappingLinkDates1 = time.Time

// ReadVmsParams_BlockDeviceMappingLinkDates_Item defines parameters for ReadVms.
type ReadVmsParams_BlockDeviceMappingLinkDates_Item struct {
	union json.RawMessage
}

// ReadVmsParamsCreationDates0 defines parameters for ReadVms.
type ReadVmsParamsCreationDates0 = openapi_types.Date

// ReadVmsParamsCreationDates1 defines parameters for ReadVms.
type ReadVmsParamsCreationDates1 = time.Time

// ReadVmsParams_CreationDates_Item defines parameters for ReadVms.
type ReadVmsParams_CreationDates_Item struct {
	union json.RawMessage
}

// ReadVmsParamsNicLinkNicLinkNicDates0 defines parameters for ReadVms.
type ReadVmsParamsNicLinkNicLinkNicDates0 = openapi_types.Date

// ReadVmsParamsNicLinkNicLinkNicDates1 defines parameters for ReadVms.
type ReadVmsParamsNicLinkNicLinkNicDates1 = time.Time

// ReadVmsParams_NicLinkNicLinkNicDates_Item defines parameters for ReadVms.
type ReadVmsParams_NicLinkNicLinkNicDates_Item struct {
	union json.RawMessage
}

// ReadVmsStateParams defines parameters for ReadVmsState.
type ReadVmsStateParams struct {
	// MaintenanceEventCodes The code for the scheduled event (`system-reboot` \| `system-maintenance`).
	MaintenanceEventCodes *[]string `form:"maintenanceEventCodes,omitempty" json:"maintenanceEventCodes,omitempty"`

	// MaintenanceEventDescriptions The description of the scheduled event.
	MaintenanceEventDescriptions *[]string `form:"maintenanceEventDescriptions,omitempty" json:"maintenanceEventDescriptions,omitempty"`

	// MaintenanceEventsNotAfter The latest time the event can end.
	MaintenanceEventsNotAfter *[]openapi_types.Date `form:"maintenanceEventsNotAfter,omitempty" json:"maintenanceEventsNotAfter,omitempty"`

	// MaintenanceEventsNotBefore The earliest time the event can start.
	MaintenanceEventsNotBefore *[]openapi_types.Date `form:"maintenanceEventsNotBefore,omitempty" json:"maintenanceEventsNotBefore,omitempty"`

	// VmStates The states of the VMs (`pending` \| `running` \| `stopping` \| `stopped` \| `shutting-down` \| `terminated` \| `quarantine`).
	VmStates *[]string `form:"vmStates,omitempty" json:"vmStates,omitempty"`

	// AvailabilityZoneNames The names of the Subregions of the VMs.
	AvailabilityZoneNames *[]string `form:"availabilityZoneNames,omitempty" json:"availabilityZoneNames,omitempty"`

	// Ids One or more IDs of VMs.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`
}

// ReadVolumesParams defines parameters for ReadVolumes.
type ReadVolumesParams struct {
	// CreationDates The dates and times of creation of the volumes, in ISO 8601 date-time format (for example, `2020-06-30T00:00:00.000Z`).
	CreationDates *[]time.Time `form:"creationDates,omitempty" json:"creationDates,omitempty"`

	// LinkVolumeDeleteOnVmDeletion Whether the volumes are deleted or not when terminating the VMs.
	LinkVolumeDeleteOnVmDeletion *bool `form:"linkVolumeDeleteOnVmDeletion,omitempty" json:"linkVolumeDeleteOnVmDeletion,omitempty"`

	// LinkVolumeDeviceNames The VM device names.
	LinkVolumeDeviceNames *[]string `form:"linkVolumeDeviceNames,omitempty" json:"linkVolumeDeviceNames,omitempty"`

	// LinkVolumeLinkDates The dates and times of creation of the volumes, in ISO 8601 date-time format (for example, `2020-06-30T00:00:00.000Z`).
	LinkVolumeLinkDates *[]time.Time `form:"linkVolumeLinkDates,omitempty" json:"linkVolumeLinkDates,omitempty"`

	// LinkVolumeLinkStates The attachment states of the volumes (`attaching` \| `detaching` \| `attached` \| `detached`).
	LinkVolumeLinkStates *[]string `form:"linkVolumeLinkStates,omitempty" json:"linkVolumeLinkStates,omitempty"`

	// LinkVolumeVmIds One or more IDs of VMs.
	LinkVolumeVmIds *[]string `form:"linkVolumeVmIds,omitempty" json:"linkVolumeVmIds,omitempty"`

	// SnapshotIds The snapshots from which the volumes were created.
	SnapshotIds *[]string `form:"snapshotIds,omitempty" json:"snapshotIds,omitempty"`

	// TagKeys The keys of the tags associated with the volumes.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the volumes.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the volumes, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// VolumeSizes The sizes of the volumes, in gibibytes (GiB).
	VolumeSizes *[]int `form:"volumeSizes,omitempty" json:"volumeSizes,omitempty"`

	// VolumeStates The states of the volumes (`creating` \| `available` \| `in-use` \| `updating` \| `deleting` \| `error`).
	VolumeStates *[]string `form:"volumeStates,omitempty" json:"volumeStates,omitempty"`

	// VolumeTypes The types of the volumes (`standard` \| `gp2` \| `io1`).
	VolumeTypes *[]string `form:"volumeTypes,omitempty" json:"volumeTypes,omitempty"`

	// AvailabilityZoneNames The names of the Subregions in which the volumes were created.
	AvailabilityZoneNames *[]string `form:"availabilityZoneNames,omitempty" json:"availabilityZoneNames,omitempty"`

	// Ids The IDs of the volumes.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`
}

// ReadVpcPeeringsParams defines parameters for ReadVpcPeerings.
type ReadVpcPeeringsParams struct {
	// ExpirationDates The dates and times at which the Vpc peerings expire, in ISO 8601 date-time format (for example, `2020-06-14T00:00:00.000Z`).
	ExpirationDates *[]time.Time `form:"expirationDates,omitempty" json:"expirationDates,omitempty"`

	// StateMessages Additional information about the states of the Vpc peerings.
	StateMessages *[]string `form:"stateMessages,omitempty" json:"stateMessages,omitempty"`

	// StateNames The states of the Vpc peerings (`pending-acceptance` \| `active` \| `rejected` \| `failed` \| `expired` \| `deleted`).
	StateNames *[]string `form:"stateNames,omitempty" json:"stateNames,omitempty"`

	// TagKeys The keys of the tags associated with the Vpc peerings.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the Vpc peerings.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the Vpc peerings, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// AccepterVpcIpRanges The IP ranges of the peer Vpcs, in CIDR notation (for example, `10.0.0.0/24`).
	AccepterVpcIpRanges *[]string `form:"accepterVpcIpRanges,omitempty" json:"accepterVpcIpRanges,omitempty"`

	// AccepterVpcVpcIds The IDs of the peer Vpcs
	AccepterVpcVpcIds *[]string `form:"accepterVpcVpcIds,omitempty" json:"accepterVpcVpcIds,omitempty"`

	// Ids The IDs of the Vpc peerings.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`

	// SourceVpcIpRanges The IP ranges of the peer Vpcs
	SourceVpcIpRanges *[]string `form:"sourceVpcIpRanges,omitempty" json:"sourceVpcIpRanges,omitempty"`

	// SourceVpcVpcIds The IDs of the peer Vpcs
	SourceVpcVpcIds *[]string `form:"sourceVpcVpcIds,omitempty" json:"sourceVpcVpcIds,omitempty"`
}

// ReadVpcsParams defines parameters for ReadVpcs.
type ReadVpcsParams struct {
	// DhcpOptionsSetIds The IDs of the DHCP options sets.
	DhcpOptionsSetIds *[]string `form:"dhcpOptionsSetIds,omitempty" json:"dhcpOptionsSetIds,omitempty"`

	// IpRanges The IP ranges for the Vpcs, in CIDR notation (for example, `10.0.0.0/16`).
	IpRanges *[]string `form:"ipRanges,omitempty" json:"ipRanges,omitempty"`

	// IsDefault If true, the Vpc used is the default one.
	IsDefault *bool `form:"isDefault,omitempty" json:"isDefault,omitempty"`

	// States The states of the Vpcs (`pending` \| `available` \| `deleting`).
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// TagKeys The keys of the tags associated with the Vpcs.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the Vpcs.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the Vpcs, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// Ids The IDs of the Vpcs.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`
}

// ReadVpnConnectionsParams defines parameters for ReadVpnConnections.
type ReadVpnConnectionsParams struct {
	// BgpAsns The Border Gateway Protocol (BGP) Autonomous System Numbers (ASNs) of the connections.
	BgpAsns *[]int `form:"bgpAsns,omitempty" json:"bgpAsns,omitempty"`

	// ClientGatewayIds The IDs of the client gateways.
	ClientGatewayIds *[]string `form:"clientGatewayIds,omitempty" json:"clientGatewayIds,omitempty"`

	// ConnectionTypes The types of the VPN connections (only `ipsec.1` is supported).
	ConnectionTypes *[]string `form:"connectionTypes,omitempty" json:"connectionTypes,omitempty"`

	// RouteDestinationIpRanges The destination IP ranges.
	RouteDestinationIpRanges *[]string `form:"routeDestinationIpRanges,omitempty" json:"routeDestinationIpRanges,omitempty"`

	// States The states of the VPN connections (`pending` \| `available` \| `deleting` \| `deleted`).
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// StaticRoutesOnly If false, the VPN connection uses dynamic routing with Border Gateway Protocol (BGP). If true, routing is controlled using static routes. For more information about how to create and delete static routes, see [CreateVpnConnectionRoute](#createvpnconnectionroute) and [DeleteVpnConnectionRoute](#deletevpnconnectionroute).
	StaticRoutesOnly *bool `form:"staticRoutesOnly,omitempty" json:"staticRoutesOnly,omitempty"`

	// TagKeys The keys of the tags associated with the VPN connections.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the VPN connections.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the VPN connections, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// VirtualGatewayIds The IDs of the virtual gateways.
	VirtualGatewayIds *[]string `form:"virtualGatewayIds,omitempty" json:"virtualGatewayIds,omitempty"`

	// Ids The IDs of the VPN connections.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`
}

// AuthorizeParams defines parameters for Authorize.
type AuthorizeParams struct {
	// ClientId The client identifier.
	ClientId *ClientId `form:"client_id,omitempty" json:"client_id,omitempty"`

	// RedirectUri The client's redirect URI.
	RedirectUri *RedirectUri `form:"redirect_uri,omitempty" json:"redirect_uri,omitempty"`

	// ResponseType The expected response type.
	ResponseType ResponseType `form:"response_type" json:"response_type"`

	// Scope The requested scopes.
	Scope *Scope `form:"scope,omitempty" json:"scope,omitempty"`

	// State An opaque value passed to the application after authentication.
	State *State `form:"state,omitempty" json:"state,omitempty"`
}

// ConsentParams defines parameters for Consent.
type ConsentParams struct {
	// ConsentChallenge token consent challenge
	ConsentChallenge ConsentChallenge `form:"consent_challenge" json:"consent_challenge"`
}

// GetFlowErrorParams defines parameters for GetFlowError.
type GetFlowErrorParams struct {
	// Id Error is the error's ID
	Id string `form:"id" json:"id"`
}

// UpdateLoginFlowParams defines parameters for UpdateLoginFlow.
type UpdateLoginFlowParams struct {
	// Flow The Login Flow ID
	// The value for this parameter comes from `flow` URL Query parameter sent to your application (`/login?flow=abcde`).
	Flow string `form:"flow" json:"flow"`

	// XSessionToken The Session Token of the Identity performing the settings flow.
	XSessionToken *string `json:"X-Session-Token,omitempty"`

	// Cookie HTTP Cookies
	// When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header
	// sent by the client to your server here. This ensures that CSRF and session cookies are respected.
	Cookie *string `json:"Cookie,omitempty"`
}

// CreateNativeLoginFlowParams defines parameters for CreateNativeLoginFlow.
type CreateNativeLoginFlowParams struct {
	// Refresh Refresh a login session
	//
	// If set to true, this will refresh an existing login session by
	// asking the user to sign in again. This will reset the
	// authenticated_at time of the session.
	Refresh *bool `form:"refresh,omitempty" json:"refresh,omitempty"`

	// Aal Request a Specific AuthenticationMethod Assurance Level
	// Use this parameter to upgrade an existing session's authenticator assurance level (AAL). This
	// allows you to ask for multi-factor authentication. When an identity sign in using e.g. username+password,
	// the AAL is 1. If you wish to "upgrade" the session's security by asking the user to perform TOTP / WebAuth, you would set this to "aal2".
	Aal *string `form:"aal,omitempty" json:"aal,omitempty"`

	// ReturnSessionTokenExchangeCode EnableSessionTokenExchangeCode requests the login flow to include a code that can be used to retrieve the session token
	// after the login flow has been completed.
	ReturnSessionTokenExchangeCode *bool `form:"return_session_token_exchange_code,omitempty" json:"return_session_token_exchange_code,omitempty"`

	// ReturnTo The URL to return the browser to after the flow was completed.
	ReturnTo *string `form:"return_to,omitempty" json:"return_to,omitempty"`

	// Via Via should contain the identity's credential the code should be sent to. Only relevant in aal2 flows.
	Via *string `form:"via,omitempty" json:"via,omitempty"`

	// XSessionToken The Session Token of the Identity performing the settings flow.
	XSessionToken *string `json:"X-Session-Token,omitempty"`
}

// CreateBrowserLoginFlowParams defines parameters for CreateBrowserLoginFlow.
type CreateBrowserLoginFlowParams struct {
	// Refresh Refresh a login session
	//
	// If set to true, this will refresh an existing login session by
	// asking the user to sign in again. This will reset the
	// authenticated_at time of the session.
	Refresh *bool `form:"refresh,omitempty" json:"refresh,omitempty"`

	// Aal Request a Specific AuthenticationMethod Assurance Level
	//
	// Use this parameter to upgrade an existing session's authenticator assurance level (AAL). This
	// allows you to ask for multi-factor authentication. When an identity sign in using e.g. username+password,
	// the AAL is 1. If you wish to "upgrade" the session's security by asking the user to perform TOTP / WebAuth/ ...
	// you would set this to "aal2".
	Aal *string `form:"aal,omitempty" json:"aal,omitempty"`

	// ReturnTo The URL to return the browser to after the flow was completed.
	ReturnTo *string `form:"return_to,omitempty" json:"return_to,omitempty"`

	// LoginChallenge The value for this parameter comes from `login_challenge` URL Query parameter sent to your application.
	LoginChallenge *string `form:"login_challenge,omitempty" json:"login_challenge,omitempty"`

	// Organization An optional organization ID that should be used for logging this user in.
	// This parameter is only effective in the  Network.
	Organization *string `form:"organization,omitempty" json:"organization,omitempty"`

	// Cookie HTTP Cookies
	//
	// When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header
	// sent by the client to your server here. This ensures that CSRF and session cookies are respected.
	Cookie *string `json:"Cookie,omitempty"`
}

// GetLoginFlowParams defines parameters for GetLoginFlow.
type GetLoginFlowParams struct {
	// Id The Login Flow ID
	//
	// The value for this parameter comes from `flow` URL Query parameter sent to your
	// application (e.g. `/login?flow=abcde`).
	Id string `form:"id" json:"id"`

	// Cookie HTTP Cookies
	// When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header
	// sent by the client to your server here. This ensures that CSRF and session cookies are respected.
	Cookie *string `json:"Cookie,omitempty"`
}

// UpdateLogoutFlowParams defines parameters for UpdateLogoutFlow.
type UpdateLogoutFlowParams struct {
	// Token A Valid Logout Token
	// If you do not have a logout token because you only have a session cookie,
	// call `/self-service/logout/browser` to generate a URL for this endpoint.
	Token *string `form:"token,omitempty" json:"token,omitempty"`

	// ReturnTo The URL to return to after the logout was completed.
	ReturnTo *string `form:"return_to,omitempty" json:"return_to,omitempty"`

	// Cookie HTTP Cookies
	//
	// When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header
	// sent by the client to your server here. This ensures that CSRF and session cookies are respected.
	Cookie *string `json:"Cookie,omitempty"`
}

// CreateBrowserLogoutFlowParams defines parameters for CreateBrowserLogoutFlow.
type CreateBrowserLogoutFlowParams struct {
	// ReturnTo Return to URL
	//
	// The URL to which the browser should be redirected to after the logout
	// has been performed.
	ReturnTo *string `form:"return_to,omitempty" json:"return_to,omitempty"`

	// Cookie HTTP Cookies
	//
	// If you call this endpoint from a backend, please include the
	// original Cookie header in the request.
	Cookie *string `json:"cookie,omitempty"`
}

// InitRecoveryFlowParams defines parameters for InitRecoveryFlow.
type InitRecoveryFlowParams struct {
	// Flow recovery flowId
	Flow string `form:"flow" json:"flow"`

	// Token Recovery Token
	// The recovery token which completes the recovery request. If the token
	// is invalid (e.g. expired) an error will be shown to the end-user.
	// This parameter is usually set in a link and not used by any direct API call.
	Token *string `form:"token,omitempty" json:"token,omitempty"`

	// Cookie HTTP Cookies
	// When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header
	// sent by the client to your server here. This ensures that CSRF and session cookies are respected.
	Cookie *string `json:"Cookie,omitempty"`
}

// UpdateRecoveryFlowParams defines parameters for UpdateRecoveryFlow.
type UpdateRecoveryFlowParams struct {
	// Flow The Recovery Flow ID
	//
	// The value for this parameter comes from `flow` URL Query parameter sent to your
	// application (e.g. `/recovery?flow=abcde`).
	Flow string `form:"flow" json:"flow"`

	// Token Recovery Token
	// The recovery token which completes the recovery request. If the token
	// is invalid (e.g. expired) an error will be shown to the end-user.
	// This parameter is usually set in a link and not used by any direct API call.
	Token *string `form:"token,omitempty" json:"token,omitempty"`

	// Cookie HTTP Cookies
	// When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header
	// sent by the client to your server here. This ensures that CSRF and session cookies are respected.
	Cookie *string `json:"Cookie,omitempty"`
}

// CreateBrowserRecoveryFlowParams defines parameters for CreateBrowserRecoveryFlow.
type CreateBrowserRecoveryFlowParams struct {
	// ReturnTo The URL to return the browser to after the flow was completed.
	ReturnTo *string `form:"return_to,omitempty" json:"return_to,omitempty"`
}

// GetRecoveryFlowParams defines parameters for GetRecoveryFlow.
type GetRecoveryFlowParams struct {
	// Id The Flow ID
	// The value for this parameter comes from `request` URL Query parameter sent to your application (`/recovery?flow=abcde`).
	Id string `form:"id" json:"id"`

	// Cookie HTTP Cookies
	//
	// When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header
	// sent by the client to your server here. This ensures that CSRF and session cookies are respected.
	Cookie *string `json:"Cookie,omitempty"`
}

// UpdateRegistrationFlowParams defines parameters for UpdateRegistrationFlow.
type UpdateRegistrationFlowParams struct {
	// Flow The Registration Flow ID
	// The value for this parameter comes from `flow` URL Query parameter sent to your application.
	Flow string `form:"flow" json:"flow"`

	// Cookie HTTP Cookies
	//
	// When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header
	// sent by the client to your server here. This ensures that CSRF and session cookies are respected.
	Cookie *string `json:"Cookie,omitempty"`
}

// CreateNativeRegistrationFlowParams defines parameters for CreateNativeRegistrationFlow.
type CreateNativeRegistrationFlowParams struct {
	// ReturnSessionTokenExchangeCode EnableSessionTokenExchangeCode requests the login flow to include a code that can be used to retrieve the session token the login flow has been completed.
	ReturnSessionTokenExchangeCode *bool `form:"return_session_token_exchange_code,omitempty" json:"return_session_token_exchange_code,omitempty"`

	// ReturnTo The URL to return the browser to after the flow was completed.
	ReturnTo *string `form:"return_to,omitempty" json:"return_to,omitempty"`
}

// CreateBrowserRegistrationFlowParams defines parameters for CreateBrowserRegistrationFlow.
type CreateBrowserRegistrationFlowParams struct {
	ReturnTo                  *string `form:"return_to,omitempty" json:"return_to,omitempty"`
	LoginChallenge            *string `form:"login_challenge,omitempty" json:"login_challenge,omitempty"`
	AfterVerificationReturnTo *string `form:"after_verification_return_to,omitempty" json:"after_verification_return_to,omitempty"`
	Organization              *string `form:"organization,omitempty" json:"organization,omitempty"`
}

// GetRegistrationFlowParams defines parameters for GetRegistrationFlow.
type GetRegistrationFlowParams struct {
	// Id The Registration Flow ID
	//
	// The value for this parameter comes from `flow` URL Query parameter sent to your
	// application (e.g. `/registration?flow=abcde`).
	Id string `form:"id" json:"id"`

	// Cookie HTTP Cookies
	//
	// When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header
	// sent by the client to your server here. This ensures that CSRF and session cookies are respected.
	Cookie *string `json:"Cookie,omitempty"`
}

// UpdateSettingsFloParams defines parameters for UpdateSettingsFlo.
type UpdateSettingsFloParams struct {
	// Flow The Settings Flow ID
	// The value for this parameter comes from `flow` URL Query parameter sent to your application (e.g. `/settings?flow=abcde`).
	Flow string `form:"flow" json:"flow"`

	// XSessionToken The Session Token of the Identity performing the settings flow.
	XSessionToken *string `json:"X-Session-Token,omitempty"`

	// Cookie HTTP Cookies
	//
	// When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header
	// sent by the client to your server here. This ensures that CSRF and session cookies are respected.
	Cookie *string `json:"Cookie,omitempty"`
}

// CreateNativeSettingsFlowParams defines parameters for CreateNativeSettingsFlow.
type CreateNativeSettingsFlowParams struct {
	// XSessionToken The Session Token of the Identity performing the settings flow.
	XSessionToken *string `json:"X-Session-Token,omitempty"`
}

// CreateBrowserSettingsFlowParams defines parameters for CreateBrowserSettingsFlow.
type CreateBrowserSettingsFlowParams struct {
	// ReturnTo The URL to return the browser to after the flow was completed.
	ReturnTo *string `form:"return_to,omitempty" json:"return_to,omitempty"`

	// Cookie HTTP Cookies
	// When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header
	// sent by the client to your server here. This ensures that CSRF and session cookies are respected.
	Cookie *string `json:"Cookie,omitempty"`
}

// GetSettingsFlowParams defines parameters for GetSettingsFlow.
type GetSettingsFlowParams struct {
	// Id ID is the Settings Flow ID
	//
	// The value for this parameter comes from `flow` URL Query parameter sent to your
	// application (e.g. `/settings?flow=abcde`).
	Id string `form:"id" json:"id"`

	// XSessionToken The Session Token
	//
	// When using the SDK in an app without a browser, please include the
	// session token here.
	XSessionToken *string `json:"X-Session-Token,omitempty"`

	// Cookie HTTP Cookies
	//
	// When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header
	// sent by the client to your server here. This ensures that CSRF and session cookies are respected.
	Cookie *string `json:"Cookie,omitempty"`
}

// UpdateVerificationFlowParams defines parameters for UpdateVerificationFlow.
type UpdateVerificationFlowParams struct {
	// Flow The Verification Flow ID
	//
	// The value for this parameter comes from `flow` URL Query parameter sent to your
	// application (e.g. `/verification?flow=abcde`).
	Flow string `form:"flow" json:"flow"`

	// Token Verification Token
	//
	// The verification token which completes the verification request. If the token
	// is invalid (e.g. expired) an error will be shown to the end-user.
	//
	// This parameter is usually set in a link and not used by any direct API call.
	Token *string `form:"token,omitempty" json:"token,omitempty"`

	// Cookie HTTP Cookies
	//
	// When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header
	// sent by the client to your server here. This ensures that CSRF and session cookies are respected.
	Cookie *string `json:"Cookie,omitempty"`
}

// CreateBrowserVerificationFlowParams defines parameters for CreateBrowserVerificationFlow.
type CreateBrowserVerificationFlowParams struct {
	// ReturnTo The URL to return the browser to after the flow was completed.
	ReturnTo *string `form:"return_to,omitempty" json:"return_to,omitempty"`
}

// GetVerificationFlowParams defines parameters for GetVerificationFlow.
type GetVerificationFlowParams struct {
	// Id The Flow ID
	//
	// The value for this parameter comes from `request` URL Query parameter sent to your
	// application (e.g. `/verification?flow=abcde`).
	Id string `form:"id" json:"id"`

	// Cookie HTTP Cookies
	//
	// When using the SDK on the server side you must include the HTTP Cookie Header
	// originally sent to your HTTP handler here.
	Cookie *string `json:"cookie,omitempty"`
}

// DisableMyOtherSessionsParams defines parameters for DisableMyOtherSessions.
type DisableMyOtherSessionsParams struct {
	// XSessionToken Set the Session Token when calling from non-browser clients. A session token has a format of `MP2YWEMeM8MxjkGKpH4dqOQ4Q4DlSPaj`.
	XSessionToken *string `json:"X-Session-Token,omitempty"`

	// Cookie Set the Cookie Header. This is especially useful when calling this endpoint from a server-side application. In that
	// scenario you must include the HTTP Cookie Header which originally was included in the request to your server.
	// It is ok if more than one cookie are included here as all other cookies will be ignored.
	Cookie *string `json:"Cookie,omitempty"`
}

// ListMySessionsParams defines parameters for ListMySessions.
type ListMySessionsParams struct {
	// PerPage Deprecated Items per Page
	//
	// DEPRECATED: Please use `page_token` instead. This parameter will be removed in the future.
	//
	// This is the number of items per page.
	PerPage *int64 `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Deprecated Pagination Page
	//
	// DEPRECATED: Please use `page_token` instead. This parameter will be removed in the future.
	//
	// This value is currently an integer, but it is not sequential. The value is not the page number, but a
	// reference. The next page can be any number and some numbers might return an empty list.
	//
	// For example, page 2 might not follow after page 1. And even if page 3 and 5 exist, but page 4 might not exist.
	// The first page can be retrieved by omitting this parameter. Following page pointers will be returned in the
	// `Link` header.
	Page *int64 `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page Size
	// This is the number of items per page to return.
	PageSize *int64 `form:"page_size,omitempty" json:"page_size,omitempty"`

	// PageToken Next Page Token
	PageToken *string `form:"page_token,omitempty" json:"page_token,omitempty"`

	// XSessionToken Set the Session Token when calling from non-browser clients. A session token has a format of `MP2YWEMeM8MxjkGKpH4dqOQ4Q4DlSPaj`.
	XSessionToken *string `json:"X-Session-Token,omitempty"`

	// Cookie Set the Cookie Header. This is especially useful when calling this endpoint from a server-side application. In that
	// scenario you must include the HTTP Cookie Header which originally was included in the request to your server.
	// It is ok if more than one cookie are included here as all other cookies will be ignored.
	Cookie *string `json:"Cookie,omitempty"`
}

// ExchangeSessionTokenParams defines parameters for ExchangeSessionToken.
type ExchangeSessionTokenParams struct {
	// InitCode The part of the code return when initializing the flow.
	InitCode string `form:"init_code" json:"init_code"`

	// ReturnToCode The part of the code returned by the return_to URL.
	ReturnToCode string `form:"return_to_code" json:"return_to_code"`
}

// ToSessionParams defines parameters for ToSession.
type ToSessionParams struct {
	// TokenizeAs Returns the session additionally as a token (such as a JWT). The value of this parameter has to be a valid, configured Session token template.
	TokenizeAs *string `form:"tokenize_as,omitempty" json:"tokenize_as,omitempty"`

	// XSessionToken Set the Session Token when calling from non-browser clients.
	XSessionToken *string `json:"X-Session-Token,omitempty"`

	// Cookie Set the Cookie Header. This is especially useful when calling this endpoint from a server-side application. In that
	// scenario you must include the HTTP Cookie Header which originally was included in the request to your server.
	// It is ok if more than one cookie are included here as all other cookies will be ignored.
	Cookie *string `json:"Cookie,omitempty"`
}

// ListOrganisationsIdentityParams defines parameters for ListOrganisationsIdentity.
type ListOrganisationsIdentityParams struct {
	// Page Paginated request
	Page *ListUserOrganisations `json:"page,omitempty"`
}

// SetIAMGranularPolicyOrganisationJSONBody defines parameters for SetIAMGranularPolicyOrganisation.
type SetIAMGranularPolicyOrganisationJSONBody struct {
	Add    *GranularPolicyList `json:"add,omitempty"`
	Delete *GranularPolicyList `json:"delete,omitempty"`
}

// SetIAMPolicyOrganisationJSONBody defines parameters for SetIAMPolicyOrganisation.
type SetIAMPolicyOrganisationJSONBody struct {
	Add    *IAMPolicy `json:"add,omitempty"`
	Delete *IAMPolicy `json:"delete,omitempty"`
}

// ListPermissionsOrganisationParams defines parameters for ListPermissionsOrganisation.
type ListPermissionsOrganisationParams struct {
	// Service service the permission is related to
	Service *Service `form:"service,omitempty" json:"service,omitempty"`

	// Resource resource the permission is related to
	Resource *Resource `form:"resource,omitempty" json:"resource,omitempty"`

	// Subresource subresource the permission is related to
	Subresource *SubResource `form:"subresource,omitempty" json:"subresource,omitempty"`

	// Action action the permission allows to perform
	Action *Action `form:"action,omitempty" json:"action,omitempty"`

	// Page Paginated request
	Page *ListPermissionsPage `json:"page,omitempty"`
}

// ListRolesOrganisationParams defines parameters for ListRolesOrganisation.
type ListRolesOrganisationParams struct {
	// Name Role name
	Name *RoleName `form:"name,omitempty" json:"name,omitempty"`

	// Page Paginated request
	Page *ListRolesPage `json:"page,omitempty"`
}

// UpdateRoleOrganisationJSONBody defines parameters for UpdateRoleOrganisation.
type UpdateRoleOrganisationJSONBody struct {
	// Description Human-readable description
	Description *string `json:"description,omitempty"`

	// Name Human-readable name
	Name *string `json:"name,omitempty"`
}

// ListServiceAccountOrganisationParams defines parameters for ListServiceAccountOrganisation.
type ListServiceAccountOrganisationParams struct {
	// Page Paginated request
	Page *ListServiceAccounts `json:"page,omitempty"`
}

// GetACLServiceAccountOrganisationParams defines parameters for GetACLServiceAccountOrganisation.
type GetACLServiceAccountOrganisationParams struct {
	// Page Paginated request
	Page        *ListPolicyPage `json:"page,omitempty"`
	Service     string          `form:"service" json:"service"`
	Resource    string          `form:"resource" json:"resource"`
	Subresource *string         `form:"subresource,omitempty" json:"subresource,omitempty"`
}

// ListSpacesOfServiceAccountParams defines parameters for ListSpacesOfServiceAccount.
type ListSpacesOfServiceAccountParams struct {
	// Page Paginated request
	Page *ListSpacesOfServiceAccount `json:"page,omitempty"`
}

// ListSpacesIdentityParams defines parameters for ListSpacesIdentity.
type ListSpacesIdentityParams struct {
	// Page Paginated request
	Page *ListSpacesIdentity `json:"page,omitempty"`
}

// ListUserOrganisationParams defines parameters for ListUserOrganisation.
type ListUserOrganisationParams struct {
	// Email User email
	Email *UserEmail `form:"email,omitempty" json:"email,omitempty"`

	// Page Paginated request
	Page *ListUser `json:"page,omitempty"`
}

// GetACLUserOrganisationParams defines parameters for GetACLUserOrganisation.
type GetACLUserOrganisationParams struct {
	// Page Paginated request
	Page        *ListPolicyPage `json:"page,omitempty"`
	Service     string          `form:"service" json:"service"`
	Resource    string          `form:"resource" json:"resource"`
	Subresource *string         `form:"subresource,omitempty" json:"subresource,omitempty"`
}

// ListSpacesOfUserParams defines parameters for ListSpacesOfUser.
type ListSpacesOfUserParams struct {
	// Page Paginated request
	Page *ListSpacesOfUser `json:"page,omitempty"`
}

// RevokeParams defines parameters for Revoke.
type RevokeParams struct {
	// Authorization The client identifier.
	Authorization *Authorization `json:"Authorization,omitempty"`
}

// SetIAMGranularPolicySpaceJSONBody defines parameters for SetIAMGranularPolicySpace.
type SetIAMGranularPolicySpaceJSONBody struct {
	Add    *GranularPolicyList `json:"add,omitempty"`
	Delete *GranularPolicyList `json:"delete,omitempty"`
}

// SetIAMPolicySpaceJSONBody defines parameters for SetIAMPolicySpace.
type SetIAMPolicySpaceJSONBody struct {
	Add    *IAMPolicy `json:"add,omitempty"`
	Delete *IAMPolicy `json:"delete,omitempty"`
}

// ListPermissionsSpaceParams defines parameters for ListPermissionsSpace.
type ListPermissionsSpaceParams struct {
	// Service service the permission is related to
	Service *Service `form:"service,omitempty" json:"service,omitempty"`

	// Resource resource the permission is related to
	Resource *Resource `form:"resource,omitempty" json:"resource,omitempty"`

	// Subresource subresource the permission is related to
	Subresource *SubResource `form:"subresource,omitempty" json:"subresource,omitempty"`

	// Action action the permission allows to perform
	Action *Action `form:"action,omitempty" json:"action,omitempty"`

	// Page Paginated request
	Page *ListPermissionsPage `json:"page,omitempty"`
}

// ListRolesSpaceParams defines parameters for ListRolesSpace.
type ListRolesSpaceParams struct {
	// Name Role name
	Name *RoleName `form:"name,omitempty" json:"name,omitempty"`

	// Page Paginated request
	Page *ListRolesPage `json:"page,omitempty"`
}

// UpdateRoleSpaceJSONBody defines parameters for UpdateRoleSpace.
type UpdateRoleSpaceJSONBody struct {
	// Description Human-readable description
	Description *string `json:"description,omitempty"`

	// Name Human-readable name
	Name *string `json:"name,omitempty"`
}

// ListServiceAccountSpaceParams defines parameters for ListServiceAccountSpace.
type ListServiceAccountSpaceParams struct {
	// Page Paginated request
	Page *ListServiceAccounts `json:"page,omitempty"`
}

// GetACLServiceAccountSpaceParams defines parameters for GetACLServiceAccountSpace.
type GetACLServiceAccountSpaceParams struct {
	// Page Paginated request
	Page        *ListPolicyPage `json:"page,omitempty"`
	Service     string          `form:"service" json:"service"`
	Resource    string          `form:"resource" json:"resource"`
	Subresource *string         `form:"subresource,omitempty" json:"subresource,omitempty"`
}

// ListUserSpaceParams defines parameters for ListUserSpace.
type ListUserSpaceParams struct {
	// Email User email
	Email *UserEmail `form:"email,omitempty" json:"email,omitempty"`

	// Page Paginated request
	Page *ListUser `json:"page,omitempty"`
}

// GetACLUserSpaceParams defines parameters for GetACLUserSpace.
type GetACLUserSpaceParams struct {
	// Page Paginated request
	Page        *ListPolicyPage `json:"page,omitempty"`
	Service     string          `form:"service" json:"service"`
	Resource    string          `form:"resource" json:"resource"`
	Subresource *string         `form:"subresource,omitempty" json:"subresource,omitempty"`
}

// TokenParams defines parameters for Token.
type TokenParams struct {
	// Authorization The client identifier.
	Authorization *Authorization `json:"Authorization,omitempty"`
}

// GetUserInfoParams defines parameters for GetUserInfo.
type GetUserInfoParams struct {
	// Authorization The client identifier.
	Authorization *Authorization `json:"Authorization,omitempty"`
}

// GetOperationByIdParams defines parameters for GetOperationById.
type GetOperationByIdParams struct {
	// Authorization the jwt token of the current user
	Authorization TokenJwt `json:"Authorization"`
}

// GetObjectParams defines parameters for GetObject.
type GetObjectParams struct {
	// Expires Optional parameter to generate a presigned URL
	Expires *string `form:"expires,omitempty" json:"expires,omitempty"`
}

// UploadPartParams defines parameters for UploadPart.
type UploadPartParams struct {
	PartNumber int    `form:"partNumber" json:"partNumber"`
	UploadId   string `form:"uploadId" json:"uploadId"`
}

// AbortMultipartUploadParams defines parameters for AbortMultipartUpload.
type AbortMultipartUploadParams struct {
	UploadId string `form:"uploadId" json:"uploadId"`
}

// CompleteMultipartUploadParams defines parameters for CompleteMultipartUpload.
type CompleteMultipartUploadParams struct {
	UploadId string `form:"uploadId" json:"uploadId"`
}

// CreateMultipartUploadParams defines parameters for CreateMultipartUpload.
type CreateMultipartUploadParams struct {
	Uploads CreateMultipartUploadParamsUploads `form:"uploads" json:"uploads"`
}

// CreateMultipartUploadParamsUploads defines parameters for CreateMultipartUpload.
type CreateMultipartUploadParamsUploads bool

// ListOperationsParams defines parameters for ListOperations.
type ListOperationsParams struct {
	Status    *OperationStatuses `form:"status,omitempty" json:"status,omitempty"`
	ClusterId *QueryClusterId    `form:"clusterId,omitempty" json:"clusterId,omitempty"`
}

// ListSpacesParams defines parameters for ListSpaces.
type ListSpacesParams struct {
	// Page list spaces paginated request
	Page *ListSpacesPage `json:"page,omitempty"`
}

// DeleteLoadBalancerTagsJSONRequestBody defines body for DeleteLoadBalancerTags for application/json ContentType.
type DeleteLoadBalancerTagsJSONRequestBody = DeleteLoadBalancerTags

// CreateLoadBalancerTagsJSONRequestBody defines body for CreateLoadBalancerTags for application/json ContentType.
type CreateLoadBalancerTagsJSONRequestBody = CreateLoadBalancerTags

// DeleteTagsJSONRequestBody defines body for DeleteTags for application/json ContentType.
type DeleteTagsJSONRequestBody = DeleteTags

// CreateTagsJSONRequestBody defines body for CreateTags for application/json ContentType.
type CreateTagsJSONRequestBody = CreateTags

// CreateClientGatewayJSONRequestBody defines body for CreateClientGateway for application/json ContentType.
type CreateClientGatewayJSONRequestBody = CreateClientGateway

// CreateDhcpOptionsJSONRequestBody defines body for CreateDhcpOptions for application/json ContentType.
type CreateDhcpOptionsJSONRequestBody = CreateDhcpOptions

// CreateFlexibleGpuJSONRequestBody defines body for CreateFlexibleGpu for application/json ContentType.
type CreateFlexibleGpuJSONRequestBody = CreateFlexibleGpu

// UpdateFlexibleGpuJSONRequestBody defines body for UpdateFlexibleGpu for application/json ContentType.
type UpdateFlexibleGpuJSONRequestBody = UpdateFlexibleGpu

// LinkFlexibleGpuJSONRequestBody defines body for LinkFlexibleGpu for application/json ContentType.
type LinkFlexibleGpuJSONRequestBody = LinkFlexibleGpu

// CreateImageJSONRequestBody defines body for CreateImage for application/json ContentType.
type CreateImageJSONRequestBody = CreateImage

// UpdateImageJSONRequestBody defines body for UpdateImage for application/json ContentType.
type UpdateImageJSONRequestBody = UpdateImage

// LinkInternetGatewayJSONRequestBody defines body for LinkInternetGateway for application/json ContentType.
type LinkInternetGatewayJSONRequestBody = LinkInternetGateway

// UnlinkInternetGatewayJSONRequestBody defines body for UnlinkInternetGateway for application/json ContentType.
type UnlinkInternetGatewayJSONRequestBody = UnlinkInternetGateway

// CreateKeypairJSONRequestBody defines body for CreateKeypair for application/json ContentType.
type CreateKeypairJSONRequestBody CreateKeypairJSONBody

// CreateListenerRuleJSONRequestBody defines body for CreateListenerRule for application/json ContentType.
type CreateListenerRuleJSONRequestBody = CreateListenerRule

// UpdateListenerRuleJSONRequestBody defines body for UpdateListenerRule for application/json ContentType.
type UpdateListenerRuleJSONRequestBody = UpdateListenerRule

// CreateLoadBalancerJSONRequestBody defines body for CreateLoadBalancer for application/json ContentType.
type CreateLoadBalancerJSONRequestBody = CreateLoadBalancer

// UpdateLoadBalancerJSONRequestBody defines body for UpdateLoadBalancer for application/json ContentType.
type UpdateLoadBalancerJSONRequestBody = UpdateLoadBalancer

// LinkLoadBalancerBackendMachinesJSONRequestBody defines body for LinkLoadBalancerBackendMachines for application/json ContentType.
type LinkLoadBalancerBackendMachinesJSONRequestBody = LinkLoadBalancerBackendMachines

// UnlinkLoadBalancerBackendMachinesJSONRequestBody defines body for UnlinkLoadBalancerBackendMachines for application/json ContentType.
type UnlinkLoadBalancerBackendMachinesJSONRequestBody = UnlinkLoadBalancerBackendMachines

// DeleteLoadBalancerListenersJSONRequestBody defines body for DeleteLoadBalancerListeners for application/json ContentType.
type DeleteLoadBalancerListenersJSONRequestBody = DeleteLoadBalancerListeners

// CreateLoadBalancerListenersJSONRequestBody defines body for CreateLoadBalancerListeners for application/json ContentType.
type CreateLoadBalancerListenersJSONRequestBody = CreateLoadBalancerListeners

// DeleteLoadBalancerPolicyJSONRequestBody defines body for DeleteLoadBalancerPolicy for application/json ContentType.
type DeleteLoadBalancerPolicyJSONRequestBody = DeleteLoadBalancerPolicy

// CreateLoadBalancerPolicyJSONRequestBody defines body for CreateLoadBalancerPolicy for application/json ContentType.
type CreateLoadBalancerPolicyJSONRequestBody = CreateLoadBalancerPolicy

// ReadVmsHealthJSONRequestBody defines body for ReadVmsHealth for application/json ContentType.
type ReadVmsHealthJSONRequestBody ReadVmsHealthJSONBody

// ReadLoadBalancerTagsJSONRequestBody defines body for ReadLoadBalancerTags for application/json ContentType.
type ReadLoadBalancerTagsJSONRequestBody ReadLoadBalancerTagsJSONBody

// CreateNatGatewayJSONRequestBody defines body for CreateNatGateway for application/json ContentType.
type CreateNatGatewayJSONRequestBody = CreateNatGateway

// CreateNicJSONRequestBody defines body for CreateNic for application/json ContentType.
type CreateNicJSONRequestBody = CreateNic

// UpdateNicJSONRequestBody defines body for UpdateNic for application/json ContentType.
type UpdateNicJSONRequestBody = UpdateNic

// LinkPrivateIpsJSONRequestBody defines body for LinkPrivateIps for application/json ContentType.
type LinkPrivateIpsJSONRequestBody = LinkPrivateIps

// UnlinkPrivateIpsJSONRequestBody defines body for UnlinkPrivateIps for application/json ContentType.
type UnlinkPrivateIpsJSONRequestBody = UnlinkPrivateIps

// LinkNicJSONRequestBody defines body for LinkNic for application/json ContentType.
type LinkNicJSONRequestBody LinkNicJSONBody

// UnlinkNicJSONRequestBody defines body for UnlinkNic for application/json ContentType.
type UnlinkNicJSONRequestBody = UnlinkNic

// LinkPublicIpJSONRequestBody defines body for LinkPublicIp for application/json ContentType.
type LinkPublicIpJSONRequestBody LinkPublicIpJSONBody

// UnlinkPublicIpJSONRequestBody defines body for UnlinkPublicIp for application/json ContentType.
type UnlinkPublicIpJSONRequestBody = UnlinkPublicIp

// CreateRouteTableJSONRequestBody defines body for CreateRouteTable for application/json ContentType.
type CreateRouteTableJSONRequestBody = CreateRouteTable

// UpdateRouteTableRoutePropagationJSONRequestBody defines body for UpdateRouteTableRoutePropagation for application/json ContentType.
type UpdateRouteTableRoutePropagationJSONRequestBody = UpdateRouteTableRoutePropagation

// DeleteRouteJSONRequestBody defines body for DeleteRoute for application/json ContentType.
type DeleteRouteJSONRequestBody = DeleteRoute

// CreateRouteJSONRequestBody defines body for CreateRoute for application/json ContentType.
type CreateRouteJSONRequestBody = CreateRoute

// UpdateRouteJSONRequestBody defines body for UpdateRoute for application/json ContentType.
type UpdateRouteJSONRequestBody = UpdateRoute

// LinkRouteTableJSONRequestBody defines body for LinkRouteTable for application/json ContentType.
type LinkRouteTableJSONRequestBody LinkRouteTableJSONBody

// UnlinkRouteTableJSONRequestBody defines body for UnlinkRouteTable for application/json ContentType.
type UnlinkRouteTableJSONRequestBody = UnlinkRouteTable

// CreateSecurityGroupJSONRequestBody defines body for CreateSecurityGroup for application/json ContentType.
type CreateSecurityGroupJSONRequestBody = CreateSecurityGroup

// DeleteSecurityGroupRuleJSONRequestBody defines body for DeleteSecurityGroupRule for application/json ContentType.
type DeleteSecurityGroupRuleJSONRequestBody = DeleteSecurityGroupRule

// CreateSecurityGroupRuleJSONRequestBody defines body for CreateSecurityGroupRule for application/json ContentType.
type CreateSecurityGroupRuleJSONRequestBody = CreateSecurityGroupRule

// CreateServerCertificateJSONRequestBody defines body for CreateServerCertificate for application/json ContentType.
type CreateServerCertificateJSONRequestBody = CreateServerCertificate

// UpdateServerCertificateJSONRequestBody defines body for UpdateServerCertificate for application/json ContentType.
type UpdateServerCertificateJSONRequestBody = UpdateServerCertificate

// CreateSnapshotJSONRequestBody defines body for CreateSnapshot for application/json ContentType.
type CreateSnapshotJSONRequestBody = CreateSnapshot

// CreateSubnetJSONRequestBody defines body for CreateSubnet for application/json ContentType.
type CreateSubnetJSONRequestBody = CreateSubnet

// UpdateSubnetJSONRequestBody defines body for UpdateSubnet for application/json ContentType.
type UpdateSubnetJSONRequestBody = UpdateSubnet

// CreateVirtualGatewayJSONRequestBody defines body for CreateVirtualGateway for application/json ContentType.
type CreateVirtualGatewayJSONRequestBody = CreateVirtualGateway

// LinkVirtualGatewayToVpcJSONRequestBody defines body for LinkVirtualGatewayToVpc for application/json ContentType.
type LinkVirtualGatewayToVpcJSONRequestBody LinkVirtualGatewayToVpcJSONBody

// UnlinkVirtualGatewayToVpcJSONRequestBody defines body for UnlinkVirtualGatewayToVpc for application/json ContentType.
type UnlinkVirtualGatewayToVpcJSONRequestBody = UnlinkVirtualGatewayToVpc

// CreateVmsJSONRequestBody defines body for CreateVms for application/json ContentType.
type CreateVmsJSONRequestBody = CreateVms

// UpdateVmJSONRequestBody defines body for UpdateVm for application/json ContentType.
type UpdateVmJSONRequestBody = UpdateVm

// StopVmJSONRequestBody defines body for StopVm for application/json ContentType.
type StopVmJSONRequestBody = StopVm

// CreateVolumeJSONRequestBody defines body for CreateVolume for application/json ContentType.
type CreateVolumeJSONRequestBody = CreateVolume

// UpdateVolumeJSONRequestBody defines body for UpdateVolume for application/json ContentType.
type UpdateVolumeJSONRequestBody = UpdateVolume

// LinkVolumeJSONRequestBody defines body for LinkVolume for application/json ContentType.
type LinkVolumeJSONRequestBody = LinkVolume

// UnlinkVolumeJSONRequestBody defines body for UnlinkVolume for application/json ContentType.
type UnlinkVolumeJSONRequestBody = UnlinkVolume

// CreateVpcPeeringJSONRequestBody defines body for CreateVpcPeering for application/json ContentType.
type CreateVpcPeeringJSONRequestBody = CreateVpcPeering

// CreateVpcJSONRequestBody defines body for CreateVpc for application/json ContentType.
type CreateVpcJSONRequestBody = CreateVpc

// UpdateVpcJSONRequestBody defines body for UpdateVpc for application/json ContentType.
type UpdateVpcJSONRequestBody = UpdateVpc

// CreateVpnConnectionJSONRequestBody defines body for CreateVpnConnection for application/json ContentType.
type CreateVpnConnectionJSONRequestBody = CreateVpnConnection

// UpdateVpnConnectionJSONRequestBody defines body for UpdateVpnConnection for application/json ContentType.
type UpdateVpnConnectionJSONRequestBody = UpdateVpnConnection

// DeleteVpnConnectionRouteJSONRequestBody defines body for DeleteVpnConnectionRoute for application/json ContentType.
type DeleteVpnConnectionRouteJSONRequestBody = DeleteVpnConnectionRoute

// CreateVpnConnectionRouteJSONRequestBody defines body for CreateVpnConnectionRoute for application/json ContentType.
type CreateVpnConnectionRouteJSONRequestBody = CreateVpnConnectionRoute

// CreateAdminServiceAccountSpaceJSONRequestBody defines body for CreateAdminServiceAccountSpace for application/json ContentType.
type CreateAdminServiceAccountSpaceJSONRequestBody = ServiceAccount

// UpdateLoginFlowJSONRequestBody defines body for UpdateLoginFlow for application/json ContentType.
type UpdateLoginFlowJSONRequestBody = UpdateLoginFlowBody

// UpdateLoginFlowFormdataRequestBody defines body for UpdateLoginFlow for application/x-www-form-urlencoded ContentType.
type UpdateLoginFlowFormdataRequestBody = UpdateLoginFlowBody

// PerformNativeLogoutJSONRequestBody defines body for PerformNativeLogout for application/json ContentType.
type PerformNativeLogoutJSONRequestBody = PerformNativeLogoutBody

// UpdateRecoveryFlowJSONRequestBody defines body for UpdateRecoveryFlow for application/json ContentType.
type UpdateRecoveryFlowJSONRequestBody = UpdateRecoveryFlowBody

// UpdateRecoveryFlowFormdataRequestBody defines body for UpdateRecoveryFlow for application/x-www-form-urlencoded ContentType.
type UpdateRecoveryFlowFormdataRequestBody = UpdateRecoveryFlowBody

// UpdateRegistrationFlowJSONRequestBody defines body for UpdateRegistrationFlow for application/json ContentType.
type UpdateRegistrationFlowJSONRequestBody = UpdateRegistrationFlowBody

// UpdateRegistrationFlowFormdataRequestBody defines body for UpdateRegistrationFlow for application/x-www-form-urlencoded ContentType.
type UpdateRegistrationFlowFormdataRequestBody = UpdateRegistrationFlowBody

// UpdateSettingsFloJSONRequestBody defines body for UpdateSettingsFlo for application/json ContentType.
type UpdateSettingsFloJSONRequestBody = UpdateSettingsFlowBody

// UpdateSettingsFloFormdataRequestBody defines body for UpdateSettingsFlo for application/x-www-form-urlencoded ContentType.
type UpdateSettingsFloFormdataRequestBody = UpdateSettingsFlowBody

// UpdateVerificationFlowJSONRequestBody defines body for UpdateVerificationFlow for application/json ContentType.
type UpdateVerificationFlowJSONRequestBody = UpdateVerificationFlowBody

// UpdateVerificationFlowFormdataRequestBody defines body for UpdateVerificationFlow for application/x-www-form-urlencoded ContentType.
type UpdateVerificationFlowFormdataRequestBody = UpdateVerificationFlowBody

// IntrospectFormdataRequestBody defines body for Introspect for application/x-www-form-urlencoded ContentType.
type IntrospectFormdataRequestBody = TokenBody

// SetIAMGranularPolicyOrganisationJSONRequestBody defines body for SetIAMGranularPolicyOrganisation for application/json ContentType.
type SetIAMGranularPolicyOrganisationJSONRequestBody SetIAMGranularPolicyOrganisationJSONBody

// SetIAMPolicyOrganisationJSONRequestBody defines body for SetIAMPolicyOrganisation for application/json ContentType.
type SetIAMPolicyOrganisationJSONRequestBody SetIAMPolicyOrganisationJSONBody

// CreateRoleOrganisationJSONRequestBody defines body for CreateRoleOrganisation for application/json ContentType.
type CreateRoleOrganisationJSONRequestBody = Role

// UpdateRoleOrganisationJSONRequestBody defines body for UpdateRoleOrganisation for application/json ContentType.
type UpdateRoleOrganisationJSONRequestBody UpdateRoleOrganisationJSONBody

// RemoveRolePermissionsOrganisationJSONRequestBody defines body for RemoveRolePermissionsOrganisation for application/json ContentType.
type RemoveRolePermissionsOrganisationJSONRequestBody = RolePermission

// AddRolePermissionsOrganisationJSONRequestBody defines body for AddRolePermissionsOrganisation for application/json ContentType.
type AddRolePermissionsOrganisationJSONRequestBody = RolePermission

// ListServiceAccountOrganisationJSONRequestBody defines body for ListServiceAccountOrganisation for application/json ContentType.
type ListServiceAccountOrganisationJSONRequestBody = IdentitiesIdsList

// CreateServiceAccountOrganisationJSONRequestBody defines body for CreateServiceAccountOrganisation for application/json ContentType.
type CreateServiceAccountOrganisationJSONRequestBody = ServiceAccount

// UpdateServiceAccountOrganisationJSONRequestBody defines body for UpdateServiceAccountOrganisation for application/json ContentType.
type UpdateServiceAccountOrganisationJSONRequestBody = ServiceAccount

// DeleteACLServiceAccountOrganisationBulkJSONRequestBody defines body for DeleteACLServiceAccountOrganisationBulk for application/json ContentType.
type DeleteACLServiceAccountOrganisationBulkJSONRequestBody = ACLList

// CreateACLServiceAccountOrganisationBulkJSONRequestBody defines body for CreateACLServiceAccountOrganisationBulk for application/json ContentType.
type CreateACLServiceAccountOrganisationBulkJSONRequestBody = ACLList

// ListUserOrganisationJSONRequestBody defines body for ListUserOrganisation for application/json ContentType.
type ListUserOrganisationJSONRequestBody = IdentitiesIdsList

// CreateUserOrganisationJSONRequestBody defines body for CreateUserOrganisation for application/json ContentType.
type CreateUserOrganisationJSONRequestBody = User

// PatchUserStateOrganisationJSONRequestBody defines body for PatchUserStateOrganisation for application/json ContentType.
type PatchUserStateOrganisationJSONRequestBody = UserState

// UpdateUserOrganisationJSONRequestBody defines body for UpdateUserOrganisation for application/json ContentType.
type UpdateUserOrganisationJSONRequestBody = UserUpdate

// DeleteACLUserOrganisationBulkJSONRequestBody defines body for DeleteACLUserOrganisationBulk for application/json ContentType.
type DeleteACLUserOrganisationBulkJSONRequestBody = ACLList

// CreateACLUserOrganisationBulkJSONRequestBody defines body for CreateACLUserOrganisationBulk for application/json ContentType.
type CreateACLUserOrganisationBulkJSONRequestBody = ACLList

// RevokeFormdataRequestBody defines body for Revoke for application/x-www-form-urlencoded ContentType.
type RevokeFormdataRequestBody = TokenBody

// SetIAMGranularPolicySpaceJSONRequestBody defines body for SetIAMGranularPolicySpace for application/json ContentType.
type SetIAMGranularPolicySpaceJSONRequestBody SetIAMGranularPolicySpaceJSONBody

// SetIAMPolicySpaceJSONRequestBody defines body for SetIAMPolicySpace for application/json ContentType.
type SetIAMPolicySpaceJSONRequestBody SetIAMPolicySpaceJSONBody

// CreateRoleSpaceJSONRequestBody defines body for CreateRoleSpace for application/json ContentType.
type CreateRoleSpaceJSONRequestBody = Role

// UpdateRoleSpaceJSONRequestBody defines body for UpdateRoleSpace for application/json ContentType.
type UpdateRoleSpaceJSONRequestBody UpdateRoleSpaceJSONBody

// RemoveRolePermissionsSpaceJSONRequestBody defines body for RemoveRolePermissionsSpace for application/json ContentType.
type RemoveRolePermissionsSpaceJSONRequestBody = RolePermission

// AddRolePermissionsSpaceJSONRequestBody defines body for AddRolePermissionsSpace for application/json ContentType.
type AddRolePermissionsSpaceJSONRequestBody = RolePermission

// ListServiceAccountSpaceJSONRequestBody defines body for ListServiceAccountSpace for application/json ContentType.
type ListServiceAccountSpaceJSONRequestBody = IdentitiesIdsList

// CreateServiceAccountSpaceJSONRequestBody defines body for CreateServiceAccountSpace for application/json ContentType.
type CreateServiceAccountSpaceJSONRequestBody = ServiceAccount

// UpdateServiceAccountSpaceJSONRequestBody defines body for UpdateServiceAccountSpace for application/json ContentType.
type UpdateServiceAccountSpaceJSONRequestBody = ServiceAccount

// DeleteACLServiceAccountSpaceBulkJSONRequestBody defines body for DeleteACLServiceAccountSpaceBulk for application/json ContentType.
type DeleteACLServiceAccountSpaceBulkJSONRequestBody = ACLList

// CreateACLServiceAccountSpaceBulkJSONRequestBody defines body for CreateACLServiceAccountSpaceBulk for application/json ContentType.
type CreateACLServiceAccountSpaceBulkJSONRequestBody = ACLList

// ListUserSpaceJSONRequestBody defines body for ListUserSpace for application/json ContentType.
type ListUserSpaceJSONRequestBody = IdentitiesIdsList

// CreateUserSpaceJSONRequestBody defines body for CreateUserSpace for application/json ContentType.
type CreateUserSpaceJSONRequestBody = User

// PatchUserStateSpaceJSONRequestBody defines body for PatchUserStateSpace for application/json ContentType.
type PatchUserStateSpaceJSONRequestBody = UserState

// UpdateUserSpaceJSONRequestBody defines body for UpdateUserSpace for application/json ContentType.
type UpdateUserSpaceJSONRequestBody = UserUpdate

// DeleteACLUserSpaceBulkJSONRequestBody defines body for DeleteACLUserSpaceBulk for application/json ContentType.
type DeleteACLUserSpaceBulkJSONRequestBody = ACLList

// CreateACLUserSpaceBulkJSONRequestBody defines body for CreateACLUserSpaceBulk for application/json ContentType.
type CreateACLUserSpaceBulkJSONRequestBody = ACLList

// TokenFormdataRequestBody defines body for Token for application/x-www-form-urlencoded ContentType.
type TokenFormdataRequestBody = TokenReq

// CreateKubernetesClusterJSONRequestBody defines body for CreateKubernetesCluster for application/json ContentType.
type CreateKubernetesClusterJSONRequestBody = KubernetesClusterConfiguration

// UpgradeMastersJSONRequestBody defines body for UpgradeMasters for application/json ContentType.
type UpgradeMastersJSONRequestBody = KubernetesNodeUpgrade

// AddNodesJSONRequestBody defines body for AddNodes for application/json ContentType.
type AddNodesJSONRequestBody = KubernetesNodeOrder

// RemoveNodesJSONRequestBody defines body for RemoveNodes for application/json ContentType.
type RemoveNodesJSONRequestBody = KubernetesNodeRemoval

// UpgradeNodesJSONRequestBody defines body for UpgradeNodes for application/json ContentType.
type UpgradeNodesJSONRequestBody = KubernetesNodeUpgrade

// CreateClusterJSONRequestBody defines body for CreateCluster for application/json ContentType.
type CreateClusterJSONRequestBody = CreateCluster

// UpdateClusterJSONRequestBody defines body for UpdateCluster for application/json ContentType.
type UpdateClusterJSONRequestBody = UpdateCluster

// CreateNodePoolJSONRequestBody defines body for CreateNodePool for application/json ContentType.
type CreateNodePoolJSONRequestBody = CreateNodepool

// UpdateNodepoolJSONRequestBody defines body for UpdateNodepool for application/json ContentType.
type UpdateNodepoolJSONRequestBody = ReqUpdateNodepool

// ListSpacesJSONRequestBody defines body for ListSpaces for application/json ContentType.
type ListSpacesJSONRequestBody = SpaceIdsList

// CreateSpaceJSONRequestBody defines body for CreateSpace for application/json ContentType.
type CreateSpaceJSONRequestBody = CreateSpace

// UpdateSpaceJSONRequestBody defines body for UpdateSpace for application/json ContentType.
type UpdateSpaceJSONRequestBody = MutableSpace

// AsContinueWithVerificationUi returns the union data inside the ContinueWith as a ContinueWithVerificationUi
func (t ContinueWith) AsContinueWithVerificationUi() (ContinueWithVerificationUi, error) {
	var body ContinueWithVerificationUi
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContinueWithVerificationUi overwrites any union data inside the ContinueWith as the provided ContinueWithVerificationUi
func (t *ContinueWith) FromContinueWithVerificationUi(v ContinueWithVerificationUi) error {
	v.Action = "show_verification_ui"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContinueWithVerificationUi performs a merge with any union data inside the ContinueWith, using the provided ContinueWithVerificationUi
func (t *ContinueWith) MergeContinueWithVerificationUi(v ContinueWithVerificationUi) error {
	v.Action = "show_verification_ui"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContinueWithSetSessionToken returns the union data inside the ContinueWith as a ContinueWithSetSessionToken
func (t ContinueWith) AsContinueWithSetSessionToken() (ContinueWithSetSessionToken, error) {
	var body ContinueWithSetSessionToken
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContinueWithSetSessionToken overwrites any union data inside the ContinueWith as the provided ContinueWithSetSessionToken
func (t *ContinueWith) FromContinueWithSetSessionToken(v ContinueWithSetSessionToken) error {
	v.Action = "set_session_token"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContinueWithSetSessionToken performs a merge with any union data inside the ContinueWith, using the provided ContinueWithSetSessionToken
func (t *ContinueWith) MergeContinueWithSetSessionToken(v ContinueWithSetSessionToken) error {
	v.Action = "set_session_token"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContinueWithSettingsUi returns the union data inside the ContinueWith as a ContinueWithSettingsUi
func (t ContinueWith) AsContinueWithSettingsUi() (ContinueWithSettingsUi, error) {
	var body ContinueWithSettingsUi
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContinueWithSettingsUi overwrites any union data inside the ContinueWith as the provided ContinueWithSettingsUi
func (t *ContinueWith) FromContinueWithSettingsUi(v ContinueWithSettingsUi) error {
	v.Action = "show_settings_ui"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContinueWithSettingsUi performs a merge with any union data inside the ContinueWith, using the provided ContinueWithSettingsUi
func (t *ContinueWith) MergeContinueWithSettingsUi(v ContinueWithSettingsUi) error {
	v.Action = "show_settings_ui"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContinueWithRecoveryUi returns the union data inside the ContinueWith as a ContinueWithRecoveryUi
func (t ContinueWith) AsContinueWithRecoveryUi() (ContinueWithRecoveryUi, error) {
	var body ContinueWithRecoveryUi
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContinueWithRecoveryUi overwrites any union data inside the ContinueWith as the provided ContinueWithRecoveryUi
func (t *ContinueWith) FromContinueWithRecoveryUi(v ContinueWithRecoveryUi) error {
	v.Action = "show_recovery_ui"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContinueWithRecoveryUi performs a merge with any union data inside the ContinueWith, using the provided ContinueWithRecoveryUi
func (t *ContinueWith) MergeContinueWithRecoveryUi(v ContinueWithRecoveryUi) error {
	v.Action = "show_recovery_ui"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ContinueWith) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"action"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ContinueWith) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "set_session_token":
		return t.AsContinueWithSetSessionToken()
	case "show_recovery_ui":
		return t.AsContinueWithRecoveryUi()
	case "show_settings_ui":
		return t.AsContinueWithSettingsUi()
	case "show_verification_ui":
		return t.AsContinueWithVerificationUi()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ContinueWith) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ContinueWith) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOperationData0 returns the union data inside the Operation_Data as a OperationData0
func (t Operation_Data) AsOperationData0() (OperationData0, error) {
	var body OperationData0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOperationData0 overwrites any union data inside the Operation_Data as the provided OperationData0
func (t *Operation_Data) FromOperationData0(v OperationData0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOperationData0 performs a merge with any union data inside the Operation_Data, using the provided OperationData0
func (t *Operation_Data) MergeOperationData0(v OperationData0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOperationData1 returns the union data inside the Operation_Data as a OperationData1
func (t Operation_Data) AsOperationData1() (OperationData1, error) {
	var body OperationData1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOperationData1 overwrites any union data inside the Operation_Data as the provided OperationData1
func (t *Operation_Data) FromOperationData1(v OperationData1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOperationData1 performs a merge with any union data inside the Operation_Data, using the provided OperationData1
func (t *Operation_Data) MergeOperationData1(v OperationData1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Operation_Data) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Operation_Data) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOperationError0 returns the union data inside the Operation_Error as a OperationError0
func (t Operation_Error) AsOperationError0() (OperationError0, error) {
	var body OperationError0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOperationError0 overwrites any union data inside the Operation_Error as the provided OperationError0
func (t *Operation_Error) FromOperationError0(v OperationError0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOperationError0 performs a merge with any union data inside the Operation_Error, using the provided OperationError0
func (t *Operation_Error) MergeOperationError0(v OperationError0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOperationError1 returns the union data inside the Operation_Error as a OperationError1
func (t Operation_Error) AsOperationError1() (OperationError1, error) {
	var body OperationError1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOperationError1 overwrites any union data inside the Operation_Error as the provided OperationError1
func (t *Operation_Error) FromOperationError1(v OperationError1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOperationError1 performs a merge with any union data inside the Operation_Error, using the provided OperationError1
func (t *Operation_Error) MergeOperationError1(v OperationError1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Operation_Error) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Operation_Error) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOperationProgress0 returns the union data inside the Operation_Progress as a OperationProgress0
func (t Operation_Progress) AsOperationProgress0() (OperationProgress0, error) {
	var body OperationProgress0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOperationProgress0 overwrites any union data inside the Operation_Progress as the provided OperationProgress0
func (t *Operation_Progress) FromOperationProgress0(v OperationProgress0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOperationProgress0 performs a merge with any union data inside the Operation_Progress, using the provided OperationProgress0
func (t *Operation_Progress) MergeOperationProgress0(v OperationProgress0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOperationProgress1 returns the union data inside the Operation_Progress as a OperationProgress1
func (t Operation_Progress) AsOperationProgress1() (OperationProgress1, error) {
	var body OperationProgress1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOperationProgress1 overwrites any union data inside the Operation_Progress as the provided OperationProgress1
func (t *Operation_Progress) FromOperationProgress1(v OperationProgress1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOperationProgress1 performs a merge with any union data inside the Operation_Progress, using the provided OperationProgress1
func (t *Operation_Progress) MergeOperationProgress1(v OperationProgress1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Operation_Progress) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Operation_Progress) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOperationResult0 returns the union data inside the Operation_Result as a OperationResult0
func (t Operation_Result) AsOperationResult0() (OperationResult0, error) {
	var body OperationResult0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOperationResult0 overwrites any union data inside the Operation_Result as the provided OperationResult0
func (t *Operation_Result) FromOperationResult0(v OperationResult0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOperationResult0 performs a merge with any union data inside the Operation_Result, using the provided OperationResult0
func (t *Operation_Result) MergeOperationResult0(v OperationResult0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOperationResult1 returns the union data inside the Operation_Result as a OperationResult1
func (t Operation_Result) AsOperationResult1() (OperationResult1, error) {
	var body OperationResult1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOperationResult1 overwrites any union data inside the Operation_Result as the provided OperationResult1
func (t *Operation_Result) FromOperationResult1(v OperationResult1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOperationResult1 performs a merge with any union data inside the Operation_Result, using the provided OperationResult1
func (t *Operation_Result) MergeOperationResult1(v OperationResult1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Operation_Result) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Operation_Result) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUiNodeInputAttributes returns the union data inside the UiNodeAttributes as a UiNodeInputAttributes
func (t UiNodeAttributes) AsUiNodeInputAttributes() (UiNodeInputAttributes, error) {
	var body UiNodeInputAttributes
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUiNodeInputAttributes overwrites any union data inside the UiNodeAttributes as the provided UiNodeInputAttributes
func (t *UiNodeAttributes) FromUiNodeInputAttributes(v UiNodeInputAttributes) error {
	v.NodeType = "input"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUiNodeInputAttributes performs a merge with any union data inside the UiNodeAttributes, using the provided UiNodeInputAttributes
func (t *UiNodeAttributes) MergeUiNodeInputAttributes(v UiNodeInputAttributes) error {
	v.NodeType = "input"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUiNodeTextAttributes returns the union data inside the UiNodeAttributes as a UiNodeTextAttributes
func (t UiNodeAttributes) AsUiNodeTextAttributes() (UiNodeTextAttributes, error) {
	var body UiNodeTextAttributes
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUiNodeTextAttributes overwrites any union data inside the UiNodeAttributes as the provided UiNodeTextAttributes
func (t *UiNodeAttributes) FromUiNodeTextAttributes(v UiNodeTextAttributes) error {
	v.NodeType = "text"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUiNodeTextAttributes performs a merge with any union data inside the UiNodeAttributes, using the provided UiNodeTextAttributes
func (t *UiNodeAttributes) MergeUiNodeTextAttributes(v UiNodeTextAttributes) error {
	v.NodeType = "text"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUiNodeImageAttributes returns the union data inside the UiNodeAttributes as a UiNodeImageAttributes
func (t UiNodeAttributes) AsUiNodeImageAttributes() (UiNodeImageAttributes, error) {
	var body UiNodeImageAttributes
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUiNodeImageAttributes overwrites any union data inside the UiNodeAttributes as the provided UiNodeImageAttributes
func (t *UiNodeAttributes) FromUiNodeImageAttributes(v UiNodeImageAttributes) error {
	v.NodeType = "img"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUiNodeImageAttributes performs a merge with any union data inside the UiNodeAttributes, using the provided UiNodeImageAttributes
func (t *UiNodeAttributes) MergeUiNodeImageAttributes(v UiNodeImageAttributes) error {
	v.NodeType = "img"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUiNodeAnchorAttributes returns the union data inside the UiNodeAttributes as a UiNodeAnchorAttributes
func (t UiNodeAttributes) AsUiNodeAnchorAttributes() (UiNodeAnchorAttributes, error) {
	var body UiNodeAnchorAttributes
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUiNodeAnchorAttributes overwrites any union data inside the UiNodeAttributes as the provided UiNodeAnchorAttributes
func (t *UiNodeAttributes) FromUiNodeAnchorAttributes(v UiNodeAnchorAttributes) error {
	v.NodeType = "a"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUiNodeAnchorAttributes performs a merge with any union data inside the UiNodeAttributes, using the provided UiNodeAnchorAttributes
func (t *UiNodeAttributes) MergeUiNodeAnchorAttributes(v UiNodeAnchorAttributes) error {
	v.NodeType = "a"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUiNodeScriptAttributes returns the union data inside the UiNodeAttributes as a UiNodeScriptAttributes
func (t UiNodeAttributes) AsUiNodeScriptAttributes() (UiNodeScriptAttributes, error) {
	var body UiNodeScriptAttributes
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUiNodeScriptAttributes overwrites any union data inside the UiNodeAttributes as the provided UiNodeScriptAttributes
func (t *UiNodeAttributes) FromUiNodeScriptAttributes(v UiNodeScriptAttributes) error {
	v.NodeType = "script"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUiNodeScriptAttributes performs a merge with any union data inside the UiNodeAttributes, using the provided UiNodeScriptAttributes
func (t *UiNodeAttributes) MergeUiNodeScriptAttributes(v UiNodeScriptAttributes) error {
	v.NodeType = "script"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UiNodeAttributes) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"node_type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t UiNodeAttributes) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "a":
		return t.AsUiNodeAnchorAttributes()
	case "img":
		return t.AsUiNodeImageAttributes()
	case "input":
		return t.AsUiNodeInputAttributes()
	case "script":
		return t.AsUiNodeScriptAttributes()
	case "text":
		return t.AsUiNodeTextAttributes()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t UiNodeAttributes) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UiNodeAttributes) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUpdateLoginFlowWithPasswordMethod returns the union data inside the UpdateLoginFlowBody as a UpdateLoginFlowWithPasswordMethod
func (t UpdateLoginFlowBody) AsUpdateLoginFlowWithPasswordMethod() (UpdateLoginFlowWithPasswordMethod, error) {
	var body UpdateLoginFlowWithPasswordMethod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateLoginFlowWithPasswordMethod overwrites any union data inside the UpdateLoginFlowBody as the provided UpdateLoginFlowWithPasswordMethod
func (t *UpdateLoginFlowBody) FromUpdateLoginFlowWithPasswordMethod(v UpdateLoginFlowWithPasswordMethod) error {
	v.Method = "password"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateLoginFlowWithPasswordMethod performs a merge with any union data inside the UpdateLoginFlowBody, using the provided UpdateLoginFlowWithPasswordMethod
func (t *UpdateLoginFlowBody) MergeUpdateLoginFlowWithPasswordMethod(v UpdateLoginFlowWithPasswordMethod) error {
	v.Method = "password"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateLoginFlowWithOidcMethod returns the union data inside the UpdateLoginFlowBody as a UpdateLoginFlowWithOidcMethod
func (t UpdateLoginFlowBody) AsUpdateLoginFlowWithOidcMethod() (UpdateLoginFlowWithOidcMethod, error) {
	var body UpdateLoginFlowWithOidcMethod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateLoginFlowWithOidcMethod overwrites any union data inside the UpdateLoginFlowBody as the provided UpdateLoginFlowWithOidcMethod
func (t *UpdateLoginFlowBody) FromUpdateLoginFlowWithOidcMethod(v UpdateLoginFlowWithOidcMethod) error {
	v.Method = "oidc"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateLoginFlowWithOidcMethod performs a merge with any union data inside the UpdateLoginFlowBody, using the provided UpdateLoginFlowWithOidcMethod
func (t *UpdateLoginFlowBody) MergeUpdateLoginFlowWithOidcMethod(v UpdateLoginFlowWithOidcMethod) error {
	v.Method = "oidc"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateLoginFlowWithTotpMethod returns the union data inside the UpdateLoginFlowBody as a UpdateLoginFlowWithTotpMethod
func (t UpdateLoginFlowBody) AsUpdateLoginFlowWithTotpMethod() (UpdateLoginFlowWithTotpMethod, error) {
	var body UpdateLoginFlowWithTotpMethod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateLoginFlowWithTotpMethod overwrites any union data inside the UpdateLoginFlowBody as the provided UpdateLoginFlowWithTotpMethod
func (t *UpdateLoginFlowBody) FromUpdateLoginFlowWithTotpMethod(v UpdateLoginFlowWithTotpMethod) error {
	v.Method = "totp"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateLoginFlowWithTotpMethod performs a merge with any union data inside the UpdateLoginFlowBody, using the provided UpdateLoginFlowWithTotpMethod
func (t *UpdateLoginFlowBody) MergeUpdateLoginFlowWithTotpMethod(v UpdateLoginFlowWithTotpMethod) error {
	v.Method = "totp"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateLoginFlowWithWebAuthnMethod returns the union data inside the UpdateLoginFlowBody as a UpdateLoginFlowWithWebAuthnMethod
func (t UpdateLoginFlowBody) AsUpdateLoginFlowWithWebAuthnMethod() (UpdateLoginFlowWithWebAuthnMethod, error) {
	var body UpdateLoginFlowWithWebAuthnMethod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateLoginFlowWithWebAuthnMethod overwrites any union data inside the UpdateLoginFlowBody as the provided UpdateLoginFlowWithWebAuthnMethod
func (t *UpdateLoginFlowBody) FromUpdateLoginFlowWithWebAuthnMethod(v UpdateLoginFlowWithWebAuthnMethod) error {
	v.Method = "webauthn"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateLoginFlowWithWebAuthnMethod performs a merge with any union data inside the UpdateLoginFlowBody, using the provided UpdateLoginFlowWithWebAuthnMethod
func (t *UpdateLoginFlowBody) MergeUpdateLoginFlowWithWebAuthnMethod(v UpdateLoginFlowWithWebAuthnMethod) error {
	v.Method = "webauthn"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateLoginFlowWithLookupSecretMethod returns the union data inside the UpdateLoginFlowBody as a UpdateLoginFlowWithLookupSecretMethod
func (t UpdateLoginFlowBody) AsUpdateLoginFlowWithLookupSecretMethod() (UpdateLoginFlowWithLookupSecretMethod, error) {
	var body UpdateLoginFlowWithLookupSecretMethod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateLoginFlowWithLookupSecretMethod overwrites any union data inside the UpdateLoginFlowBody as the provided UpdateLoginFlowWithLookupSecretMethod
func (t *UpdateLoginFlowBody) FromUpdateLoginFlowWithLookupSecretMethod(v UpdateLoginFlowWithLookupSecretMethod) error {
	v.Method = "lookup_secret"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateLoginFlowWithLookupSecretMethod performs a merge with any union data inside the UpdateLoginFlowBody, using the provided UpdateLoginFlowWithLookupSecretMethod
func (t *UpdateLoginFlowBody) MergeUpdateLoginFlowWithLookupSecretMethod(v UpdateLoginFlowWithLookupSecretMethod) error {
	v.Method = "lookup_secret"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateLoginFlowWithCodeMethod returns the union data inside the UpdateLoginFlowBody as a UpdateLoginFlowWithCodeMethod
func (t UpdateLoginFlowBody) AsUpdateLoginFlowWithCodeMethod() (UpdateLoginFlowWithCodeMethod, error) {
	var body UpdateLoginFlowWithCodeMethod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateLoginFlowWithCodeMethod overwrites any union data inside the UpdateLoginFlowBody as the provided UpdateLoginFlowWithCodeMethod
func (t *UpdateLoginFlowBody) FromUpdateLoginFlowWithCodeMethod(v UpdateLoginFlowWithCodeMethod) error {
	v.Method = "code"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateLoginFlowWithCodeMethod performs a merge with any union data inside the UpdateLoginFlowBody, using the provided UpdateLoginFlowWithCodeMethod
func (t *UpdateLoginFlowBody) MergeUpdateLoginFlowWithCodeMethod(v UpdateLoginFlowWithCodeMethod) error {
	v.Method = "code"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateLoginFlowBody) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"method"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t UpdateLoginFlowBody) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "code":
		return t.AsUpdateLoginFlowWithCodeMethod()
	case "lookup_secret":
		return t.AsUpdateLoginFlowWithLookupSecretMethod()
	case "oidc":
		return t.AsUpdateLoginFlowWithOidcMethod()
	case "password":
		return t.AsUpdateLoginFlowWithPasswordMethod()
	case "totp":
		return t.AsUpdateLoginFlowWithTotpMethod()
	case "webauthn":
		return t.AsUpdateLoginFlowWithWebAuthnMethod()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t UpdateLoginFlowBody) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateLoginFlowBody) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUpdateRecoveryFlowWithLinkMethod returns the union data inside the UpdateRecoveryFlowBody as a UpdateRecoveryFlowWithLinkMethod
func (t UpdateRecoveryFlowBody) AsUpdateRecoveryFlowWithLinkMethod() (UpdateRecoveryFlowWithLinkMethod, error) {
	var body UpdateRecoveryFlowWithLinkMethod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateRecoveryFlowWithLinkMethod overwrites any union data inside the UpdateRecoveryFlowBody as the provided UpdateRecoveryFlowWithLinkMethod
func (t *UpdateRecoveryFlowBody) FromUpdateRecoveryFlowWithLinkMethod(v UpdateRecoveryFlowWithLinkMethod) error {
	v.Method = "link"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateRecoveryFlowWithLinkMethod performs a merge with any union data inside the UpdateRecoveryFlowBody, using the provided UpdateRecoveryFlowWithLinkMethod
func (t *UpdateRecoveryFlowBody) MergeUpdateRecoveryFlowWithLinkMethod(v UpdateRecoveryFlowWithLinkMethod) error {
	v.Method = "link"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateRecoveryFlowWithCodeMethod returns the union data inside the UpdateRecoveryFlowBody as a UpdateRecoveryFlowWithCodeMethod
func (t UpdateRecoveryFlowBody) AsUpdateRecoveryFlowWithCodeMethod() (UpdateRecoveryFlowWithCodeMethod, error) {
	var body UpdateRecoveryFlowWithCodeMethod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateRecoveryFlowWithCodeMethod overwrites any union data inside the UpdateRecoveryFlowBody as the provided UpdateRecoveryFlowWithCodeMethod
func (t *UpdateRecoveryFlowBody) FromUpdateRecoveryFlowWithCodeMethod(v UpdateRecoveryFlowWithCodeMethod) error {
	v.Method = "code"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateRecoveryFlowWithCodeMethod performs a merge with any union data inside the UpdateRecoveryFlowBody, using the provided UpdateRecoveryFlowWithCodeMethod
func (t *UpdateRecoveryFlowBody) MergeUpdateRecoveryFlowWithCodeMethod(v UpdateRecoveryFlowWithCodeMethod) error {
	v.Method = "code"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateRecoveryFlowBody) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"method"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t UpdateRecoveryFlowBody) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "code":
		return t.AsUpdateRecoveryFlowWithCodeMethod()
	case "link":
		return t.AsUpdateRecoveryFlowWithLinkMethod()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t UpdateRecoveryFlowBody) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateRecoveryFlowBody) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUpdateRegistrationFlowWithPasswordMethod returns the union data inside the UpdateRegistrationFlowBody as a UpdateRegistrationFlowWithPasswordMethod
func (t UpdateRegistrationFlowBody) AsUpdateRegistrationFlowWithPasswordMethod() (UpdateRegistrationFlowWithPasswordMethod, error) {
	var body UpdateRegistrationFlowWithPasswordMethod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateRegistrationFlowWithPasswordMethod overwrites any union data inside the UpdateRegistrationFlowBody as the provided UpdateRegistrationFlowWithPasswordMethod
func (t *UpdateRegistrationFlowBody) FromUpdateRegistrationFlowWithPasswordMethod(v UpdateRegistrationFlowWithPasswordMethod) error {
	v.Method = "password"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateRegistrationFlowWithPasswordMethod performs a merge with any union data inside the UpdateRegistrationFlowBody, using the provided UpdateRegistrationFlowWithPasswordMethod
func (t *UpdateRegistrationFlowBody) MergeUpdateRegistrationFlowWithPasswordMethod(v UpdateRegistrationFlowWithPasswordMethod) error {
	v.Method = "password"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateRegistrationFlowWithOidcMethod returns the union data inside the UpdateRegistrationFlowBody as a UpdateRegistrationFlowWithOidcMethod
func (t UpdateRegistrationFlowBody) AsUpdateRegistrationFlowWithOidcMethod() (UpdateRegistrationFlowWithOidcMethod, error) {
	var body UpdateRegistrationFlowWithOidcMethod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateRegistrationFlowWithOidcMethod overwrites any union data inside the UpdateRegistrationFlowBody as the provided UpdateRegistrationFlowWithOidcMethod
func (t *UpdateRegistrationFlowBody) FromUpdateRegistrationFlowWithOidcMethod(v UpdateRegistrationFlowWithOidcMethod) error {
	v.Method = "oidc"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateRegistrationFlowWithOidcMethod performs a merge with any union data inside the UpdateRegistrationFlowBody, using the provided UpdateRegistrationFlowWithOidcMethod
func (t *UpdateRegistrationFlowBody) MergeUpdateRegistrationFlowWithOidcMethod(v UpdateRegistrationFlowWithOidcMethod) error {
	v.Method = "oidc"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateRegistrationFlowWithWebAuthnMethod returns the union data inside the UpdateRegistrationFlowBody as a UpdateRegistrationFlowWithWebAuthnMethod
func (t UpdateRegistrationFlowBody) AsUpdateRegistrationFlowWithWebAuthnMethod() (UpdateRegistrationFlowWithWebAuthnMethod, error) {
	var body UpdateRegistrationFlowWithWebAuthnMethod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateRegistrationFlowWithWebAuthnMethod overwrites any union data inside the UpdateRegistrationFlowBody as the provided UpdateRegistrationFlowWithWebAuthnMethod
func (t *UpdateRegistrationFlowBody) FromUpdateRegistrationFlowWithWebAuthnMethod(v UpdateRegistrationFlowWithWebAuthnMethod) error {
	v.Method = "webauthn"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateRegistrationFlowWithWebAuthnMethod performs a merge with any union data inside the UpdateRegistrationFlowBody, using the provided UpdateRegistrationFlowWithWebAuthnMethod
func (t *UpdateRegistrationFlowBody) MergeUpdateRegistrationFlowWithWebAuthnMethod(v UpdateRegistrationFlowWithWebAuthnMethod) error {
	v.Method = "webauthn"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateRegistrationFlowWithCodeMethod returns the union data inside the UpdateRegistrationFlowBody as a UpdateRegistrationFlowWithCodeMethod
func (t UpdateRegistrationFlowBody) AsUpdateRegistrationFlowWithCodeMethod() (UpdateRegistrationFlowWithCodeMethod, error) {
	var body UpdateRegistrationFlowWithCodeMethod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateRegistrationFlowWithCodeMethod overwrites any union data inside the UpdateRegistrationFlowBody as the provided UpdateRegistrationFlowWithCodeMethod
func (t *UpdateRegistrationFlowBody) FromUpdateRegistrationFlowWithCodeMethod(v UpdateRegistrationFlowWithCodeMethod) error {
	v.Method = "code"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateRegistrationFlowWithCodeMethod performs a merge with any union data inside the UpdateRegistrationFlowBody, using the provided UpdateRegistrationFlowWithCodeMethod
func (t *UpdateRegistrationFlowBody) MergeUpdateRegistrationFlowWithCodeMethod(v UpdateRegistrationFlowWithCodeMethod) error {
	v.Method = "code"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateRegistrationFlowBody) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"method"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t UpdateRegistrationFlowBody) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "code":
		return t.AsUpdateRegistrationFlowWithCodeMethod()
	case "oidc":
		return t.AsUpdateRegistrationFlowWithOidcMethod()
	case "password":
		return t.AsUpdateRegistrationFlowWithPasswordMethod()
	case "webauthn":
		return t.AsUpdateRegistrationFlowWithWebAuthnMethod()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t UpdateRegistrationFlowBody) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateRegistrationFlowBody) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUpdateSettingsFlowWithPasswordMethod returns the union data inside the UpdateSettingsFlowBody as a UpdateSettingsFlowWithPasswordMethod
func (t UpdateSettingsFlowBody) AsUpdateSettingsFlowWithPasswordMethod() (UpdateSettingsFlowWithPasswordMethod, error) {
	var body UpdateSettingsFlowWithPasswordMethod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateSettingsFlowWithPasswordMethod overwrites any union data inside the UpdateSettingsFlowBody as the provided UpdateSettingsFlowWithPasswordMethod
func (t *UpdateSettingsFlowBody) FromUpdateSettingsFlowWithPasswordMethod(v UpdateSettingsFlowWithPasswordMethod) error {
	v.Method = "password"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateSettingsFlowWithPasswordMethod performs a merge with any union data inside the UpdateSettingsFlowBody, using the provided UpdateSettingsFlowWithPasswordMethod
func (t *UpdateSettingsFlowBody) MergeUpdateSettingsFlowWithPasswordMethod(v UpdateSettingsFlowWithPasswordMethod) error {
	v.Method = "password"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateSettingsFlowWithTotpMethod returns the union data inside the UpdateSettingsFlowBody as a UpdateSettingsFlowWithTotpMethod
func (t UpdateSettingsFlowBody) AsUpdateSettingsFlowWithTotpMethod() (UpdateSettingsFlowWithTotpMethod, error) {
	var body UpdateSettingsFlowWithTotpMethod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateSettingsFlowWithTotpMethod overwrites any union data inside the UpdateSettingsFlowBody as the provided UpdateSettingsFlowWithTotpMethod
func (t *UpdateSettingsFlowBody) FromUpdateSettingsFlowWithTotpMethod(v UpdateSettingsFlowWithTotpMethod) error {
	v.Method = "totp"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateSettingsFlowWithTotpMethod performs a merge with any union data inside the UpdateSettingsFlowBody, using the provided UpdateSettingsFlowWithTotpMethod
func (t *UpdateSettingsFlowBody) MergeUpdateSettingsFlowWithTotpMethod(v UpdateSettingsFlowWithTotpMethod) error {
	v.Method = "totp"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateSettingsFlowBody) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"method"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t UpdateSettingsFlowBody) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "password":
		return t.AsUpdateSettingsFlowWithPasswordMethod()
	case "totp":
		return t.AsUpdateSettingsFlowWithTotpMethod()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t UpdateSettingsFlowBody) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateSettingsFlowBody) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUpdateVerificationFlowWithLinkMethod returns the union data inside the UpdateVerificationFlowBody as a UpdateVerificationFlowWithLinkMethod
func (t UpdateVerificationFlowBody) AsUpdateVerificationFlowWithLinkMethod() (UpdateVerificationFlowWithLinkMethod, error) {
	var body UpdateVerificationFlowWithLinkMethod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateVerificationFlowWithLinkMethod overwrites any union data inside the UpdateVerificationFlowBody as the provided UpdateVerificationFlowWithLinkMethod
func (t *UpdateVerificationFlowBody) FromUpdateVerificationFlowWithLinkMethod(v UpdateVerificationFlowWithLinkMethod) error {
	v.Method = "link"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateVerificationFlowWithLinkMethod performs a merge with any union data inside the UpdateVerificationFlowBody, using the provided UpdateVerificationFlowWithLinkMethod
func (t *UpdateVerificationFlowBody) MergeUpdateVerificationFlowWithLinkMethod(v UpdateVerificationFlowWithLinkMethod) error {
	v.Method = "link"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateVerificationFlowWithCodeMethod returns the union data inside the UpdateVerificationFlowBody as a UpdateVerificationFlowWithCodeMethod
func (t UpdateVerificationFlowBody) AsUpdateVerificationFlowWithCodeMethod() (UpdateVerificationFlowWithCodeMethod, error) {
	var body UpdateVerificationFlowWithCodeMethod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateVerificationFlowWithCodeMethod overwrites any union data inside the UpdateVerificationFlowBody as the provided UpdateVerificationFlowWithCodeMethod
func (t *UpdateVerificationFlowBody) FromUpdateVerificationFlowWithCodeMethod(v UpdateVerificationFlowWithCodeMethod) error {
	v.Method = "code"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateVerificationFlowWithCodeMethod performs a merge with any union data inside the UpdateVerificationFlowBody, using the provided UpdateVerificationFlowWithCodeMethod
func (t *UpdateVerificationFlowBody) MergeUpdateVerificationFlowWithCodeMethod(v UpdateVerificationFlowWithCodeMethod) error {
	v.Method = "code"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateVerificationFlowBody) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"method"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t UpdateVerificationFlowBody) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "code":
		return t.AsUpdateVerificationFlowWithCodeMethod()
	case "link":
		return t.AsUpdateVerificationFlowWithLinkMethod()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t UpdateVerificationFlowBody) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateVerificationFlowBody) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// DeleteLoadBalancerTagsWithBody request with any body
	DeleteLoadBalancerTagsWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteLoadBalancerTags(ctx context.Context, spaceId SpaceId, body DeleteLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLoadBalancerTagsWithBody request with any body
	CreateLoadBalancerTagsWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLoadBalancerTags(ctx context.Context, spaceId SpaceId, body CreateLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTagsWithBody request with any body
	DeleteTagsWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteTags(ctx context.Context, spaceId SpaceId, body DeleteTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTagsWithBody request with any body
	CreateTagsWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTags(ctx context.Context, spaceId SpaceId, body CreateTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadClientGateways request
	ReadClientGateways(ctx context.Context, spaceId SpaceId, params *ReadClientGatewaysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateClientGatewayWithBody request with any body
	CreateClientGatewayWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateClientGateway(ctx context.Context, spaceId SpaceId, body CreateClientGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteClientGateway request
	DeleteClientGateway(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadClientGatewaysById request
	ReadClientGatewaysById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadDhcpOptions request
	ReadDhcpOptions(ctx context.Context, spaceId SpaceId, params *ReadDhcpOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDhcpOptionsWithBody request with any body
	CreateDhcpOptionsWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDhcpOptions(ctx context.Context, spaceId SpaceId, body CreateDhcpOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDhcpOptions request
	DeleteDhcpOptions(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadDhcpOptionsById request
	ReadDhcpOptionsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadFlexibleGpus request
	ReadFlexibleGpus(ctx context.Context, spaceId SpaceId, params *ReadFlexibleGpusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFlexibleGpuWithBody request with any body
	CreateFlexibleGpuWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFlexibleGpu(ctx context.Context, spaceId SpaceId, body CreateFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFlexibleGpu request
	DeleteFlexibleGpu(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadFlexibleGpusById request
	ReadFlexibleGpusById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateFlexibleGpuWithBody request with any body
	UpdateFlexibleGpuWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateFlexibleGpu(ctx context.Context, spaceId SpaceId, id string, body UpdateFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkFlexibleGpuWithBody request with any body
	LinkFlexibleGpuWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkFlexibleGpu(ctx context.Context, spaceId SpaceId, id string, body LinkFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkFlexibleGpu request
	UnlinkFlexibleGpu(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadImages request
	ReadImages(ctx context.Context, spaceId SpaceId, params *ReadImagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateImageWithBody request with any body
	CreateImageWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateImage(ctx context.Context, spaceId SpaceId, body CreateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteImage request
	DeleteImage(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadImagesById request
	ReadImagesById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateImageWithBody request with any body
	UpdateImageWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateImage(ctx context.Context, spaceId SpaceId, id string, body UpdateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadInternetGateways request
	ReadInternetGateways(ctx context.Context, spaceId SpaceId, params *ReadInternetGatewaysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateInternetGateway request
	CreateInternetGateway(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteInternetGateway request
	DeleteInternetGateway(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadInternetGatewaysById request
	ReadInternetGatewaysById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkInternetGatewayWithBody request with any body
	LinkInternetGatewayWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkInternetGateway(ctx context.Context, spaceId SpaceId, id string, body LinkInternetGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkInternetGatewayWithBody request with any body
	UnlinkInternetGatewayWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnlinkInternetGateway(ctx context.Context, spaceId SpaceId, id string, body UnlinkInternetGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadKeypairs request
	ReadKeypairs(ctx context.Context, spaceId SpaceId, params *ReadKeypairsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateKeypairWithBody request with any body
	CreateKeypairWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateKeypair(ctx context.Context, spaceId SpaceId, body CreateKeypairJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteKeypair request
	DeleteKeypair(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadKeypairsById request
	ReadKeypairsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadListenerRules request
	ReadListenerRules(ctx context.Context, spaceId SpaceId, params *ReadListenerRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateListenerRuleWithBody request with any body
	CreateListenerRuleWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateListenerRule(ctx context.Context, spaceId SpaceId, body CreateListenerRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteListenerRule request
	DeleteListenerRule(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadListenerRulesById request
	ReadListenerRulesById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateListenerRuleWithBody request with any body
	UpdateListenerRuleWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateListenerRule(ctx context.Context, spaceId SpaceId, id string, body UpdateListenerRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadLoadBalancers request
	ReadLoadBalancers(ctx context.Context, spaceId SpaceId, params *ReadLoadBalancersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLoadBalancerWithBody request with any body
	CreateLoadBalancerWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLoadBalancer(ctx context.Context, spaceId SpaceId, body CreateLoadBalancerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLoadBalancer request
	DeleteLoadBalancer(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadLoadBalancersById request
	ReadLoadBalancersById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateLoadBalancerWithBody request with any body
	UpdateLoadBalancerWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateLoadBalancer(ctx context.Context, spaceId SpaceId, id string, body UpdateLoadBalancerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkLoadBalancerBackendMachinesWithBody request with any body
	LinkLoadBalancerBackendMachinesWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkLoadBalancerBackendMachines(ctx context.Context, spaceId SpaceId, id string, body LinkLoadBalancerBackendMachinesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkLoadBalancerBackendMachinesWithBody request with any body
	UnlinkLoadBalancerBackendMachinesWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnlinkLoadBalancerBackendMachines(ctx context.Context, spaceId SpaceId, id string, body UnlinkLoadBalancerBackendMachinesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLoadBalancerListenersWithBody request with any body
	DeleteLoadBalancerListenersWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteLoadBalancerListeners(ctx context.Context, spaceId SpaceId, id string, body DeleteLoadBalancerListenersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLoadBalancerListenersWithBody request with any body
	CreateLoadBalancerListenersWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLoadBalancerListeners(ctx context.Context, spaceId SpaceId, id string, body CreateLoadBalancerListenersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLoadBalancerPolicyWithBody request with any body
	DeleteLoadBalancerPolicyWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteLoadBalancerPolicy(ctx context.Context, spaceId SpaceId, id string, body DeleteLoadBalancerPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLoadBalancerPolicyWithBody request with any body
	CreateLoadBalancerPolicyWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLoadBalancerPolicy(ctx context.Context, spaceId SpaceId, id string, body CreateLoadBalancerPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVmsHealthWithBody request with any body
	ReadVmsHealthWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReadVmsHealth(ctx context.Context, spaceId SpaceId, id string, body ReadVmsHealthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadLoadBalancerTagsWithBody request with any body
	ReadLoadBalancerTagsWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReadLoadBalancerTags(ctx context.Context, spaceId SpaceId, body ReadLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadNatGateway request
	ReadNatGateway(ctx context.Context, spaceId SpaceId, params *ReadNatGatewayParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNatGatewayWithBody request with any body
	CreateNatGatewayWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNatGateway(ctx context.Context, spaceId SpaceId, body CreateNatGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNatGateway request
	DeleteNatGateway(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadNatGatewayById request
	ReadNatGatewayById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadNics request
	ReadNics(ctx context.Context, spaceId SpaceId, params *ReadNicsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNicWithBody request with any body
	CreateNicWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNic(ctx context.Context, spaceId SpaceId, body CreateNicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNic request
	DeleteNic(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadNicsById request
	ReadNicsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateNicWithBody request with any body
	UpdateNicWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateNic(ctx context.Context, spaceId SpaceId, id string, body UpdateNicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkPrivateIpsWithBody request with any body
	LinkPrivateIpsWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkPrivateIps(ctx context.Context, spaceId SpaceId, id string, body LinkPrivateIpsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkPrivateIpsWithBody request with any body
	UnlinkPrivateIpsWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnlinkPrivateIps(ctx context.Context, spaceId SpaceId, id string, body UnlinkPrivateIpsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkNicWithBody request with any body
	LinkNicWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkNic(ctx context.Context, spaceId SpaceId, id string, body LinkNicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkNicWithBody request with any body
	UnlinkNicWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnlinkNic(ctx context.Context, spaceId SpaceId, id string, body UnlinkNicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadPublicIpRanges request
	ReadPublicIpRanges(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadPublicIps request
	ReadPublicIps(ctx context.Context, spaceId SpaceId, params *ReadPublicIpsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePublicIp request
	CreatePublicIp(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePublicIp request
	DeletePublicIp(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadPublicIpsById request
	ReadPublicIpsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkPublicIpWithBody request with any body
	LinkPublicIpWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkPublicIp(ctx context.Context, spaceId SpaceId, id string, body LinkPublicIpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkPublicIpWithBody request with any body
	UnlinkPublicIpWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnlinkPublicIp(ctx context.Context, spaceId SpaceId, id string, body UnlinkPublicIpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadRouteTables request
	ReadRouteTables(ctx context.Context, spaceId SpaceId, params *ReadRouteTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRouteTableWithBody request with any body
	CreateRouteTableWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRouteTable(ctx context.Context, spaceId SpaceId, body CreateRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRouteTable request
	DeleteRouteTable(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadRouteTablesById request
	ReadRouteTablesById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRouteTableRoutePropagationWithBody request with any body
	UpdateRouteTableRoutePropagationWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRouteTableRoutePropagation(ctx context.Context, spaceId SpaceId, id string, body UpdateRouteTableRoutePropagationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRouteWithBody request with any body
	DeleteRouteWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteRoute(ctx context.Context, spaceId SpaceId, id string, body DeleteRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRouteWithBody request with any body
	CreateRouteWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRoute(ctx context.Context, spaceId SpaceId, id string, body CreateRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRouteWithBody request with any body
	UpdateRouteWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRoute(ctx context.Context, spaceId SpaceId, id string, body UpdateRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkRouteTableWithBody request with any body
	LinkRouteTableWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkRouteTable(ctx context.Context, spaceId SpaceId, id string, body LinkRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkRouteTableWithBody request with any body
	UnlinkRouteTableWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnlinkRouteTable(ctx context.Context, spaceId SpaceId, id string, body UnlinkRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadSecurityGroups request
	ReadSecurityGroups(ctx context.Context, spaceId SpaceId, params *ReadSecurityGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSecurityGroupWithBody request with any body
	CreateSecurityGroupWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSecurityGroup(ctx context.Context, spaceId SpaceId, body CreateSecurityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSecurityGroup request
	DeleteSecurityGroup(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadSecurityGroupsById request
	ReadSecurityGroupsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSecurityGroupRuleWithBody request with any body
	DeleteSecurityGroupRuleWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteSecurityGroupRule(ctx context.Context, spaceId SpaceId, id string, body DeleteSecurityGroupRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSecurityGroupRuleWithBody request with any body
	CreateSecurityGroupRuleWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSecurityGroupRule(ctx context.Context, spaceId SpaceId, id string, body CreateSecurityGroupRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadServerCertificates request
	ReadServerCertificates(ctx context.Context, spaceId SpaceId, params *ReadServerCertificatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateServerCertificateWithBody request with any body
	CreateServerCertificateWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateServerCertificate(ctx context.Context, spaceId SpaceId, body CreateServerCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServerCertificate request
	DeleteServerCertificate(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateServerCertificateWithBody request with any body
	UpdateServerCertificateWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateServerCertificate(ctx context.Context, spaceId SpaceId, id string, body UpdateServerCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadSnapshots request
	ReadSnapshots(ctx context.Context, spaceId SpaceId, params *ReadSnapshotsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSnapshotWithBody request with any body
	CreateSnapshotWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSnapshot(ctx context.Context, spaceId SpaceId, body CreateSnapshotJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSnapshot request
	DeleteSnapshot(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadSnapshotsById request
	ReadSnapshotsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadSubnets request
	ReadSubnets(ctx context.Context, spaceId SpaceId, params *ReadSubnetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSubnetWithBody request with any body
	CreateSubnetWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSubnet(ctx context.Context, spaceId SpaceId, body CreateSubnetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSubnet request
	DeleteSubnet(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadSubnetsById request
	ReadSubnetsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSubnetWithBody request with any body
	UpdateSubnetWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSubnet(ctx context.Context, spaceId SpaceId, id string, body UpdateSubnetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadTags request
	ReadTags(ctx context.Context, spaceId SpaceId, params *ReadTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVirtualGateways request
	ReadVirtualGateways(ctx context.Context, spaceId SpaceId, params *ReadVirtualGatewaysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVirtualGatewayWithBody request with any body
	CreateVirtualGatewayWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVirtualGateway(ctx context.Context, spaceId SpaceId, body CreateVirtualGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVirtualGateway request
	DeleteVirtualGateway(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVirtualGatewaysById request
	ReadVirtualGatewaysById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkVirtualGatewayToVpcWithBody request with any body
	LinkVirtualGatewayToVpcWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkVirtualGatewayToVpc(ctx context.Context, spaceId SpaceId, id string, body LinkVirtualGatewayToVpcJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkVirtualGatewayToVpcWithBody request with any body
	UnlinkVirtualGatewayToVpcWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnlinkVirtualGatewayToVpc(ctx context.Context, spaceId SpaceId, id string, body UnlinkVirtualGatewayToVpcJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVms request
	ReadVms(ctx context.Context, spaceId SpaceId, params *ReadVmsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVmsWithBody request with any body
	CreateVmsWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVms(ctx context.Context, spaceId SpaceId, body CreateVmsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVmsState request
	ReadVmsState(ctx context.Context, spaceId SpaceId, params *ReadVmsStateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVms request
	DeleteVms(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVmsById request
	ReadVmsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVmWithBody request with any body
	UpdateVmWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVm(ctx context.Context, spaceId SpaceId, id string, body UpdateVmJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadAdminPassword request
	ReadAdminPassword(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadConsoleOutput request
	ReadConsoleOutput(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RebootVm request
	RebootVm(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartVm request
	StartVm(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StopVmWithBody request with any body
	StopVmWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StopVm(ctx context.Context, spaceId SpaceId, id string, body StopVmJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVolumes request
	ReadVolumes(ctx context.Context, spaceId SpaceId, params *ReadVolumesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVolumeWithBody request with any body
	CreateVolumeWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVolume(ctx context.Context, spaceId SpaceId, body CreateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVolume request
	DeleteVolume(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVolumesById request
	ReadVolumesById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVolumeWithBody request with any body
	UpdateVolumeWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVolume(ctx context.Context, spaceId SpaceId, id string, body UpdateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkVolumeWithBody request with any body
	LinkVolumeWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkVolume(ctx context.Context, spaceId SpaceId, id string, body LinkVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkVolumeWithBody request with any body
	UnlinkVolumeWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnlinkVolume(ctx context.Context, spaceId SpaceId, id string, body UnlinkVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVpcPeerings request
	ReadVpcPeerings(ctx context.Context, spaceId SpaceId, params *ReadVpcPeeringsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVpcPeeringWithBody request with any body
	CreateVpcPeeringWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVpcPeering(ctx context.Context, spaceId SpaceId, body CreateVpcPeeringJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVpcPeering request
	DeleteVpcPeering(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVpcPeeringsById request
	ReadVpcPeeringsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AcceptVpcPeering request
	AcceptVpcPeering(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RejectVpcPeering request
	RejectVpcPeering(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVpcs request
	ReadVpcs(ctx context.Context, spaceId SpaceId, params *ReadVpcsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVpcWithBody request with any body
	CreateVpcWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVpc(ctx context.Context, spaceId SpaceId, body CreateVpcJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVpc request
	DeleteVpc(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVpcsById request
	ReadVpcsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVpcWithBody request with any body
	UpdateVpcWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVpc(ctx context.Context, spaceId SpaceId, id string, body UpdateVpcJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVpnConnections request
	ReadVpnConnections(ctx context.Context, spaceId SpaceId, params *ReadVpnConnectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVpnConnectionWithBody request with any body
	CreateVpnConnectionWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVpnConnection(ctx context.Context, spaceId SpaceId, body CreateVpnConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVpnConnection request
	DeleteVpnConnection(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVpnConnectionsById request
	ReadVpnConnectionsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVpnConnectionWithBody request with any body
	UpdateVpnConnectionWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVpnConnection(ctx context.Context, spaceId SpaceId, id string, body UpdateVpnConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVpnConnectionRouteWithBody request with any body
	DeleteVpnConnectionRouteWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteVpnConnectionRoute(ctx context.Context, spaceId SpaceId, id string, body DeleteVpnConnectionRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVpnConnectionRouteWithBody request with any body
	CreateVpnConnectionRouteWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVpnConnectionRoute(ctx context.Context, spaceId SpaceId, id string, body CreateVpnConnectionRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JsonWebKeys request
	JsonWebKeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DiscoverOidcConfiguration request
	DiscoverOidcConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWebAuthnJavaScript request
	GetWebAuthnJavaScript(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAdminServiceAccountSpaceWithBody request with any body
	CreateAdminServiceAccountSpaceWithBody(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAdminServiceAccountSpace(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, body CreateAdminServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Authorize request
	Authorize(ctx context.Context, params *AuthorizeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Consent request
	Consent(ctx context.Context, params *ConsentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFlowError request
	GetFlowError(ctx context.Context, params *GetFlowErrorParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateLoginFlowWithBody request with any body
	UpdateLoginFlowWithBody(ctx context.Context, params *UpdateLoginFlowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateLoginFlow(ctx context.Context, params *UpdateLoginFlowParams, body UpdateLoginFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateLoginFlowWithFormdataBody(ctx context.Context, params *UpdateLoginFlowParams, body UpdateLoginFlowFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNativeLoginFlow request
	CreateNativeLoginFlow(ctx context.Context, params *CreateNativeLoginFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBrowserLoginFlow request
	CreateBrowserLoginFlow(ctx context.Context, params *CreateBrowserLoginFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLoginFlow request
	GetLoginFlow(ctx context.Context, params *GetLoginFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateLogoutFlow request
	UpdateLogoutFlow(ctx context.Context, params *UpdateLogoutFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PerformNativeLogoutWithBody request with any body
	PerformNativeLogoutWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PerformNativeLogout(ctx context.Context, body PerformNativeLogoutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBrowserLogoutFlow request
	CreateBrowserLogoutFlow(ctx context.Context, params *CreateBrowserLogoutFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InitRecoveryFlow request
	InitRecoveryFlow(ctx context.Context, params *InitRecoveryFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRecoveryFlowWithBody request with any body
	UpdateRecoveryFlowWithBody(ctx context.Context, params *UpdateRecoveryFlowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRecoveryFlow(ctx context.Context, params *UpdateRecoveryFlowParams, body UpdateRecoveryFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRecoveryFlowWithFormdataBody(ctx context.Context, params *UpdateRecoveryFlowParams, body UpdateRecoveryFlowFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNativeRecoveryFlow request
	CreateNativeRecoveryFlow(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBrowserRecoveryFlow request
	CreateBrowserRecoveryFlow(ctx context.Context, params *CreateBrowserRecoveryFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRecoveryFlow request
	GetRecoveryFlow(ctx context.Context, params *GetRecoveryFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRegistrationFlowWithBody request with any body
	UpdateRegistrationFlowWithBody(ctx context.Context, params *UpdateRegistrationFlowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRegistrationFlow(ctx context.Context, params *UpdateRegistrationFlowParams, body UpdateRegistrationFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRegistrationFlowWithFormdataBody(ctx context.Context, params *UpdateRegistrationFlowParams, body UpdateRegistrationFlowFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNativeRegistrationFlow request
	CreateNativeRegistrationFlow(ctx context.Context, params *CreateNativeRegistrationFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBrowserRegistrationFlow request
	CreateBrowserRegistrationFlow(ctx context.Context, params *CreateBrowserRegistrationFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRegistrationFlow request
	GetRegistrationFlow(ctx context.Context, params *GetRegistrationFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSettingsFloWithBody request with any body
	UpdateSettingsFloWithBody(ctx context.Context, params *UpdateSettingsFloParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSettingsFlo(ctx context.Context, params *UpdateSettingsFloParams, body UpdateSettingsFloJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSettingsFloWithFormdataBody(ctx context.Context, params *UpdateSettingsFloParams, body UpdateSettingsFloFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNativeSettingsFlow request
	CreateNativeSettingsFlow(ctx context.Context, params *CreateNativeSettingsFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBrowserSettingsFlow request
	CreateBrowserSettingsFlow(ctx context.Context, params *CreateBrowserSettingsFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSettingsFlow request
	GetSettingsFlow(ctx context.Context, params *GetSettingsFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVerificationFlowWithBody request with any body
	UpdateVerificationFlowWithBody(ctx context.Context, params *UpdateVerificationFlowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVerificationFlow(ctx context.Context, params *UpdateVerificationFlowParams, body UpdateVerificationFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVerificationFlowWithFormdataBody(ctx context.Context, params *UpdateVerificationFlowParams, body UpdateVerificationFlowFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNativeVerificationFlow request
	CreateNativeVerificationFlow(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBrowserVerificationFlow request
	CreateBrowserVerificationFlow(ctx context.Context, params *CreateBrowserVerificationFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVerificationFlow request
	GetVerificationFlow(ctx context.Context, params *GetVerificationFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DisableMyOtherSessions request
	DisableMyOtherSessions(ctx context.Context, params *DisableMyOtherSessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMySessions request
	ListMySessions(ctx context.Context, params *ListMySessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExchangeSessionToken request
	ExchangeSessionToken(ctx context.Context, params *ExchangeSessionTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ToSession request
	ToSession(ctx context.Context, params *ToSessionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IntrospectWithBody request with any body
	IntrospectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IntrospectWithFormdataBody(ctx context.Context, body IntrospectFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListOrganisationsIdentity request
	ListOrganisationsIdentity(ctx context.Context, params *ListOrganisationsIdentityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIAMGranularPolicyOrganisation request
	GetIAMGranularPolicyOrganisation(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetIAMGranularPolicyOrganisationWithBody request with any body
	SetIAMGranularPolicyOrganisationWithBody(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetIAMGranularPolicyOrganisation(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, body SetIAMGranularPolicyOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIAMPolicyOrganisation request
	GetIAMPolicyOrganisation(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetIAMPolicyOrganisationWithBody request with any body
	SetIAMPolicyOrganisationWithBody(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetIAMPolicyOrganisation(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, body SetIAMPolicyOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPermissionsOrganisation request
	ListPermissionsOrganisation(ctx context.Context, organisationId OrganisationId, params *ListPermissionsOrganisationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPermissionOrganisation request
	GetPermissionOrganisation(ctx context.Context, organisationId OrganisationId, permissionUuid PermissionUuid, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRolesOrganisation request
	ListRolesOrganisation(ctx context.Context, organisationId OrganisationId, params *ListRolesOrganisationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRoleOrganisationWithBody request with any body
	CreateRoleOrganisationWithBody(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRoleOrganisation(ctx context.Context, organisationId OrganisationId, body CreateRoleOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRoleOrganisation request
	DeleteRoleOrganisation(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRoleOrganisation request
	GetRoleOrganisation(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRoleOrganisationWithBody request with any body
	UpdateRoleOrganisationWithBody(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRoleOrganisation(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, body UpdateRoleOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveRolePermissionsOrganisationWithBody request with any body
	RemoveRolePermissionsOrganisationWithBody(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveRolePermissionsOrganisation(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, body RemoveRolePermissionsOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRolePermissionsOrganisation request
	GetRolePermissionsOrganisation(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddRolePermissionsOrganisationWithBody request with any body
	AddRolePermissionsOrganisationWithBody(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddRolePermissionsOrganisation(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, body AddRolePermissionsOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListServiceAccountOrganisationWithBody request with any body
	ListServiceAccountOrganisationWithBody(ctx context.Context, organisationId OrganisationId, params *ListServiceAccountOrganisationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListServiceAccountOrganisation(ctx context.Context, organisationId OrganisationId, params *ListServiceAccountOrganisationParams, body ListServiceAccountOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateServiceAccountOrganisationWithBody request with any body
	CreateServiceAccountOrganisationWithBody(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateServiceAccountOrganisation(ctx context.Context, organisationId OrganisationId, body CreateServiceAccountOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServiceAccountOrganisation request
	DeleteServiceAccountOrganisation(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServiceAccountOrganisation request
	GetServiceAccountOrganisation(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateServiceAccountOrganisationWithBody request with any body
	UpdateServiceAccountOrganisationWithBody(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateServiceAccountOrganisation(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, body UpdateServiceAccountOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetACLServiceAccountOrganisation request
	GetACLServiceAccountOrganisation(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, params *GetACLServiceAccountOrganisationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteACLServiceAccountOrganisationBulkWithBody request with any body
	DeleteACLServiceAccountOrganisationBulkWithBody(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteACLServiceAccountOrganisationBulk(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, body DeleteACLServiceAccountOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateACLServiceAccountOrganisationBulkWithBody request with any body
	CreateACLServiceAccountOrganisationBulkWithBody(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateACLServiceAccountOrganisationBulk(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, body CreateACLServiceAccountOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSpacesOfServiceAccount request
	ListSpacesOfServiceAccount(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, params *ListSpacesOfServiceAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSpacesIdentity request
	ListSpacesIdentity(ctx context.Context, organisationId OrganisationId, params *ListSpacesIdentityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserOrganisationWithBody request with any body
	ListUserOrganisationWithBody(ctx context.Context, organisationId OrganisationId, params *ListUserOrganisationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListUserOrganisation(ctx context.Context, organisationId OrganisationId, params *ListUserOrganisationParams, body ListUserOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserOrganisationWithBody request with any body
	CreateUserOrganisationWithBody(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUserOrganisation(ctx context.Context, organisationId OrganisationId, body CreateUserOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserOrganisation request
	DeleteUserOrganisation(ctx context.Context, organisationId OrganisationId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserOrganisation request
	GetUserOrganisation(ctx context.Context, organisationId OrganisationId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchUserStateOrganisationWithBody request with any body
	PatchUserStateOrganisationWithBody(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchUserStateOrganisation(ctx context.Context, organisationId OrganisationId, userId UserId, body PatchUserStateOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserOrganisationWithBody request with any body
	UpdateUserOrganisationWithBody(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUserOrganisation(ctx context.Context, organisationId OrganisationId, userId UserId, body UpdateUserOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetACLUserOrganisation request
	GetACLUserOrganisation(ctx context.Context, organisationId OrganisationId, userId UserId, params *GetACLUserOrganisationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteACLUserOrganisationBulkWithBody request with any body
	DeleteACLUserOrganisationBulkWithBody(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteACLUserOrganisationBulk(ctx context.Context, organisationId OrganisationId, userId UserId, body DeleteACLUserOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateACLUserOrganisationBulkWithBody request with any body
	CreateACLUserOrganisationBulkWithBody(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateACLUserOrganisationBulk(ctx context.Context, organisationId OrganisationId, userId UserId, body CreateACLUserOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RecoverUserOrganisation request
	RecoverUserOrganisation(ctx context.Context, organisationId OrganisationId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSpacesOfUser request
	ListSpacesOfUser(ctx context.Context, organisationId OrganisationId, userId UserId, params *ListSpacesOfUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevokeWithBody request with any body
	RevokeWithBody(ctx context.Context, params *RevokeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevokeWithFormdataBody(ctx context.Context, params *RevokeParams, body RevokeFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIAMGranularPolicySpace request
	GetIAMGranularPolicySpace(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetIAMGranularPolicySpaceWithBody request with any body
	SetIAMGranularPolicySpaceWithBody(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetIAMGranularPolicySpace(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, body SetIAMGranularPolicySpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIAMPolicySpace request
	GetIAMPolicySpace(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetIAMPolicySpaceWithBody request with any body
	SetIAMPolicySpaceWithBody(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetIAMPolicySpace(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, body SetIAMPolicySpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPermissionsSpace request
	ListPermissionsSpace(ctx context.Context, spaceId SpaceId, params *ListPermissionsSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPermissionSpace request
	GetPermissionSpace(ctx context.Context, spaceId SpaceId, permissionUuid PermissionUuid, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRolesSpace request
	ListRolesSpace(ctx context.Context, spaceId SpaceId, params *ListRolesSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRoleSpaceWithBody request with any body
	CreateRoleSpaceWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRoleSpace(ctx context.Context, spaceId SpaceId, body CreateRoleSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRoleSpace request
	DeleteRoleSpace(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRoleSpace request
	GetRoleSpace(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRoleSpaceWithBody request with any body
	UpdateRoleSpaceWithBody(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRoleSpace(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, body UpdateRoleSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveRolePermissionsSpaceWithBody request with any body
	RemoveRolePermissionsSpaceWithBody(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveRolePermissionsSpace(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, body RemoveRolePermissionsSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRolePermissionsSpace request
	GetRolePermissionsSpace(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddRolePermissionsSpaceWithBody request with any body
	AddRolePermissionsSpaceWithBody(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddRolePermissionsSpace(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, body AddRolePermissionsSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListServiceAccountSpaceWithBody request with any body
	ListServiceAccountSpaceWithBody(ctx context.Context, spaceId SpaceId, params *ListServiceAccountSpaceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListServiceAccountSpace(ctx context.Context, spaceId SpaceId, params *ListServiceAccountSpaceParams, body ListServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateServiceAccountSpaceWithBody request with any body
	CreateServiceAccountSpaceWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateServiceAccountSpace(ctx context.Context, spaceId SpaceId, body CreateServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServiceAccountSpace request
	DeleteServiceAccountSpace(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServiceAccountSpace request
	GetServiceAccountSpace(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignServiceAccountToSpace request
	AssignServiceAccountToSpace(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateServiceAccountSpaceWithBody request with any body
	UpdateServiceAccountSpaceWithBody(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateServiceAccountSpace(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, body UpdateServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetACLServiceAccountSpace request
	GetACLServiceAccountSpace(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, params *GetACLServiceAccountSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteACLServiceAccountSpaceBulkWithBody request with any body
	DeleteACLServiceAccountSpaceBulkWithBody(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteACLServiceAccountSpaceBulk(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, body DeleteACLServiceAccountSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateACLServiceAccountSpaceBulkWithBody request with any body
	CreateACLServiceAccountSpaceBulkWithBody(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateACLServiceAccountSpaceBulk(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, body CreateACLServiceAccountSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserSpaceWithBody request with any body
	ListUserSpaceWithBody(ctx context.Context, spaceId SpaceId, params *ListUserSpaceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListUserSpace(ctx context.Context, spaceId SpaceId, params *ListUserSpaceParams, body ListUserSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserSpaceWithBody request with any body
	CreateUserSpaceWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUserSpace(ctx context.Context, spaceId SpaceId, body CreateUserSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnassignUserSpace request
	UnassignUserSpace(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserSpace request
	GetUserSpace(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchUserStateSpaceWithBody request with any body
	PatchUserStateSpaceWithBody(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchUserStateSpace(ctx context.Context, spaceId SpaceId, userId UserId, body PatchUserStateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignUserToSpace request
	AssignUserToSpace(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserSpaceWithBody request with any body
	UpdateUserSpaceWithBody(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUserSpace(ctx context.Context, spaceId SpaceId, userId UserId, body UpdateUserSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetACLUserSpace request
	GetACLUserSpace(ctx context.Context, spaceId SpaceId, userId UserId, params *GetACLUserSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteACLUserSpaceBulkWithBody request with any body
	DeleteACLUserSpaceBulkWithBody(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteACLUserSpaceBulk(ctx context.Context, spaceId SpaceId, userId UserId, body DeleteACLUserSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateACLUserSpaceBulkWithBody request with any body
	CreateACLUserSpaceBulkWithBody(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateACLUserSpaceBulk(ctx context.Context, spaceId SpaceId, userId UserId, body CreateACLUserSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RecoverUserSpace request
	RecoverUserSpace(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TokenWithBody request with any body
	TokenWithBody(ctx context.Context, params *TokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TokenWithFormdataBody(ctx context.Context, params *TokenParams, body TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserInfo request
	GetUserInfo(ctx context.Context, params *GetUserInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Healthcheck request
	Healthcheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListKubernetesClusters request
	ListKubernetesClusters(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateKubernetesClusterWithBody request with any body
	CreateKubernetesClusterWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateKubernetesCluster(ctx context.Context, spaceId SpaceId, body CreateKubernetesClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteKubernetesClusterById request
	DeleteKubernetesClusterById(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKubernetesClusterById request
	GetKubernetesClusterById(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKubeConfig request
	GetKubeConfig(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpgradeMastersWithBody request with any body
	UpgradeMastersWithBody(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpgradeMasters(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, body UpgradeMastersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddNodesWithBody request with any body
	AddNodesWithBody(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddNodes(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, body AddNodesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveNodesWithBody request with any body
	RemoveNodesWithBody(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveNodes(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, body RemoveNodesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpgradeNodesWithBody request with any body
	UpgradeNodesWithBody(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpgradeNodes(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, body UpgradeNodesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListOperation request
	ListOperation(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPrivateKey request
	GetPrivateKey(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClusterStatus request
	GetClusterStatus(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateNodes request
	UpdateNodes(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOperationById request
	GetOperationById(ctx context.Context, spaceId SpaceId, operationId OperationId, params *GetOperationByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBuckets request
	ListBuckets(ctx context.Context, spaceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBucket request
	DeleteBucket(ctx context.Context, spaceId string, bucket string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListObjects request
	ListObjects(ctx context.Context, spaceId string, bucket string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBucket request
	CreateBucket(ctx context.Context, spaceId string, bucket string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteObject request
	DeleteObject(ctx context.Context, spaceId string, bucket string, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetObject request
	GetObject(ctx context.Context, spaceId string, bucket string, key string, params *GetObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutObjectWithBody request with any body
	PutObjectWithBody(ctx context.Context, spaceId string, bucket string, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadPartWithBody request with any body
	UploadPartWithBody(ctx context.Context, spaceId string, bucket string, key string, params *UploadPartParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AbortMultipartUpload request
	AbortMultipartUpload(ctx context.Context, spaceId string, bucket string, key string, params *AbortMultipartUploadParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CompleteMultipartUploadWithBody request with any body
	CompleteMultipartUploadWithBody(ctx context.Context, spaceId string, bucket string, key string, params *CompleteMultipartUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateMultipartUpload request
	CreateMultipartUpload(ctx context.Context, spaceId string, bucket string, key string, params *CreateMultipartUploadParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListClusters request
	ListClusters(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateClusterWithBody request with any body
	CreateClusterWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCluster(ctx context.Context, spaceId SpaceId, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCluster request
	DeleteCluster(ctx context.Context, spaceId SpaceId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCluster request
	GetCluster(ctx context.Context, spaceId SpaceId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateClusterWithBody request with any body
	UpdateClusterWithBody(ctx context.Context, spaceId SpaceId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCluster(ctx context.Context, spaceId SpaceId, clusterId ClusterId, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListNodepools request
	ListNodepools(ctx context.Context, spaceId SpaceId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNodePoolWithBody request with any body
	CreateNodePoolWithBody(ctx context.Context, spaceId SpaceId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNodePool(ctx context.Context, spaceId SpaceId, clusterId ClusterId, body CreateNodePoolJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNodePool request
	DeleteNodePool(ctx context.Context, spaceId SpaceId, clusterId ClusterId, nodePoolName NodepoolName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateNodepoolWithBody request with any body
	UpdateNodepoolWithBody(ctx context.Context, spaceId SpaceId, clusterId ClusterId, nodePoolName NodepoolName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateNodepool(ctx context.Context, spaceId SpaceId, clusterId ClusterId, nodePoolName NodepoolName, body UpdateNodepoolJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListOperations request
	ListOperations(ctx context.Context, spaceId SpaceId, params *ListOperationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOperation request
	GetOperation(ctx context.Context, spaceId SpaceId, id IdUuid, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListVersions request
	ListVersions(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSpacesWithBody request with any body
	ListSpacesWithBody(ctx context.Context, organisationId OrganisationId, params *ListSpacesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListSpaces(ctx context.Context, organisationId OrganisationId, params *ListSpacesParams, body ListSpacesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSpaceWithBody request with any body
	CreateSpaceWithBody(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSpace(ctx context.Context, organisationId OrganisationId, body CreateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSpace request
	DeleteSpace(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpaceById request
	GetSpaceById(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSpaceWithBody request with any body
	UpdateSpaceWithBody(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSpace(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, body UpdateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) DeleteLoadBalancerTagsWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLoadBalancerTagsRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLoadBalancerTags(ctx context.Context, spaceId SpaceId, body DeleteLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLoadBalancerTagsRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLoadBalancerTagsWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLoadBalancerTagsRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLoadBalancerTags(ctx context.Context, spaceId SpaceId, body CreateLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLoadBalancerTagsRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTagsWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTagsRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTags(ctx context.Context, spaceId SpaceId, body DeleteTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTagsRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTagsWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTagsRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTags(ctx context.Context, spaceId SpaceId, body CreateTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTagsRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadClientGateways(ctx context.Context, spaceId SpaceId, params *ReadClientGatewaysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadClientGatewaysRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClientGatewayWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientGatewayRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClientGateway(ctx context.Context, spaceId SpaceId, body CreateClientGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientGatewayRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteClientGateway(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClientGatewayRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadClientGatewaysById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadClientGatewaysByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadDhcpOptions(ctx context.Context, spaceId SpaceId, params *ReadDhcpOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadDhcpOptionsRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDhcpOptionsWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDhcpOptionsRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDhcpOptions(ctx context.Context, spaceId SpaceId, body CreateDhcpOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDhcpOptionsRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDhcpOptions(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDhcpOptionsRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadDhcpOptionsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadDhcpOptionsByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadFlexibleGpus(ctx context.Context, spaceId SpaceId, params *ReadFlexibleGpusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadFlexibleGpusRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFlexibleGpuWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFlexibleGpuRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFlexibleGpu(ctx context.Context, spaceId SpaceId, body CreateFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFlexibleGpuRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFlexibleGpu(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFlexibleGpuRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadFlexibleGpusById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadFlexibleGpusByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFlexibleGpuWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFlexibleGpuRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFlexibleGpu(ctx context.Context, spaceId SpaceId, id string, body UpdateFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFlexibleGpuRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkFlexibleGpuWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkFlexibleGpuRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkFlexibleGpu(ctx context.Context, spaceId SpaceId, id string, body LinkFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkFlexibleGpuRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkFlexibleGpu(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkFlexibleGpuRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadImages(ctx context.Context, spaceId SpaceId, params *ReadImagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadImagesRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateImageWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateImageRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateImage(ctx context.Context, spaceId SpaceId, body CreateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateImageRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteImage(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteImageRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadImagesById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadImagesByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateImageWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateImageRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateImage(ctx context.Context, spaceId SpaceId, id string, body UpdateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateImageRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadInternetGateways(ctx context.Context, spaceId SpaceId, params *ReadInternetGatewaysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadInternetGatewaysRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateInternetGateway(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateInternetGatewayRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteInternetGateway(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteInternetGatewayRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadInternetGatewaysById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadInternetGatewaysByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkInternetGatewayWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkInternetGatewayRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkInternetGateway(ctx context.Context, spaceId SpaceId, id string, body LinkInternetGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkInternetGatewayRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkInternetGatewayWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkInternetGatewayRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkInternetGateway(ctx context.Context, spaceId SpaceId, id string, body UnlinkInternetGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkInternetGatewayRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadKeypairs(ctx context.Context, spaceId SpaceId, params *ReadKeypairsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadKeypairsRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKeypairWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeypairRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKeypair(ctx context.Context, spaceId SpaceId, body CreateKeypairJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeypairRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteKeypair(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteKeypairRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadKeypairsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadKeypairsByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadListenerRules(ctx context.Context, spaceId SpaceId, params *ReadListenerRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadListenerRulesRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateListenerRuleWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateListenerRuleRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateListenerRule(ctx context.Context, spaceId SpaceId, body CreateListenerRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateListenerRuleRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteListenerRule(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteListenerRuleRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadListenerRulesById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadListenerRulesByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateListenerRuleWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateListenerRuleRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateListenerRule(ctx context.Context, spaceId SpaceId, id string, body UpdateListenerRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateListenerRuleRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadLoadBalancers(ctx context.Context, spaceId SpaceId, params *ReadLoadBalancersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadLoadBalancersRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLoadBalancerWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLoadBalancerRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLoadBalancer(ctx context.Context, spaceId SpaceId, body CreateLoadBalancerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLoadBalancerRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLoadBalancer(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLoadBalancerRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadLoadBalancersById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadLoadBalancersByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLoadBalancerWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLoadBalancerRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLoadBalancer(ctx context.Context, spaceId SpaceId, id string, body UpdateLoadBalancerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLoadBalancerRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkLoadBalancerBackendMachinesWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkLoadBalancerBackendMachinesRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkLoadBalancerBackendMachines(ctx context.Context, spaceId SpaceId, id string, body LinkLoadBalancerBackendMachinesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkLoadBalancerBackendMachinesRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkLoadBalancerBackendMachinesWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkLoadBalancerBackendMachinesRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkLoadBalancerBackendMachines(ctx context.Context, spaceId SpaceId, id string, body UnlinkLoadBalancerBackendMachinesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkLoadBalancerBackendMachinesRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLoadBalancerListenersWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLoadBalancerListenersRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLoadBalancerListeners(ctx context.Context, spaceId SpaceId, id string, body DeleteLoadBalancerListenersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLoadBalancerListenersRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLoadBalancerListenersWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLoadBalancerListenersRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLoadBalancerListeners(ctx context.Context, spaceId SpaceId, id string, body CreateLoadBalancerListenersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLoadBalancerListenersRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLoadBalancerPolicyWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLoadBalancerPolicyRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLoadBalancerPolicy(ctx context.Context, spaceId SpaceId, id string, body DeleteLoadBalancerPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLoadBalancerPolicyRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLoadBalancerPolicyWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLoadBalancerPolicyRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLoadBalancerPolicy(ctx context.Context, spaceId SpaceId, id string, body CreateLoadBalancerPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLoadBalancerPolicyRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVmsHealthWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVmsHealthRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVmsHealth(ctx context.Context, spaceId SpaceId, id string, body ReadVmsHealthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVmsHealthRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadLoadBalancerTagsWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadLoadBalancerTagsRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadLoadBalancerTags(ctx context.Context, spaceId SpaceId, body ReadLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadLoadBalancerTagsRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadNatGateway(ctx context.Context, spaceId SpaceId, params *ReadNatGatewayParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadNatGatewayRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNatGatewayWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNatGatewayRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNatGateway(ctx context.Context, spaceId SpaceId, body CreateNatGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNatGatewayRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNatGateway(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNatGatewayRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadNatGatewayById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadNatGatewayByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadNics(ctx context.Context, spaceId SpaceId, params *ReadNicsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadNicsRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNicWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNicRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNic(ctx context.Context, spaceId SpaceId, body CreateNicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNicRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNic(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNicRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadNicsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadNicsByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNicWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNicRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNic(ctx context.Context, spaceId SpaceId, id string, body UpdateNicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNicRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkPrivateIpsWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkPrivateIpsRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkPrivateIps(ctx context.Context, spaceId SpaceId, id string, body LinkPrivateIpsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkPrivateIpsRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkPrivateIpsWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkPrivateIpsRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkPrivateIps(ctx context.Context, spaceId SpaceId, id string, body UnlinkPrivateIpsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkPrivateIpsRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkNicWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkNicRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkNic(ctx context.Context, spaceId SpaceId, id string, body LinkNicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkNicRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkNicWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkNicRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkNic(ctx context.Context, spaceId SpaceId, id string, body UnlinkNicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkNicRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadPublicIpRanges(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadPublicIpRangesRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadPublicIps(ctx context.Context, spaceId SpaceId, params *ReadPublicIpsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadPublicIpsRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePublicIp(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePublicIpRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePublicIp(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePublicIpRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadPublicIpsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadPublicIpsByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkPublicIpWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkPublicIpRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkPublicIp(ctx context.Context, spaceId SpaceId, id string, body LinkPublicIpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkPublicIpRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkPublicIpWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkPublicIpRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkPublicIp(ctx context.Context, spaceId SpaceId, id string, body UnlinkPublicIpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkPublicIpRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadRouteTables(ctx context.Context, spaceId SpaceId, params *ReadRouteTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadRouteTablesRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRouteTableWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRouteTableRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRouteTable(ctx context.Context, spaceId SpaceId, body CreateRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRouteTableRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRouteTable(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRouteTableRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadRouteTablesById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadRouteTablesByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRouteTableRoutePropagationWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRouteTableRoutePropagationRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRouteTableRoutePropagation(ctx context.Context, spaceId SpaceId, id string, body UpdateRouteTableRoutePropagationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRouteTableRoutePropagationRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRouteWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRouteRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRoute(ctx context.Context, spaceId SpaceId, id string, body DeleteRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRouteRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRouteWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRouteRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRoute(ctx context.Context, spaceId SpaceId, id string, body CreateRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRouteRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRouteWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRouteRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRoute(ctx context.Context, spaceId SpaceId, id string, body UpdateRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRouteRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkRouteTableWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkRouteTableRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkRouteTable(ctx context.Context, spaceId SpaceId, id string, body LinkRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkRouteTableRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkRouteTableWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkRouteTableRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkRouteTable(ctx context.Context, spaceId SpaceId, id string, body UnlinkRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkRouteTableRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadSecurityGroups(ctx context.Context, spaceId SpaceId, params *ReadSecurityGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadSecurityGroupsRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSecurityGroupWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSecurityGroupRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSecurityGroup(ctx context.Context, spaceId SpaceId, body CreateSecurityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSecurityGroupRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSecurityGroup(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSecurityGroupRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadSecurityGroupsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadSecurityGroupsByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSecurityGroupRuleWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSecurityGroupRuleRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSecurityGroupRule(ctx context.Context, spaceId SpaceId, id string, body DeleteSecurityGroupRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSecurityGroupRuleRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSecurityGroupRuleWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSecurityGroupRuleRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSecurityGroupRule(ctx context.Context, spaceId SpaceId, id string, body CreateSecurityGroupRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSecurityGroupRuleRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadServerCertificates(ctx context.Context, spaceId SpaceId, params *ReadServerCertificatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadServerCertificatesRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServerCertificateWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerCertificateRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServerCertificate(ctx context.Context, spaceId SpaceId, body CreateServerCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerCertificateRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServerCertificate(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServerCertificateRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServerCertificateWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServerCertificateRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServerCertificate(ctx context.Context, spaceId SpaceId, id string, body UpdateServerCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServerCertificateRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadSnapshots(ctx context.Context, spaceId SpaceId, params *ReadSnapshotsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadSnapshotsRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSnapshotWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSnapshotRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSnapshot(ctx context.Context, spaceId SpaceId, body CreateSnapshotJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSnapshotRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSnapshot(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSnapshotRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadSnapshotsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadSnapshotsByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadSubnets(ctx context.Context, spaceId SpaceId, params *ReadSubnetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadSubnetsRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSubnetWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSubnetRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSubnet(ctx context.Context, spaceId SpaceId, body CreateSubnetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSubnetRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSubnet(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSubnetRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadSubnetsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadSubnetsByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSubnetWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSubnetRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSubnet(ctx context.Context, spaceId SpaceId, id string, body UpdateSubnetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSubnetRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadTags(ctx context.Context, spaceId SpaceId, params *ReadTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadTagsRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVirtualGateways(ctx context.Context, spaceId SpaceId, params *ReadVirtualGatewaysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVirtualGatewaysRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVirtualGatewayWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVirtualGatewayRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVirtualGateway(ctx context.Context, spaceId SpaceId, body CreateVirtualGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVirtualGatewayRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVirtualGateway(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVirtualGatewayRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVirtualGatewaysById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVirtualGatewaysByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkVirtualGatewayToVpcWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkVirtualGatewayToVpcRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkVirtualGatewayToVpc(ctx context.Context, spaceId SpaceId, id string, body LinkVirtualGatewayToVpcJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkVirtualGatewayToVpcRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkVirtualGatewayToVpcWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkVirtualGatewayToVpcRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkVirtualGatewayToVpc(ctx context.Context, spaceId SpaceId, id string, body UnlinkVirtualGatewayToVpcJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkVirtualGatewayToVpcRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVms(ctx context.Context, spaceId SpaceId, params *ReadVmsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVmsRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVmsWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVmsRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVms(ctx context.Context, spaceId SpaceId, body CreateVmsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVmsRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVmsState(ctx context.Context, spaceId SpaceId, params *ReadVmsStateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVmsStateRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVms(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVmsRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVmsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVmsByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVmWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVmRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVm(ctx context.Context, spaceId SpaceId, id string, body UpdateVmJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVmRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadAdminPassword(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadAdminPasswordRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadConsoleOutput(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadConsoleOutputRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RebootVm(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRebootVmRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartVm(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartVmRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopVmWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopVmRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopVm(ctx context.Context, spaceId SpaceId, id string, body StopVmJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopVmRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVolumes(ctx context.Context, spaceId SpaceId, params *ReadVolumesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVolumesRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVolumeWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVolumeRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVolume(ctx context.Context, spaceId SpaceId, body CreateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVolumeRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVolume(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVolumeRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVolumesById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVolumesByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVolumeWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVolumeRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVolume(ctx context.Context, spaceId SpaceId, id string, body UpdateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVolumeRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkVolumeWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkVolumeRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkVolume(ctx context.Context, spaceId SpaceId, id string, body LinkVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkVolumeRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkVolumeWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkVolumeRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkVolume(ctx context.Context, spaceId SpaceId, id string, body UnlinkVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkVolumeRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVpcPeerings(ctx context.Context, spaceId SpaceId, params *ReadVpcPeeringsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVpcPeeringsRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVpcPeeringWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVpcPeeringRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVpcPeering(ctx context.Context, spaceId SpaceId, body CreateVpcPeeringJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVpcPeeringRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVpcPeering(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVpcPeeringRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVpcPeeringsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVpcPeeringsByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AcceptVpcPeering(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcceptVpcPeeringRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RejectVpcPeering(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRejectVpcPeeringRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVpcs(ctx context.Context, spaceId SpaceId, params *ReadVpcsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVpcsRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVpcWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVpcRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVpc(ctx context.Context, spaceId SpaceId, body CreateVpcJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVpcRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVpc(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVpcRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVpcsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVpcsByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVpcWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVpcRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVpc(ctx context.Context, spaceId SpaceId, id string, body UpdateVpcJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVpcRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVpnConnections(ctx context.Context, spaceId SpaceId, params *ReadVpnConnectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVpnConnectionsRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVpnConnectionWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVpnConnectionRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVpnConnection(ctx context.Context, spaceId SpaceId, body CreateVpnConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVpnConnectionRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVpnConnection(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVpnConnectionRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVpnConnectionsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVpnConnectionsByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVpnConnectionWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVpnConnectionRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVpnConnection(ctx context.Context, spaceId SpaceId, id string, body UpdateVpnConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVpnConnectionRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVpnConnectionRouteWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVpnConnectionRouteRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVpnConnectionRoute(ctx context.Context, spaceId SpaceId, id string, body DeleteVpnConnectionRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVpnConnectionRouteRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVpnConnectionRouteWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVpnConnectionRouteRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVpnConnectionRoute(ctx context.Context, spaceId SpaceId, id string, body CreateVpnConnectionRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVpnConnectionRouteRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JsonWebKeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJsonWebKeysRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DiscoverOidcConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDiscoverOidcConfigurationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWebAuthnJavaScript(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebAuthnJavaScriptRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAdminServiceAccountSpaceWithBody(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAdminServiceAccountSpaceRequestWithBody(c.Server, organisationId, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAdminServiceAccountSpace(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, body CreateAdminServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAdminServiceAccountSpaceRequest(c.Server, organisationId, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Authorize(ctx context.Context, params *AuthorizeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthorizeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Consent(ctx context.Context, params *ConsentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConsentRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFlowError(ctx context.Context, params *GetFlowErrorParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFlowErrorRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLoginFlowWithBody(ctx context.Context, params *UpdateLoginFlowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLoginFlowRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLoginFlow(ctx context.Context, params *UpdateLoginFlowParams, body UpdateLoginFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLoginFlowRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLoginFlowWithFormdataBody(ctx context.Context, params *UpdateLoginFlowParams, body UpdateLoginFlowFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLoginFlowRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNativeLoginFlow(ctx context.Context, params *CreateNativeLoginFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNativeLoginFlowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBrowserLoginFlow(ctx context.Context, params *CreateBrowserLoginFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBrowserLoginFlowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLoginFlow(ctx context.Context, params *GetLoginFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLoginFlowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLogoutFlow(ctx context.Context, params *UpdateLogoutFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLogoutFlowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PerformNativeLogoutWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPerformNativeLogoutRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PerformNativeLogout(ctx context.Context, body PerformNativeLogoutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPerformNativeLogoutRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBrowserLogoutFlow(ctx context.Context, params *CreateBrowserLogoutFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBrowserLogoutFlowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InitRecoveryFlow(ctx context.Context, params *InitRecoveryFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInitRecoveryFlowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRecoveryFlowWithBody(ctx context.Context, params *UpdateRecoveryFlowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRecoveryFlowRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRecoveryFlow(ctx context.Context, params *UpdateRecoveryFlowParams, body UpdateRecoveryFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRecoveryFlowRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRecoveryFlowWithFormdataBody(ctx context.Context, params *UpdateRecoveryFlowParams, body UpdateRecoveryFlowFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRecoveryFlowRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNativeRecoveryFlow(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNativeRecoveryFlowRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBrowserRecoveryFlow(ctx context.Context, params *CreateBrowserRecoveryFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBrowserRecoveryFlowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRecoveryFlow(ctx context.Context, params *GetRecoveryFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRecoveryFlowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRegistrationFlowWithBody(ctx context.Context, params *UpdateRegistrationFlowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRegistrationFlowRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRegistrationFlow(ctx context.Context, params *UpdateRegistrationFlowParams, body UpdateRegistrationFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRegistrationFlowRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRegistrationFlowWithFormdataBody(ctx context.Context, params *UpdateRegistrationFlowParams, body UpdateRegistrationFlowFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRegistrationFlowRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNativeRegistrationFlow(ctx context.Context, params *CreateNativeRegistrationFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNativeRegistrationFlowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBrowserRegistrationFlow(ctx context.Context, params *CreateBrowserRegistrationFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBrowserRegistrationFlowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRegistrationFlow(ctx context.Context, params *GetRegistrationFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRegistrationFlowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSettingsFloWithBody(ctx context.Context, params *UpdateSettingsFloParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSettingsFloRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSettingsFlo(ctx context.Context, params *UpdateSettingsFloParams, body UpdateSettingsFloJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSettingsFloRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSettingsFloWithFormdataBody(ctx context.Context, params *UpdateSettingsFloParams, body UpdateSettingsFloFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSettingsFloRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNativeSettingsFlow(ctx context.Context, params *CreateNativeSettingsFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNativeSettingsFlowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBrowserSettingsFlow(ctx context.Context, params *CreateBrowserSettingsFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBrowserSettingsFlowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSettingsFlow(ctx context.Context, params *GetSettingsFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSettingsFlowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVerificationFlowWithBody(ctx context.Context, params *UpdateVerificationFlowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVerificationFlowRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVerificationFlow(ctx context.Context, params *UpdateVerificationFlowParams, body UpdateVerificationFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVerificationFlowRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVerificationFlowWithFormdataBody(ctx context.Context, params *UpdateVerificationFlowParams, body UpdateVerificationFlowFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVerificationFlowRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNativeVerificationFlow(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNativeVerificationFlowRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBrowserVerificationFlow(ctx context.Context, params *CreateBrowserVerificationFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBrowserVerificationFlowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVerificationFlow(ctx context.Context, params *GetVerificationFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVerificationFlowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisableMyOtherSessions(ctx context.Context, params *DisableMyOtherSessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisableMyOtherSessionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMySessions(ctx context.Context, params *ListMySessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMySessionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExchangeSessionToken(ctx context.Context, params *ExchangeSessionTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExchangeSessionTokenRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToSession(ctx context.Context, params *ToSessionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToSessionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IntrospectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIntrospectRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IntrospectWithFormdataBody(ctx context.Context, body IntrospectFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIntrospectRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListOrganisationsIdentity(ctx context.Context, params *ListOrganisationsIdentityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListOrganisationsIdentityRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIAMGranularPolicyOrganisation(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIAMGranularPolicyOrganisationRequest(c.Server, organisationId, subjectType, subjectId, objectType)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetIAMGranularPolicyOrganisationWithBody(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetIAMGranularPolicyOrganisationRequestWithBody(c.Server, organisationId, subjectType, subjectId, objectType, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetIAMGranularPolicyOrganisation(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, body SetIAMGranularPolicyOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetIAMGranularPolicyOrganisationRequest(c.Server, organisationId, subjectType, subjectId, objectType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIAMPolicyOrganisation(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIAMPolicyOrganisationRequest(c.Server, organisationId, subjectType, subjectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetIAMPolicyOrganisationWithBody(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetIAMPolicyOrganisationRequestWithBody(c.Server, organisationId, subjectType, subjectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetIAMPolicyOrganisation(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, body SetIAMPolicyOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetIAMPolicyOrganisationRequest(c.Server, organisationId, subjectType, subjectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPermissionsOrganisation(ctx context.Context, organisationId OrganisationId, params *ListPermissionsOrganisationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPermissionsOrganisationRequest(c.Server, organisationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPermissionOrganisation(ctx context.Context, organisationId OrganisationId, permissionUuid PermissionUuid, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPermissionOrganisationRequest(c.Server, organisationId, permissionUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRolesOrganisation(ctx context.Context, organisationId OrganisationId, params *ListRolesOrganisationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRolesOrganisationRequest(c.Server, organisationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRoleOrganisationWithBody(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRoleOrganisationRequestWithBody(c.Server, organisationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRoleOrganisation(ctx context.Context, organisationId OrganisationId, body CreateRoleOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRoleOrganisationRequest(c.Server, organisationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRoleOrganisation(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRoleOrganisationRequest(c.Server, organisationId, roleUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRoleOrganisation(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRoleOrganisationRequest(c.Server, organisationId, roleUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRoleOrganisationWithBody(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRoleOrganisationRequestWithBody(c.Server, organisationId, roleUuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRoleOrganisation(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, body UpdateRoleOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRoleOrganisationRequest(c.Server, organisationId, roleUuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveRolePermissionsOrganisationWithBody(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveRolePermissionsOrganisationRequestWithBody(c.Server, organisationId, roleUuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveRolePermissionsOrganisation(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, body RemoveRolePermissionsOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveRolePermissionsOrganisationRequest(c.Server, organisationId, roleUuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRolePermissionsOrganisation(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRolePermissionsOrganisationRequest(c.Server, organisationId, roleUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddRolePermissionsOrganisationWithBody(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddRolePermissionsOrganisationRequestWithBody(c.Server, organisationId, roleUuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddRolePermissionsOrganisation(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, body AddRolePermissionsOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddRolePermissionsOrganisationRequest(c.Server, organisationId, roleUuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListServiceAccountOrganisationWithBody(ctx context.Context, organisationId OrganisationId, params *ListServiceAccountOrganisationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListServiceAccountOrganisationRequestWithBody(c.Server, organisationId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListServiceAccountOrganisation(ctx context.Context, organisationId OrganisationId, params *ListServiceAccountOrganisationParams, body ListServiceAccountOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListServiceAccountOrganisationRequest(c.Server, organisationId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServiceAccountOrganisationWithBody(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceAccountOrganisationRequestWithBody(c.Server, organisationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServiceAccountOrganisation(ctx context.Context, organisationId OrganisationId, body CreateServiceAccountOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceAccountOrganisationRequest(c.Server, organisationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServiceAccountOrganisation(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServiceAccountOrganisationRequest(c.Server, organisationId, serviceAccountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServiceAccountOrganisation(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServiceAccountOrganisationRequest(c.Server, organisationId, serviceAccountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServiceAccountOrganisationWithBody(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServiceAccountOrganisationRequestWithBody(c.Server, organisationId, serviceAccountId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServiceAccountOrganisation(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, body UpdateServiceAccountOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServiceAccountOrganisationRequest(c.Server, organisationId, serviceAccountId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetACLServiceAccountOrganisation(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, params *GetACLServiceAccountOrganisationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetACLServiceAccountOrganisationRequest(c.Server, organisationId, serviceAccountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteACLServiceAccountOrganisationBulkWithBody(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteACLServiceAccountOrganisationBulkRequestWithBody(c.Server, organisationId, serviceAccountId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteACLServiceAccountOrganisationBulk(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, body DeleteACLServiceAccountOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteACLServiceAccountOrganisationBulkRequest(c.Server, organisationId, serviceAccountId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateACLServiceAccountOrganisationBulkWithBody(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateACLServiceAccountOrganisationBulkRequestWithBody(c.Server, organisationId, serviceAccountId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateACLServiceAccountOrganisationBulk(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, body CreateACLServiceAccountOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateACLServiceAccountOrganisationBulkRequest(c.Server, organisationId, serviceAccountId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSpacesOfServiceAccount(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, params *ListSpacesOfServiceAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSpacesOfServiceAccountRequest(c.Server, organisationId, serviceAccountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSpacesIdentity(ctx context.Context, organisationId OrganisationId, params *ListSpacesIdentityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSpacesIdentityRequest(c.Server, organisationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserOrganisationWithBody(ctx context.Context, organisationId OrganisationId, params *ListUserOrganisationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserOrganisationRequestWithBody(c.Server, organisationId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserOrganisation(ctx context.Context, organisationId OrganisationId, params *ListUserOrganisationParams, body ListUserOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserOrganisationRequest(c.Server, organisationId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserOrganisationWithBody(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserOrganisationRequestWithBody(c.Server, organisationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserOrganisation(ctx context.Context, organisationId OrganisationId, body CreateUserOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserOrganisationRequest(c.Server, organisationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserOrganisation(ctx context.Context, organisationId OrganisationId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserOrganisationRequest(c.Server, organisationId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserOrganisation(ctx context.Context, organisationId OrganisationId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserOrganisationRequest(c.Server, organisationId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchUserStateOrganisationWithBody(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchUserStateOrganisationRequestWithBody(c.Server, organisationId, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchUserStateOrganisation(ctx context.Context, organisationId OrganisationId, userId UserId, body PatchUserStateOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchUserStateOrganisationRequest(c.Server, organisationId, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserOrganisationWithBody(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserOrganisationRequestWithBody(c.Server, organisationId, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserOrganisation(ctx context.Context, organisationId OrganisationId, userId UserId, body UpdateUserOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserOrganisationRequest(c.Server, organisationId, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetACLUserOrganisation(ctx context.Context, organisationId OrganisationId, userId UserId, params *GetACLUserOrganisationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetACLUserOrganisationRequest(c.Server, organisationId, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteACLUserOrganisationBulkWithBody(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteACLUserOrganisationBulkRequestWithBody(c.Server, organisationId, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteACLUserOrganisationBulk(ctx context.Context, organisationId OrganisationId, userId UserId, body DeleteACLUserOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteACLUserOrganisationBulkRequest(c.Server, organisationId, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateACLUserOrganisationBulkWithBody(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateACLUserOrganisationBulkRequestWithBody(c.Server, organisationId, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateACLUserOrganisationBulk(ctx context.Context, organisationId OrganisationId, userId UserId, body CreateACLUserOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateACLUserOrganisationBulkRequest(c.Server, organisationId, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RecoverUserOrganisation(ctx context.Context, organisationId OrganisationId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRecoverUserOrganisationRequest(c.Server, organisationId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSpacesOfUser(ctx context.Context, organisationId OrganisationId, userId UserId, params *ListSpacesOfUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSpacesOfUserRequest(c.Server, organisationId, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokeWithBody(ctx context.Context, params *RevokeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokeRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokeWithFormdataBody(ctx context.Context, params *RevokeParams, body RevokeFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokeRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIAMGranularPolicySpace(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIAMGranularPolicySpaceRequest(c.Server, spaceId, subjectType, subjectId, objectType)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetIAMGranularPolicySpaceWithBody(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetIAMGranularPolicySpaceRequestWithBody(c.Server, spaceId, subjectType, subjectId, objectType, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetIAMGranularPolicySpace(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, body SetIAMGranularPolicySpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetIAMGranularPolicySpaceRequest(c.Server, spaceId, subjectType, subjectId, objectType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIAMPolicySpace(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIAMPolicySpaceRequest(c.Server, spaceId, subjectType, subjectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetIAMPolicySpaceWithBody(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetIAMPolicySpaceRequestWithBody(c.Server, spaceId, subjectType, subjectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetIAMPolicySpace(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, body SetIAMPolicySpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetIAMPolicySpaceRequest(c.Server, spaceId, subjectType, subjectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPermissionsSpace(ctx context.Context, spaceId SpaceId, params *ListPermissionsSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPermissionsSpaceRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPermissionSpace(ctx context.Context, spaceId SpaceId, permissionUuid PermissionUuid, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPermissionSpaceRequest(c.Server, spaceId, permissionUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRolesSpace(ctx context.Context, spaceId SpaceId, params *ListRolesSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRolesSpaceRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRoleSpaceWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRoleSpaceRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRoleSpace(ctx context.Context, spaceId SpaceId, body CreateRoleSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRoleSpaceRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRoleSpace(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRoleSpaceRequest(c.Server, spaceId, roleUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRoleSpace(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRoleSpaceRequest(c.Server, spaceId, roleUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRoleSpaceWithBody(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRoleSpaceRequestWithBody(c.Server, spaceId, roleUuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRoleSpace(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, body UpdateRoleSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRoleSpaceRequest(c.Server, spaceId, roleUuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveRolePermissionsSpaceWithBody(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveRolePermissionsSpaceRequestWithBody(c.Server, spaceId, roleUuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveRolePermissionsSpace(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, body RemoveRolePermissionsSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveRolePermissionsSpaceRequest(c.Server, spaceId, roleUuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRolePermissionsSpace(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRolePermissionsSpaceRequest(c.Server, spaceId, roleUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddRolePermissionsSpaceWithBody(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddRolePermissionsSpaceRequestWithBody(c.Server, spaceId, roleUuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddRolePermissionsSpace(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, body AddRolePermissionsSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddRolePermissionsSpaceRequest(c.Server, spaceId, roleUuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListServiceAccountSpaceWithBody(ctx context.Context, spaceId SpaceId, params *ListServiceAccountSpaceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListServiceAccountSpaceRequestWithBody(c.Server, spaceId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListServiceAccountSpace(ctx context.Context, spaceId SpaceId, params *ListServiceAccountSpaceParams, body ListServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListServiceAccountSpaceRequest(c.Server, spaceId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServiceAccountSpaceWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceAccountSpaceRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServiceAccountSpace(ctx context.Context, spaceId SpaceId, body CreateServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceAccountSpaceRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServiceAccountSpace(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServiceAccountSpaceRequest(c.Server, spaceId, serviceAccountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServiceAccountSpace(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServiceAccountSpaceRequest(c.Server, spaceId, serviceAccountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignServiceAccountToSpace(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignServiceAccountToSpaceRequest(c.Server, spaceId, serviceAccountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServiceAccountSpaceWithBody(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServiceAccountSpaceRequestWithBody(c.Server, spaceId, serviceAccountId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServiceAccountSpace(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, body UpdateServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServiceAccountSpaceRequest(c.Server, spaceId, serviceAccountId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetACLServiceAccountSpace(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, params *GetACLServiceAccountSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetACLServiceAccountSpaceRequest(c.Server, spaceId, serviceAccountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteACLServiceAccountSpaceBulkWithBody(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteACLServiceAccountSpaceBulkRequestWithBody(c.Server, spaceId, serviceAccountId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteACLServiceAccountSpaceBulk(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, body DeleteACLServiceAccountSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteACLServiceAccountSpaceBulkRequest(c.Server, spaceId, serviceAccountId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateACLServiceAccountSpaceBulkWithBody(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateACLServiceAccountSpaceBulkRequestWithBody(c.Server, spaceId, serviceAccountId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateACLServiceAccountSpaceBulk(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, body CreateACLServiceAccountSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateACLServiceAccountSpaceBulkRequest(c.Server, spaceId, serviceAccountId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserSpaceWithBody(ctx context.Context, spaceId SpaceId, params *ListUserSpaceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserSpaceRequestWithBody(c.Server, spaceId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserSpace(ctx context.Context, spaceId SpaceId, params *ListUserSpaceParams, body ListUserSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserSpaceRequest(c.Server, spaceId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserSpaceWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserSpaceRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserSpace(ctx context.Context, spaceId SpaceId, body CreateUserSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserSpaceRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignUserSpace(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignUserSpaceRequest(c.Server, spaceId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserSpace(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserSpaceRequest(c.Server, spaceId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchUserStateSpaceWithBody(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchUserStateSpaceRequestWithBody(c.Server, spaceId, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchUserStateSpace(ctx context.Context, spaceId SpaceId, userId UserId, body PatchUserStateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchUserStateSpaceRequest(c.Server, spaceId, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignUserToSpace(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignUserToSpaceRequest(c.Server, spaceId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserSpaceWithBody(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserSpaceRequestWithBody(c.Server, spaceId, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserSpace(ctx context.Context, spaceId SpaceId, userId UserId, body UpdateUserSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserSpaceRequest(c.Server, spaceId, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetACLUserSpace(ctx context.Context, spaceId SpaceId, userId UserId, params *GetACLUserSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetACLUserSpaceRequest(c.Server, spaceId, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteACLUserSpaceBulkWithBody(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteACLUserSpaceBulkRequestWithBody(c.Server, spaceId, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteACLUserSpaceBulk(ctx context.Context, spaceId SpaceId, userId UserId, body DeleteACLUserSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteACLUserSpaceBulkRequest(c.Server, spaceId, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateACLUserSpaceBulkWithBody(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateACLUserSpaceBulkRequestWithBody(c.Server, spaceId, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateACLUserSpaceBulk(ctx context.Context, spaceId SpaceId, userId UserId, body CreateACLUserSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateACLUserSpaceBulkRequest(c.Server, spaceId, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RecoverUserSpace(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRecoverUserSpaceRequest(c.Server, spaceId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TokenWithBody(ctx context.Context, params *TokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTokenRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TokenWithFormdataBody(ctx context.Context, params *TokenParams, body TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTokenRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserInfo(ctx context.Context, params *GetUserInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserInfoRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Healthcheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHealthcheckRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListKubernetesClusters(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListKubernetesClustersRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKubernetesClusterWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKubernetesClusterRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKubernetesCluster(ctx context.Context, spaceId SpaceId, body CreateKubernetesClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKubernetesClusterRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteKubernetesClusterById(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteKubernetesClusterByIdRequest(c.Server, spaceId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKubernetesClusterById(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKubernetesClusterByIdRequest(c.Server, spaceId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKubeConfig(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKubeConfigRequest(c.Server, spaceId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpgradeMastersWithBody(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpgradeMastersRequestWithBody(c.Server, spaceId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpgradeMasters(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, body UpgradeMastersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpgradeMastersRequest(c.Server, spaceId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddNodesWithBody(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddNodesRequestWithBody(c.Server, spaceId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddNodes(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, body AddNodesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddNodesRequest(c.Server, spaceId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNodesWithBody(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNodesRequestWithBody(c.Server, spaceId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveNodes(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, body RemoveNodesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveNodesRequest(c.Server, spaceId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpgradeNodesWithBody(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpgradeNodesRequestWithBody(c.Server, spaceId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpgradeNodes(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, body UpgradeNodesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpgradeNodesRequest(c.Server, spaceId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListOperation(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListOperationRequest(c.Server, spaceId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPrivateKey(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPrivateKeyRequest(c.Server, spaceId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClusterStatus(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterStatusRequest(c.Server, spaceId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNodes(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNodesRequest(c.Server, spaceId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOperationById(ctx context.Context, spaceId SpaceId, operationId OperationId, params *GetOperationByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOperationByIdRequest(c.Server, spaceId, operationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBuckets(ctx context.Context, spaceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBucketsRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBucket(ctx context.Context, spaceId string, bucket string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBucketRequest(c.Server, spaceId, bucket)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListObjects(ctx context.Context, spaceId string, bucket string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListObjectsRequest(c.Server, spaceId, bucket)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBucket(ctx context.Context, spaceId string, bucket string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBucketRequest(c.Server, spaceId, bucket)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteObject(ctx context.Context, spaceId string, bucket string, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteObjectRequest(c.Server, spaceId, bucket, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetObject(ctx context.Context, spaceId string, bucket string, key string, params *GetObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetObjectRequest(c.Server, spaceId, bucket, key, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutObjectWithBody(ctx context.Context, spaceId string, bucket string, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutObjectRequestWithBody(c.Server, spaceId, bucket, key, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadPartWithBody(ctx context.Context, spaceId string, bucket string, key string, params *UploadPartParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadPartRequestWithBody(c.Server, spaceId, bucket, key, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AbortMultipartUpload(ctx context.Context, spaceId string, bucket string, key string, params *AbortMultipartUploadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAbortMultipartUploadRequest(c.Server, spaceId, bucket, key, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompleteMultipartUploadWithBody(ctx context.Context, spaceId string, bucket string, key string, params *CompleteMultipartUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompleteMultipartUploadRequestWithBody(c.Server, spaceId, bucket, key, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMultipartUpload(ctx context.Context, spaceId string, bucket string, key string, params *CreateMultipartUploadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMultipartUploadRequest(c.Server, spaceId, bucket, key, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListClusters(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListClustersRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClusterWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClusterRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCluster(ctx context.Context, spaceId SpaceId, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClusterRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCluster(ctx context.Context, spaceId SpaceId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClusterRequest(c.Server, spaceId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCluster(ctx context.Context, spaceId SpaceId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterRequest(c.Server, spaceId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClusterWithBody(ctx context.Context, spaceId SpaceId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClusterRequestWithBody(c.Server, spaceId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCluster(ctx context.Context, spaceId SpaceId, clusterId ClusterId, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClusterRequest(c.Server, spaceId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListNodepools(ctx context.Context, spaceId SpaceId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListNodepoolsRequest(c.Server, spaceId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNodePoolWithBody(ctx context.Context, spaceId SpaceId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNodePoolRequestWithBody(c.Server, spaceId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNodePool(ctx context.Context, spaceId SpaceId, clusterId ClusterId, body CreateNodePoolJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNodePoolRequest(c.Server, spaceId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNodePool(ctx context.Context, spaceId SpaceId, clusterId ClusterId, nodePoolName NodepoolName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNodePoolRequest(c.Server, spaceId, clusterId, nodePoolName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNodepoolWithBody(ctx context.Context, spaceId SpaceId, clusterId ClusterId, nodePoolName NodepoolName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNodepoolRequestWithBody(c.Server, spaceId, clusterId, nodePoolName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNodepool(ctx context.Context, spaceId SpaceId, clusterId ClusterId, nodePoolName NodepoolName, body UpdateNodepoolJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNodepoolRequest(c.Server, spaceId, clusterId, nodePoolName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListOperations(ctx context.Context, spaceId SpaceId, params *ListOperationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListOperationsRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOperation(ctx context.Context, spaceId SpaceId, id IdUuid, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOperationRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListVersions(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVersionsRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSpacesWithBody(ctx context.Context, organisationId OrganisationId, params *ListSpacesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSpacesRequestWithBody(c.Server, organisationId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSpaces(ctx context.Context, organisationId OrganisationId, params *ListSpacesParams, body ListSpacesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSpacesRequest(c.Server, organisationId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpaceWithBody(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpaceRequestWithBody(c.Server, organisationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpace(ctx context.Context, organisationId OrganisationId, body CreateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpaceRequest(c.Server, organisationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSpace(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSpaceRequest(c.Server, organisationId, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpaceById(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpaceByIdRequest(c.Server, organisationId, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSpaceWithBody(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSpaceRequestWithBody(c.Server, organisationId, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSpace(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, body UpdateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSpaceRequest(c.Server, organisationId, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewDeleteLoadBalancerTagsRequest calls the generic DeleteLoadBalancerTags builder with application/json body
func NewDeleteLoadBalancerTagsRequest(server string, spaceId SpaceId, body DeleteLoadBalancerTagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteLoadBalancerTagsRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewDeleteLoadBalancerTagsRequestWithBody generates requests for DeleteLoadBalancerTags with any type of body
func NewDeleteLoadBalancerTagsRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/bulk/loadBalancersTags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateLoadBalancerTagsRequest calls the generic CreateLoadBalancerTags builder with application/json body
func NewCreateLoadBalancerTagsRequest(server string, spaceId SpaceId, body CreateLoadBalancerTagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLoadBalancerTagsRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateLoadBalancerTagsRequestWithBody generates requests for CreateLoadBalancerTags with any type of body
func NewCreateLoadBalancerTagsRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/bulk/loadBalancersTags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTagsRequest calls the generic DeleteTags builder with application/json body
func NewDeleteTagsRequest(server string, spaceId SpaceId, body DeleteTagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteTagsRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewDeleteTagsRequestWithBody generates requests for DeleteTags with any type of body
func NewDeleteTagsRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/bulk/tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateTagsRequest calls the generic CreateTags builder with application/json body
func NewCreateTagsRequest(server string, spaceId SpaceId, body CreateTagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTagsRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateTagsRequestWithBody generates requests for CreateTags with any type of body
func NewCreateTagsRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/bulk/tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadClientGatewaysRequest generates requests for ReadClientGateways
func NewReadClientGatewaysRequest(server string, spaceId SpaceId, params *ReadClientGatewaysParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/clientGateways", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BgpAsns != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bgpAsns", runtime.ParamLocationQuery, *params.BgpAsns); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ConnectionTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "connectionTypes", runtime.ParamLocationQuery, *params.ConnectionTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PublicIps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "publicIps", runtime.ParamLocationQuery, *params.PublicIps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateClientGatewayRequest calls the generic CreateClientGateway builder with application/json body
func NewCreateClientGatewayRequest(server string, spaceId SpaceId, body CreateClientGatewayJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateClientGatewayRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateClientGatewayRequestWithBody generates requests for CreateClientGateway with any type of body
func NewCreateClientGatewayRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/clientGateways", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteClientGatewayRequest generates requests for DeleteClientGateway
func NewDeleteClientGatewayRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/clientGateways/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadClientGatewaysByIdRequest generates requests for ReadClientGatewaysById
func NewReadClientGatewaysByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/clientGateways/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadDhcpOptionsRequest generates requests for ReadDhcpOptions
func NewReadDhcpOptionsRequest(server string, spaceId SpaceId, params *ReadDhcpOptionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/dhcpOptions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Default != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "default", runtime.ParamLocationQuery, *params.Default); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DomainNameServers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domainNameServers", runtime.ParamLocationQuery, *params.DomainNameServers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DomainNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domainNames", runtime.ParamLocationQuery, *params.DomainNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LogServers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "logServers", runtime.ParamLocationQuery, *params.LogServers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NtpServers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ntpServers", runtime.ParamLocationQuery, *params.NtpServers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDhcpOptionsRequest calls the generic CreateDhcpOptions builder with application/json body
func NewCreateDhcpOptionsRequest(server string, spaceId SpaceId, body CreateDhcpOptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDhcpOptionsRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateDhcpOptionsRequestWithBody generates requests for CreateDhcpOptions with any type of body
func NewCreateDhcpOptionsRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/dhcpOptions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDhcpOptionsRequest generates requests for DeleteDhcpOptions
func NewDeleteDhcpOptionsRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/dhcpOptions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadDhcpOptionsByIdRequest generates requests for ReadDhcpOptionsById
func NewReadDhcpOptionsByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/dhcpOptions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadFlexibleGpusRequest generates requests for ReadFlexibleGpus
func NewReadFlexibleGpusRequest(server string, spaceId SpaceId, params *ReadFlexibleGpusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/flexibleGpus", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DeleteOnVmDeletion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleteOnVmDeletion", runtime.ParamLocationQuery, *params.DeleteOnVmDeletion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Generations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "generations", runtime.ParamLocationQuery, *params.Generations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModelNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modelNames", runtime.ParamLocationQuery, *params.ModelNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VmIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vmIds", runtime.ParamLocationQuery, *params.VmIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AvailabilityZoneNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "availabilityZoneNames", runtime.ParamLocationQuery, *params.AvailabilityZoneNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFlexibleGpuRequest calls the generic CreateFlexibleGpu builder with application/json body
func NewCreateFlexibleGpuRequest(server string, spaceId SpaceId, body CreateFlexibleGpuJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFlexibleGpuRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateFlexibleGpuRequestWithBody generates requests for CreateFlexibleGpu with any type of body
func NewCreateFlexibleGpuRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/flexibleGpus", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFlexibleGpuRequest generates requests for DeleteFlexibleGpu
func NewDeleteFlexibleGpuRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/flexibleGpus/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadFlexibleGpusByIdRequest generates requests for ReadFlexibleGpusById
func NewReadFlexibleGpusByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/flexibleGpus/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateFlexibleGpuRequest calls the generic UpdateFlexibleGpu builder with application/json body
func NewUpdateFlexibleGpuRequest(server string, spaceId SpaceId, id string, body UpdateFlexibleGpuJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateFlexibleGpuRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateFlexibleGpuRequestWithBody generates requests for UpdateFlexibleGpu with any type of body
func NewUpdateFlexibleGpuRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/flexibleGpus/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLinkFlexibleGpuRequest calls the generic LinkFlexibleGpu builder with application/json body
func NewLinkFlexibleGpuRequest(server string, spaceId SpaceId, id string, body LinkFlexibleGpuJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkFlexibleGpuRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewLinkFlexibleGpuRequestWithBody generates requests for LinkFlexibleGpu with any type of body
func NewLinkFlexibleGpuRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/flexibleGpus/%s/vms/link", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnlinkFlexibleGpuRequest generates requests for UnlinkFlexibleGpu
func NewUnlinkFlexibleGpuRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/flexibleGpus/%s/vms/unlink", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadImagesRequest generates requests for ReadImages
func NewReadImagesRequest(server string, spaceId SpaceId, params *ReadImagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/images", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AccountAliases != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accountAliases", runtime.ParamLocationQuery, *params.AccountAliases); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Architectures != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "architectures", runtime.ParamLocationQuery, *params.Architectures); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BlockDeviceMappingDeleteOnVmDeletion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blockDeviceMappingDeleteOnVmDeletion", runtime.ParamLocationQuery, *params.BlockDeviceMappingDeleteOnVmDeletion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BlockDeviceMappingDeviceNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blockDeviceMappingDeviceNames", runtime.ParamLocationQuery, *params.BlockDeviceMappingDeviceNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BlockDeviceMappingSnapshotIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blockDeviceMappingSnapshotIds", runtime.ParamLocationQuery, *params.BlockDeviceMappingSnapshotIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BlockDeviceMappingVolumeSizes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blockDeviceMappingVolumeSizes", runtime.ParamLocationQuery, *params.BlockDeviceMappingVolumeSizes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BlockDeviceMappingVolumeTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blockDeviceMappingVolumeTypes", runtime.ParamLocationQuery, *params.BlockDeviceMappingVolumeTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Descriptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "descriptions", runtime.ParamLocationQuery, *params.Descriptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FileLocations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fileLocations", runtime.ParamLocationQuery, *params.FileLocations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Hypervisors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hypervisors", runtime.ParamLocationQuery, *params.Hypervisors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageNames", runtime.ParamLocationQuery, *params.ImageNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductCodeNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "productCodeNames", runtime.ParamLocationQuery, *params.ProductCodeNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductCodes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "productCodes", runtime.ParamLocationQuery, *params.ProductCodes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RootDeviceNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rootDeviceNames", runtime.ParamLocationQuery, *params.RootDeviceNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RootDeviceTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rootDeviceTypes", runtime.ParamLocationQuery, *params.RootDeviceTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VirtualizationTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "virtualizationTypes", runtime.ParamLocationQuery, *params.VirtualizationTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsPublic != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isPublic", runtime.ParamLocationQuery, *params.IsPublic); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateImageRequest calls the generic CreateImage builder with application/json body
func NewCreateImageRequest(server string, spaceId SpaceId, body CreateImageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateImageRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateImageRequestWithBody generates requests for CreateImage with any type of body
func NewCreateImageRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/images", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteImageRequest generates requests for DeleteImage
func NewDeleteImageRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/images/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadImagesByIdRequest generates requests for ReadImagesById
func NewReadImagesByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/images/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateImageRequest calls the generic UpdateImage builder with application/json body
func NewUpdateImageRequest(server string, spaceId SpaceId, id string, body UpdateImageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateImageRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateImageRequestWithBody generates requests for UpdateImage with any type of body
func NewUpdateImageRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/images/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadInternetGatewaysRequest generates requests for ReadInternetGateways
func NewReadInternetGatewaysRequest(server string, spaceId SpaceId, params *ReadInternetGatewaysParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/internetGateways", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LinkStates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkStates", runtime.ParamLocationQuery, *params.LinkStates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkVpcIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkVpcIds", runtime.ParamLocationQuery, *params.LinkVpcIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateInternetGatewayRequest generates requests for CreateInternetGateway
func NewCreateInternetGatewayRequest(server string, spaceId SpaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/internetGateways", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteInternetGatewayRequest generates requests for DeleteInternetGateway
func NewDeleteInternetGatewayRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/internetGateways/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadInternetGatewaysByIdRequest generates requests for ReadInternetGatewaysById
func NewReadInternetGatewaysByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/internetGateways/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLinkInternetGatewayRequest calls the generic LinkInternetGateway builder with application/json body
func NewLinkInternetGatewayRequest(server string, spaceId SpaceId, id string, body LinkInternetGatewayJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkInternetGatewayRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewLinkInternetGatewayRequestWithBody generates requests for LinkInternetGateway with any type of body
func NewLinkInternetGatewayRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/internetGateways/%s/vpcs/link", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnlinkInternetGatewayRequest calls the generic UnlinkInternetGateway builder with application/json body
func NewUnlinkInternetGatewayRequest(server string, spaceId SpaceId, id string, body UnlinkInternetGatewayJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnlinkInternetGatewayRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUnlinkInternetGatewayRequestWithBody generates requests for UnlinkInternetGateway with any type of body
func NewUnlinkInternetGatewayRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/internetGateways/%s/vpcs/unlink", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadKeypairsRequest generates requests for ReadKeypairs
func NewReadKeypairsRequest(server string, spaceId SpaceId, params *ReadKeypairsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/keypairs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.KeypairFingerprints != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keypairFingerprints", runtime.ParamLocationQuery, *params.KeypairFingerprints); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.KeypairNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keypairNames", runtime.ParamLocationQuery, *params.KeypairNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.KeypairTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keypairTypes", runtime.ParamLocationQuery, *params.KeypairTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateKeypairRequest calls the generic CreateKeypair builder with application/json body
func NewCreateKeypairRequest(server string, spaceId SpaceId, body CreateKeypairJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateKeypairRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateKeypairRequestWithBody generates requests for CreateKeypair with any type of body
func NewCreateKeypairRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/keypairs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteKeypairRequest generates requests for DeleteKeypair
func NewDeleteKeypairRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/keypairs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadKeypairsByIdRequest generates requests for ReadKeypairsById
func NewReadKeypairsByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/keypairs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadListenerRulesRequest generates requests for ReadListenerRules
func NewReadListenerRulesRequest(server string, spaceId SpaceId, params *ReadListenerRulesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/listenerRules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ListenerRuleNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "listenerRuleNames", runtime.ParamLocationQuery, *params.ListenerRuleNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateListenerRuleRequest calls the generic CreateListenerRule builder with application/json body
func NewCreateListenerRuleRequest(server string, spaceId SpaceId, body CreateListenerRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateListenerRuleRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateListenerRuleRequestWithBody generates requests for CreateListenerRule with any type of body
func NewCreateListenerRuleRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/listenerRules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteListenerRuleRequest generates requests for DeleteListenerRule
func NewDeleteListenerRuleRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/listenerRules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadListenerRulesByIdRequest generates requests for ReadListenerRulesById
func NewReadListenerRulesByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/listenerRules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateListenerRuleRequest calls the generic UpdateListenerRule builder with application/json body
func NewUpdateListenerRuleRequest(server string, spaceId SpaceId, id string, body UpdateListenerRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateListenerRuleRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateListenerRuleRequestWithBody generates requests for UpdateListenerRule with any type of body
func NewUpdateListenerRuleRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/listenerRules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadLoadBalancersRequest generates requests for ReadLoadBalancers
func NewReadLoadBalancersRequest(server string, spaceId SpaceId, params *ReadLoadBalancersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/loadBalancers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LoadBalancerNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "loadBalancerNames", runtime.ParamLocationQuery, *params.LoadBalancerNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateLoadBalancerRequest calls the generic CreateLoadBalancer builder with application/json body
func NewCreateLoadBalancerRequest(server string, spaceId SpaceId, body CreateLoadBalancerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLoadBalancerRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateLoadBalancerRequestWithBody generates requests for CreateLoadBalancer with any type of body
func NewCreateLoadBalancerRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/loadBalancers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLoadBalancerRequest generates requests for DeleteLoadBalancer
func NewDeleteLoadBalancerRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/loadBalancers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadLoadBalancersByIdRequest generates requests for ReadLoadBalancersById
func NewReadLoadBalancersByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/loadBalancers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateLoadBalancerRequest calls the generic UpdateLoadBalancer builder with application/json body
func NewUpdateLoadBalancerRequest(server string, spaceId SpaceId, id string, body UpdateLoadBalancerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateLoadBalancerRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateLoadBalancerRequestWithBody generates requests for UpdateLoadBalancer with any type of body
func NewUpdateLoadBalancerRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/loadBalancers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLinkLoadBalancerBackendMachinesRequest calls the generic LinkLoadBalancerBackendMachines builder with application/json body
func NewLinkLoadBalancerBackendMachinesRequest(server string, spaceId SpaceId, id string, body LinkLoadBalancerBackendMachinesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkLoadBalancerBackendMachinesRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewLinkLoadBalancerBackendMachinesRequestWithBody generates requests for LinkLoadBalancerBackendMachines with any type of body
func NewLinkLoadBalancerBackendMachinesRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/loadBalancers/%s/backendMachines/link", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnlinkLoadBalancerBackendMachinesRequest calls the generic UnlinkLoadBalancerBackendMachines builder with application/json body
func NewUnlinkLoadBalancerBackendMachinesRequest(server string, spaceId SpaceId, id string, body UnlinkLoadBalancerBackendMachinesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnlinkLoadBalancerBackendMachinesRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUnlinkLoadBalancerBackendMachinesRequestWithBody generates requests for UnlinkLoadBalancerBackendMachines with any type of body
func NewUnlinkLoadBalancerBackendMachinesRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/loadBalancers/%s/backendMachines/unlink", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLoadBalancerListenersRequest calls the generic DeleteLoadBalancerListeners builder with application/json body
func NewDeleteLoadBalancerListenersRequest(server string, spaceId SpaceId, id string, body DeleteLoadBalancerListenersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteLoadBalancerListenersRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewDeleteLoadBalancerListenersRequestWithBody generates requests for DeleteLoadBalancerListeners with any type of body
func NewDeleteLoadBalancerListenersRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/loadBalancers/%s/listeners", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateLoadBalancerListenersRequest calls the generic CreateLoadBalancerListeners builder with application/json body
func NewCreateLoadBalancerListenersRequest(server string, spaceId SpaceId, id string, body CreateLoadBalancerListenersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLoadBalancerListenersRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewCreateLoadBalancerListenersRequestWithBody generates requests for CreateLoadBalancerListeners with any type of body
func NewCreateLoadBalancerListenersRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/loadBalancers/%s/listeners", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLoadBalancerPolicyRequest calls the generic DeleteLoadBalancerPolicy builder with application/json body
func NewDeleteLoadBalancerPolicyRequest(server string, spaceId SpaceId, id string, body DeleteLoadBalancerPolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteLoadBalancerPolicyRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewDeleteLoadBalancerPolicyRequestWithBody generates requests for DeleteLoadBalancerPolicy with any type of body
func NewDeleteLoadBalancerPolicyRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/loadBalancers/%s/policies", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateLoadBalancerPolicyRequest calls the generic CreateLoadBalancerPolicy builder with application/json body
func NewCreateLoadBalancerPolicyRequest(server string, spaceId SpaceId, id string, body CreateLoadBalancerPolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLoadBalancerPolicyRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewCreateLoadBalancerPolicyRequestWithBody generates requests for CreateLoadBalancerPolicy with any type of body
func NewCreateLoadBalancerPolicyRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/loadBalancers/%s/policies", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadVmsHealthRequest calls the generic ReadVmsHealth builder with application/json body
func NewReadVmsHealthRequest(server string, spaceId SpaceId, id string, body ReadVmsHealthJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReadVmsHealthRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewReadVmsHealthRequestWithBody generates requests for ReadVmsHealth with any type of body
func NewReadVmsHealthRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/loadBalancers/%s/vmsHealth", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadLoadBalancerTagsRequest calls the generic ReadLoadBalancerTags builder with application/json body
func NewReadLoadBalancerTagsRequest(server string, spaceId SpaceId, body ReadLoadBalancerTagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReadLoadBalancerTagsRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewReadLoadBalancerTagsRequestWithBody generates requests for ReadLoadBalancerTags with any type of body
func NewReadLoadBalancerTagsRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/loadBalancersTags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadNatGatewayRequest generates requests for ReadNatGateway
func NewReadNatGatewayRequest(server string, spaceId SpaceId, params *ReadNatGatewayParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/natGateways", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubnetIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subnetIds", runtime.ParamLocationQuery, *params.SubnetIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VpcIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vpcIds", runtime.ParamLocationQuery, *params.VpcIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNatGatewayRequest calls the generic CreateNatGateway builder with application/json body
func NewCreateNatGatewayRequest(server string, spaceId SpaceId, body CreateNatGatewayJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNatGatewayRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateNatGatewayRequestWithBody generates requests for CreateNatGateway with any type of body
func NewCreateNatGatewayRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/natGateways", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteNatGatewayRequest generates requests for DeleteNatGateway
func NewDeleteNatGatewayRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/natGateways/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadNatGatewayByIdRequest generates requests for ReadNatGatewayById
func NewReadNatGatewayByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/natGateways/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadNicsRequest generates requests for ReadNics
func NewReadNicsRequest(server string, spaceId SpaceId, params *ReadNicsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/nics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Descriptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "descriptions", runtime.ParamLocationQuery, *params.Descriptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsSourceDestCheck != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isSourceDestCheck", runtime.ParamLocationQuery, *params.IsSourceDestCheck); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkNicDeleteOnVmDeletion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkNicDeleteOnVmDeletion", runtime.ParamLocationQuery, *params.LinkNicDeleteOnVmDeletion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkNicDeviceNumbers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkNicDeviceNumbers", runtime.ParamLocationQuery, *params.LinkNicDeviceNumbers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkNicLinkNicIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkNicLinkNicIds", runtime.ParamLocationQuery, *params.LinkNicLinkNicIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkNicStates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkNicStates", runtime.ParamLocationQuery, *params.LinkNicStates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkNicVmIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkNicVmIds", runtime.ParamLocationQuery, *params.LinkNicVmIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkPublicIpLinkPublicIpIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkPublicIpLinkPublicIpIds", runtime.ParamLocationQuery, *params.LinkPublicIpLinkPublicIpIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkPublicIpPublicIpIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkPublicIpPublicIpIds", runtime.ParamLocationQuery, *params.LinkPublicIpPublicIpIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkPublicIpPublicIps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkPublicIpPublicIps", runtime.ParamLocationQuery, *params.LinkPublicIpPublicIps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MacAddresses != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "macAddresses", runtime.ParamLocationQuery, *params.MacAddresses); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrivateDnsNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "privateDnsNames", runtime.ParamLocationQuery, *params.PrivateDnsNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrivateIpsLinkPublicIpPublicIps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "privateIpsLinkPublicIpPublicIps", runtime.ParamLocationQuery, *params.PrivateIpsLinkPublicIpPublicIps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrivateIpsPrimaryIp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "privateIpsPrimaryIp", runtime.ParamLocationQuery, *params.PrivateIpsPrimaryIp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrivateIpsPrivateIps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "privateIpsPrivateIps", runtime.ParamLocationQuery, *params.PrivateIpsPrivateIps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SecurityGroupIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "securityGroupIds", runtime.ParamLocationQuery, *params.SecurityGroupIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SecurityGroupNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "securityGroupNames", runtime.ParamLocationQuery, *params.SecurityGroupNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubnetIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subnetIds", runtime.ParamLocationQuery, *params.SubnetIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VpcIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vpcIds", runtime.ParamLocationQuery, *params.VpcIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AvailabilityZoneNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "availabilityZoneNames", runtime.ParamLocationQuery, *params.AvailabilityZoneNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNicRequest calls the generic CreateNic builder with application/json body
func NewCreateNicRequest(server string, spaceId SpaceId, body CreateNicJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNicRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateNicRequestWithBody generates requests for CreateNic with any type of body
func NewCreateNicRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/nics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteNicRequest generates requests for DeleteNic
func NewDeleteNicRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/nics/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadNicsByIdRequest generates requests for ReadNicsById
func NewReadNicsByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/nics/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateNicRequest calls the generic UpdateNic builder with application/json body
func NewUpdateNicRequest(server string, spaceId SpaceId, id string, body UpdateNicJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateNicRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateNicRequestWithBody generates requests for UpdateNic with any type of body
func NewUpdateNicRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/nics/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLinkPrivateIpsRequest calls the generic LinkPrivateIps builder with application/json body
func NewLinkPrivateIpsRequest(server string, spaceId SpaceId, id string, body LinkPrivateIpsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkPrivateIpsRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewLinkPrivateIpsRequestWithBody generates requests for LinkPrivateIps with any type of body
func NewLinkPrivateIpsRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/nics/%s/privateIps/link", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnlinkPrivateIpsRequest calls the generic UnlinkPrivateIps builder with application/json body
func NewUnlinkPrivateIpsRequest(server string, spaceId SpaceId, id string, body UnlinkPrivateIpsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnlinkPrivateIpsRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUnlinkPrivateIpsRequestWithBody generates requests for UnlinkPrivateIps with any type of body
func NewUnlinkPrivateIpsRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/nics/%s/privateIps/unlink", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLinkNicRequest calls the generic LinkNic builder with application/json body
func NewLinkNicRequest(server string, spaceId SpaceId, id string, body LinkNicJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkNicRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewLinkNicRequestWithBody generates requests for LinkNic with any type of body
func NewLinkNicRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/nics/%s/vms/link", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnlinkNicRequest calls the generic UnlinkNic builder with application/json body
func NewUnlinkNicRequest(server string, spaceId SpaceId, id string, body UnlinkNicJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnlinkNicRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUnlinkNicRequestWithBody generates requests for UnlinkNic with any type of body
func NewUnlinkNicRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/nics/%s/vms/unlink", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadPublicIpRangesRequest generates requests for ReadPublicIpRanges
func NewReadPublicIpRangesRequest(server string, spaceId SpaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/publicIpRanges", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadPublicIpsRequest generates requests for ReadPublicIps
func NewReadPublicIpsRequest(server string, spaceId SpaceId, params *ReadPublicIpsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/publicIps", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LinkPublicIpIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkPublicIpIds", runtime.ParamLocationQuery, *params.LinkPublicIpIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicIds", runtime.ParamLocationQuery, *params.NicIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrivateIps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "privateIps", runtime.ParamLocationQuery, *params.PrivateIps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VmIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vmIds", runtime.ParamLocationQuery, *params.VmIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePublicIpRequest generates requests for CreatePublicIp
func NewCreatePublicIpRequest(server string, spaceId SpaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/publicIps", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeletePublicIpRequest generates requests for DeletePublicIp
func NewDeletePublicIpRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/publicIps/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadPublicIpsByIdRequest generates requests for ReadPublicIpsById
func NewReadPublicIpsByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/publicIps/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLinkPublicIpRequest calls the generic LinkPublicIp builder with application/json body
func NewLinkPublicIpRequest(server string, spaceId SpaceId, id string, body LinkPublicIpJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkPublicIpRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewLinkPublicIpRequestWithBody generates requests for LinkPublicIp with any type of body
func NewLinkPublicIpRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/publicIps/%s/link", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnlinkPublicIpRequest calls the generic UnlinkPublicIp builder with application/json body
func NewUnlinkPublicIpRequest(server string, spaceId SpaceId, id string, body UnlinkPublicIpJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnlinkPublicIpRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUnlinkPublicIpRequestWithBody generates requests for UnlinkPublicIp with any type of body
func NewUnlinkPublicIpRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/publicIps/%s/unlink", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadRouteTablesRequest generates requests for ReadRouteTables
func NewReadRouteTablesRequest(server string, spaceId SpaceId, params *ReadRouteTablesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/routeTables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LinkRouteTableIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkRouteTableIds", runtime.ParamLocationQuery, *params.LinkRouteTableIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkRouteTableLinkRouteTableIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkRouteTableLinkRouteTableIds", runtime.ParamLocationQuery, *params.LinkRouteTableLinkRouteTableIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkRouteTableMain != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkRouteTableMain", runtime.ParamLocationQuery, *params.LinkRouteTableMain); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkSubnetIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkSubnetIds", runtime.ParamLocationQuery, *params.LinkSubnetIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RouteCreationMethods != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "routeCreationMethods", runtime.ParamLocationQuery, *params.RouteCreationMethods); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RouteDestinationIpRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "routeDestinationIpRanges", runtime.ParamLocationQuery, *params.RouteDestinationIpRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RouteDestinationServiceIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "routeDestinationServiceIds", runtime.ParamLocationQuery, *params.RouteDestinationServiceIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RouteGatewayIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "routeGatewayIds", runtime.ParamLocationQuery, *params.RouteGatewayIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RouteStates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "routeStates", runtime.ParamLocationQuery, *params.RouteStates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RouteVmIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "routeVmIds", runtime.ParamLocationQuery, *params.RouteVmIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VpcIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vpcIds", runtime.ParamLocationQuery, *params.VpcIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RouteNatGatewayIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "routeNatGatewayIds", runtime.ParamLocationQuery, *params.RouteNatGatewayIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RouteVpcPeeringIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "routeVpcPeeringIds", runtime.ParamLocationQuery, *params.RouteVpcPeeringIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRouteTableRequest calls the generic CreateRouteTable builder with application/json body
func NewCreateRouteTableRequest(server string, spaceId SpaceId, body CreateRouteTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRouteTableRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateRouteTableRequestWithBody generates requests for CreateRouteTable with any type of body
func NewCreateRouteTableRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/routeTables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRouteTableRequest generates requests for DeleteRouteTable
func NewDeleteRouteTableRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/routeTables/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadRouteTablesByIdRequest generates requests for ReadRouteTablesById
func NewReadRouteTablesByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/routeTables/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRouteTableRoutePropagationRequest calls the generic UpdateRouteTableRoutePropagation builder with application/json body
func NewUpdateRouteTableRoutePropagationRequest(server string, spaceId SpaceId, id string, body UpdateRouteTableRoutePropagationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRouteTableRoutePropagationRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateRouteTableRoutePropagationRequestWithBody generates requests for UpdateRouteTableRoutePropagation with any type of body
func NewUpdateRouteTableRoutePropagationRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/routeTables/%s/routePropagation", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRouteRequest calls the generic DeleteRoute builder with application/json body
func NewDeleteRouteRequest(server string, spaceId SpaceId, id string, body DeleteRouteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteRouteRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewDeleteRouteRequestWithBody generates requests for DeleteRoute with any type of body
func NewDeleteRouteRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/routeTables/%s/routes", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateRouteRequest calls the generic CreateRoute builder with application/json body
func NewCreateRouteRequest(server string, spaceId SpaceId, id string, body CreateRouteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRouteRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewCreateRouteRequestWithBody generates requests for CreateRoute with any type of body
func NewCreateRouteRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/routeTables/%s/routes", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateRouteRequest calls the generic UpdateRoute builder with application/json body
func NewUpdateRouteRequest(server string, spaceId SpaceId, id string, body UpdateRouteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRouteRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateRouteRequestWithBody generates requests for UpdateRoute with any type of body
func NewUpdateRouteRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/routeTables/%s/routes", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLinkRouteTableRequest calls the generic LinkRouteTable builder with application/json body
func NewLinkRouteTableRequest(server string, spaceId SpaceId, id string, body LinkRouteTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkRouteTableRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewLinkRouteTableRequestWithBody generates requests for LinkRouteTable with any type of body
func NewLinkRouteTableRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/routeTables/%s/subnets/link", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnlinkRouteTableRequest calls the generic UnlinkRouteTable builder with application/json body
func NewUnlinkRouteTableRequest(server string, spaceId SpaceId, id string, body UnlinkRouteTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnlinkRouteTableRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUnlinkRouteTableRequestWithBody generates requests for UnlinkRouteTable with any type of body
func NewUnlinkRouteTableRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/routeTables/%s/subnets/unlink", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadSecurityGroupsRequest generates requests for ReadSecurityGroups
func NewReadSecurityGroupsRequest(server string, spaceId SpaceId, params *ReadSecurityGroupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/securityGroups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Descriptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "descriptions", runtime.ParamLocationQuery, *params.Descriptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InboundRuleFromPortRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inboundRuleFromPortRanges", runtime.ParamLocationQuery, *params.InboundRuleFromPortRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InboundRuleIpRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inboundRuleIpRanges", runtime.ParamLocationQuery, *params.InboundRuleIpRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InboundRuleProtocols != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inboundRuleProtocols", runtime.ParamLocationQuery, *params.InboundRuleProtocols); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InboundRuleSecurityGroupIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inboundRuleSecurityGroupIds", runtime.ParamLocationQuery, *params.InboundRuleSecurityGroupIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InboundRuleSecurityGroupNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inboundRuleSecurityGroupNames", runtime.ParamLocationQuery, *params.InboundRuleSecurityGroupNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InboundRuleToPortRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inboundRuleToPortRanges", runtime.ParamLocationQuery, *params.InboundRuleToPortRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OutboundRuleFromPortRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outboundRuleFromPortRanges", runtime.ParamLocationQuery, *params.OutboundRuleFromPortRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OutboundRuleIpRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outboundRuleIpRanges", runtime.ParamLocationQuery, *params.OutboundRuleIpRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OutboundRuleProtocols != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outboundRuleProtocols", runtime.ParamLocationQuery, *params.OutboundRuleProtocols); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OutboundRuleSecurityGroupIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outboundRuleSecurityGroupIds", runtime.ParamLocationQuery, *params.OutboundRuleSecurityGroupIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OutboundRuleSecurityGroupNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outboundRuleSecurityGroupNames", runtime.ParamLocationQuery, *params.OutboundRuleSecurityGroupNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OutboundRuleToPortRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outboundRuleToPortRanges", runtime.ParamLocationQuery, *params.OutboundRuleToPortRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SecurityGroupIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "securityGroupIds", runtime.ParamLocationQuery, *params.SecurityGroupIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SecurityGroupNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "securityGroupNames", runtime.ParamLocationQuery, *params.SecurityGroupNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VpcIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vpcIds", runtime.ParamLocationQuery, *params.VpcIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSecurityGroupRequest calls the generic CreateSecurityGroup builder with application/json body
func NewCreateSecurityGroupRequest(server string, spaceId SpaceId, body CreateSecurityGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSecurityGroupRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateSecurityGroupRequestWithBody generates requests for CreateSecurityGroup with any type of body
func NewCreateSecurityGroupRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/securityGroups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSecurityGroupRequest generates requests for DeleteSecurityGroup
func NewDeleteSecurityGroupRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/securityGroups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadSecurityGroupsByIdRequest generates requests for ReadSecurityGroupsById
func NewReadSecurityGroupsByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/securityGroups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteSecurityGroupRuleRequest calls the generic DeleteSecurityGroupRule builder with application/json body
func NewDeleteSecurityGroupRuleRequest(server string, spaceId SpaceId, id string, body DeleteSecurityGroupRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteSecurityGroupRuleRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewDeleteSecurityGroupRuleRequestWithBody generates requests for DeleteSecurityGroupRule with any type of body
func NewDeleteSecurityGroupRuleRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/securityGroups/%s/rules", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateSecurityGroupRuleRequest calls the generic CreateSecurityGroupRule builder with application/json body
func NewCreateSecurityGroupRuleRequest(server string, spaceId SpaceId, id string, body CreateSecurityGroupRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSecurityGroupRuleRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewCreateSecurityGroupRuleRequestWithBody generates requests for CreateSecurityGroupRule with any type of body
func NewCreateSecurityGroupRuleRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/securityGroups/%s/rules", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadServerCertificatesRequest generates requests for ReadServerCertificates
func NewReadServerCertificatesRequest(server string, spaceId SpaceId, params *ReadServerCertificatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/serverCertificates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Paths != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paths", runtime.ParamLocationQuery, *params.Paths); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateServerCertificateRequest calls the generic CreateServerCertificate builder with application/json body
func NewCreateServerCertificateRequest(server string, spaceId SpaceId, body CreateServerCertificateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServerCertificateRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateServerCertificateRequestWithBody generates requests for CreateServerCertificate with any type of body
func NewCreateServerCertificateRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/serverCertificates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServerCertificateRequest generates requests for DeleteServerCertificate
func NewDeleteServerCertificateRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/serverCertificates/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateServerCertificateRequest calls the generic UpdateServerCertificate builder with application/json body
func NewUpdateServerCertificateRequest(server string, spaceId SpaceId, id string, body UpdateServerCertificateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateServerCertificateRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateServerCertificateRequestWithBody generates requests for UpdateServerCertificate with any type of body
func NewUpdateServerCertificateRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/serverCertificates/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadSnapshotsRequest generates requests for ReadSnapshots
func NewReadSnapshotsRequest(server string, spaceId SpaceId, params *ReadSnapshotsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/snapshots", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Descriptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "descriptions", runtime.ParamLocationQuery, *params.Descriptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FromCreationDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromCreationDate", runtime.ParamLocationQuery, *params.FromCreationDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Progresses != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "progresses", runtime.ParamLocationQuery, *params.Progresses); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToCreationDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toCreationDate", runtime.ParamLocationQuery, *params.ToCreationDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VolumeIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "volumeIds", runtime.ParamLocationQuery, *params.VolumeIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VolumeSizes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "volumeSizes", runtime.ParamLocationQuery, *params.VolumeSizes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsPublic != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isPublic", runtime.ParamLocationQuery, *params.IsPublic); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSnapshotRequest calls the generic CreateSnapshot builder with application/json body
func NewCreateSnapshotRequest(server string, spaceId SpaceId, body CreateSnapshotJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSnapshotRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateSnapshotRequestWithBody generates requests for CreateSnapshot with any type of body
func NewCreateSnapshotRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/snapshots", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSnapshotRequest generates requests for DeleteSnapshot
func NewDeleteSnapshotRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/snapshots/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadSnapshotsByIdRequest generates requests for ReadSnapshotsById
func NewReadSnapshotsByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/snapshots/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadSubnetsRequest generates requests for ReadSubnets
func NewReadSubnetsRequest(server string, spaceId SpaceId, params *ReadSubnetsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/subnets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AvailableIpsCounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "availableIpsCounts", runtime.ParamLocationQuery, *params.AvailableIpsCounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IpRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ipRanges", runtime.ParamLocationQuery, *params.IpRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VpcIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vpcIds", runtime.ParamLocationQuery, *params.VpcIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AvailabilityZoneNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "availabilityZoneNames", runtime.ParamLocationQuery, *params.AvailabilityZoneNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSubnetRequest calls the generic CreateSubnet builder with application/json body
func NewCreateSubnetRequest(server string, spaceId SpaceId, body CreateSubnetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSubnetRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateSubnetRequestWithBody generates requests for CreateSubnet with any type of body
func NewCreateSubnetRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/subnets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSubnetRequest generates requests for DeleteSubnet
func NewDeleteSubnetRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/subnets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadSubnetsByIdRequest generates requests for ReadSubnetsById
func NewReadSubnetsByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/subnets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSubnetRequest calls the generic UpdateSubnet builder with application/json body
func NewUpdateSubnetRequest(server string, spaceId SpaceId, id string, body UpdateSubnetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSubnetRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateSubnetRequestWithBody generates requests for UpdateSubnet with any type of body
func NewUpdateSubnetRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/subnets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadTagsRequest generates requests for ReadTags
func NewReadTagsRequest(server string, spaceId SpaceId, params *ReadTagsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Keys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keys", runtime.ParamLocationQuery, *params.Keys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResourceIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resourceIds", runtime.ParamLocationQuery, *params.ResourceIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResourceTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resourceTypes", runtime.ParamLocationQuery, *params.ResourceTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Values != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "values", runtime.ParamLocationQuery, *params.Values); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadVirtualGatewaysRequest generates requests for ReadVirtualGateways
func NewReadVirtualGatewaysRequest(server string, spaceId SpaceId, params *ReadVirtualGatewaysParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/virtualGateways", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ConnectionTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "connectionTypes", runtime.ParamLocationQuery, *params.ConnectionTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkStates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkStates", runtime.ParamLocationQuery, *params.LinkStates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkVpcIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkVpcIds", runtime.ParamLocationQuery, *params.LinkVpcIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVirtualGatewayRequest calls the generic CreateVirtualGateway builder with application/json body
func NewCreateVirtualGatewayRequest(server string, spaceId SpaceId, body CreateVirtualGatewayJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVirtualGatewayRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateVirtualGatewayRequestWithBody generates requests for CreateVirtualGateway with any type of body
func NewCreateVirtualGatewayRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/virtualGateways", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVirtualGatewayRequest generates requests for DeleteVirtualGateway
func NewDeleteVirtualGatewayRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/virtualGateways/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadVirtualGatewaysByIdRequest generates requests for ReadVirtualGatewaysById
func NewReadVirtualGatewaysByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/virtualGateways/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLinkVirtualGatewayToVpcRequest calls the generic LinkVirtualGatewayToVpc builder with application/json body
func NewLinkVirtualGatewayToVpcRequest(server string, spaceId SpaceId, id string, body LinkVirtualGatewayToVpcJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkVirtualGatewayToVpcRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewLinkVirtualGatewayToVpcRequestWithBody generates requests for LinkVirtualGatewayToVpc with any type of body
func NewLinkVirtualGatewayToVpcRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/virtualGateways/%s/vpcs/link", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnlinkVirtualGatewayToVpcRequest calls the generic UnlinkVirtualGatewayToVpc builder with application/json body
func NewUnlinkVirtualGatewayToVpcRequest(server string, spaceId SpaceId, id string, body UnlinkVirtualGatewayToVpcJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnlinkVirtualGatewayToVpcRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUnlinkVirtualGatewayToVpcRequestWithBody generates requests for UnlinkVirtualGatewayToVpc with any type of body
func NewUnlinkVirtualGatewayToVpcRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/virtualGateways/%s/vpcs/unlink", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadVmsRequest generates requests for ReadVms
func NewReadVmsRequest(server string, spaceId SpaceId, params *ReadVmsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vms", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Architectures != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "architectures", runtime.ParamLocationQuery, *params.Architectures); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BlockDeviceMappingDeleteOnVmDeletion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blockDeviceMappingDeleteOnVmDeletion", runtime.ParamLocationQuery, *params.BlockDeviceMappingDeleteOnVmDeletion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BlockDeviceMappingDeviceNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blockDeviceMappingDeviceNames", runtime.ParamLocationQuery, *params.BlockDeviceMappingDeviceNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BlockDeviceMappingLinkDates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blockDeviceMappingLinkDates", runtime.ParamLocationQuery, *params.BlockDeviceMappingLinkDates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BlockDeviceMappingStates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blockDeviceMappingStates", runtime.ParamLocationQuery, *params.BlockDeviceMappingStates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BlockDeviceMappingVolumeIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blockDeviceMappingVolumeIds", runtime.ParamLocationQuery, *params.BlockDeviceMappingVolumeIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClientTokens != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "clientTokens", runtime.ParamLocationQuery, *params.ClientTokens); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreationDates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "creationDates", runtime.ParamLocationQuery, *params.CreationDates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageIds", runtime.ParamLocationQuery, *params.ImageIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsSourceDestChecked != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isSourceDestChecked", runtime.ParamLocationQuery, *params.IsSourceDestChecked); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.KeypairNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keypairNames", runtime.ParamLocationQuery, *params.KeypairNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LaunchNumbers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "launchNumbers", runtime.ParamLocationQuery, *params.LaunchNumbers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Lifecycles != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lifecycles", runtime.ParamLocationQuery, *params.Lifecycles); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicDescriptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicDescriptions", runtime.ParamLocationQuery, *params.NicDescriptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicIsSourceDestChecked != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicIsSourceDestChecked", runtime.ParamLocationQuery, *params.NicIsSourceDestChecked); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicLinkNicDeleteOnVmDeletion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicLinkNicDeleteOnVmDeletion", runtime.ParamLocationQuery, *params.NicLinkNicDeleteOnVmDeletion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicLinkNicDeviceNumbers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicLinkNicDeviceNumbers", runtime.ParamLocationQuery, *params.NicLinkNicDeviceNumbers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicLinkNicLinkNicDates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicLinkNicLinkNicDates", runtime.ParamLocationQuery, *params.NicLinkNicLinkNicDates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicLinkNicLinkNicIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicLinkNicLinkNicIds", runtime.ParamLocationQuery, *params.NicLinkNicLinkNicIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicLinkNicStates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicLinkNicStates", runtime.ParamLocationQuery, *params.NicLinkNicStates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicLinkNicVmIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicLinkNicVmIds", runtime.ParamLocationQuery, *params.NicLinkNicVmIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicLinkPublicIpLinkPublicIpIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicLinkPublicIpLinkPublicIpIds", runtime.ParamLocationQuery, *params.NicLinkPublicIpLinkPublicIpIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicLinkPublicIpPublicIpIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicLinkPublicIpPublicIpIds", runtime.ParamLocationQuery, *params.NicLinkPublicIpPublicIpIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicLinkPublicIpPublicIps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicLinkPublicIpPublicIps", runtime.ParamLocationQuery, *params.NicLinkPublicIpPublicIps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicMacAddresses != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicMacAddresses", runtime.ParamLocationQuery, *params.NicMacAddresses); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicNicIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicNicIds", runtime.ParamLocationQuery, *params.NicNicIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicPrivateIpsLinkPublicIpIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicPrivateIpsLinkPublicIpIds", runtime.ParamLocationQuery, *params.NicPrivateIpsLinkPublicIpIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicPrivateIpsPrimaryIp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicPrivateIpsPrimaryIp", runtime.ParamLocationQuery, *params.NicPrivateIpsPrimaryIp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicPrivateIpsPrivateIps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicPrivateIpsPrivateIps", runtime.ParamLocationQuery, *params.NicPrivateIpsPrivateIps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicSecurityGroupIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicSecurityGroupIds", runtime.ParamLocationQuery, *params.NicSecurityGroupIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicSecurityGroupNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicSecurityGroupNames", runtime.ParamLocationQuery, *params.NicSecurityGroupNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicStates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicStates", runtime.ParamLocationQuery, *params.NicStates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicSubnetIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicSubnetIds", runtime.ParamLocationQuery, *params.NicSubnetIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Platforms != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "platforms", runtime.ParamLocationQuery, *params.Platforms); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrivateIps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "privateIps", runtime.ParamLocationQuery, *params.PrivateIps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductCodes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "productCodes", runtime.ParamLocationQuery, *params.ProductCodes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PublicIps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "publicIps", runtime.ParamLocationQuery, *params.PublicIps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReservationIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reservationIds", runtime.ParamLocationQuery, *params.ReservationIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RootDeviceNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rootDeviceNames", runtime.ParamLocationQuery, *params.RootDeviceNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RootDeviceTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rootDeviceTypes", runtime.ParamLocationQuery, *params.RootDeviceTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SecurityGroupIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "securityGroupIds", runtime.ParamLocationQuery, *params.SecurityGroupIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SecurityGroupNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "securityGroupNames", runtime.ParamLocationQuery, *params.SecurityGroupNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StateReasonCodes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stateReasonCodes", runtime.ParamLocationQuery, *params.StateReasonCodes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StateReasonMessages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stateReasonMessages", runtime.ParamLocationQuery, *params.StateReasonMessages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StateReasons != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stateReasons", runtime.ParamLocationQuery, *params.StateReasons); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubnetIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subnetIds", runtime.ParamLocationQuery, *params.SubnetIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tenancies != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tenancies", runtime.ParamLocationQuery, *params.Tenancies); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VmSecurityGroupIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vmSecurityGroupIds", runtime.ParamLocationQuery, *params.VmSecurityGroupIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VmSecurityGroupNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vmSecurityGroupNames", runtime.ParamLocationQuery, *params.VmSecurityGroupNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VmStateCodes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vmStateCodes", runtime.ParamLocationQuery, *params.VmStateCodes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VmStateNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vmStateNames", runtime.ParamLocationQuery, *params.VmStateNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Types != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "types", runtime.ParamLocationQuery, *params.Types); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VpcIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vpcIds", runtime.ParamLocationQuery, *params.VpcIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicVpcIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicVpcIds", runtime.ParamLocationQuery, *params.NicVpcIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicAvailabilityZoneNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicAvailabilityZoneNames", runtime.ParamLocationQuery, *params.NicAvailabilityZoneNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AvailabilityZoneNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "availabilityZoneNames", runtime.ParamLocationQuery, *params.AvailabilityZoneNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVmsRequest calls the generic CreateVms builder with application/json body
func NewCreateVmsRequest(server string, spaceId SpaceId, body CreateVmsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVmsRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateVmsRequestWithBody generates requests for CreateVms with any type of body
func NewCreateVmsRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vms", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadVmsStateRequest generates requests for ReadVmsState
func NewReadVmsStateRequest(server string, spaceId SpaceId, params *ReadVmsStateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vms/states", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MaintenanceEventCodes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maintenanceEventCodes", runtime.ParamLocationQuery, *params.MaintenanceEventCodes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaintenanceEventDescriptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maintenanceEventDescriptions", runtime.ParamLocationQuery, *params.MaintenanceEventDescriptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaintenanceEventsNotAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maintenanceEventsNotAfter", runtime.ParamLocationQuery, *params.MaintenanceEventsNotAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaintenanceEventsNotBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maintenanceEventsNotBefore", runtime.ParamLocationQuery, *params.MaintenanceEventsNotBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VmStates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vmStates", runtime.ParamLocationQuery, *params.VmStates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AvailabilityZoneNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "availabilityZoneNames", runtime.ParamLocationQuery, *params.AvailabilityZoneNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteVmsRequest generates requests for DeleteVms
func NewDeleteVmsRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vms/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadVmsByIdRequest generates requests for ReadVmsById
func NewReadVmsByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vms/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVmRequest calls the generic UpdateVm builder with application/json body
func NewUpdateVmRequest(server string, spaceId SpaceId, id string, body UpdateVmJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVmRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateVmRequestWithBody generates requests for UpdateVm with any type of body
func NewUpdateVmRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vms/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadAdminPasswordRequest generates requests for ReadAdminPassword
func NewReadAdminPasswordRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vms/%s/adminPasswords", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadConsoleOutputRequest generates requests for ReadConsoleOutput
func NewReadConsoleOutputRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vms/%s/consoleOutputs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRebootVmRequest generates requests for RebootVm
func NewRebootVmRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vms/%s/reboot", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartVmRequest generates requests for StartVm
func NewStartVmRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vms/%s/start", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStopVmRequest calls the generic StopVm builder with application/json body
func NewStopVmRequest(server string, spaceId SpaceId, id string, body StopVmJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStopVmRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewStopVmRequestWithBody generates requests for StopVm with any type of body
func NewStopVmRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vms/%s/stop", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadVolumesRequest generates requests for ReadVolumes
func NewReadVolumesRequest(server string, spaceId SpaceId, params *ReadVolumesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/volumes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreationDates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "creationDates", runtime.ParamLocationQuery, *params.CreationDates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkVolumeDeleteOnVmDeletion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkVolumeDeleteOnVmDeletion", runtime.ParamLocationQuery, *params.LinkVolumeDeleteOnVmDeletion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkVolumeDeviceNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkVolumeDeviceNames", runtime.ParamLocationQuery, *params.LinkVolumeDeviceNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkVolumeLinkDates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkVolumeLinkDates", runtime.ParamLocationQuery, *params.LinkVolumeLinkDates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkVolumeLinkStates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkVolumeLinkStates", runtime.ParamLocationQuery, *params.LinkVolumeLinkStates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkVolumeVmIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkVolumeVmIds", runtime.ParamLocationQuery, *params.LinkVolumeVmIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SnapshotIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "snapshotIds", runtime.ParamLocationQuery, *params.SnapshotIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VolumeSizes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "volumeSizes", runtime.ParamLocationQuery, *params.VolumeSizes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VolumeStates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "volumeStates", runtime.ParamLocationQuery, *params.VolumeStates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VolumeTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "volumeTypes", runtime.ParamLocationQuery, *params.VolumeTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AvailabilityZoneNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "availabilityZoneNames", runtime.ParamLocationQuery, *params.AvailabilityZoneNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVolumeRequest calls the generic CreateVolume builder with application/json body
func NewCreateVolumeRequest(server string, spaceId SpaceId, body CreateVolumeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVolumeRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateVolumeRequestWithBody generates requests for CreateVolume with any type of body
func NewCreateVolumeRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/volumes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVolumeRequest generates requests for DeleteVolume
func NewDeleteVolumeRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/volumes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadVolumesByIdRequest generates requests for ReadVolumesById
func NewReadVolumesByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/volumes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVolumeRequest calls the generic UpdateVolume builder with application/json body
func NewUpdateVolumeRequest(server string, spaceId SpaceId, id string, body UpdateVolumeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVolumeRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateVolumeRequestWithBody generates requests for UpdateVolume with any type of body
func NewUpdateVolumeRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/volumes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLinkVolumeRequest calls the generic LinkVolume builder with application/json body
func NewLinkVolumeRequest(server string, spaceId SpaceId, id string, body LinkVolumeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkVolumeRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewLinkVolumeRequestWithBody generates requests for LinkVolume with any type of body
func NewLinkVolumeRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/volumes/%s/vms/link", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnlinkVolumeRequest calls the generic UnlinkVolume builder with application/json body
func NewUnlinkVolumeRequest(server string, spaceId SpaceId, id string, body UnlinkVolumeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnlinkVolumeRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUnlinkVolumeRequestWithBody generates requests for UnlinkVolume with any type of body
func NewUnlinkVolumeRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/volumes/%s/vms/unlink", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadVpcPeeringsRequest generates requests for ReadVpcPeerings
func NewReadVpcPeeringsRequest(server string, spaceId SpaceId, params *ReadVpcPeeringsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpcPeerings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExpirationDates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expirationDates", runtime.ParamLocationQuery, *params.ExpirationDates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StateMessages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stateMessages", runtime.ParamLocationQuery, *params.StateMessages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StateNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stateNames", runtime.ParamLocationQuery, *params.StateNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AccepterVpcIpRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accepterVpcIpRanges", runtime.ParamLocationQuery, *params.AccepterVpcIpRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AccepterVpcVpcIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accepterVpcVpcIds", runtime.ParamLocationQuery, *params.AccepterVpcVpcIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SourceVpcIpRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sourceVpcIpRanges", runtime.ParamLocationQuery, *params.SourceVpcIpRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SourceVpcVpcIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sourceVpcVpcIds", runtime.ParamLocationQuery, *params.SourceVpcVpcIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVpcPeeringRequest calls the generic CreateVpcPeering builder with application/json body
func NewCreateVpcPeeringRequest(server string, spaceId SpaceId, body CreateVpcPeeringJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVpcPeeringRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateVpcPeeringRequestWithBody generates requests for CreateVpcPeering with any type of body
func NewCreateVpcPeeringRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpcPeerings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVpcPeeringRequest generates requests for DeleteVpcPeering
func NewDeleteVpcPeeringRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpcPeerings/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadVpcPeeringsByIdRequest generates requests for ReadVpcPeeringsById
func NewReadVpcPeeringsByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpcPeerings/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAcceptVpcPeeringRequest generates requests for AcceptVpcPeering
func NewAcceptVpcPeeringRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpcPeerings/%s/accept", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRejectVpcPeeringRequest generates requests for RejectVpcPeering
func NewRejectVpcPeeringRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpcPeerings/%s/reject", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadVpcsRequest generates requests for ReadVpcs
func NewReadVpcsRequest(server string, spaceId SpaceId, params *ReadVpcsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpcs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DhcpOptionsSetIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dhcpOptionsSetIds", runtime.ParamLocationQuery, *params.DhcpOptionsSetIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IpRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ipRanges", runtime.ParamLocationQuery, *params.IpRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsDefault != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isDefault", runtime.ParamLocationQuery, *params.IsDefault); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVpcRequest calls the generic CreateVpc builder with application/json body
func NewCreateVpcRequest(server string, spaceId SpaceId, body CreateVpcJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVpcRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateVpcRequestWithBody generates requests for CreateVpc with any type of body
func NewCreateVpcRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpcs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVpcRequest generates requests for DeleteVpc
func NewDeleteVpcRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpcs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadVpcsByIdRequest generates requests for ReadVpcsById
func NewReadVpcsByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpcs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVpcRequest calls the generic UpdateVpc builder with application/json body
func NewUpdateVpcRequest(server string, spaceId SpaceId, id string, body UpdateVpcJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVpcRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateVpcRequestWithBody generates requests for UpdateVpc with any type of body
func NewUpdateVpcRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpcs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadVpnConnectionsRequest generates requests for ReadVpnConnections
func NewReadVpnConnectionsRequest(server string, spaceId SpaceId, params *ReadVpnConnectionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpnConnections", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BgpAsns != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bgpAsns", runtime.ParamLocationQuery, *params.BgpAsns); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClientGatewayIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "clientGatewayIds", runtime.ParamLocationQuery, *params.ClientGatewayIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ConnectionTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "connectionTypes", runtime.ParamLocationQuery, *params.ConnectionTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RouteDestinationIpRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "routeDestinationIpRanges", runtime.ParamLocationQuery, *params.RouteDestinationIpRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StaticRoutesOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "staticRoutesOnly", runtime.ParamLocationQuery, *params.StaticRoutesOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VirtualGatewayIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "virtualGatewayIds", runtime.ParamLocationQuery, *params.VirtualGatewayIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVpnConnectionRequest calls the generic CreateVpnConnection builder with application/json body
func NewCreateVpnConnectionRequest(server string, spaceId SpaceId, body CreateVpnConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVpnConnectionRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateVpnConnectionRequestWithBody generates requests for CreateVpnConnection with any type of body
func NewCreateVpnConnectionRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpnConnections", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVpnConnectionRequest generates requests for DeleteVpnConnection
func NewDeleteVpnConnectionRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpnConnections/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadVpnConnectionsByIdRequest generates requests for ReadVpnConnectionsById
func NewReadVpnConnectionsByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpnConnections/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVpnConnectionRequest calls the generic UpdateVpnConnection builder with application/json body
func NewUpdateVpnConnectionRequest(server string, spaceId SpaceId, id string, body UpdateVpnConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVpnConnectionRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateVpnConnectionRequestWithBody generates requests for UpdateVpnConnection with any type of body
func NewUpdateVpnConnectionRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpnConnections/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVpnConnectionRouteRequest calls the generic DeleteVpnConnectionRoute builder with application/json body
func NewDeleteVpnConnectionRouteRequest(server string, spaceId SpaceId, id string, body DeleteVpnConnectionRouteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteVpnConnectionRouteRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewDeleteVpnConnectionRouteRequestWithBody generates requests for DeleteVpnConnectionRoute with any type of body
func NewDeleteVpnConnectionRouteRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpnConnections/%s/routes", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateVpnConnectionRouteRequest calls the generic CreateVpnConnectionRoute builder with application/json body
func NewCreateVpnConnectionRouteRequest(server string, spaceId SpaceId, id string, body CreateVpnConnectionRouteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVpnConnectionRouteRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewCreateVpnConnectionRouteRequestWithBody generates requests for CreateVpnConnectionRoute with any type of body
func NewCreateVpnConnectionRouteRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpnConnections/%s/routes", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewJsonWebKeysRequest generates requests for JsonWebKeys
func NewJsonWebKeysRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/.well-known/jwks.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDiscoverOidcConfigurationRequest generates requests for DiscoverOidcConfiguration
func NewDiscoverOidcConfigurationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/.well-known/openid-configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWebAuthnJavaScriptRequest generates requests for GetWebAuthnJavaScript
func NewGetWebAuthnJavaScriptRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/.well-known/webauthn.js")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAdminServiceAccountSpaceRequest calls the generic CreateAdminServiceAccountSpace builder with application/json body
func NewCreateAdminServiceAccountSpaceRequest(server string, organisationId OrganisationId, spaceId SpaceId, body CreateAdminServiceAccountSpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAdminServiceAccountSpaceRequestWithBody(server, organisationId, spaceId, "application/json", bodyReader)
}

// NewCreateAdminServiceAccountSpaceRequestWithBody generates requests for CreateAdminServiceAccountSpace with any type of body
func NewCreateAdminServiceAccountSpaceRequestWithBody(server string, organisationId OrganisationId, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/admin/organisations/%s/spaces/%s/serviceAccounts", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuthorizeRequest generates requests for Authorize
func NewAuthorizeRequest(server string, params *AuthorizeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/authorize")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ClientId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, *params.ClientId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RedirectUri != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect_uri", runtime.ParamLocationQuery, *params.RedirectUri); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_type", runtime.ParamLocationQuery, params.ResponseType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Scope != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scope", runtime.ParamLocationQuery, *params.Scope); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConsentRequest generates requests for Consent
func NewConsentRequest(server string, params *ConsentParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/consent")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "consent_challenge", runtime.ParamLocationQuery, params.ConsentChallenge); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFlowErrorRequest generates requests for GetFlowError
func NewGetFlowErrorRequest(server string, params *GetFlowErrorParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/errors")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateLoginFlowRequest calls the generic UpdateLoginFlow builder with application/json body
func NewUpdateLoginFlowRequest(server string, params *UpdateLoginFlowParams, body UpdateLoginFlowJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateLoginFlowRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateLoginFlowRequestWithFormdataBody calls the generic UpdateLoginFlow builder with application/x-www-form-urlencoded body
func NewUpdateLoginFlowRequestWithFormdataBody(server string, params *UpdateLoginFlowParams, body UpdateLoginFlowFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewUpdateLoginFlowRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewUpdateLoginFlowRequestWithBody generates requests for UpdateLoginFlow with any type of body
func NewUpdateLoginFlowRequestWithBody(server string, params *UpdateLoginFlowParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "flow", runtime.ParamLocationQuery, params.Flow); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XSessionToken != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Session-Token", runtime.ParamLocationHeader, *params.XSessionToken)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Session-Token", headerParam0)
		}

		if params.Cookie != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam1)
		}

	}

	return req, nil
}

// NewCreateNativeLoginFlowRequest generates requests for CreateNativeLoginFlow
func NewCreateNativeLoginFlowRequest(server string, params *CreateNativeLoginFlowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/login/api")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Refresh != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "refresh", runtime.ParamLocationQuery, *params.Refresh); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Aal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "aal", runtime.ParamLocationQuery, *params.Aal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReturnSessionTokenExchangeCode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return_session_token_exchange_code", runtime.ParamLocationQuery, *params.ReturnSessionTokenExchangeCode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReturnTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return_to", runtime.ParamLocationQuery, *params.ReturnTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Via != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "via", runtime.ParamLocationQuery, *params.Via); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XSessionToken != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Session-Token", runtime.ParamLocationHeader, *params.XSessionToken)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Session-Token", headerParam0)
		}

	}

	return req, nil
}

// NewCreateBrowserLoginFlowRequest generates requests for CreateBrowserLoginFlow
func NewCreateBrowserLoginFlowRequest(server string, params *CreateBrowserLoginFlowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/login/browser")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Refresh != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "refresh", runtime.ParamLocationQuery, *params.Refresh); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Aal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "aal", runtime.ParamLocationQuery, *params.Aal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReturnTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return_to", runtime.ParamLocationQuery, *params.ReturnTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LoginChallenge != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "login_challenge", runtime.ParamLocationQuery, *params.LoginChallenge); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Organization != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organization", runtime.ParamLocationQuery, *params.Organization); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Cookie != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam0)
		}

	}

	return req, nil
}

// NewGetLoginFlowRequest generates requests for GetLoginFlow
func NewGetLoginFlowRequest(server string, params *GetLoginFlowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/login/flows")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Cookie != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateLogoutFlowRequest generates requests for UpdateLogoutFlow
func NewUpdateLogoutFlowRequest(server string, params *UpdateLogoutFlowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Token != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token", runtime.ParamLocationQuery, *params.Token); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReturnTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return_to", runtime.ParamLocationQuery, *params.ReturnTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Cookie != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam0)
		}

	}

	return req, nil
}

// NewPerformNativeLogoutRequest calls the generic PerformNativeLogout builder with application/json body
func NewPerformNativeLogoutRequest(server string, body PerformNativeLogoutJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPerformNativeLogoutRequestWithBody(server, "application/json", bodyReader)
}

// NewPerformNativeLogoutRequestWithBody generates requests for PerformNativeLogout with any type of body
func NewPerformNativeLogoutRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/logout/api")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateBrowserLogoutFlowRequest generates requests for CreateBrowserLogoutFlow
func NewCreateBrowserLogoutFlowRequest(server string, params *CreateBrowserLogoutFlowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/logout/browser")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ReturnTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return_to", runtime.ParamLocationQuery, *params.ReturnTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Cookie != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("cookie", headerParam0)
		}

	}

	return req, nil
}

// NewInitRecoveryFlowRequest generates requests for InitRecoveryFlow
func NewInitRecoveryFlowRequest(server string, params *InitRecoveryFlowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/recovery")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "flow", runtime.ParamLocationQuery, params.Flow); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Token != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token", runtime.ParamLocationQuery, *params.Token); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Cookie != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateRecoveryFlowRequest calls the generic UpdateRecoveryFlow builder with application/json body
func NewUpdateRecoveryFlowRequest(server string, params *UpdateRecoveryFlowParams, body UpdateRecoveryFlowJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRecoveryFlowRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateRecoveryFlowRequestWithFormdataBody calls the generic UpdateRecoveryFlow builder with application/x-www-form-urlencoded body
func NewUpdateRecoveryFlowRequestWithFormdataBody(server string, params *UpdateRecoveryFlowParams, body UpdateRecoveryFlowFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewUpdateRecoveryFlowRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewUpdateRecoveryFlowRequestWithBody generates requests for UpdateRecoveryFlow with any type of body
func NewUpdateRecoveryFlowRequestWithBody(server string, params *UpdateRecoveryFlowParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/recovery")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "flow", runtime.ParamLocationQuery, params.Flow); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Token != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token", runtime.ParamLocationQuery, *params.Token); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Cookie != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam0)
		}

	}

	return req, nil
}

// NewCreateNativeRecoveryFlowRequest generates requests for CreateNativeRecoveryFlow
func NewCreateNativeRecoveryFlowRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/recovery/api")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBrowserRecoveryFlowRequest generates requests for CreateBrowserRecoveryFlow
func NewCreateBrowserRecoveryFlowRequest(server string, params *CreateBrowserRecoveryFlowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/recovery/browser")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ReturnTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return_to", runtime.ParamLocationQuery, *params.ReturnTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRecoveryFlowRequest generates requests for GetRecoveryFlow
func NewGetRecoveryFlowRequest(server string, params *GetRecoveryFlowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/recovery/flows")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Cookie != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateRegistrationFlowRequest calls the generic UpdateRegistrationFlow builder with application/json body
func NewUpdateRegistrationFlowRequest(server string, params *UpdateRegistrationFlowParams, body UpdateRegistrationFlowJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRegistrationFlowRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateRegistrationFlowRequestWithFormdataBody calls the generic UpdateRegistrationFlow builder with application/x-www-form-urlencoded body
func NewUpdateRegistrationFlowRequestWithFormdataBody(server string, params *UpdateRegistrationFlowParams, body UpdateRegistrationFlowFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewUpdateRegistrationFlowRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewUpdateRegistrationFlowRequestWithBody generates requests for UpdateRegistrationFlow with any type of body
func NewUpdateRegistrationFlowRequestWithBody(server string, params *UpdateRegistrationFlowParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/registration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "flow", runtime.ParamLocationQuery, params.Flow); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Cookie != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam0)
		}

	}

	return req, nil
}

// NewCreateNativeRegistrationFlowRequest generates requests for CreateNativeRegistrationFlow
func NewCreateNativeRegistrationFlowRequest(server string, params *CreateNativeRegistrationFlowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/registration/api")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ReturnSessionTokenExchangeCode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return_session_token_exchange_code", runtime.ParamLocationQuery, *params.ReturnSessionTokenExchangeCode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReturnTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return_to", runtime.ParamLocationQuery, *params.ReturnTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBrowserRegistrationFlowRequest generates requests for CreateBrowserRegistrationFlow
func NewCreateBrowserRegistrationFlowRequest(server string, params *CreateBrowserRegistrationFlowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/registration/browser")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ReturnTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return_to", runtime.ParamLocationQuery, *params.ReturnTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LoginChallenge != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "login_challenge", runtime.ParamLocationQuery, *params.LoginChallenge); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AfterVerificationReturnTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after_verification_return_to", runtime.ParamLocationQuery, *params.AfterVerificationReturnTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Organization != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organization", runtime.ParamLocationQuery, *params.Organization); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRegistrationFlowRequest generates requests for GetRegistrationFlow
func NewGetRegistrationFlowRequest(server string, params *GetRegistrationFlowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/registration/flows")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Cookie != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateSettingsFloRequest calls the generic UpdateSettingsFlo builder with application/json body
func NewUpdateSettingsFloRequest(server string, params *UpdateSettingsFloParams, body UpdateSettingsFloJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSettingsFloRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateSettingsFloRequestWithFormdataBody calls the generic UpdateSettingsFlo builder with application/x-www-form-urlencoded body
func NewUpdateSettingsFloRequestWithFormdataBody(server string, params *UpdateSettingsFloParams, body UpdateSettingsFloFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewUpdateSettingsFloRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewUpdateSettingsFloRequestWithBody generates requests for UpdateSettingsFlo with any type of body
func NewUpdateSettingsFloRequestWithBody(server string, params *UpdateSettingsFloParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "flow", runtime.ParamLocationQuery, params.Flow); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XSessionToken != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Session-Token", runtime.ParamLocationHeader, *params.XSessionToken)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Session-Token", headerParam0)
		}

		if params.Cookie != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam1)
		}

	}

	return req, nil
}

// NewCreateNativeSettingsFlowRequest generates requests for CreateNativeSettingsFlow
func NewCreateNativeSettingsFlowRequest(server string, params *CreateNativeSettingsFlowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/settings/api")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XSessionToken != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Session-Token", runtime.ParamLocationHeader, *params.XSessionToken)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Session-Token", headerParam0)
		}

	}

	return req, nil
}

// NewCreateBrowserSettingsFlowRequest generates requests for CreateBrowserSettingsFlow
func NewCreateBrowserSettingsFlowRequest(server string, params *CreateBrowserSettingsFlowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/settings/browser")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ReturnTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return_to", runtime.ParamLocationQuery, *params.ReturnTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Cookie != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam0)
		}

	}

	return req, nil
}

// NewGetSettingsFlowRequest generates requests for GetSettingsFlow
func NewGetSettingsFlowRequest(server string, params *GetSettingsFlowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/settings/flows")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XSessionToken != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Session-Token", runtime.ParamLocationHeader, *params.XSessionToken)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Session-Token", headerParam0)
		}

		if params.Cookie != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam1)
		}

	}

	return req, nil
}

// NewUpdateVerificationFlowRequest calls the generic UpdateVerificationFlow builder with application/json body
func NewUpdateVerificationFlowRequest(server string, params *UpdateVerificationFlowParams, body UpdateVerificationFlowJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVerificationFlowRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateVerificationFlowRequestWithFormdataBody calls the generic UpdateVerificationFlow builder with application/x-www-form-urlencoded body
func NewUpdateVerificationFlowRequestWithFormdataBody(server string, params *UpdateVerificationFlowParams, body UpdateVerificationFlowFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewUpdateVerificationFlowRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewUpdateVerificationFlowRequestWithBody generates requests for UpdateVerificationFlow with any type of body
func NewUpdateVerificationFlowRequestWithBody(server string, params *UpdateVerificationFlowParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/verification")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "flow", runtime.ParamLocationQuery, params.Flow); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Token != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token", runtime.ParamLocationQuery, *params.Token); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Cookie != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam0)
		}

	}

	return req, nil
}

// NewCreateNativeVerificationFlowRequest generates requests for CreateNativeVerificationFlow
func NewCreateNativeVerificationFlowRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/verification/api")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBrowserVerificationFlowRequest generates requests for CreateBrowserVerificationFlow
func NewCreateBrowserVerificationFlowRequest(server string, params *CreateBrowserVerificationFlowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/verification/browser")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ReturnTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return_to", runtime.ParamLocationQuery, *params.ReturnTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVerificationFlowRequest generates requests for GetVerificationFlow
func NewGetVerificationFlowRequest(server string, params *GetVerificationFlowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/verification/flows")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Cookie != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("cookie", headerParam0)
		}

	}

	return req, nil
}

// NewDisableMyOtherSessionsRequest generates requests for DisableMyOtherSessions
func NewDisableMyOtherSessionsRequest(server string, params *DisableMyOtherSessionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/sessions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XSessionToken != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Session-Token", runtime.ParamLocationHeader, *params.XSessionToken)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Session-Token", headerParam0)
		}

		if params.Cookie != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam1)
		}

	}

	return req, nil
}

// NewListMySessionsRequest generates requests for ListMySessions
func NewListMySessionsRequest(server string, params *ListMySessionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/sessions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_token", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XSessionToken != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Session-Token", runtime.ParamLocationHeader, *params.XSessionToken)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Session-Token", headerParam0)
		}

		if params.Cookie != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam1)
		}

	}

	return req, nil
}

// NewExchangeSessionTokenRequest generates requests for ExchangeSessionToken
func NewExchangeSessionTokenRequest(server string, params *ExchangeSessionTokenParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/sessions/token-exchange")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "init_code", runtime.ParamLocationQuery, params.InitCode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return_to_code", runtime.ParamLocationQuery, params.ReturnToCode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewToSessionRequest generates requests for ToSession
func NewToSessionRequest(server string, params *ToSessionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/sessions/whoami")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TokenizeAs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tokenize_as", runtime.ParamLocationQuery, *params.TokenizeAs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XSessionToken != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Session-Token", runtime.ParamLocationHeader, *params.XSessionToken)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Session-Token", headerParam0)
		}

		if params.Cookie != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam1)
		}

	}

	return req, nil
}

// NewIntrospectRequestWithFormdataBody calls the generic Introspect builder with application/x-www-form-urlencoded body
func NewIntrospectRequestWithFormdataBody(server string, body IntrospectFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewIntrospectRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewIntrospectRequestWithBody generates requests for Introspect with any type of body
func NewIntrospectRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/introspect")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListOrganisationsIdentityRequest generates requests for ListOrganisationsIdentity
func NewListOrganisationsIdentityRequest(server string, params *ListOrganisationsIdentityParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIAMGranularPolicyOrganisationRequest generates requests for GetIAMGranularPolicyOrganisation
func NewGetIAMGranularPolicyOrganisationRequest(server string, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "subjectType", runtime.ParamLocationPath, subjectType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "subjectId", runtime.ParamLocationPath, subjectId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "objectType", runtime.ParamLocationPath, objectType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/iamgranularPolicy/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetIAMGranularPolicyOrganisationRequest calls the generic SetIAMGranularPolicyOrganisation builder with application/json body
func NewSetIAMGranularPolicyOrganisationRequest(server string, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, body SetIAMGranularPolicyOrganisationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetIAMGranularPolicyOrganisationRequestWithBody(server, organisationId, subjectType, subjectId, objectType, "application/json", bodyReader)
}

// NewSetIAMGranularPolicyOrganisationRequestWithBody generates requests for SetIAMGranularPolicyOrganisation with any type of body
func NewSetIAMGranularPolicyOrganisationRequestWithBody(server string, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "subjectType", runtime.ParamLocationPath, subjectType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "subjectId", runtime.ParamLocationPath, subjectId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "objectType", runtime.ParamLocationPath, objectType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/iamgranularPolicy/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetIAMPolicyOrganisationRequest generates requests for GetIAMPolicyOrganisation
func NewGetIAMPolicyOrganisationRequest(server string, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "subjectType", runtime.ParamLocationPath, subjectType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "subjectId", runtime.ParamLocationPath, subjectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/iampolicy/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetIAMPolicyOrganisationRequest calls the generic SetIAMPolicyOrganisation builder with application/json body
func NewSetIAMPolicyOrganisationRequest(server string, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, body SetIAMPolicyOrganisationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetIAMPolicyOrganisationRequestWithBody(server, organisationId, subjectType, subjectId, "application/json", bodyReader)
}

// NewSetIAMPolicyOrganisationRequestWithBody generates requests for SetIAMPolicyOrganisation with any type of body
func NewSetIAMPolicyOrganisationRequestWithBody(server string, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "subjectType", runtime.ParamLocationPath, subjectType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "subjectId", runtime.ParamLocationPath, subjectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/iampolicy/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPermissionsOrganisationRequest generates requests for ListPermissionsOrganisation
func NewListPermissionsOrganisationRequest(server string, organisationId OrganisationId, params *ListPermissionsOrganisationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/permissions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Service != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "service", runtime.ParamLocationQuery, *params.Service); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Resource != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resource", runtime.ParamLocationQuery, *params.Resource); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Subresource != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subresource", runtime.ParamLocationQuery, *params.Subresource); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Action != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "action", runtime.ParamLocationQuery, *params.Action); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPermissionOrganisationRequest generates requests for GetPermissionOrganisation
func NewGetPermissionOrganisationRequest(server string, organisationId OrganisationId, permissionUuid PermissionUuid) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "permissionUuid", runtime.ParamLocationPath, permissionUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/permissions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRolesOrganisationRequest generates requests for ListRolesOrganisation
func NewListRolesOrganisationRequest(server string, organisationId OrganisationId, params *ListRolesOrganisationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/roles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRoleOrganisationRequest calls the generic CreateRoleOrganisation builder with application/json body
func NewCreateRoleOrganisationRequest(server string, organisationId OrganisationId, body CreateRoleOrganisationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRoleOrganisationRequestWithBody(server, organisationId, "application/json", bodyReader)
}

// NewCreateRoleOrganisationRequestWithBody generates requests for CreateRoleOrganisation with any type of body
func NewCreateRoleOrganisationRequestWithBody(server string, organisationId OrganisationId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/roles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRoleOrganisationRequest generates requests for DeleteRoleOrganisation
func NewDeleteRoleOrganisationRequest(server string, organisationId OrganisationId, roleUuid RoleUuid) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUuid", runtime.ParamLocationPath, roleUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/roles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRoleOrganisationRequest generates requests for GetRoleOrganisation
func NewGetRoleOrganisationRequest(server string, organisationId OrganisationId, roleUuid RoleUuid) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUuid", runtime.ParamLocationPath, roleUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/roles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRoleOrganisationRequest calls the generic UpdateRoleOrganisation builder with application/json body
func NewUpdateRoleOrganisationRequest(server string, organisationId OrganisationId, roleUuid RoleUuid, body UpdateRoleOrganisationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRoleOrganisationRequestWithBody(server, organisationId, roleUuid, "application/json", bodyReader)
}

// NewUpdateRoleOrganisationRequestWithBody generates requests for UpdateRoleOrganisation with any type of body
func NewUpdateRoleOrganisationRequestWithBody(server string, organisationId OrganisationId, roleUuid RoleUuid, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUuid", runtime.ParamLocationPath, roleUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/roles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveRolePermissionsOrganisationRequest calls the generic RemoveRolePermissionsOrganisation builder with application/json body
func NewRemoveRolePermissionsOrganisationRequest(server string, organisationId OrganisationId, roleUuid RoleUuid, body RemoveRolePermissionsOrganisationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveRolePermissionsOrganisationRequestWithBody(server, organisationId, roleUuid, "application/json", bodyReader)
}

// NewRemoveRolePermissionsOrganisationRequestWithBody generates requests for RemoveRolePermissionsOrganisation with any type of body
func NewRemoveRolePermissionsOrganisationRequestWithBody(server string, organisationId OrganisationId, roleUuid RoleUuid, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUuid", runtime.ParamLocationPath, roleUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/roles/%s/permissions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRolePermissionsOrganisationRequest generates requests for GetRolePermissionsOrganisation
func NewGetRolePermissionsOrganisationRequest(server string, organisationId OrganisationId, roleUuid RoleUuid) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUuid", runtime.ParamLocationPath, roleUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/roles/%s/permissions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddRolePermissionsOrganisationRequest calls the generic AddRolePermissionsOrganisation builder with application/json body
func NewAddRolePermissionsOrganisationRequest(server string, organisationId OrganisationId, roleUuid RoleUuid, body AddRolePermissionsOrganisationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddRolePermissionsOrganisationRequestWithBody(server, organisationId, roleUuid, "application/json", bodyReader)
}

// NewAddRolePermissionsOrganisationRequestWithBody generates requests for AddRolePermissionsOrganisation with any type of body
func NewAddRolePermissionsOrganisationRequestWithBody(server string, organisationId OrganisationId, roleUuid RoleUuid, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUuid", runtime.ParamLocationPath, roleUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/roles/%s/permissions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListServiceAccountOrganisationRequest calls the generic ListServiceAccountOrganisation builder with application/json body
func NewListServiceAccountOrganisationRequest(server string, organisationId OrganisationId, params *ListServiceAccountOrganisationParams, body ListServiceAccountOrganisationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListServiceAccountOrganisationRequestWithBody(server, organisationId, params, "application/json", bodyReader)
}

// NewListServiceAccountOrganisationRequestWithBody generates requests for ListServiceAccountOrganisation with any type of body
func NewListServiceAccountOrganisationRequestWithBody(server string, organisationId OrganisationId, params *ListServiceAccountOrganisationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/serviceAccounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateServiceAccountOrganisationRequest calls the generic CreateServiceAccountOrganisation builder with application/json body
func NewCreateServiceAccountOrganisationRequest(server string, organisationId OrganisationId, body CreateServiceAccountOrganisationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServiceAccountOrganisationRequestWithBody(server, organisationId, "application/json", bodyReader)
}

// NewCreateServiceAccountOrganisationRequestWithBody generates requests for CreateServiceAccountOrganisation with any type of body
func NewCreateServiceAccountOrganisationRequestWithBody(server string, organisationId OrganisationId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/serviceAccounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServiceAccountOrganisationRequest generates requests for DeleteServiceAccountOrganisation
func NewDeleteServiceAccountOrganisationRequest(server string, organisationId OrganisationId, serviceAccountId ServiceAccountId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/serviceAccounts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServiceAccountOrganisationRequest generates requests for GetServiceAccountOrganisation
func NewGetServiceAccountOrganisationRequest(server string, organisationId OrganisationId, serviceAccountId ServiceAccountId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/serviceAccounts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateServiceAccountOrganisationRequest calls the generic UpdateServiceAccountOrganisation builder with application/json body
func NewUpdateServiceAccountOrganisationRequest(server string, organisationId OrganisationId, serviceAccountId ServiceAccountId, body UpdateServiceAccountOrganisationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateServiceAccountOrganisationRequestWithBody(server, organisationId, serviceAccountId, "application/json", bodyReader)
}

// NewUpdateServiceAccountOrganisationRequestWithBody generates requests for UpdateServiceAccountOrganisation with any type of body
func NewUpdateServiceAccountOrganisationRequestWithBody(server string, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/serviceAccounts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetACLServiceAccountOrganisationRequest generates requests for GetACLServiceAccountOrganisation
func NewGetACLServiceAccountOrganisationRequest(server string, organisationId OrganisationId, serviceAccountId ServiceAccountId, params *GetACLServiceAccountOrganisationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/serviceAccounts/%s/acl", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "service", runtime.ParamLocationQuery, params.Service); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resource", runtime.ParamLocationQuery, params.Resource); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Subresource != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subresource", runtime.ParamLocationQuery, *params.Subresource); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteACLServiceAccountOrganisationBulkRequest calls the generic DeleteACLServiceAccountOrganisationBulk builder with application/json body
func NewDeleteACLServiceAccountOrganisationBulkRequest(server string, organisationId OrganisationId, serviceAccountId ServiceAccountId, body DeleteACLServiceAccountOrganisationBulkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteACLServiceAccountOrganisationBulkRequestWithBody(server, organisationId, serviceAccountId, "application/json", bodyReader)
}

// NewDeleteACLServiceAccountOrganisationBulkRequestWithBody generates requests for DeleteACLServiceAccountOrganisationBulk with any type of body
func NewDeleteACLServiceAccountOrganisationBulkRequestWithBody(server string, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/serviceAccounts/%s/bulk/acl", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateACLServiceAccountOrganisationBulkRequest calls the generic CreateACLServiceAccountOrganisationBulk builder with application/json body
func NewCreateACLServiceAccountOrganisationBulkRequest(server string, organisationId OrganisationId, serviceAccountId ServiceAccountId, body CreateACLServiceAccountOrganisationBulkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateACLServiceAccountOrganisationBulkRequestWithBody(server, organisationId, serviceAccountId, "application/json", bodyReader)
}

// NewCreateACLServiceAccountOrganisationBulkRequestWithBody generates requests for CreateACLServiceAccountOrganisationBulk with any type of body
func NewCreateACLServiceAccountOrganisationBulkRequestWithBody(server string, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/serviceAccounts/%s/bulk/acl", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListSpacesOfServiceAccountRequest generates requests for ListSpacesOfServiceAccount
func NewListSpacesOfServiceAccountRequest(server string, organisationId OrganisationId, serviceAccountId ServiceAccountId, params *ListSpacesOfServiceAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/serviceAccounts/%s/spaces", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSpacesIdentityRequest generates requests for ListSpacesIdentity
func NewListSpacesIdentityRequest(server string, organisationId OrganisationId, params *ListSpacesIdentityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/spaces", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUserOrganisationRequest calls the generic ListUserOrganisation builder with application/json body
func NewListUserOrganisationRequest(server string, organisationId OrganisationId, params *ListUserOrganisationParams, body ListUserOrganisationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListUserOrganisationRequestWithBody(server, organisationId, params, "application/json", bodyReader)
}

// NewListUserOrganisationRequestWithBody generates requests for ListUserOrganisation with any type of body
func NewListUserOrganisationRequestWithBody(server string, organisationId OrganisationId, params *ListUserOrganisationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Email != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "email", runtime.ParamLocationQuery, *params.Email); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateUserOrganisationRequest calls the generic CreateUserOrganisation builder with application/json body
func NewCreateUserOrganisationRequest(server string, organisationId OrganisationId, body CreateUserOrganisationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserOrganisationRequestWithBody(server, organisationId, "application/json", bodyReader)
}

// NewCreateUserOrganisationRequestWithBody generates requests for CreateUserOrganisation with any type of body
func NewCreateUserOrganisationRequestWithBody(server string, organisationId OrganisationId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserOrganisationRequest generates requests for DeleteUserOrganisation
func NewDeleteUserOrganisationRequest(server string, organisationId OrganisationId, userId UserId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserOrganisationRequest generates requests for GetUserOrganisation
func NewGetUserOrganisationRequest(server string, organisationId OrganisationId, userId UserId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchUserStateOrganisationRequest calls the generic PatchUserStateOrganisation builder with application/json body
func NewPatchUserStateOrganisationRequest(server string, organisationId OrganisationId, userId UserId, body PatchUserStateOrganisationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchUserStateOrganisationRequestWithBody(server, organisationId, userId, "application/json", bodyReader)
}

// NewPatchUserStateOrganisationRequestWithBody generates requests for PatchUserStateOrganisation with any type of body
func NewPatchUserStateOrganisationRequestWithBody(server string, organisationId OrganisationId, userId UserId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateUserOrganisationRequest calls the generic UpdateUserOrganisation builder with application/json body
func NewUpdateUserOrganisationRequest(server string, organisationId OrganisationId, userId UserId, body UpdateUserOrganisationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserOrganisationRequestWithBody(server, organisationId, userId, "application/json", bodyReader)
}

// NewUpdateUserOrganisationRequestWithBody generates requests for UpdateUserOrganisation with any type of body
func NewUpdateUserOrganisationRequestWithBody(server string, organisationId OrganisationId, userId UserId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetACLUserOrganisationRequest generates requests for GetACLUserOrganisation
func NewGetACLUserOrganisationRequest(server string, organisationId OrganisationId, userId UserId, params *GetACLUserOrganisationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/users/%s/acl", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "service", runtime.ParamLocationQuery, params.Service); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resource", runtime.ParamLocationQuery, params.Resource); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Subresource != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subresource", runtime.ParamLocationQuery, *params.Subresource); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteACLUserOrganisationBulkRequest calls the generic DeleteACLUserOrganisationBulk builder with application/json body
func NewDeleteACLUserOrganisationBulkRequest(server string, organisationId OrganisationId, userId UserId, body DeleteACLUserOrganisationBulkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteACLUserOrganisationBulkRequestWithBody(server, organisationId, userId, "application/json", bodyReader)
}

// NewDeleteACLUserOrganisationBulkRequestWithBody generates requests for DeleteACLUserOrganisationBulk with any type of body
func NewDeleteACLUserOrganisationBulkRequestWithBody(server string, organisationId OrganisationId, userId UserId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/users/%s/bulk/acl", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateACLUserOrganisationBulkRequest calls the generic CreateACLUserOrganisationBulk builder with application/json body
func NewCreateACLUserOrganisationBulkRequest(server string, organisationId OrganisationId, userId UserId, body CreateACLUserOrganisationBulkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateACLUserOrganisationBulkRequestWithBody(server, organisationId, userId, "application/json", bodyReader)
}

// NewCreateACLUserOrganisationBulkRequestWithBody generates requests for CreateACLUserOrganisationBulk with any type of body
func NewCreateACLUserOrganisationBulkRequestWithBody(server string, organisationId OrganisationId, userId UserId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/users/%s/bulk/acl", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRecoverUserOrganisationRequest generates requests for RecoverUserOrganisation
func NewRecoverUserOrganisationRequest(server string, organisationId OrganisationId, userId UserId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/users/%s/recover", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSpacesOfUserRequest generates requests for ListSpacesOfUser
func NewListSpacesOfUserRequest(server string, organisationId OrganisationId, userId UserId, params *ListSpacesOfUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/users/%s/spaces", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRevokeRequestWithFormdataBody calls the generic Revoke builder with application/x-www-form-urlencoded body
func NewRevokeRequestWithFormdataBody(server string, params *RevokeParams, body RevokeFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewRevokeRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewRevokeRequestWithBody generates requests for Revoke with any type of body
func NewRevokeRequestWithBody(server string, params *RevokeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/revoke")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Authorization != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, *params.Authorization)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Authorization", headerParam0)
		}

	}

	return req, nil
}

// NewGetIAMGranularPolicySpaceRequest generates requests for GetIAMGranularPolicySpace
func NewGetIAMGranularPolicySpaceRequest(server string, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "subjectType", runtime.ParamLocationPath, subjectType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "subjectId", runtime.ParamLocationPath, subjectId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "objectType", runtime.ParamLocationPath, objectType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/iamgranularPolicy/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetIAMGranularPolicySpaceRequest calls the generic SetIAMGranularPolicySpace builder with application/json body
func NewSetIAMGranularPolicySpaceRequest(server string, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, body SetIAMGranularPolicySpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetIAMGranularPolicySpaceRequestWithBody(server, spaceId, subjectType, subjectId, objectType, "application/json", bodyReader)
}

// NewSetIAMGranularPolicySpaceRequestWithBody generates requests for SetIAMGranularPolicySpace with any type of body
func NewSetIAMGranularPolicySpaceRequestWithBody(server string, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "subjectType", runtime.ParamLocationPath, subjectType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "subjectId", runtime.ParamLocationPath, subjectId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "objectType", runtime.ParamLocationPath, objectType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/iamgranularPolicy/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetIAMPolicySpaceRequest generates requests for GetIAMPolicySpace
func NewGetIAMPolicySpaceRequest(server string, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "subjectType", runtime.ParamLocationPath, subjectType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "subjectId", runtime.ParamLocationPath, subjectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/iampolicy/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetIAMPolicySpaceRequest calls the generic SetIAMPolicySpace builder with application/json body
func NewSetIAMPolicySpaceRequest(server string, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, body SetIAMPolicySpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetIAMPolicySpaceRequestWithBody(server, spaceId, subjectType, subjectId, "application/json", bodyReader)
}

// NewSetIAMPolicySpaceRequestWithBody generates requests for SetIAMPolicySpace with any type of body
func NewSetIAMPolicySpaceRequestWithBody(server string, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "subjectType", runtime.ParamLocationPath, subjectType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "subjectId", runtime.ParamLocationPath, subjectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/iampolicy/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPermissionsSpaceRequest generates requests for ListPermissionsSpace
func NewListPermissionsSpaceRequest(server string, spaceId SpaceId, params *ListPermissionsSpaceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/permissions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Service != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "service", runtime.ParamLocationQuery, *params.Service); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Resource != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resource", runtime.ParamLocationQuery, *params.Resource); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Subresource != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subresource", runtime.ParamLocationQuery, *params.Subresource); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Action != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "action", runtime.ParamLocationQuery, *params.Action); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPermissionSpaceRequest generates requests for GetPermissionSpace
func NewGetPermissionSpaceRequest(server string, spaceId SpaceId, permissionUuid PermissionUuid) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "permissionUuid", runtime.ParamLocationPath, permissionUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/permissions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRolesSpaceRequest generates requests for ListRolesSpace
func NewListRolesSpaceRequest(server string, spaceId SpaceId, params *ListRolesSpaceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/roles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRoleSpaceRequest calls the generic CreateRoleSpace builder with application/json body
func NewCreateRoleSpaceRequest(server string, spaceId SpaceId, body CreateRoleSpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRoleSpaceRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateRoleSpaceRequestWithBody generates requests for CreateRoleSpace with any type of body
func NewCreateRoleSpaceRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/roles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRoleSpaceRequest generates requests for DeleteRoleSpace
func NewDeleteRoleSpaceRequest(server string, spaceId SpaceId, roleUuid RoleUuid) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUuid", runtime.ParamLocationPath, roleUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/roles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRoleSpaceRequest generates requests for GetRoleSpace
func NewGetRoleSpaceRequest(server string, spaceId SpaceId, roleUuid RoleUuid) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUuid", runtime.ParamLocationPath, roleUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/roles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRoleSpaceRequest calls the generic UpdateRoleSpace builder with application/json body
func NewUpdateRoleSpaceRequest(server string, spaceId SpaceId, roleUuid RoleUuid, body UpdateRoleSpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRoleSpaceRequestWithBody(server, spaceId, roleUuid, "application/json", bodyReader)
}

// NewUpdateRoleSpaceRequestWithBody generates requests for UpdateRoleSpace with any type of body
func NewUpdateRoleSpaceRequestWithBody(server string, spaceId SpaceId, roleUuid RoleUuid, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUuid", runtime.ParamLocationPath, roleUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/roles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveRolePermissionsSpaceRequest calls the generic RemoveRolePermissionsSpace builder with application/json body
func NewRemoveRolePermissionsSpaceRequest(server string, spaceId SpaceId, roleUuid RoleUuid, body RemoveRolePermissionsSpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveRolePermissionsSpaceRequestWithBody(server, spaceId, roleUuid, "application/json", bodyReader)
}

// NewRemoveRolePermissionsSpaceRequestWithBody generates requests for RemoveRolePermissionsSpace with any type of body
func NewRemoveRolePermissionsSpaceRequestWithBody(server string, spaceId SpaceId, roleUuid RoleUuid, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUuid", runtime.ParamLocationPath, roleUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/roles/%s/permissions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRolePermissionsSpaceRequest generates requests for GetRolePermissionsSpace
func NewGetRolePermissionsSpaceRequest(server string, spaceId SpaceId, roleUuid RoleUuid) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUuid", runtime.ParamLocationPath, roleUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/roles/%s/permissions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddRolePermissionsSpaceRequest calls the generic AddRolePermissionsSpace builder with application/json body
func NewAddRolePermissionsSpaceRequest(server string, spaceId SpaceId, roleUuid RoleUuid, body AddRolePermissionsSpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddRolePermissionsSpaceRequestWithBody(server, spaceId, roleUuid, "application/json", bodyReader)
}

// NewAddRolePermissionsSpaceRequestWithBody generates requests for AddRolePermissionsSpace with any type of body
func NewAddRolePermissionsSpaceRequestWithBody(server string, spaceId SpaceId, roleUuid RoleUuid, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUuid", runtime.ParamLocationPath, roleUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/roles/%s/permissions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListServiceAccountSpaceRequest calls the generic ListServiceAccountSpace builder with application/json body
func NewListServiceAccountSpaceRequest(server string, spaceId SpaceId, params *ListServiceAccountSpaceParams, body ListServiceAccountSpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListServiceAccountSpaceRequestWithBody(server, spaceId, params, "application/json", bodyReader)
}

// NewListServiceAccountSpaceRequestWithBody generates requests for ListServiceAccountSpace with any type of body
func NewListServiceAccountSpaceRequestWithBody(server string, spaceId SpaceId, params *ListServiceAccountSpaceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/serviceAccounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateServiceAccountSpaceRequest calls the generic CreateServiceAccountSpace builder with application/json body
func NewCreateServiceAccountSpaceRequest(server string, spaceId SpaceId, body CreateServiceAccountSpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServiceAccountSpaceRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateServiceAccountSpaceRequestWithBody generates requests for CreateServiceAccountSpace with any type of body
func NewCreateServiceAccountSpaceRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/serviceAccounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServiceAccountSpaceRequest generates requests for DeleteServiceAccountSpace
func NewDeleteServiceAccountSpaceRequest(server string, spaceId SpaceId, serviceAccountId ServiceAccountId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/serviceAccounts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServiceAccountSpaceRequest generates requests for GetServiceAccountSpace
func NewGetServiceAccountSpaceRequest(server string, spaceId SpaceId, serviceAccountId ServiceAccountId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/serviceAccounts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignServiceAccountToSpaceRequest generates requests for AssignServiceAccountToSpace
func NewAssignServiceAccountToSpaceRequest(server string, spaceId SpaceId, serviceAccountId ServiceAccountId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/serviceAccounts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateServiceAccountSpaceRequest calls the generic UpdateServiceAccountSpace builder with application/json body
func NewUpdateServiceAccountSpaceRequest(server string, spaceId SpaceId, serviceAccountId ServiceAccountId, body UpdateServiceAccountSpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateServiceAccountSpaceRequestWithBody(server, spaceId, serviceAccountId, "application/json", bodyReader)
}

// NewUpdateServiceAccountSpaceRequestWithBody generates requests for UpdateServiceAccountSpace with any type of body
func NewUpdateServiceAccountSpaceRequestWithBody(server string, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/serviceAccounts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetACLServiceAccountSpaceRequest generates requests for GetACLServiceAccountSpace
func NewGetACLServiceAccountSpaceRequest(server string, spaceId SpaceId, serviceAccountId ServiceAccountId, params *GetACLServiceAccountSpaceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/serviceAccounts/%s/acl", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "service", runtime.ParamLocationQuery, params.Service); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resource", runtime.ParamLocationQuery, params.Resource); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Subresource != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subresource", runtime.ParamLocationQuery, *params.Subresource); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteACLServiceAccountSpaceBulkRequest calls the generic DeleteACLServiceAccountSpaceBulk builder with application/json body
func NewDeleteACLServiceAccountSpaceBulkRequest(server string, spaceId SpaceId, serviceAccountId ServiceAccountId, body DeleteACLServiceAccountSpaceBulkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteACLServiceAccountSpaceBulkRequestWithBody(server, spaceId, serviceAccountId, "application/json", bodyReader)
}

// NewDeleteACLServiceAccountSpaceBulkRequestWithBody generates requests for DeleteACLServiceAccountSpaceBulk with any type of body
func NewDeleteACLServiceAccountSpaceBulkRequestWithBody(server string, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/serviceAccounts/%s/bulk/acl", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateACLServiceAccountSpaceBulkRequest calls the generic CreateACLServiceAccountSpaceBulk builder with application/json body
func NewCreateACLServiceAccountSpaceBulkRequest(server string, spaceId SpaceId, serviceAccountId ServiceAccountId, body CreateACLServiceAccountSpaceBulkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateACLServiceAccountSpaceBulkRequestWithBody(server, spaceId, serviceAccountId, "application/json", bodyReader)
}

// NewCreateACLServiceAccountSpaceBulkRequestWithBody generates requests for CreateACLServiceAccountSpaceBulk with any type of body
func NewCreateACLServiceAccountSpaceBulkRequestWithBody(server string, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/serviceAccounts/%s/bulk/acl", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListUserSpaceRequest calls the generic ListUserSpace builder with application/json body
func NewListUserSpaceRequest(server string, spaceId SpaceId, params *ListUserSpaceParams, body ListUserSpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListUserSpaceRequestWithBody(server, spaceId, params, "application/json", bodyReader)
}

// NewListUserSpaceRequestWithBody generates requests for ListUserSpace with any type of body
func NewListUserSpaceRequestWithBody(server string, spaceId SpaceId, params *ListUserSpaceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Email != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "email", runtime.ParamLocationQuery, *params.Email); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateUserSpaceRequest calls the generic CreateUserSpace builder with application/json body
func NewCreateUserSpaceRequest(server string, spaceId SpaceId, body CreateUserSpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserSpaceRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateUserSpaceRequestWithBody generates requests for CreateUserSpace with any type of body
func NewCreateUserSpaceRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnassignUserSpaceRequest generates requests for UnassignUserSpace
func NewUnassignUserSpaceRequest(server string, spaceId SpaceId, userId UserId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserSpaceRequest generates requests for GetUserSpace
func NewGetUserSpaceRequest(server string, spaceId SpaceId, userId UserId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchUserStateSpaceRequest calls the generic PatchUserStateSpace builder with application/json body
func NewPatchUserStateSpaceRequest(server string, spaceId SpaceId, userId UserId, body PatchUserStateSpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchUserStateSpaceRequestWithBody(server, spaceId, userId, "application/json", bodyReader)
}

// NewPatchUserStateSpaceRequestWithBody generates requests for PatchUserStateSpace with any type of body
func NewPatchUserStateSpaceRequestWithBody(server string, spaceId SpaceId, userId UserId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAssignUserToSpaceRequest generates requests for AssignUserToSpace
func NewAssignUserToSpaceRequest(server string, spaceId SpaceId, userId UserId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserSpaceRequest calls the generic UpdateUserSpace builder with application/json body
func NewUpdateUserSpaceRequest(server string, spaceId SpaceId, userId UserId, body UpdateUserSpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserSpaceRequestWithBody(server, spaceId, userId, "application/json", bodyReader)
}

// NewUpdateUserSpaceRequestWithBody generates requests for UpdateUserSpace with any type of body
func NewUpdateUserSpaceRequestWithBody(server string, spaceId SpaceId, userId UserId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetACLUserSpaceRequest generates requests for GetACLUserSpace
func NewGetACLUserSpaceRequest(server string, spaceId SpaceId, userId UserId, params *GetACLUserSpaceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/users/%s/acl", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "service", runtime.ParamLocationQuery, params.Service); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resource", runtime.ParamLocationQuery, params.Resource); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Subresource != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subresource", runtime.ParamLocationQuery, *params.Subresource); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteACLUserSpaceBulkRequest calls the generic DeleteACLUserSpaceBulk builder with application/json body
func NewDeleteACLUserSpaceBulkRequest(server string, spaceId SpaceId, userId UserId, body DeleteACLUserSpaceBulkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteACLUserSpaceBulkRequestWithBody(server, spaceId, userId, "application/json", bodyReader)
}

// NewDeleteACLUserSpaceBulkRequestWithBody generates requests for DeleteACLUserSpaceBulk with any type of body
func NewDeleteACLUserSpaceBulkRequestWithBody(server string, spaceId SpaceId, userId UserId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/users/%s/bulk/acl", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateACLUserSpaceBulkRequest calls the generic CreateACLUserSpaceBulk builder with application/json body
func NewCreateACLUserSpaceBulkRequest(server string, spaceId SpaceId, userId UserId, body CreateACLUserSpaceBulkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateACLUserSpaceBulkRequestWithBody(server, spaceId, userId, "application/json", bodyReader)
}

// NewCreateACLUserSpaceBulkRequestWithBody generates requests for CreateACLUserSpaceBulk with any type of body
func NewCreateACLUserSpaceBulkRequestWithBody(server string, spaceId SpaceId, userId UserId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/users/%s/bulk/acl", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRecoverUserSpaceRequest generates requests for RecoverUserSpace
func NewRecoverUserSpaceRequest(server string, spaceId SpaceId, userId UserId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/users/%s/recover", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTokenRequestWithFormdataBody calls the generic Token builder with application/x-www-form-urlencoded body
func NewTokenRequestWithFormdataBody(server string, params *TokenParams, body TokenFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTokenRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewTokenRequestWithBody generates requests for Token with any type of body
func NewTokenRequestWithBody(server string, params *TokenParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Authorization != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, *params.Authorization)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Authorization", headerParam0)
		}

	}

	return req, nil
}

// NewGetUserInfoRequest generates requests for GetUserInfo
func NewGetUserInfoRequest(server string, params *GetUserInfoParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/userinfo")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Authorization != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, *params.Authorization)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Authorization", headerParam0)
		}

	}

	return req, nil
}

// NewHealthcheckRequest generates requests for Healthcheck
func NewHealthcheckRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/kubernetes/healthcheck")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListKubernetesClustersRequest generates requests for ListKubernetesClusters
func NewListKubernetesClustersRequest(server string, spaceId SpaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/kubernetes/spaces/%s/clusters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateKubernetesClusterRequest calls the generic CreateKubernetesCluster builder with application/json body
func NewCreateKubernetesClusterRequest(server string, spaceId SpaceId, body CreateKubernetesClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateKubernetesClusterRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateKubernetesClusterRequestWithBody generates requests for CreateKubernetesCluster with any type of body
func NewCreateKubernetesClusterRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/kubernetes/spaces/%s/clusters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteKubernetesClusterByIdRequest generates requests for DeleteKubernetesClusterById
func NewDeleteKubernetesClusterByIdRequest(server string, spaceId SpaceId, clusterId KubernetesClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/kubernetes/spaces/%s/clusters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKubernetesClusterByIdRequest generates requests for GetKubernetesClusterById
func NewGetKubernetesClusterByIdRequest(server string, spaceId SpaceId, clusterId KubernetesClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/kubernetes/spaces/%s/clusters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKubeConfigRequest generates requests for GetKubeConfig
func NewGetKubeConfigRequest(server string, spaceId SpaceId, clusterId KubernetesClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/kubernetes/spaces/%s/clusters/%s/kubeconfig", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpgradeMastersRequest calls the generic UpgradeMasters builder with application/json body
func NewUpgradeMastersRequest(server string, spaceId SpaceId, clusterId KubernetesClusterId, body UpgradeMastersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpgradeMastersRequestWithBody(server, spaceId, clusterId, "application/json", bodyReader)
}

// NewUpgradeMastersRequestWithBody generates requests for UpgradeMasters with any type of body
func NewUpgradeMastersRequestWithBody(server string, spaceId SpaceId, clusterId KubernetesClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/kubernetes/spaces/%s/clusters/%s/masters/upgrade", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddNodesRequest calls the generic AddNodes builder with application/json body
func NewAddNodesRequest(server string, spaceId SpaceId, clusterId KubernetesClusterId, body AddNodesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddNodesRequestWithBody(server, spaceId, clusterId, "application/json", bodyReader)
}

// NewAddNodesRequestWithBody generates requests for AddNodes with any type of body
func NewAddNodesRequestWithBody(server string, spaceId SpaceId, clusterId KubernetesClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/kubernetes/spaces/%s/clusters/%s/nodes/add", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveNodesRequest calls the generic RemoveNodes builder with application/json body
func NewRemoveNodesRequest(server string, spaceId SpaceId, clusterId KubernetesClusterId, body RemoveNodesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveNodesRequestWithBody(server, spaceId, clusterId, "application/json", bodyReader)
}

// NewRemoveNodesRequestWithBody generates requests for RemoveNodes with any type of body
func NewRemoveNodesRequestWithBody(server string, spaceId SpaceId, clusterId KubernetesClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/kubernetes/spaces/%s/clusters/%s/nodes/remove", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpgradeNodesRequest calls the generic UpgradeNodes builder with application/json body
func NewUpgradeNodesRequest(server string, spaceId SpaceId, clusterId KubernetesClusterId, body UpgradeNodesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpgradeNodesRequestWithBody(server, spaceId, clusterId, "application/json", bodyReader)
}

// NewUpgradeNodesRequestWithBody generates requests for UpgradeNodes with any type of body
func NewUpgradeNodesRequestWithBody(server string, spaceId SpaceId, clusterId KubernetesClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/kubernetes/spaces/%s/clusters/%s/nodes/upgrade", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListOperationRequest generates requests for ListOperation
func NewListOperationRequest(server string, spaceId SpaceId, clusterId KubernetesClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/kubernetes/spaces/%s/clusters/%s/operations", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPrivateKeyRequest generates requests for GetPrivateKey
func NewGetPrivateKeyRequest(server string, spaceId SpaceId, clusterId KubernetesClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/kubernetes/spaces/%s/clusters/%s/privateKey", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClusterStatusRequest generates requests for GetClusterStatus
func NewGetClusterStatusRequest(server string, spaceId SpaceId, clusterId KubernetesClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/kubernetes/spaces/%s/clusters/%s/status", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateNodesRequest generates requests for UpdateNodes
func NewUpdateNodesRequest(server string, spaceId SpaceId, clusterId KubernetesClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/kubernetes/spaces/%s/clusters/%s/update", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOperationByIdRequest generates requests for GetOperationById
func NewGetOperationByIdRequest(server string, spaceId SpaceId, operationId OperationId, params *GetOperationByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "operationId", runtime.ParamLocationPath, operationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/kubernetes/spaces/%s/operations/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

	}

	return req, nil
}

// NewListBucketsRequest generates requests for ListBuckets
func NewListBucketsRequest(server string, spaceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/objectStorage/spaces/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteBucketRequest generates requests for DeleteBucket
func NewDeleteBucketRequest(server string, spaceId string, bucket string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "bucket", runtime.ParamLocationPath, bucket)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/objectStorage/spaces/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListObjectsRequest generates requests for ListObjects
func NewListObjectsRequest(server string, spaceId string, bucket string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "bucket", runtime.ParamLocationPath, bucket)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/objectStorage/spaces/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBucketRequest generates requests for CreateBucket
func NewCreateBucketRequest(server string, spaceId string, bucket string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "bucket", runtime.ParamLocationPath, bucket)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/objectStorage/spaces/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteObjectRequest generates requests for DeleteObject
func NewDeleteObjectRequest(server string, spaceId string, bucket string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "bucket", runtime.ParamLocationPath, bucket)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/objectStorage/spaces/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetObjectRequest generates requests for GetObject
func NewGetObjectRequest(server string, spaceId string, bucket string, key string, params *GetObjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "bucket", runtime.ParamLocationPath, bucket)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/objectStorage/spaces/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expires != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expires", runtime.ParamLocationQuery, *params.Expires); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutObjectRequestWithBody generates requests for PutObject with any type of body
func NewPutObjectRequestWithBody(server string, spaceId string, bucket string, key string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "bucket", runtime.ParamLocationPath, bucket)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/objectStorage/spaces/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUploadPartRequestWithBody generates requests for UploadPart with any type of body
func NewUploadPartRequestWithBody(server string, spaceId string, bucket string, key string, params *UploadPartParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "bucket", runtime.ParamLocationPath, bucket)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/objectStorage/spaces/%s/%s/%s#partNumber&uploadId", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "partNumber", runtime.ParamLocationQuery, params.PartNumber); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "uploadId", runtime.ParamLocationQuery, params.UploadId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAbortMultipartUploadRequest generates requests for AbortMultipartUpload
func NewAbortMultipartUploadRequest(server string, spaceId string, bucket string, key string, params *AbortMultipartUploadParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "bucket", runtime.ParamLocationPath, bucket)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/objectStorage/spaces/%s/%s/%s#uploadId", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "uploadId", runtime.ParamLocationQuery, params.UploadId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCompleteMultipartUploadRequestWithBody generates requests for CompleteMultipartUpload with any type of body
func NewCompleteMultipartUploadRequestWithBody(server string, spaceId string, bucket string, key string, params *CompleteMultipartUploadParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "bucket", runtime.ParamLocationPath, bucket)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/objectStorage/spaces/%s/%s/%s#uploadId", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "uploadId", runtime.ParamLocationQuery, params.UploadId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateMultipartUploadRequest generates requests for CreateMultipartUpload
func NewCreateMultipartUploadRequest(server string, spaceId string, bucket string, key string, params *CreateMultipartUploadParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "bucket", runtime.ParamLocationPath, bucket)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/objectStorage/spaces/%s/%s/%s#uploads", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "uploads", runtime.ParamLocationQuery, params.Uploads); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListClustersRequest generates requests for ListClusters
func NewListClustersRequest(server string, spaceId SpaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openshift/spaces/%s/clusters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateClusterRequest calls the generic CreateCluster builder with application/json body
func NewCreateClusterRequest(server string, spaceId SpaceId, body CreateClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateClusterRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateClusterRequestWithBody generates requests for CreateCluster with any type of body
func NewCreateClusterRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openshift/spaces/%s/clusters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteClusterRequest generates requests for DeleteCluster
func NewDeleteClusterRequest(server string, spaceId SpaceId, clusterId ClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openshift/spaces/%s/clusters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClusterRequest generates requests for GetCluster
func NewGetClusterRequest(server string, spaceId SpaceId, clusterId ClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openshift/spaces/%s/clusters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateClusterRequest calls the generic UpdateCluster builder with application/json body
func NewUpdateClusterRequest(server string, spaceId SpaceId, clusterId ClusterId, body UpdateClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateClusterRequestWithBody(server, spaceId, clusterId, "application/json", bodyReader)
}

// NewUpdateClusterRequestWithBody generates requests for UpdateCluster with any type of body
func NewUpdateClusterRequestWithBody(server string, spaceId SpaceId, clusterId ClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openshift/spaces/%s/clusters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListNodepoolsRequest generates requests for ListNodepools
func NewListNodepoolsRequest(server string, spaceId SpaceId, clusterId ClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openshift/spaces/%s/clusters/%s/nodepools", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNodePoolRequest calls the generic CreateNodePool builder with application/json body
func NewCreateNodePoolRequest(server string, spaceId SpaceId, clusterId ClusterId, body CreateNodePoolJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNodePoolRequestWithBody(server, spaceId, clusterId, "application/json", bodyReader)
}

// NewCreateNodePoolRequestWithBody generates requests for CreateNodePool with any type of body
func NewCreateNodePoolRequestWithBody(server string, spaceId SpaceId, clusterId ClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openshift/spaces/%s/clusters/%s/nodepools", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteNodePoolRequest generates requests for DeleteNodePool
func NewDeleteNodePoolRequest(server string, spaceId SpaceId, clusterId ClusterId, nodePoolName NodepoolName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "nodePoolName", runtime.ParamLocationPath, nodePoolName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openshift/spaces/%s/clusters/%s/nodepools/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateNodepoolRequest calls the generic UpdateNodepool builder with application/json body
func NewUpdateNodepoolRequest(server string, spaceId SpaceId, clusterId ClusterId, nodePoolName NodepoolName, body UpdateNodepoolJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateNodepoolRequestWithBody(server, spaceId, clusterId, nodePoolName, "application/json", bodyReader)
}

// NewUpdateNodepoolRequestWithBody generates requests for UpdateNodepool with any type of body
func NewUpdateNodepoolRequestWithBody(server string, spaceId SpaceId, clusterId ClusterId, nodePoolName NodepoolName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "nodePoolName", runtime.ParamLocationPath, nodePoolName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openshift/spaces/%s/clusters/%s/nodepools/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListOperationsRequest generates requests for ListOperations
func NewListOperationsRequest(server string, spaceId SpaceId, params *ListOperationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openshift/spaces/%s/operations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClusterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "clusterId", runtime.ParamLocationQuery, *params.ClusterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOperationRequest generates requests for GetOperation
func NewGetOperationRequest(server string, spaceId SpaceId, id IdUuid) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openshift/spaces/%s/operations/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListVersionsRequest generates requests for ListVersions
func NewListVersionsRequest(server string, spaceId SpaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openshift/spaces/%s/versions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSpacesRequest calls the generic ListSpaces builder with application/json body
func NewListSpacesRequest(server string, organisationId OrganisationId, params *ListSpacesParams, body ListSpacesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListSpacesRequestWithBody(server, organisationId, params, "application/json", bodyReader)
}

// NewListSpacesRequestWithBody generates requests for ListSpaces with any type of body
func NewListSpacesRequestWithBody(server string, organisationId OrganisationId, params *ListSpacesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organisations/%s/spaces", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateSpaceRequest calls the generic CreateSpace builder with application/json body
func NewCreateSpaceRequest(server string, organisationId OrganisationId, body CreateSpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSpaceRequestWithBody(server, organisationId, "application/json", bodyReader)
}

// NewCreateSpaceRequestWithBody generates requests for CreateSpace with any type of body
func NewCreateSpaceRequestWithBody(server string, organisationId OrganisationId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organisations/%s/spaces", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSpaceRequest generates requests for DeleteSpace
func NewDeleteSpaceRequest(server string, organisationId OrganisationId, spaceId SpaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organisations/%s/spaces/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSpaceByIdRequest generates requests for GetSpaceById
func NewGetSpaceByIdRequest(server string, organisationId OrganisationId, spaceId SpaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organisations/%s/spaces/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSpaceRequest calls the generic UpdateSpace builder with application/json body
func NewUpdateSpaceRequest(server string, organisationId OrganisationId, spaceId SpaceId, body UpdateSpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSpaceRequestWithBody(server, organisationId, spaceId, "application/json", bodyReader)
}

// NewUpdateSpaceRequestWithBody generates requests for UpdateSpace with any type of body
func NewUpdateSpaceRequestWithBody(server string, organisationId OrganisationId, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organisations/%s/spaces/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// DeleteLoadBalancerTagsWithBodyWithResponse request with any body
	DeleteLoadBalancerTagsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerTagsResponse, error)

	DeleteLoadBalancerTagsWithResponse(ctx context.Context, spaceId SpaceId, body DeleteLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerTagsResponse, error)

	// CreateLoadBalancerTagsWithBodyWithResponse request with any body
	CreateLoadBalancerTagsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLoadBalancerTagsResponse, error)

	CreateLoadBalancerTagsWithResponse(ctx context.Context, spaceId SpaceId, body CreateLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLoadBalancerTagsResponse, error)

	// DeleteTagsWithBodyWithResponse request with any body
	DeleteTagsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteTagsResponse, error)

	DeleteTagsWithResponse(ctx context.Context, spaceId SpaceId, body DeleteTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteTagsResponse, error)

	// CreateTagsWithBodyWithResponse request with any body
	CreateTagsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTagsResponse, error)

	CreateTagsWithResponse(ctx context.Context, spaceId SpaceId, body CreateTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTagsResponse, error)

	// ReadClientGatewaysWithResponse request
	ReadClientGatewaysWithResponse(ctx context.Context, spaceId SpaceId, params *ReadClientGatewaysParams, reqEditors ...RequestEditorFn) (*ReadClientGatewaysResponse, error)

	// CreateClientGatewayWithBodyWithResponse request with any body
	CreateClientGatewayWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientGatewayResponse, error)

	CreateClientGatewayWithResponse(ctx context.Context, spaceId SpaceId, body CreateClientGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientGatewayResponse, error)

	// DeleteClientGatewayWithResponse request
	DeleteClientGatewayWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteClientGatewayResponse, error)

	// ReadClientGatewaysByIdWithResponse request
	ReadClientGatewaysByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadClientGatewaysByIdResponse, error)

	// ReadDhcpOptionsWithResponse request
	ReadDhcpOptionsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadDhcpOptionsParams, reqEditors ...RequestEditorFn) (*ReadDhcpOptionsResponse, error)

	// CreateDhcpOptionsWithBodyWithResponse request with any body
	CreateDhcpOptionsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDhcpOptionsResponse, error)

	CreateDhcpOptionsWithResponse(ctx context.Context, spaceId SpaceId, body CreateDhcpOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDhcpOptionsResponse, error)

	// DeleteDhcpOptionsWithResponse request
	DeleteDhcpOptionsWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteDhcpOptionsResponse, error)

	// ReadDhcpOptionsByIdWithResponse request
	ReadDhcpOptionsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadDhcpOptionsByIdResponse, error)

	// ReadFlexibleGpusWithResponse request
	ReadFlexibleGpusWithResponse(ctx context.Context, spaceId SpaceId, params *ReadFlexibleGpusParams, reqEditors ...RequestEditorFn) (*ReadFlexibleGpusResponse, error)

	// CreateFlexibleGpuWithBodyWithResponse request with any body
	CreateFlexibleGpuWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFlexibleGpuResponse, error)

	CreateFlexibleGpuWithResponse(ctx context.Context, spaceId SpaceId, body CreateFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFlexibleGpuResponse, error)

	// DeleteFlexibleGpuWithResponse request
	DeleteFlexibleGpuWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteFlexibleGpuResponse, error)

	// ReadFlexibleGpusByIdWithResponse request
	ReadFlexibleGpusByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadFlexibleGpusByIdResponse, error)

	// UpdateFlexibleGpuWithBodyWithResponse request with any body
	UpdateFlexibleGpuWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFlexibleGpuResponse, error)

	UpdateFlexibleGpuWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFlexibleGpuResponse, error)

	// LinkFlexibleGpuWithBodyWithResponse request with any body
	LinkFlexibleGpuWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkFlexibleGpuResponse, error)

	LinkFlexibleGpuWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkFlexibleGpuResponse, error)

	// UnlinkFlexibleGpuWithResponse request
	UnlinkFlexibleGpuWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*UnlinkFlexibleGpuResponse, error)

	// ReadImagesWithResponse request
	ReadImagesWithResponse(ctx context.Context, spaceId SpaceId, params *ReadImagesParams, reqEditors ...RequestEditorFn) (*ReadImagesResponse, error)

	// CreateImageWithBodyWithResponse request with any body
	CreateImageWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateImageResponse, error)

	CreateImageWithResponse(ctx context.Context, spaceId SpaceId, body CreateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateImageResponse, error)

	// DeleteImageWithResponse request
	DeleteImageWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteImageResponse, error)

	// ReadImagesByIdWithResponse request
	ReadImagesByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadImagesByIdResponse, error)

	// UpdateImageWithBodyWithResponse request with any body
	UpdateImageWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateImageResponse, error)

	UpdateImageWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateImageResponse, error)

	// ReadInternetGatewaysWithResponse request
	ReadInternetGatewaysWithResponse(ctx context.Context, spaceId SpaceId, params *ReadInternetGatewaysParams, reqEditors ...RequestEditorFn) (*ReadInternetGatewaysResponse, error)

	// CreateInternetGatewayWithResponse request
	CreateInternetGatewayWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*CreateInternetGatewayResponse, error)

	// DeleteInternetGatewayWithResponse request
	DeleteInternetGatewayWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteInternetGatewayResponse, error)

	// ReadInternetGatewaysByIdWithResponse request
	ReadInternetGatewaysByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadInternetGatewaysByIdResponse, error)

	// LinkInternetGatewayWithBodyWithResponse request with any body
	LinkInternetGatewayWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkInternetGatewayResponse, error)

	LinkInternetGatewayWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkInternetGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkInternetGatewayResponse, error)

	// UnlinkInternetGatewayWithBodyWithResponse request with any body
	UnlinkInternetGatewayWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkInternetGatewayResponse, error)

	UnlinkInternetGatewayWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkInternetGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkInternetGatewayResponse, error)

	// ReadKeypairsWithResponse request
	ReadKeypairsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadKeypairsParams, reqEditors ...RequestEditorFn) (*ReadKeypairsResponse, error)

	// CreateKeypairWithBodyWithResponse request with any body
	CreateKeypairWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeypairResponse, error)

	CreateKeypairWithResponse(ctx context.Context, spaceId SpaceId, body CreateKeypairJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeypairResponse, error)

	// DeleteKeypairWithResponse request
	DeleteKeypairWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteKeypairResponse, error)

	// ReadKeypairsByIdWithResponse request
	ReadKeypairsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadKeypairsByIdResponse, error)

	// ReadListenerRulesWithResponse request
	ReadListenerRulesWithResponse(ctx context.Context, spaceId SpaceId, params *ReadListenerRulesParams, reqEditors ...RequestEditorFn) (*ReadListenerRulesResponse, error)

	// CreateListenerRuleWithBodyWithResponse request with any body
	CreateListenerRuleWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateListenerRuleResponse, error)

	CreateListenerRuleWithResponse(ctx context.Context, spaceId SpaceId, body CreateListenerRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateListenerRuleResponse, error)

	// DeleteListenerRuleWithResponse request
	DeleteListenerRuleWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteListenerRuleResponse, error)

	// ReadListenerRulesByIdWithResponse request
	ReadListenerRulesByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadListenerRulesByIdResponse, error)

	// UpdateListenerRuleWithBodyWithResponse request with any body
	UpdateListenerRuleWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateListenerRuleResponse, error)

	UpdateListenerRuleWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateListenerRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateListenerRuleResponse, error)

	// ReadLoadBalancersWithResponse request
	ReadLoadBalancersWithResponse(ctx context.Context, spaceId SpaceId, params *ReadLoadBalancersParams, reqEditors ...RequestEditorFn) (*ReadLoadBalancersResponse, error)

	// CreateLoadBalancerWithBodyWithResponse request with any body
	CreateLoadBalancerWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLoadBalancerResponse, error)

	CreateLoadBalancerWithResponse(ctx context.Context, spaceId SpaceId, body CreateLoadBalancerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLoadBalancerResponse, error)

	// DeleteLoadBalancerWithResponse request
	DeleteLoadBalancerWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerResponse, error)

	// ReadLoadBalancersByIdWithResponse request
	ReadLoadBalancersByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadLoadBalancersByIdResponse, error)

	// UpdateLoadBalancerWithBodyWithResponse request with any body
	UpdateLoadBalancerWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLoadBalancerResponse, error)

	UpdateLoadBalancerWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateLoadBalancerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLoadBalancerResponse, error)

	// LinkLoadBalancerBackendMachinesWithBodyWithResponse request with any body
	LinkLoadBalancerBackendMachinesWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkLoadBalancerBackendMachinesResponse, error)

	LinkLoadBalancerBackendMachinesWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkLoadBalancerBackendMachinesJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkLoadBalancerBackendMachinesResponse, error)

	// UnlinkLoadBalancerBackendMachinesWithBodyWithResponse request with any body
	UnlinkLoadBalancerBackendMachinesWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkLoadBalancerBackendMachinesResponse, error)

	UnlinkLoadBalancerBackendMachinesWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkLoadBalancerBackendMachinesJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkLoadBalancerBackendMachinesResponse, error)

	// DeleteLoadBalancerListenersWithBodyWithResponse request with any body
	DeleteLoadBalancerListenersWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerListenersResponse, error)

	DeleteLoadBalancerListenersWithResponse(ctx context.Context, spaceId SpaceId, id string, body DeleteLoadBalancerListenersJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerListenersResponse, error)

	// CreateLoadBalancerListenersWithBodyWithResponse request with any body
	CreateLoadBalancerListenersWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLoadBalancerListenersResponse, error)

	CreateLoadBalancerListenersWithResponse(ctx context.Context, spaceId SpaceId, id string, body CreateLoadBalancerListenersJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLoadBalancerListenersResponse, error)

	// DeleteLoadBalancerPolicyWithBodyWithResponse request with any body
	DeleteLoadBalancerPolicyWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerPolicyResponse, error)

	DeleteLoadBalancerPolicyWithResponse(ctx context.Context, spaceId SpaceId, id string, body DeleteLoadBalancerPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerPolicyResponse, error)

	// CreateLoadBalancerPolicyWithBodyWithResponse request with any body
	CreateLoadBalancerPolicyWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLoadBalancerPolicyResponse, error)

	CreateLoadBalancerPolicyWithResponse(ctx context.Context, spaceId SpaceId, id string, body CreateLoadBalancerPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLoadBalancerPolicyResponse, error)

	// ReadVmsHealthWithBodyWithResponse request with any body
	ReadVmsHealthWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReadVmsHealthResponse, error)

	ReadVmsHealthWithResponse(ctx context.Context, spaceId SpaceId, id string, body ReadVmsHealthJSONRequestBody, reqEditors ...RequestEditorFn) (*ReadVmsHealthResponse, error)

	// ReadLoadBalancerTagsWithBodyWithResponse request with any body
	ReadLoadBalancerTagsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReadLoadBalancerTagsResponse, error)

	ReadLoadBalancerTagsWithResponse(ctx context.Context, spaceId SpaceId, body ReadLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReadLoadBalancerTagsResponse, error)

	// ReadNatGatewayWithResponse request
	ReadNatGatewayWithResponse(ctx context.Context, spaceId SpaceId, params *ReadNatGatewayParams, reqEditors ...RequestEditorFn) (*ReadNatGatewayResponse, error)

	// CreateNatGatewayWithBodyWithResponse request with any body
	CreateNatGatewayWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNatGatewayResponse, error)

	CreateNatGatewayWithResponse(ctx context.Context, spaceId SpaceId, body CreateNatGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNatGatewayResponse, error)

	// DeleteNatGatewayWithResponse request
	DeleteNatGatewayWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteNatGatewayResponse, error)

	// ReadNatGatewayByIdWithResponse request
	ReadNatGatewayByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadNatGatewayByIdResponse, error)

	// ReadNicsWithResponse request
	ReadNicsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadNicsParams, reqEditors ...RequestEditorFn) (*ReadNicsResponse, error)

	// CreateNicWithBodyWithResponse request with any body
	CreateNicWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNicResponse, error)

	CreateNicWithResponse(ctx context.Context, spaceId SpaceId, body CreateNicJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNicResponse, error)

	// DeleteNicWithResponse request
	DeleteNicWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteNicResponse, error)

	// ReadNicsByIdWithResponse request
	ReadNicsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadNicsByIdResponse, error)

	// UpdateNicWithBodyWithResponse request with any body
	UpdateNicWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNicResponse, error)

	UpdateNicWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateNicJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNicResponse, error)

	// LinkPrivateIpsWithBodyWithResponse request with any body
	LinkPrivateIpsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkPrivateIpsResponse, error)

	LinkPrivateIpsWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkPrivateIpsJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkPrivateIpsResponse, error)

	// UnlinkPrivateIpsWithBodyWithResponse request with any body
	UnlinkPrivateIpsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkPrivateIpsResponse, error)

	UnlinkPrivateIpsWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkPrivateIpsJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkPrivateIpsResponse, error)

	// LinkNicWithBodyWithResponse request with any body
	LinkNicWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkNicResponse, error)

	LinkNicWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkNicJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkNicResponse, error)

	// UnlinkNicWithBodyWithResponse request with any body
	UnlinkNicWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkNicResponse, error)

	UnlinkNicWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkNicJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkNicResponse, error)

	// ReadPublicIpRangesWithResponse request
	ReadPublicIpRangesWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*ReadPublicIpRangesResponse, error)

	// ReadPublicIpsWithResponse request
	ReadPublicIpsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadPublicIpsParams, reqEditors ...RequestEditorFn) (*ReadPublicIpsResponse, error)

	// CreatePublicIpWithResponse request
	CreatePublicIpWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*CreatePublicIpResponse, error)

	// DeletePublicIpWithResponse request
	DeletePublicIpWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeletePublicIpResponse, error)

	// ReadPublicIpsByIdWithResponse request
	ReadPublicIpsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadPublicIpsByIdResponse, error)

	// LinkPublicIpWithBodyWithResponse request with any body
	LinkPublicIpWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkPublicIpResponse, error)

	LinkPublicIpWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkPublicIpJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkPublicIpResponse, error)

	// UnlinkPublicIpWithBodyWithResponse request with any body
	UnlinkPublicIpWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkPublicIpResponse, error)

	UnlinkPublicIpWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkPublicIpJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkPublicIpResponse, error)

	// ReadRouteTablesWithResponse request
	ReadRouteTablesWithResponse(ctx context.Context, spaceId SpaceId, params *ReadRouteTablesParams, reqEditors ...RequestEditorFn) (*ReadRouteTablesResponse, error)

	// CreateRouteTableWithBodyWithResponse request with any body
	CreateRouteTableWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRouteTableResponse, error)

	CreateRouteTableWithResponse(ctx context.Context, spaceId SpaceId, body CreateRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRouteTableResponse, error)

	// DeleteRouteTableWithResponse request
	DeleteRouteTableWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteRouteTableResponse, error)

	// ReadRouteTablesByIdWithResponse request
	ReadRouteTablesByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadRouteTablesByIdResponse, error)

	// UpdateRouteTableRoutePropagationWithBodyWithResponse request with any body
	UpdateRouteTableRoutePropagationWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRouteTableRoutePropagationResponse, error)

	UpdateRouteTableRoutePropagationWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateRouteTableRoutePropagationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRouteTableRoutePropagationResponse, error)

	// DeleteRouteWithBodyWithResponse request with any body
	DeleteRouteWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteRouteResponse, error)

	DeleteRouteWithResponse(ctx context.Context, spaceId SpaceId, id string, body DeleteRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteRouteResponse, error)

	// CreateRouteWithBodyWithResponse request with any body
	CreateRouteWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRouteResponse, error)

	CreateRouteWithResponse(ctx context.Context, spaceId SpaceId, id string, body CreateRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRouteResponse, error)

	// UpdateRouteWithBodyWithResponse request with any body
	UpdateRouteWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRouteResponse, error)

	UpdateRouteWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRouteResponse, error)

	// LinkRouteTableWithBodyWithResponse request with any body
	LinkRouteTableWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkRouteTableResponse, error)

	LinkRouteTableWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkRouteTableResponse, error)

	// UnlinkRouteTableWithBodyWithResponse request with any body
	UnlinkRouteTableWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkRouteTableResponse, error)

	UnlinkRouteTableWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkRouteTableResponse, error)

	// ReadSecurityGroupsWithResponse request
	ReadSecurityGroupsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadSecurityGroupsParams, reqEditors ...RequestEditorFn) (*ReadSecurityGroupsResponse, error)

	// CreateSecurityGroupWithBodyWithResponse request with any body
	CreateSecurityGroupWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSecurityGroupResponse, error)

	CreateSecurityGroupWithResponse(ctx context.Context, spaceId SpaceId, body CreateSecurityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSecurityGroupResponse, error)

	// DeleteSecurityGroupWithResponse request
	DeleteSecurityGroupWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteSecurityGroupResponse, error)

	// ReadSecurityGroupsByIdWithResponse request
	ReadSecurityGroupsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadSecurityGroupsByIdResponse, error)

	// DeleteSecurityGroupRuleWithBodyWithResponse request with any body
	DeleteSecurityGroupRuleWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteSecurityGroupRuleResponse, error)

	DeleteSecurityGroupRuleWithResponse(ctx context.Context, spaceId SpaceId, id string, body DeleteSecurityGroupRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteSecurityGroupRuleResponse, error)

	// CreateSecurityGroupRuleWithBodyWithResponse request with any body
	CreateSecurityGroupRuleWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSecurityGroupRuleResponse, error)

	CreateSecurityGroupRuleWithResponse(ctx context.Context, spaceId SpaceId, id string, body CreateSecurityGroupRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSecurityGroupRuleResponse, error)

	// ReadServerCertificatesWithResponse request
	ReadServerCertificatesWithResponse(ctx context.Context, spaceId SpaceId, params *ReadServerCertificatesParams, reqEditors ...RequestEditorFn) (*ReadServerCertificatesResponse, error)

	// CreateServerCertificateWithBodyWithResponse request with any body
	CreateServerCertificateWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServerCertificateResponse, error)

	CreateServerCertificateWithResponse(ctx context.Context, spaceId SpaceId, body CreateServerCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServerCertificateResponse, error)

	// DeleteServerCertificateWithResponse request
	DeleteServerCertificateWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteServerCertificateResponse, error)

	// UpdateServerCertificateWithBodyWithResponse request with any body
	UpdateServerCertificateWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServerCertificateResponse, error)

	UpdateServerCertificateWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateServerCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServerCertificateResponse, error)

	// ReadSnapshotsWithResponse request
	ReadSnapshotsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadSnapshotsParams, reqEditors ...RequestEditorFn) (*ReadSnapshotsResponse, error)

	// CreateSnapshotWithBodyWithResponse request with any body
	CreateSnapshotWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSnapshotResponse, error)

	CreateSnapshotWithResponse(ctx context.Context, spaceId SpaceId, body CreateSnapshotJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSnapshotResponse, error)

	// DeleteSnapshotWithResponse request
	DeleteSnapshotWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteSnapshotResponse, error)

	// ReadSnapshotsByIdWithResponse request
	ReadSnapshotsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadSnapshotsByIdResponse, error)

	// ReadSubnetsWithResponse request
	ReadSubnetsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadSubnetsParams, reqEditors ...RequestEditorFn) (*ReadSubnetsResponse, error)

	// CreateSubnetWithBodyWithResponse request with any body
	CreateSubnetWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSubnetResponse, error)

	CreateSubnetWithResponse(ctx context.Context, spaceId SpaceId, body CreateSubnetJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSubnetResponse, error)

	// DeleteSubnetWithResponse request
	DeleteSubnetWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteSubnetResponse, error)

	// ReadSubnetsByIdWithResponse request
	ReadSubnetsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadSubnetsByIdResponse, error)

	// UpdateSubnetWithBodyWithResponse request with any body
	UpdateSubnetWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSubnetResponse, error)

	UpdateSubnetWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateSubnetJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSubnetResponse, error)

	// ReadTagsWithResponse request
	ReadTagsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadTagsParams, reqEditors ...RequestEditorFn) (*ReadTagsResponse, error)

	// ReadVirtualGatewaysWithResponse request
	ReadVirtualGatewaysWithResponse(ctx context.Context, spaceId SpaceId, params *ReadVirtualGatewaysParams, reqEditors ...RequestEditorFn) (*ReadVirtualGatewaysResponse, error)

	// CreateVirtualGatewayWithBodyWithResponse request with any body
	CreateVirtualGatewayWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVirtualGatewayResponse, error)

	CreateVirtualGatewayWithResponse(ctx context.Context, spaceId SpaceId, body CreateVirtualGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVirtualGatewayResponse, error)

	// DeleteVirtualGatewayWithResponse request
	DeleteVirtualGatewayWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteVirtualGatewayResponse, error)

	// ReadVirtualGatewaysByIdWithResponse request
	ReadVirtualGatewaysByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadVirtualGatewaysByIdResponse, error)

	// LinkVirtualGatewayToVpcWithBodyWithResponse request with any body
	LinkVirtualGatewayToVpcWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkVirtualGatewayToVpcResponse, error)

	LinkVirtualGatewayToVpcWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkVirtualGatewayToVpcJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkVirtualGatewayToVpcResponse, error)

	// UnlinkVirtualGatewayToVpcWithBodyWithResponse request with any body
	UnlinkVirtualGatewayToVpcWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkVirtualGatewayToVpcResponse, error)

	UnlinkVirtualGatewayToVpcWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkVirtualGatewayToVpcJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkVirtualGatewayToVpcResponse, error)

	// ReadVmsWithResponse request
	ReadVmsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadVmsParams, reqEditors ...RequestEditorFn) (*ReadVmsResponse, error)

	// CreateVmsWithBodyWithResponse request with any body
	CreateVmsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVmsResponse, error)

	CreateVmsWithResponse(ctx context.Context, spaceId SpaceId, body CreateVmsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVmsResponse, error)

	// ReadVmsStateWithResponse request
	ReadVmsStateWithResponse(ctx context.Context, spaceId SpaceId, params *ReadVmsStateParams, reqEditors ...RequestEditorFn) (*ReadVmsStateResponse, error)

	// DeleteVmsWithResponse request
	DeleteVmsWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteVmsResponse, error)

	// ReadVmsByIdWithResponse request
	ReadVmsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadVmsByIdResponse, error)

	// UpdateVmWithBodyWithResponse request with any body
	UpdateVmWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVmResponse, error)

	UpdateVmWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateVmJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVmResponse, error)

	// ReadAdminPasswordWithResponse request
	ReadAdminPasswordWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadAdminPasswordResponse, error)

	// ReadConsoleOutputWithResponse request
	ReadConsoleOutputWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadConsoleOutputResponse, error)

	// RebootVmWithResponse request
	RebootVmWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*RebootVmResponse, error)

	// StartVmWithResponse request
	StartVmWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*StartVmResponse, error)

	// StopVmWithBodyWithResponse request with any body
	StopVmWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StopVmResponse, error)

	StopVmWithResponse(ctx context.Context, spaceId SpaceId, id string, body StopVmJSONRequestBody, reqEditors ...RequestEditorFn) (*StopVmResponse, error)

	// ReadVolumesWithResponse request
	ReadVolumesWithResponse(ctx context.Context, spaceId SpaceId, params *ReadVolumesParams, reqEditors ...RequestEditorFn) (*ReadVolumesResponse, error)

	// CreateVolumeWithBodyWithResponse request with any body
	CreateVolumeWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVolumeResponse, error)

	CreateVolumeWithResponse(ctx context.Context, spaceId SpaceId, body CreateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVolumeResponse, error)

	// DeleteVolumeWithResponse request
	DeleteVolumeWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteVolumeResponse, error)

	// ReadVolumesByIdWithResponse request
	ReadVolumesByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadVolumesByIdResponse, error)

	// UpdateVolumeWithBodyWithResponse request with any body
	UpdateVolumeWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVolumeResponse, error)

	UpdateVolumeWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVolumeResponse, error)

	// LinkVolumeWithBodyWithResponse request with any body
	LinkVolumeWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkVolumeResponse, error)

	LinkVolumeWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkVolumeResponse, error)

	// UnlinkVolumeWithBodyWithResponse request with any body
	UnlinkVolumeWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkVolumeResponse, error)

	UnlinkVolumeWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkVolumeResponse, error)

	// ReadVpcPeeringsWithResponse request
	ReadVpcPeeringsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadVpcPeeringsParams, reqEditors ...RequestEditorFn) (*ReadVpcPeeringsResponse, error)

	// CreateVpcPeeringWithBodyWithResponse request with any body
	CreateVpcPeeringWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVpcPeeringResponse, error)

	CreateVpcPeeringWithResponse(ctx context.Context, spaceId SpaceId, body CreateVpcPeeringJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVpcPeeringResponse, error)

	// DeleteVpcPeeringWithResponse request
	DeleteVpcPeeringWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteVpcPeeringResponse, error)

	// ReadVpcPeeringsByIdWithResponse request
	ReadVpcPeeringsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadVpcPeeringsByIdResponse, error)

	// AcceptVpcPeeringWithResponse request
	AcceptVpcPeeringWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*AcceptVpcPeeringResponse, error)

	// RejectVpcPeeringWithResponse request
	RejectVpcPeeringWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*RejectVpcPeeringResponse, error)

	// ReadVpcsWithResponse request
	ReadVpcsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadVpcsParams, reqEditors ...RequestEditorFn) (*ReadVpcsResponse, error)

	// CreateVpcWithBodyWithResponse request with any body
	CreateVpcWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVpcResponse, error)

	CreateVpcWithResponse(ctx context.Context, spaceId SpaceId, body CreateVpcJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVpcResponse, error)

	// DeleteVpcWithResponse request
	DeleteVpcWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteVpcResponse, error)

	// ReadVpcsByIdWithResponse request
	ReadVpcsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadVpcsByIdResponse, error)

	// UpdateVpcWithBodyWithResponse request with any body
	UpdateVpcWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVpcResponse, error)

	UpdateVpcWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateVpcJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVpcResponse, error)

	// ReadVpnConnectionsWithResponse request
	ReadVpnConnectionsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadVpnConnectionsParams, reqEditors ...RequestEditorFn) (*ReadVpnConnectionsResponse, error)

	// CreateVpnConnectionWithBodyWithResponse request with any body
	CreateVpnConnectionWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVpnConnectionResponse, error)

	CreateVpnConnectionWithResponse(ctx context.Context, spaceId SpaceId, body CreateVpnConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVpnConnectionResponse, error)

	// DeleteVpnConnectionWithResponse request
	DeleteVpnConnectionWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteVpnConnectionResponse, error)

	// ReadVpnConnectionsByIdWithResponse request
	ReadVpnConnectionsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadVpnConnectionsByIdResponse, error)

	// UpdateVpnConnectionWithBodyWithResponse request with any body
	UpdateVpnConnectionWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVpnConnectionResponse, error)

	UpdateVpnConnectionWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateVpnConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVpnConnectionResponse, error)

	// DeleteVpnConnectionRouteWithBodyWithResponse request with any body
	DeleteVpnConnectionRouteWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteVpnConnectionRouteResponse, error)

	DeleteVpnConnectionRouteWithResponse(ctx context.Context, spaceId SpaceId, id string, body DeleteVpnConnectionRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteVpnConnectionRouteResponse, error)

	// CreateVpnConnectionRouteWithBodyWithResponse request with any body
	CreateVpnConnectionRouteWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVpnConnectionRouteResponse, error)

	CreateVpnConnectionRouteWithResponse(ctx context.Context, spaceId SpaceId, id string, body CreateVpnConnectionRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVpnConnectionRouteResponse, error)

	// JsonWebKeysWithResponse request
	JsonWebKeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*JsonWebKeysResponse, error)

	// DiscoverOidcConfigurationWithResponse request
	DiscoverOidcConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DiscoverOidcConfigurationResponse, error)

	// GetWebAuthnJavaScriptWithResponse request
	GetWebAuthnJavaScriptWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWebAuthnJavaScriptResponse, error)

	// CreateAdminServiceAccountSpaceWithBodyWithResponse request with any body
	CreateAdminServiceAccountSpaceWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAdminServiceAccountSpaceResponse, error)

	CreateAdminServiceAccountSpaceWithResponse(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, body CreateAdminServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAdminServiceAccountSpaceResponse, error)

	// AuthorizeWithResponse request
	AuthorizeWithResponse(ctx context.Context, params *AuthorizeParams, reqEditors ...RequestEditorFn) (*AuthorizeResponse, error)

	// ConsentWithResponse request
	ConsentWithResponse(ctx context.Context, params *ConsentParams, reqEditors ...RequestEditorFn) (*ConsentResponse, error)

	// GetFlowErrorWithResponse request
	GetFlowErrorWithResponse(ctx context.Context, params *GetFlowErrorParams, reqEditors ...RequestEditorFn) (*GetFlowErrorResponse, error)

	// UpdateLoginFlowWithBodyWithResponse request with any body
	UpdateLoginFlowWithBodyWithResponse(ctx context.Context, params *UpdateLoginFlowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLoginFlowResponse, error)

	UpdateLoginFlowWithResponse(ctx context.Context, params *UpdateLoginFlowParams, body UpdateLoginFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLoginFlowResponse, error)

	UpdateLoginFlowWithFormdataBodyWithResponse(ctx context.Context, params *UpdateLoginFlowParams, body UpdateLoginFlowFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateLoginFlowResponse, error)

	// CreateNativeLoginFlowWithResponse request
	CreateNativeLoginFlowWithResponse(ctx context.Context, params *CreateNativeLoginFlowParams, reqEditors ...RequestEditorFn) (*CreateNativeLoginFlowResponse, error)

	// CreateBrowserLoginFlowWithResponse request
	CreateBrowserLoginFlowWithResponse(ctx context.Context, params *CreateBrowserLoginFlowParams, reqEditors ...RequestEditorFn) (*CreateBrowserLoginFlowResponse, error)

	// GetLoginFlowWithResponse request
	GetLoginFlowWithResponse(ctx context.Context, params *GetLoginFlowParams, reqEditors ...RequestEditorFn) (*GetLoginFlowResponse, error)

	// UpdateLogoutFlowWithResponse request
	UpdateLogoutFlowWithResponse(ctx context.Context, params *UpdateLogoutFlowParams, reqEditors ...RequestEditorFn) (*UpdateLogoutFlowResponse, error)

	// PerformNativeLogoutWithBodyWithResponse request with any body
	PerformNativeLogoutWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PerformNativeLogoutResponse, error)

	PerformNativeLogoutWithResponse(ctx context.Context, body PerformNativeLogoutJSONRequestBody, reqEditors ...RequestEditorFn) (*PerformNativeLogoutResponse, error)

	// CreateBrowserLogoutFlowWithResponse request
	CreateBrowserLogoutFlowWithResponse(ctx context.Context, params *CreateBrowserLogoutFlowParams, reqEditors ...RequestEditorFn) (*CreateBrowserLogoutFlowResponse, error)

	// InitRecoveryFlowWithResponse request
	InitRecoveryFlowWithResponse(ctx context.Context, params *InitRecoveryFlowParams, reqEditors ...RequestEditorFn) (*InitRecoveryFlowResponse, error)

	// UpdateRecoveryFlowWithBodyWithResponse request with any body
	UpdateRecoveryFlowWithBodyWithResponse(ctx context.Context, params *UpdateRecoveryFlowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRecoveryFlowResponse, error)

	UpdateRecoveryFlowWithResponse(ctx context.Context, params *UpdateRecoveryFlowParams, body UpdateRecoveryFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRecoveryFlowResponse, error)

	UpdateRecoveryFlowWithFormdataBodyWithResponse(ctx context.Context, params *UpdateRecoveryFlowParams, body UpdateRecoveryFlowFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateRecoveryFlowResponse, error)

	// CreateNativeRecoveryFlowWithResponse request
	CreateNativeRecoveryFlowWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CreateNativeRecoveryFlowResponse, error)

	// CreateBrowserRecoveryFlowWithResponse request
	CreateBrowserRecoveryFlowWithResponse(ctx context.Context, params *CreateBrowserRecoveryFlowParams, reqEditors ...RequestEditorFn) (*CreateBrowserRecoveryFlowResponse, error)

	// GetRecoveryFlowWithResponse request
	GetRecoveryFlowWithResponse(ctx context.Context, params *GetRecoveryFlowParams, reqEditors ...RequestEditorFn) (*GetRecoveryFlowResponse, error)

	// UpdateRegistrationFlowWithBodyWithResponse request with any body
	UpdateRegistrationFlowWithBodyWithResponse(ctx context.Context, params *UpdateRegistrationFlowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRegistrationFlowResponse, error)

	UpdateRegistrationFlowWithResponse(ctx context.Context, params *UpdateRegistrationFlowParams, body UpdateRegistrationFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRegistrationFlowResponse, error)

	UpdateRegistrationFlowWithFormdataBodyWithResponse(ctx context.Context, params *UpdateRegistrationFlowParams, body UpdateRegistrationFlowFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateRegistrationFlowResponse, error)

	// CreateNativeRegistrationFlowWithResponse request
	CreateNativeRegistrationFlowWithResponse(ctx context.Context, params *CreateNativeRegistrationFlowParams, reqEditors ...RequestEditorFn) (*CreateNativeRegistrationFlowResponse, error)

	// CreateBrowserRegistrationFlowWithResponse request
	CreateBrowserRegistrationFlowWithResponse(ctx context.Context, params *CreateBrowserRegistrationFlowParams, reqEditors ...RequestEditorFn) (*CreateBrowserRegistrationFlowResponse, error)

	// GetRegistrationFlowWithResponse request
	GetRegistrationFlowWithResponse(ctx context.Context, params *GetRegistrationFlowParams, reqEditors ...RequestEditorFn) (*GetRegistrationFlowResponse, error)

	// UpdateSettingsFloWithBodyWithResponse request with any body
	UpdateSettingsFloWithBodyWithResponse(ctx context.Context, params *UpdateSettingsFloParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSettingsFloResponse, error)

	UpdateSettingsFloWithResponse(ctx context.Context, params *UpdateSettingsFloParams, body UpdateSettingsFloJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSettingsFloResponse, error)

	UpdateSettingsFloWithFormdataBodyWithResponse(ctx context.Context, params *UpdateSettingsFloParams, body UpdateSettingsFloFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateSettingsFloResponse, error)

	// CreateNativeSettingsFlowWithResponse request
	CreateNativeSettingsFlowWithResponse(ctx context.Context, params *CreateNativeSettingsFlowParams, reqEditors ...RequestEditorFn) (*CreateNativeSettingsFlowResponse, error)

	// CreateBrowserSettingsFlowWithResponse request
	CreateBrowserSettingsFlowWithResponse(ctx context.Context, params *CreateBrowserSettingsFlowParams, reqEditors ...RequestEditorFn) (*CreateBrowserSettingsFlowResponse, error)

	// GetSettingsFlowWithResponse request
	GetSettingsFlowWithResponse(ctx context.Context, params *GetSettingsFlowParams, reqEditors ...RequestEditorFn) (*GetSettingsFlowResponse, error)

	// UpdateVerificationFlowWithBodyWithResponse request with any body
	UpdateVerificationFlowWithBodyWithResponse(ctx context.Context, params *UpdateVerificationFlowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVerificationFlowResponse, error)

	UpdateVerificationFlowWithResponse(ctx context.Context, params *UpdateVerificationFlowParams, body UpdateVerificationFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVerificationFlowResponse, error)

	UpdateVerificationFlowWithFormdataBodyWithResponse(ctx context.Context, params *UpdateVerificationFlowParams, body UpdateVerificationFlowFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateVerificationFlowResponse, error)

	// CreateNativeVerificationFlowWithResponse request
	CreateNativeVerificationFlowWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CreateNativeVerificationFlowResponse, error)

	// CreateBrowserVerificationFlowWithResponse request
	CreateBrowserVerificationFlowWithResponse(ctx context.Context, params *CreateBrowserVerificationFlowParams, reqEditors ...RequestEditorFn) (*CreateBrowserVerificationFlowResponse, error)

	// GetVerificationFlowWithResponse request
	GetVerificationFlowWithResponse(ctx context.Context, params *GetVerificationFlowParams, reqEditors ...RequestEditorFn) (*GetVerificationFlowResponse, error)

	// DisableMyOtherSessionsWithResponse request
	DisableMyOtherSessionsWithResponse(ctx context.Context, params *DisableMyOtherSessionsParams, reqEditors ...RequestEditorFn) (*DisableMyOtherSessionsResponse, error)

	// ListMySessionsWithResponse request
	ListMySessionsWithResponse(ctx context.Context, params *ListMySessionsParams, reqEditors ...RequestEditorFn) (*ListMySessionsResponse, error)

	// ExchangeSessionTokenWithResponse request
	ExchangeSessionTokenWithResponse(ctx context.Context, params *ExchangeSessionTokenParams, reqEditors ...RequestEditorFn) (*ExchangeSessionTokenResponse, error)

	// ToSessionWithResponse request
	ToSessionWithResponse(ctx context.Context, params *ToSessionParams, reqEditors ...RequestEditorFn) (*ToSessionResponse, error)

	// IntrospectWithBodyWithResponse request with any body
	IntrospectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IntrospectResponse, error)

	IntrospectWithFormdataBodyWithResponse(ctx context.Context, body IntrospectFormdataRequestBody, reqEditors ...RequestEditorFn) (*IntrospectResponse, error)

	// ListOrganisationsIdentityWithResponse request
	ListOrganisationsIdentityWithResponse(ctx context.Context, params *ListOrganisationsIdentityParams, reqEditors ...RequestEditorFn) (*ListOrganisationsIdentityResponse, error)

	// GetIAMGranularPolicyOrganisationWithResponse request
	GetIAMGranularPolicyOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, reqEditors ...RequestEditorFn) (*GetIAMGranularPolicyOrganisationResponse, error)

	// SetIAMGranularPolicyOrganisationWithBodyWithResponse request with any body
	SetIAMGranularPolicyOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetIAMGranularPolicyOrganisationResponse, error)

	SetIAMGranularPolicyOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, body SetIAMGranularPolicyOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*SetIAMGranularPolicyOrganisationResponse, error)

	// GetIAMPolicyOrganisationWithResponse request
	GetIAMPolicyOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, reqEditors ...RequestEditorFn) (*GetIAMPolicyOrganisationResponse, error)

	// SetIAMPolicyOrganisationWithBodyWithResponse request with any body
	SetIAMPolicyOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetIAMPolicyOrganisationResponse, error)

	SetIAMPolicyOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, body SetIAMPolicyOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*SetIAMPolicyOrganisationResponse, error)

	// ListPermissionsOrganisationWithResponse request
	ListPermissionsOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, params *ListPermissionsOrganisationParams, reqEditors ...RequestEditorFn) (*ListPermissionsOrganisationResponse, error)

	// GetPermissionOrganisationWithResponse request
	GetPermissionOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, permissionUuid PermissionUuid, reqEditors ...RequestEditorFn) (*GetPermissionOrganisationResponse, error)

	// ListRolesOrganisationWithResponse request
	ListRolesOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, params *ListRolesOrganisationParams, reqEditors ...RequestEditorFn) (*ListRolesOrganisationResponse, error)

	// CreateRoleOrganisationWithBodyWithResponse request with any body
	CreateRoleOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRoleOrganisationResponse, error)

	CreateRoleOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, body CreateRoleOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRoleOrganisationResponse, error)

	// DeleteRoleOrganisationWithResponse request
	DeleteRoleOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*DeleteRoleOrganisationResponse, error)

	// GetRoleOrganisationWithResponse request
	GetRoleOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*GetRoleOrganisationResponse, error)

	// UpdateRoleOrganisationWithBodyWithResponse request with any body
	UpdateRoleOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRoleOrganisationResponse, error)

	UpdateRoleOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, body UpdateRoleOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRoleOrganisationResponse, error)

	// RemoveRolePermissionsOrganisationWithBodyWithResponse request with any body
	RemoveRolePermissionsOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveRolePermissionsOrganisationResponse, error)

	RemoveRolePermissionsOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, body RemoveRolePermissionsOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveRolePermissionsOrganisationResponse, error)

	// GetRolePermissionsOrganisationWithResponse request
	GetRolePermissionsOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*GetRolePermissionsOrganisationResponse, error)

	// AddRolePermissionsOrganisationWithBodyWithResponse request with any body
	AddRolePermissionsOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddRolePermissionsOrganisationResponse, error)

	AddRolePermissionsOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, body AddRolePermissionsOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*AddRolePermissionsOrganisationResponse, error)

	// ListServiceAccountOrganisationWithBodyWithResponse request with any body
	ListServiceAccountOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, params *ListServiceAccountOrganisationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListServiceAccountOrganisationResponse, error)

	ListServiceAccountOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, params *ListServiceAccountOrganisationParams, body ListServiceAccountOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*ListServiceAccountOrganisationResponse, error)

	// CreateServiceAccountOrganisationWithBodyWithResponse request with any body
	CreateServiceAccountOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceAccountOrganisationResponse, error)

	CreateServiceAccountOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, body CreateServiceAccountOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceAccountOrganisationResponse, error)

	// DeleteServiceAccountOrganisationWithResponse request
	DeleteServiceAccountOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*DeleteServiceAccountOrganisationResponse, error)

	// GetServiceAccountOrganisationWithResponse request
	GetServiceAccountOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*GetServiceAccountOrganisationResponse, error)

	// UpdateServiceAccountOrganisationWithBodyWithResponse request with any body
	UpdateServiceAccountOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServiceAccountOrganisationResponse, error)

	UpdateServiceAccountOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, body UpdateServiceAccountOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServiceAccountOrganisationResponse, error)

	// GetACLServiceAccountOrganisationWithResponse request
	GetACLServiceAccountOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, params *GetACLServiceAccountOrganisationParams, reqEditors ...RequestEditorFn) (*GetACLServiceAccountOrganisationResponse, error)

	// DeleteACLServiceAccountOrganisationBulkWithBodyWithResponse request with any body
	DeleteACLServiceAccountOrganisationBulkWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteACLServiceAccountOrganisationBulkResponse, error)

	DeleteACLServiceAccountOrganisationBulkWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, body DeleteACLServiceAccountOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteACLServiceAccountOrganisationBulkResponse, error)

	// CreateACLServiceAccountOrganisationBulkWithBodyWithResponse request with any body
	CreateACLServiceAccountOrganisationBulkWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateACLServiceAccountOrganisationBulkResponse, error)

	CreateACLServiceAccountOrganisationBulkWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, body CreateACLServiceAccountOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateACLServiceAccountOrganisationBulkResponse, error)

	// ListSpacesOfServiceAccountWithResponse request
	ListSpacesOfServiceAccountWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, params *ListSpacesOfServiceAccountParams, reqEditors ...RequestEditorFn) (*ListSpacesOfServiceAccountResponse, error)

	// ListSpacesIdentityWithResponse request
	ListSpacesIdentityWithResponse(ctx context.Context, organisationId OrganisationId, params *ListSpacesIdentityParams, reqEditors ...RequestEditorFn) (*ListSpacesIdentityResponse, error)

	// ListUserOrganisationWithBodyWithResponse request with any body
	ListUserOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, params *ListUserOrganisationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListUserOrganisationResponse, error)

	ListUserOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, params *ListUserOrganisationParams, body ListUserOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*ListUserOrganisationResponse, error)

	// CreateUserOrganisationWithBodyWithResponse request with any body
	CreateUserOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserOrganisationResponse, error)

	CreateUserOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, body CreateUserOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserOrganisationResponse, error)

	// DeleteUserOrganisationWithResponse request
	DeleteUserOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, reqEditors ...RequestEditorFn) (*DeleteUserOrganisationResponse, error)

	// GetUserOrganisationWithResponse request
	GetUserOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, reqEditors ...RequestEditorFn) (*GetUserOrganisationResponse, error)

	// PatchUserStateOrganisationWithBodyWithResponse request with any body
	PatchUserStateOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchUserStateOrganisationResponse, error)

	PatchUserStateOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, body PatchUserStateOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchUserStateOrganisationResponse, error)

	// UpdateUserOrganisationWithBodyWithResponse request with any body
	UpdateUserOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserOrganisationResponse, error)

	UpdateUserOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, body UpdateUserOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserOrganisationResponse, error)

	// GetACLUserOrganisationWithResponse request
	GetACLUserOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, params *GetACLUserOrganisationParams, reqEditors ...RequestEditorFn) (*GetACLUserOrganisationResponse, error)

	// DeleteACLUserOrganisationBulkWithBodyWithResponse request with any body
	DeleteACLUserOrganisationBulkWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteACLUserOrganisationBulkResponse, error)

	DeleteACLUserOrganisationBulkWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, body DeleteACLUserOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteACLUserOrganisationBulkResponse, error)

	// CreateACLUserOrganisationBulkWithBodyWithResponse request with any body
	CreateACLUserOrganisationBulkWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateACLUserOrganisationBulkResponse, error)

	CreateACLUserOrganisationBulkWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, body CreateACLUserOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateACLUserOrganisationBulkResponse, error)

	// RecoverUserOrganisationWithResponse request
	RecoverUserOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, reqEditors ...RequestEditorFn) (*RecoverUserOrganisationResponse, error)

	// ListSpacesOfUserWithResponse request
	ListSpacesOfUserWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, params *ListSpacesOfUserParams, reqEditors ...RequestEditorFn) (*ListSpacesOfUserResponse, error)

	// RevokeWithBodyWithResponse request with any body
	RevokeWithBodyWithResponse(ctx context.Context, params *RevokeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevokeResponse, error)

	RevokeWithFormdataBodyWithResponse(ctx context.Context, params *RevokeParams, body RevokeFormdataRequestBody, reqEditors ...RequestEditorFn) (*RevokeResponse, error)

	// GetIAMGranularPolicySpaceWithResponse request
	GetIAMGranularPolicySpaceWithResponse(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, reqEditors ...RequestEditorFn) (*GetIAMGranularPolicySpaceResponse, error)

	// SetIAMGranularPolicySpaceWithBodyWithResponse request with any body
	SetIAMGranularPolicySpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetIAMGranularPolicySpaceResponse, error)

	SetIAMGranularPolicySpaceWithResponse(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, body SetIAMGranularPolicySpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*SetIAMGranularPolicySpaceResponse, error)

	// GetIAMPolicySpaceWithResponse request
	GetIAMPolicySpaceWithResponse(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, reqEditors ...RequestEditorFn) (*GetIAMPolicySpaceResponse, error)

	// SetIAMPolicySpaceWithBodyWithResponse request with any body
	SetIAMPolicySpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetIAMPolicySpaceResponse, error)

	SetIAMPolicySpaceWithResponse(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, body SetIAMPolicySpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*SetIAMPolicySpaceResponse, error)

	// ListPermissionsSpaceWithResponse request
	ListPermissionsSpaceWithResponse(ctx context.Context, spaceId SpaceId, params *ListPermissionsSpaceParams, reqEditors ...RequestEditorFn) (*ListPermissionsSpaceResponse, error)

	// GetPermissionSpaceWithResponse request
	GetPermissionSpaceWithResponse(ctx context.Context, spaceId SpaceId, permissionUuid PermissionUuid, reqEditors ...RequestEditorFn) (*GetPermissionSpaceResponse, error)

	// ListRolesSpaceWithResponse request
	ListRolesSpaceWithResponse(ctx context.Context, spaceId SpaceId, params *ListRolesSpaceParams, reqEditors ...RequestEditorFn) (*ListRolesSpaceResponse, error)

	// CreateRoleSpaceWithBodyWithResponse request with any body
	CreateRoleSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRoleSpaceResponse, error)

	CreateRoleSpaceWithResponse(ctx context.Context, spaceId SpaceId, body CreateRoleSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRoleSpaceResponse, error)

	// DeleteRoleSpaceWithResponse request
	DeleteRoleSpaceWithResponse(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*DeleteRoleSpaceResponse, error)

	// GetRoleSpaceWithResponse request
	GetRoleSpaceWithResponse(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*GetRoleSpaceResponse, error)

	// UpdateRoleSpaceWithBodyWithResponse request with any body
	UpdateRoleSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRoleSpaceResponse, error)

	UpdateRoleSpaceWithResponse(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, body UpdateRoleSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRoleSpaceResponse, error)

	// RemoveRolePermissionsSpaceWithBodyWithResponse request with any body
	RemoveRolePermissionsSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveRolePermissionsSpaceResponse, error)

	RemoveRolePermissionsSpaceWithResponse(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, body RemoveRolePermissionsSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveRolePermissionsSpaceResponse, error)

	// GetRolePermissionsSpaceWithResponse request
	GetRolePermissionsSpaceWithResponse(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*GetRolePermissionsSpaceResponse, error)

	// AddRolePermissionsSpaceWithBodyWithResponse request with any body
	AddRolePermissionsSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddRolePermissionsSpaceResponse, error)

	AddRolePermissionsSpaceWithResponse(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, body AddRolePermissionsSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*AddRolePermissionsSpaceResponse, error)

	// ListServiceAccountSpaceWithBodyWithResponse request with any body
	ListServiceAccountSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, params *ListServiceAccountSpaceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListServiceAccountSpaceResponse, error)

	ListServiceAccountSpaceWithResponse(ctx context.Context, spaceId SpaceId, params *ListServiceAccountSpaceParams, body ListServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*ListServiceAccountSpaceResponse, error)

	// CreateServiceAccountSpaceWithBodyWithResponse request with any body
	CreateServiceAccountSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceAccountSpaceResponse, error)

	CreateServiceAccountSpaceWithResponse(ctx context.Context, spaceId SpaceId, body CreateServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceAccountSpaceResponse, error)

	// DeleteServiceAccountSpaceWithResponse request
	DeleteServiceAccountSpaceWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*DeleteServiceAccountSpaceResponse, error)

	// GetServiceAccountSpaceWithResponse request
	GetServiceAccountSpaceWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*GetServiceAccountSpaceResponse, error)

	// AssignServiceAccountToSpaceWithResponse request
	AssignServiceAccountToSpaceWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*AssignServiceAccountToSpaceResponse, error)

	// UpdateServiceAccountSpaceWithBodyWithResponse request with any body
	UpdateServiceAccountSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServiceAccountSpaceResponse, error)

	UpdateServiceAccountSpaceWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, body UpdateServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServiceAccountSpaceResponse, error)

	// GetACLServiceAccountSpaceWithResponse request
	GetACLServiceAccountSpaceWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, params *GetACLServiceAccountSpaceParams, reqEditors ...RequestEditorFn) (*GetACLServiceAccountSpaceResponse, error)

	// DeleteACLServiceAccountSpaceBulkWithBodyWithResponse request with any body
	DeleteACLServiceAccountSpaceBulkWithBodyWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteACLServiceAccountSpaceBulkResponse, error)

	DeleteACLServiceAccountSpaceBulkWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, body DeleteACLServiceAccountSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteACLServiceAccountSpaceBulkResponse, error)

	// CreateACLServiceAccountSpaceBulkWithBodyWithResponse request with any body
	CreateACLServiceAccountSpaceBulkWithBodyWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateACLServiceAccountSpaceBulkResponse, error)

	CreateACLServiceAccountSpaceBulkWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, body CreateACLServiceAccountSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateACLServiceAccountSpaceBulkResponse, error)

	// ListUserSpaceWithBodyWithResponse request with any body
	ListUserSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, params *ListUserSpaceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListUserSpaceResponse, error)

	ListUserSpaceWithResponse(ctx context.Context, spaceId SpaceId, params *ListUserSpaceParams, body ListUserSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*ListUserSpaceResponse, error)

	// CreateUserSpaceWithBodyWithResponse request with any body
	CreateUserSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserSpaceResponse, error)

	CreateUserSpaceWithResponse(ctx context.Context, spaceId SpaceId, body CreateUserSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserSpaceResponse, error)

	// UnassignUserSpaceWithResponse request
	UnassignUserSpaceWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*UnassignUserSpaceResponse, error)

	// GetUserSpaceWithResponse request
	GetUserSpaceWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*GetUserSpaceResponse, error)

	// PatchUserStateSpaceWithBodyWithResponse request with any body
	PatchUserStateSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchUserStateSpaceResponse, error)

	PatchUserStateSpaceWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, body PatchUserStateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchUserStateSpaceResponse, error)

	// AssignUserToSpaceWithResponse request
	AssignUserToSpaceWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*AssignUserToSpaceResponse, error)

	// UpdateUserSpaceWithBodyWithResponse request with any body
	UpdateUserSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserSpaceResponse, error)

	UpdateUserSpaceWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, body UpdateUserSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserSpaceResponse, error)

	// GetACLUserSpaceWithResponse request
	GetACLUserSpaceWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, params *GetACLUserSpaceParams, reqEditors ...RequestEditorFn) (*GetACLUserSpaceResponse, error)

	// DeleteACLUserSpaceBulkWithBodyWithResponse request with any body
	DeleteACLUserSpaceBulkWithBodyWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteACLUserSpaceBulkResponse, error)

	DeleteACLUserSpaceBulkWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, body DeleteACLUserSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteACLUserSpaceBulkResponse, error)

	// CreateACLUserSpaceBulkWithBodyWithResponse request with any body
	CreateACLUserSpaceBulkWithBodyWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateACLUserSpaceBulkResponse, error)

	CreateACLUserSpaceBulkWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, body CreateACLUserSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateACLUserSpaceBulkResponse, error)

	// RecoverUserSpaceWithResponse request
	RecoverUserSpaceWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*RecoverUserSpaceResponse, error)

	// TokenWithBodyWithResponse request with any body
	TokenWithBodyWithResponse(ctx context.Context, params *TokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TokenResponse, error)

	TokenWithFormdataBodyWithResponse(ctx context.Context, params *TokenParams, body TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*TokenResponse, error)

	// GetUserInfoWithResponse request
	GetUserInfoWithResponse(ctx context.Context, params *GetUserInfoParams, reqEditors ...RequestEditorFn) (*GetUserInfoResponse, error)

	// HealthcheckWithResponse request
	HealthcheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthcheckResponse, error)

	// ListKubernetesClustersWithResponse request
	ListKubernetesClustersWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*ListKubernetesClustersResponse, error)

	// CreateKubernetesClusterWithBodyWithResponse request with any body
	CreateKubernetesClusterWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKubernetesClusterResponse, error)

	CreateKubernetesClusterWithResponse(ctx context.Context, spaceId SpaceId, body CreateKubernetesClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKubernetesClusterResponse, error)

	// DeleteKubernetesClusterByIdWithResponse request
	DeleteKubernetesClusterByIdWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*DeleteKubernetesClusterByIdResponse, error)

	// GetKubernetesClusterByIdWithResponse request
	GetKubernetesClusterByIdWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*GetKubernetesClusterByIdResponse, error)

	// GetKubeConfigWithResponse request
	GetKubeConfigWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*GetKubeConfigResponse, error)

	// UpgradeMastersWithBodyWithResponse request with any body
	UpgradeMastersWithBodyWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpgradeMastersResponse, error)

	UpgradeMastersWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, body UpgradeMastersJSONRequestBody, reqEditors ...RequestEditorFn) (*UpgradeMastersResponse, error)

	// AddNodesWithBodyWithResponse request with any body
	AddNodesWithBodyWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddNodesResponse, error)

	AddNodesWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, body AddNodesJSONRequestBody, reqEditors ...RequestEditorFn) (*AddNodesResponse, error)

	// RemoveNodesWithBodyWithResponse request with any body
	RemoveNodesWithBodyWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveNodesResponse, error)

	RemoveNodesWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, body RemoveNodesJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveNodesResponse, error)

	// UpgradeNodesWithBodyWithResponse request with any body
	UpgradeNodesWithBodyWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpgradeNodesResponse, error)

	UpgradeNodesWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, body UpgradeNodesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpgradeNodesResponse, error)

	// ListOperationWithResponse request
	ListOperationWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*ListOperationResponse, error)

	// GetPrivateKeyWithResponse request
	GetPrivateKeyWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*GetPrivateKeyResponse, error)

	// GetClusterStatusWithResponse request
	GetClusterStatusWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*GetClusterStatusResponse, error)

	// UpdateNodesWithResponse request
	UpdateNodesWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*UpdateNodesResponse, error)

	// GetOperationByIdWithResponse request
	GetOperationByIdWithResponse(ctx context.Context, spaceId SpaceId, operationId OperationId, params *GetOperationByIdParams, reqEditors ...RequestEditorFn) (*GetOperationByIdResponse, error)

	// ListClustersWithResponse request
	ListClustersWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*ListClustersResponse, error)

	// CreateClusterWithBodyWithResponse request with any body
	CreateClusterWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error)

	CreateClusterWithResponse(ctx context.Context, spaceId SpaceId, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error)

	// DeleteClusterWithResponse request
	DeleteClusterWithResponse(ctx context.Context, spaceId SpaceId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*DeleteClusterResponse, error)

	// GetClusterWithResponse request
	GetClusterWithResponse(ctx context.Context, spaceId SpaceId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*GetClusterResponse, error)

	// UpdateClusterWithBodyWithResponse request with any body
	UpdateClusterWithBodyWithResponse(ctx context.Context, spaceId SpaceId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error)

	UpdateClusterWithResponse(ctx context.Context, spaceId SpaceId, clusterId ClusterId, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error)

	// ListNodepoolsWithResponse request
	ListNodepoolsWithResponse(ctx context.Context, spaceId SpaceId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*ListNodepoolsResponse, error)

	// CreateNodePoolWithBodyWithResponse request with any body
	CreateNodePoolWithBodyWithResponse(ctx context.Context, spaceId SpaceId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNodePoolResponse, error)

	CreateNodePoolWithResponse(ctx context.Context, spaceId SpaceId, clusterId ClusterId, body CreateNodePoolJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNodePoolResponse, error)

	// DeleteNodePoolWithResponse request
	DeleteNodePoolWithResponse(ctx context.Context, spaceId SpaceId, clusterId ClusterId, nodePoolName NodepoolName, reqEditors ...RequestEditorFn) (*DeleteNodePoolResponse, error)

	// UpdateNodepoolWithBodyWithResponse request with any body
	UpdateNodepoolWithBodyWithResponse(ctx context.Context, spaceId SpaceId, clusterId ClusterId, nodePoolName NodepoolName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNodepoolResponse, error)

	UpdateNodepoolWithResponse(ctx context.Context, spaceId SpaceId, clusterId ClusterId, nodePoolName NodepoolName, body UpdateNodepoolJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNodepoolResponse, error)

	// ListOperationsWithResponse request
	ListOperationsWithResponse(ctx context.Context, spaceId SpaceId, params *ListOperationsParams, reqEditors ...RequestEditorFn) (*ListOperationsResponse, error)

	// GetOperationWithResponse request
	GetOperationWithResponse(ctx context.Context, spaceId SpaceId, id IdUuid, reqEditors ...RequestEditorFn) (*GetOperationResponse, error)

	// ListVersionsWithResponse request
	ListVersionsWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*ListVersionsResponse, error)

	// ListSpacesWithBodyWithResponse request with any body
	ListSpacesWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, params *ListSpacesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListSpacesResponse, error)

	ListSpacesWithResponse(ctx context.Context, organisationId OrganisationId, params *ListSpacesParams, body ListSpacesJSONRequestBody, reqEditors ...RequestEditorFn) (*ListSpacesResponse, error)

	// CreateSpaceWithBodyWithResponse request with any body
	CreateSpaceWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpaceResponse, error)

	CreateSpaceWithResponse(ctx context.Context, organisationId OrganisationId, body CreateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpaceResponse, error)

	// DeleteSpaceWithResponse request
	DeleteSpaceWithResponse(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, reqEditors ...RequestEditorFn) (*DeleteSpaceResponse, error)

	// GetSpaceByIdWithResponse request
	GetSpaceByIdWithResponse(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, reqEditors ...RequestEditorFn) (*GetSpaceByIdResponse, error)

	// UpdateSpaceWithBodyWithResponse request with any body
	UpdateSpaceWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSpaceResponse, error)

	UpdateSpaceWithResponse(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, body UpdateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSpaceResponse, error)
}

type DeleteLoadBalancerTagsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteLoadBalancerTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLoadBalancerTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLoadBalancerTagsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateLoadBalancerTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLoadBalancerTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTagsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTagsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadClientGatewaysResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadClientGatewaysResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadClientGatewaysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadClientGatewaysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClientGatewayResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateClientGatewayResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateClientGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClientGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClientGatewayResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteClientGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClientGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadClientGatewaysByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadClientGatewaysByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadClientGatewaysByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadClientGatewaysByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadDhcpOptionsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadDhcpOptionsResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadDhcpOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadDhcpOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDhcpOptionsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateDhcpOptionsResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateDhcpOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDhcpOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDhcpOptionsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteDhcpOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDhcpOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadDhcpOptionsByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadDhcpOptionsByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadDhcpOptionsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadDhcpOptionsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadFlexibleGpusResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadFlexibleGpusResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadFlexibleGpusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadFlexibleGpusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFlexibleGpuResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateFlexibleGpuResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateFlexibleGpuResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFlexibleGpuResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFlexibleGpuResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteFlexibleGpuResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFlexibleGpuResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadFlexibleGpusByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadFlexibleGpusByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadFlexibleGpusByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadFlexibleGpusByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateFlexibleGpuResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateFlexibleGpuResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateFlexibleGpuResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFlexibleGpuResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkFlexibleGpuResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r LinkFlexibleGpuResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkFlexibleGpuResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkFlexibleGpuResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UnlinkFlexibleGpuResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkFlexibleGpuResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadImagesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadImagesResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadImagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadImagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateImageResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateImageResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteImageResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadImagesByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadImagesByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadImagesByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadImagesByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateImageResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateImageResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadInternetGatewaysResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadInternetGatewaysResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadInternetGatewaysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadInternetGatewaysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateInternetGatewayResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateInternetGatewayResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateInternetGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateInternetGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteInternetGatewayResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteInternetGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteInternetGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadInternetGatewaysByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadInternetGatewaysByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadInternetGatewaysByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadInternetGatewaysByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkInternetGatewayResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r LinkInternetGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkInternetGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkInternetGatewayResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UnlinkInternetGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkInternetGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadKeypairsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadKeypairsResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadKeypairsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadKeypairsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateKeypairResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateKeypairResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateKeypairResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateKeypairResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteKeypairResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteKeypairResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteKeypairResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadKeypairsByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadKeypairsByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadKeypairsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadKeypairsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadListenerRulesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadListenerRulesResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadListenerRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadListenerRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateListenerRuleResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateListenerRuleResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateListenerRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateListenerRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteListenerRuleResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteListenerRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteListenerRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadListenerRulesByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadListenerRulesByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadListenerRulesByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadListenerRulesByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateListenerRuleResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateListenerRuleResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateListenerRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateListenerRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadLoadBalancersResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadLoadBalancersResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadLoadBalancersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadLoadBalancersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLoadBalancerResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateLoadBalancerResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateLoadBalancerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLoadBalancerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLoadBalancerResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteLoadBalancerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLoadBalancerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadLoadBalancersByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadLoadBalancersByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadLoadBalancersByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadLoadBalancersByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateLoadBalancerResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateLoadBalancerResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateLoadBalancerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateLoadBalancerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkLoadBalancerBackendMachinesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r LinkLoadBalancerBackendMachinesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkLoadBalancerBackendMachinesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkLoadBalancerBackendMachinesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UnlinkLoadBalancerBackendMachinesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkLoadBalancerBackendMachinesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLoadBalancerListenersResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteLoadBalancerListenersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLoadBalancerListenersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLoadBalancerListenersResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateLoadBalancerListenersResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateLoadBalancerListenersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLoadBalancerListenersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLoadBalancerPolicyResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteLoadBalancerPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLoadBalancerPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLoadBalancerPolicyResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateLoadBalancerPolicyResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateLoadBalancerPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLoadBalancerPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVmsHealthResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadVmsHealthResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadVmsHealthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVmsHealthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadLoadBalancerTagsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadLoadBalancerTagsResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadLoadBalancerTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadLoadBalancerTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadNatGatewayResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadNatGatewayResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadNatGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadNatGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNatGatewayResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateNatGatewayResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateNatGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNatGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNatGatewayResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteNatGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNatGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadNatGatewayByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadNatGatewayByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadNatGatewayByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadNatGatewayByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadNicsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadNicsResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadNicsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadNicsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNicResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateNicResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateNicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNicResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteNicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadNicsByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadNicsByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadNicsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadNicsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateNicResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateNicResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateNicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateNicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkPrivateIpsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r LinkPrivateIpsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkPrivateIpsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkPrivateIpsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UnlinkPrivateIpsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkPrivateIpsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkNicResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *LinkNicResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r LinkNicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkNicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkNicResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UnlinkNicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkNicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadPublicIpRangesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadPublicIpRangesResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadPublicIpRangesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadPublicIpRangesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadPublicIpsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadPublicIpsResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadPublicIpsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadPublicIpsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePublicIpResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreatePublicIpResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreatePublicIpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePublicIpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePublicIpResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeletePublicIpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePublicIpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadPublicIpsByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadPublicIpsByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadPublicIpsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadPublicIpsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkPublicIpResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *LinkPublicIpResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r LinkPublicIpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkPublicIpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkPublicIpResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UnlinkPublicIpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkPublicIpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadRouteTablesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadRouteTablesResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadRouteTablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadRouteTablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRouteTableResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateRouteTableResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateRouteTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRouteTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRouteTableResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteRouteTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRouteTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadRouteTablesByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadRouteTablesByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadRouteTablesByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadRouteTablesByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRouteTableRoutePropagationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateRouteTableRoutePropagationResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateRouteTableRoutePropagationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRouteTableRoutePropagationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRouteResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteRouteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRouteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRouteResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateRouteResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateRouteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRouteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRouteResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateRouteResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateRouteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRouteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkRouteTableResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *LinkRouteTableResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r LinkRouteTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkRouteTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkRouteTableResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UnlinkRouteTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkRouteTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadSecurityGroupsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadSecurityGroupsResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadSecurityGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadSecurityGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSecurityGroupResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateSecurityGroupResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateSecurityGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSecurityGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSecurityGroupResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSecurityGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSecurityGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadSecurityGroupsByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadSecurityGroupsByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadSecurityGroupsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadSecurityGroupsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSecurityGroupRuleResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSecurityGroupRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSecurityGroupRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSecurityGroupRuleResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateSecurityGroupRuleResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateSecurityGroupRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSecurityGroupRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadServerCertificatesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadServerCertificatesResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadServerCertificatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadServerCertificatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServerCertificateResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateServerCertificateResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateServerCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServerCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServerCertificateResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteServerCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServerCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateServerCertificateResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON204                   *UpdateServerCertificateResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateServerCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateServerCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadSnapshotsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadSnapshotsResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadSnapshotsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadSnapshotsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSnapshotResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateSnapshotResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateSnapshotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSnapshotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSnapshotResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSnapshotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSnapshotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadSnapshotsByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadSnapshotsByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadSnapshotsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadSnapshotsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadSubnetsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadSubnetsResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadSubnetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadSubnetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSubnetResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateSubnetResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateSubnetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSubnetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSubnetResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSubnetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSubnetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadSubnetsByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadSubnetsByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadSubnetsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadSubnetsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSubnetResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateSubnetResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateSubnetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSubnetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadTagsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadTagsResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVirtualGatewaysResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadVirtualGatewaysResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadVirtualGatewaysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVirtualGatewaysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVirtualGatewayResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateVirtualGatewayResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateVirtualGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVirtualGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVirtualGatewayResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteVirtualGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVirtualGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVirtualGatewaysByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadVirtualGatewaysByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadVirtualGatewaysByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVirtualGatewaysByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkVirtualGatewayToVpcResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *LinkVirtualGatewayToVpcResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r LinkVirtualGatewayToVpcResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkVirtualGatewayToVpcResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkVirtualGatewayToVpcResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UnlinkVirtualGatewayToVpcResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkVirtualGatewayToVpcResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVmsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadVmsResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadVmsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVmsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVmsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateVmsResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateVmsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVmsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVmsStateResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadVmsStateResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadVmsStateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVmsStateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVmsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteVmsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVmsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVmsByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadVmsByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadVmsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVmsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVmResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateVmResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateVmResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVmResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadAdminPasswordResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadAdminPasswordResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadAdminPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadAdminPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadConsoleOutputResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadConsoleOutputResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadConsoleOutputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadConsoleOutputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RebootVmResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r RebootVmResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RebootVmResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartVmResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *StartVmResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r StartVmResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartVmResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StopVmResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *StopVmResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r StopVmResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StopVmResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVolumesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadVolumesResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadVolumesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVolumesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVolumeResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateVolumeResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateVolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVolumeResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteVolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVolumesByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadVolumesByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadVolumesByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVolumesByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVolumeResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateVolumeResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateVolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkVolumeResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r LinkVolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkVolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkVolumeResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UnlinkVolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkVolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVpcPeeringsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadVpcPeeringsResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadVpcPeeringsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVpcPeeringsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVpcPeeringResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateVpcPeeringResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateVpcPeeringResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVpcPeeringResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVpcPeeringResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteVpcPeeringResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVpcPeeringResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVpcPeeringsByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadVpcPeeringsByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadVpcPeeringsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVpcPeeringsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AcceptVpcPeeringResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *AcceptVpcPeeringResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r AcceptVpcPeeringResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AcceptVpcPeeringResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RejectVpcPeeringResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r RejectVpcPeeringResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RejectVpcPeeringResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVpcsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadVpcsResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadVpcsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVpcsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVpcResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateVpcResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateVpcResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVpcResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVpcResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteVpcResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVpcResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVpcsByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadVpcsByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadVpcsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVpcsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVpcResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateVpcResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateVpcResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVpcResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVpnConnectionsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadVpnConnectionsResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadVpnConnectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVpnConnectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVpnConnectionResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateVpnConnectionResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateVpnConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVpnConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVpnConnectionResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteVpnConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVpnConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVpnConnectionsByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadVpnConnectionsByIdResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadVpnConnectionsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVpnConnectionsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVpnConnectionResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateVpnConnectionResponseSchema
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateVpnConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVpnConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVpnConnectionRouteResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteVpnConnectionRouteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVpnConnectionRouteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVpnConnectionRouteResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateVpnConnectionRouteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVpnConnectionRouteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JsonWebKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JsonWebKeysResponseSchema
	JSON400      *ErrorOauth2
	JSON401      *ErrorOauth2
}

// Status returns HTTPResponse.Status
func (r JsonWebKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JsonWebKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DiscoverOidcConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OidcConfiguration
	JSONDefault  *ErrorOauth2
}

// Status returns HTTPResponse.Status
func (r DiscoverOidcConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DiscoverOidcConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWebAuthnJavaScriptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebAuthnJavaScriptResponseSchema
}

// Status returns HTTPResponse.Status
func (r GetWebAuthnJavaScriptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWebAuthnJavaScriptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAdminServiceAccountSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateServiceAccount201ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateAdminServiceAccountSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAdminServiceAccountSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthorizeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorOauth2
	JSON401      *ErrorOauth2
	JSON403      *ErrorOauth2
	JSON500      *ErrorOauth2
}

// Status returns HTTPResponse.Status
func (r AuthorizeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthorizeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConsentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ConsentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConsentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFlowErrorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FlowError
	JSON403      *ErrorGeneric
	JSON404      *ErrorGeneric
	JSON500      *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r GetFlowErrorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFlowErrorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateLoginFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessfulNativeLogin
	JSON400      *LoginFlow
	JSON410      *ErrorGeneric
	JSON422      *ErrorBrowserLocationChangeRequired
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r UpdateLoginFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateLoginFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNativeLoginFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoginFlow
	JSON400      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r CreateNativeLoginFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNativeLoginFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBrowserLoginFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoginFlow
	JSON400      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r CreateBrowserLoginFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBrowserLoginFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLoginFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoginFlow
	JSON403      *ErrorGeneric
	JSON404      *ErrorGeneric
	JSON410      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r GetLoginFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLoginFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateLogoutFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r UpdateLogoutFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateLogoutFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PerformNativeLogoutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r PerformNativeLogoutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PerformNativeLogoutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBrowserLogoutFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogoutFlow
	JSON400      *ErrorGeneric
	JSON401      *ErrorGeneric
	JSON500      *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r CreateBrowserLogoutFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBrowserLogoutFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InitRecoveryFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecoveryFlow
	JSON400      *RecoveryFlow
	JSON410      *ErrorGeneric
	JSON422      *ErrorBrowserLocationChangeRequired
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r InitRecoveryFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InitRecoveryFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRecoveryFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecoveryFlow
	JSON400      *RecoveryFlow
	JSON410      *ErrorGeneric
	JSON422      *ErrorBrowserLocationChangeRequired
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r UpdateRecoveryFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRecoveryFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNativeRecoveryFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecoveryFlow
	JSON400      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r CreateNativeRecoveryFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNativeRecoveryFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBrowserRecoveryFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecoveryFlow
	JSON400      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r CreateBrowserRecoveryFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBrowserRecoveryFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRecoveryFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecoveryFlow
	JSON404      *ErrorGeneric
	JSON410      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r GetRecoveryFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRecoveryFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRegistrationFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessfulNativeRegistration
	JSON400      *RegistrationFlow
	JSON410      *ErrorGeneric
	JSON422      *ErrorBrowserLocationChangeRequired
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r UpdateRegistrationFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRegistrationFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNativeRegistrationFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RegistrationFlow
	JSON400      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r CreateNativeRegistrationFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNativeRegistrationFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBrowserRegistrationFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RegistrationFlow
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r CreateBrowserRegistrationFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBrowserRegistrationFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRegistrationFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RegistrationFlow
	JSON403      *ErrorGeneric
	JSON404      *ErrorGeneric
	JSON410      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r GetRegistrationFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRegistrationFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSettingsFloResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SettingsFlow
	JSON400      *SettingsFlow
	JSON401      *ErrorGeneric
	JSON403      *ErrorGeneric
	JSON410      *ErrorGeneric
	JSON422      *ErrorBrowserLocationChangeRequired
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r UpdateSettingsFloResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSettingsFloResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNativeSettingsFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SettingsFlow
	JSON400      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r CreateNativeSettingsFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNativeSettingsFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBrowserSettingsFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SettingsFlow
	JSON400      *ErrorGeneric
	JSON401      *ErrorGeneric
	JSON403      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r CreateBrowserSettingsFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBrowserSettingsFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSettingsFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SettingsFlow
	JSON401      *ErrorGeneric
	JSON403      *ErrorGeneric
	JSON404      *ErrorGeneric
	JSON410      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r GetSettingsFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSettingsFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVerificationFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VerificationFlow
	JSON400      *VerificationFlow
	JSON410      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r UpdateVerificationFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVerificationFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNativeVerificationFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VerificationFlow
	JSON400      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r CreateNativeVerificationFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNativeVerificationFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBrowserVerificationFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VerificationFlow
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r CreateBrowserVerificationFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBrowserVerificationFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVerificationFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VerificationFlow
	JSON403      *ErrorGeneric
	JSON404      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r GetVerificationFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVerificationFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DisableMyOtherSessionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteMySessionsCount
	JSON400      *ErrorGeneric
	JSON401      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r DisableMyOtherSessionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DisableMyOtherSessionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMySessionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListMySessionsResponseSchema
	JSON400      *ErrorGeneric
	JSON401      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r ListMySessionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMySessionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExchangeSessionTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessfulNativeLogin
	JSON403      *ErrorGeneric
	JSON404      *ErrorGeneric
	JSON410      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r ExchangeSessionTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExchangeSessionTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ToSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Session
	JSON401      *ErrorGeneric
	JSON403      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r ToSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ToSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IntrospectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IntrospectResponseSchema
	JSON500      *ErrorOauth2
}

// Status returns HTTPResponse.Status
func (r IntrospectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IntrospectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListOrganisationsIdentityResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListUserOrganisations200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ListOrganisationsIdentityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListOrganisationsIdentityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIAMGranularPolicyOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetIAMGranularPolicy200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetIAMGranularPolicyOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIAMGranularPolicyOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetIAMGranularPolicyOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r SetIAMGranularPolicyOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetIAMGranularPolicyOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIAMPolicyOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetIAMPolicy200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetIAMPolicyOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIAMPolicyOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetIAMPolicyOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r SetIAMPolicyOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetIAMPolicyOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPermissionsOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListPermissions200ResponseSchema
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ListPermissionsOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPermissionsOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPermissionOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetPermission200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetPermissionOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPermissionOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRolesOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListRoles200ResponseSchema
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ListRolesOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRolesOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRoleOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *CreateRole200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateRoleOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRoleOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRoleOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteRoleOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRoleOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRoleOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetRole200ResponseSchema
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetRoleOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRoleOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRoleOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateRoleOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRoleOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveRolePermissionsOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r RemoveRolePermissionsOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveRolePermissionsOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRolePermissionsOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetRolePermissions200ResponseSchema
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetRolePermissionsOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRolePermissionsOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddRolePermissionsOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r AddRolePermissionsOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddRolePermissionsOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListServiceAccountOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListServiceAccount200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ListServiceAccountOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServiceAccountOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServiceAccountOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateServiceAccount201ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateServiceAccountOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServiceAccountOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServiceAccountOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteServiceAccountOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServiceAccountOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceAccountOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetServiceAccount200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetServiceAccountOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceAccountOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateServiceAccountOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateServiceAccount200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateServiceAccountOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateServiceAccountOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetACLServiceAccountOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetACL200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetACLServiceAccountOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetACLServiceAccountOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteACLServiceAccountOrganisationBulkResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteACLServiceAccountOrganisationBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteACLServiceAccountOrganisationBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateACLServiceAccountOrganisationBulkResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateACLServiceAccountOrganisationBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateACLServiceAccountOrganisationBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSpacesOfServiceAccountResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListSpacesServiceAccount200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ListSpacesOfServiceAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSpacesOfServiceAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSpacesIdentityResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListSpacesIdentity200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ListSpacesIdentityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSpacesIdentityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListUser200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ListUserOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateUser201ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateUserOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteUserOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetUser200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetUserOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchUserStateOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *PatchUserState200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchUserStateOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchUserStateOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateUser200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateUserOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetACLUserOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetACL200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetACLUserOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetACLUserOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteACLUserOrganisationBulkResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteACLUserOrganisationBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteACLUserOrganisationBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateACLUserOrganisationBulkResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateACLUserOrganisationBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateACLUserOrganisationBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RecoverUserOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *RecoverUser200ResponseSchema
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r RecoverUserOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RecoverUserOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSpacesOfUserResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListSpacesUser200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ListSpacesOfUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSpacesOfUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevokeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorOauth2
	JSON401      *ErrorOauth2
}

// Status returns HTTPResponse.Status
func (r RevokeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevokeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIAMGranularPolicySpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetIAMGranularPolicy200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetIAMGranularPolicySpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIAMGranularPolicySpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetIAMGranularPolicySpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r SetIAMGranularPolicySpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetIAMGranularPolicySpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIAMPolicySpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetIAMPolicy200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetIAMPolicySpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIAMPolicySpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetIAMPolicySpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r SetIAMPolicySpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetIAMPolicySpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPermissionsSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListPermissions200ResponseSchema
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ListPermissionsSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPermissionsSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPermissionSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetPermission200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetPermissionSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPermissionSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRolesSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListRoles200ResponseSchema
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ListRolesSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRolesSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRoleSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *CreateRole200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateRoleSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRoleSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRoleSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteRoleSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRoleSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRoleSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetRole200ResponseSchema
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetRoleSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRoleSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRoleSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateRoleSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRoleSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveRolePermissionsSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r RemoveRolePermissionsSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveRolePermissionsSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRolePermissionsSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetRolePermissions200ResponseSchema
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetRolePermissionsSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRolePermissionsSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddRolePermissionsSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r AddRolePermissionsSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddRolePermissionsSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListServiceAccountSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListServiceAccount200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ListServiceAccountSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServiceAccountSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServiceAccountSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateServiceAccount201ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateServiceAccountSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServiceAccountSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServiceAccountSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteServiceAccountSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServiceAccountSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceAccountSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetServiceAccount200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetServiceAccountSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceAccountSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignServiceAccountToSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r AssignServiceAccountToSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignServiceAccountToSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateServiceAccountSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateServiceAccount200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateServiceAccountSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateServiceAccountSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetACLServiceAccountSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetACL200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetACLServiceAccountSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetACLServiceAccountSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteACLServiceAccountSpaceBulkResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteACLServiceAccountSpaceBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteACLServiceAccountSpaceBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateACLServiceAccountSpaceBulkResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateACLServiceAccountSpaceBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateACLServiceAccountSpaceBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListUser200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ListUserSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateUser201ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateUserSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnassignUserSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UnassignUserSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnassignUserSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetUser200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetUserSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchUserStateSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *PatchUserState200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchUserStateSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchUserStateSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignUserToSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r AssignUserToSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignUserToSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateUser200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateUserSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetACLUserSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetACL200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetACLUserSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetACLUserSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteACLUserSpaceBulkResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteACLUserSpaceBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteACLUserSpaceBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateACLUserSpaceBulkResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateACLUserSpaceBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateACLUserSpaceBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RecoverUserSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *RecoverUser200ResponseSchema
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r RecoverUserSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RecoverUserSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenResponseSchema
	JSON400      *ErrorOauth2
	JSON401      *ErrorOauth2
	JSON500      *ErrorOauth2
}

// Status returns HTTPResponse.Status
func (r TokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetUserInfo200ResponseSchema
	JSONDefault  *ErrorOauth2
}

// Status returns HTTPResponse.Status
func (r GetUserInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HealthcheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r HealthcheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HealthcheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListKubernetesClustersResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ClusterList200ResponseSchema
	ApplicationproblemJSON400 *ErrorResponseSchema
	ApplicationproblemJSON500 *ErrorResponseSchema
}

// Status returns HTTPResponse.Status
func (r ListKubernetesClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListKubernetesClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateKubernetesClusterResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON202                   *Operation202ResponseSchema
	ApplicationproblemJSON400 *ErrorResponseSchema
	ApplicationproblemJSON409 *ErrorResponseSchema
	ApplicationproblemJSON500 *ErrorResponseSchema
}

// Status returns HTTPResponse.Status
func (r CreateKubernetesClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateKubernetesClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteKubernetesClusterByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON202                   *Operation202ResponseSchema
	ApplicationproblemJSON400 *ErrorResponseSchema
	ApplicationproblemJSON404 *ErrorResponseSchema
	ApplicationproblemJSON409 *ErrorResponseSchema
	ApplicationproblemJSON500 *ErrorResponseSchema
}

// Status returns HTTPResponse.Status
func (r DeleteKubernetesClusterByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteKubernetesClusterByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKubernetesClusterByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *Cluster200ResponseSchema
	ApplicationproblemJSON400 *ErrorResponseSchema
	ApplicationproblemJSON500 *ErrorResponseSchema
}

// Status returns HTTPResponse.Status
func (r GetKubernetesClusterByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKubernetesClusterByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKubeConfigResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *ErrorResponseSchema
	ApplicationproblemJSON500 *ErrorResponseSchema
}

// Status returns HTTPResponse.Status
func (r GetKubeConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKubeConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpgradeMastersResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON202                   *Operation202ResponseSchema
	ApplicationproblemJSON400 *ErrorResponseSchema
	ApplicationproblemJSON409 *ErrorResponseSchema
	ApplicationproblemJSON500 *ErrorResponseSchema
}

// Status returns HTTPResponse.Status
func (r UpgradeMastersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpgradeMastersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddNodesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON202                   *Operation202ResponseSchema
	ApplicationproblemJSON400 *ErrorResponseSchema
	ApplicationproblemJSON409 *ErrorResponseSchema
	ApplicationproblemJSON500 *ErrorResponseSchema
}

// Status returns HTTPResponse.Status
func (r AddNodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddNodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveNodesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON202                   *Operation202ResponseSchema
	ApplicationproblemJSON400 *ErrorResponseSchema
	ApplicationproblemJSON409 *ErrorResponseSchema
	ApplicationproblemJSON500 *ErrorResponseSchema
}

// Status returns HTTPResponse.Status
func (r RemoveNodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveNodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpgradeNodesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON202                   *Operation202ResponseSchema
	ApplicationproblemJSON400 *ErrorResponseSchema
	ApplicationproblemJSON409 *ErrorResponseSchema
	ApplicationproblemJSON500 *ErrorResponseSchema
}

// Status returns HTTPResponse.Status
func (r UpgradeNodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpgradeNodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListOperationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *OperationList200ResponseSchema
	ApplicationproblemJSON400 *ErrorResponseSchema
	ApplicationproblemJSON500 *ErrorResponseSchema
}

// Status returns HTTPResponse.Status
func (r ListOperationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListOperationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPrivateKeyResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *ErrorResponseSchema
	ApplicationproblemJSON500 *ErrorResponseSchema
}

// Status returns HTTPResponse.Status
func (r GetPrivateKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPrivateKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterStatusResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ClusterStatusResponseSchema
	ApplicationproblemJSON400 *ErrorResponseSchema
	ApplicationproblemJSON500 *ErrorResponseSchema
}

// Status returns HTTPResponse.Status
func (r GetClusterStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateNodesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON202                   *Operation202ResponseSchema
	ApplicationproblemJSON400 *ErrorResponseSchema
	ApplicationproblemJSON409 *ErrorResponseSchema
	ApplicationproblemJSON500 *ErrorResponseSchema
}

// Status returns HTTPResponse.Status
func (r UpdateNodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateNodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOperationByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *Operation200ResponseSchema
	ApplicationproblemJSON400 *ErrorResponseSchema
	ApplicationproblemJSON500 *ErrorResponseSchema
}

// Status returns HTTPResponse.Status
func (r GetOperationByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOperationByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListClustersResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ClustersResponseSchema
	ApplicationproblemJSON400 *Error400Schema
	ApplicationproblemJSON500 *Error500Schema
}

// Status returns HTTPResponse.Status
func (r ListClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClusterResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *ClusterCreateResponseSchema
	ApplicationproblemJSON400 *Error400Schema
	ApplicationproblemJSON500 *Error500Schema
}

// Status returns HTTPResponse.Status
func (r CreateClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClusterResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON202                   *ClusterDeleteResponseSchema
	ApplicationproblemJSON400 *Error400Schema
	ApplicationproblemJSON404 *Error404Schema
	ApplicationproblemJSON500 *Error500Schema
}

// Status returns HTTPResponse.Status
func (r DeleteClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ClusterGetResponseSchema
	ApplicationproblemJSON400 *Error400Schema
	ApplicationproblemJSON404 *Error404Schema
	ApplicationproblemJSON500 *Error500Schema
}

// Status returns HTTPResponse.Status
func (r GetClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateClusterResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ClusterGetResponseSchema
	ApplicationproblemJSON400 *Error400Schema
	ApplicationproblemJSON404 *Error404Schema
	ApplicationproblemJSON500 *Error500Schema
}

// Status returns HTTPResponse.Status
func (r UpdateClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListNodepoolsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *NodepoolsResponseSchema
	ApplicationproblemJSON400 *Error400Schema
	ApplicationproblemJSON500 *Error500Schema
}

// Status returns HTTPResponse.Status
func (r ListNodepoolsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListNodepoolsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNodePoolResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *NodepoolCreateResponseSchema
	ApplicationproblemJSON400 *Error400Schema
	ApplicationproblemJSON500 *Error500Schema
}

// Status returns HTTPResponse.Status
func (r CreateNodePoolResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNodePoolResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNodePoolResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON202                   *NodepoolDeleteResponseSchema
	ApplicationproblemJSON400 *Error400Schema
	ApplicationproblemJSON404 *Error404Schema
	ApplicationproblemJSON500 *Error500Schema
}

// Status returns HTTPResponse.Status
func (r DeleteNodePoolResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNodePoolResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateNodepoolResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON202                   *UpdateNodeCountResponseSchema
	ApplicationproblemJSON400 *Error400Schema
	ApplicationproblemJSON404 *Error404Schema
	ApplicationproblemJSON500 *Error500Schema
}

// Status returns HTTPResponse.Status
func (r UpdateNodepoolResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateNodepoolResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListOperationsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *OperationsResponseSchema
	ApplicationproblemJSON400 *Error400Schema
	ApplicationproblemJSON500 *Error500Schema
}

// Status returns HTTPResponse.Status
func (r ListOperationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListOperationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOperationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *OperationResponseSchema
	ApplicationproblemJSON400 *Error400Schema
	ApplicationproblemJSON404 *Error404Schema
	ApplicationproblemJSON500 *Error500Schema
}

// Status returns HTTPResponse.Status
func (r GetOperationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOperationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListVersionsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *VersionsResponseSchema
	ApplicationproblemJSON400 *Error400Schema
	ApplicationproblemJSON500 *Error500Schema
}

// Status returns HTTPResponse.Status
func (r ListVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSpacesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListSpaces200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ListSpacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSpacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *CreateSpace200ResponseSchema
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpaceByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetSpaceById200ResponseSchema
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSpaceByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpaceByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// DeleteLoadBalancerTagsWithBodyWithResponse request with arbitrary body returning *DeleteLoadBalancerTagsResponse
func (c *ClientWithResponses) DeleteLoadBalancerTagsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerTagsResponse, error) {
	rsp, err := c.DeleteLoadBalancerTagsWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLoadBalancerTagsResponse(rsp)
}

func (c *ClientWithResponses) DeleteLoadBalancerTagsWithResponse(ctx context.Context, spaceId SpaceId, body DeleteLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerTagsResponse, error) {
	rsp, err := c.DeleteLoadBalancerTags(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLoadBalancerTagsResponse(rsp)
}

// CreateLoadBalancerTagsWithBodyWithResponse request with arbitrary body returning *CreateLoadBalancerTagsResponse
func (c *ClientWithResponses) CreateLoadBalancerTagsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLoadBalancerTagsResponse, error) {
	rsp, err := c.CreateLoadBalancerTagsWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLoadBalancerTagsResponse(rsp)
}

func (c *ClientWithResponses) CreateLoadBalancerTagsWithResponse(ctx context.Context, spaceId SpaceId, body CreateLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLoadBalancerTagsResponse, error) {
	rsp, err := c.CreateLoadBalancerTags(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLoadBalancerTagsResponse(rsp)
}

// DeleteTagsWithBodyWithResponse request with arbitrary body returning *DeleteTagsResponse
func (c *ClientWithResponses) DeleteTagsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteTagsResponse, error) {
	rsp, err := c.DeleteTagsWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTagsResponse(rsp)
}

func (c *ClientWithResponses) DeleteTagsWithResponse(ctx context.Context, spaceId SpaceId, body DeleteTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteTagsResponse, error) {
	rsp, err := c.DeleteTags(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTagsResponse(rsp)
}

// CreateTagsWithBodyWithResponse request with arbitrary body returning *CreateTagsResponse
func (c *ClientWithResponses) CreateTagsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTagsResponse, error) {
	rsp, err := c.CreateTagsWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTagsResponse(rsp)
}

func (c *ClientWithResponses) CreateTagsWithResponse(ctx context.Context, spaceId SpaceId, body CreateTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTagsResponse, error) {
	rsp, err := c.CreateTags(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTagsResponse(rsp)
}

// ReadClientGatewaysWithResponse request returning *ReadClientGatewaysResponse
func (c *ClientWithResponses) ReadClientGatewaysWithResponse(ctx context.Context, spaceId SpaceId, params *ReadClientGatewaysParams, reqEditors ...RequestEditorFn) (*ReadClientGatewaysResponse, error) {
	rsp, err := c.ReadClientGateways(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadClientGatewaysResponse(rsp)
}

// CreateClientGatewayWithBodyWithResponse request with arbitrary body returning *CreateClientGatewayResponse
func (c *ClientWithResponses) CreateClientGatewayWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientGatewayResponse, error) {
	rsp, err := c.CreateClientGatewayWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientGatewayResponse(rsp)
}

func (c *ClientWithResponses) CreateClientGatewayWithResponse(ctx context.Context, spaceId SpaceId, body CreateClientGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientGatewayResponse, error) {
	rsp, err := c.CreateClientGateway(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientGatewayResponse(rsp)
}

// DeleteClientGatewayWithResponse request returning *DeleteClientGatewayResponse
func (c *ClientWithResponses) DeleteClientGatewayWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteClientGatewayResponse, error) {
	rsp, err := c.DeleteClientGateway(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClientGatewayResponse(rsp)
}

// ReadClientGatewaysByIdWithResponse request returning *ReadClientGatewaysByIdResponse
func (c *ClientWithResponses) ReadClientGatewaysByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadClientGatewaysByIdResponse, error) {
	rsp, err := c.ReadClientGatewaysById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadClientGatewaysByIdResponse(rsp)
}

// ReadDhcpOptionsWithResponse request returning *ReadDhcpOptionsResponse
func (c *ClientWithResponses) ReadDhcpOptionsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadDhcpOptionsParams, reqEditors ...RequestEditorFn) (*ReadDhcpOptionsResponse, error) {
	rsp, err := c.ReadDhcpOptions(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadDhcpOptionsResponse(rsp)
}

// CreateDhcpOptionsWithBodyWithResponse request with arbitrary body returning *CreateDhcpOptionsResponse
func (c *ClientWithResponses) CreateDhcpOptionsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDhcpOptionsResponse, error) {
	rsp, err := c.CreateDhcpOptionsWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDhcpOptionsResponse(rsp)
}

func (c *ClientWithResponses) CreateDhcpOptionsWithResponse(ctx context.Context, spaceId SpaceId, body CreateDhcpOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDhcpOptionsResponse, error) {
	rsp, err := c.CreateDhcpOptions(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDhcpOptionsResponse(rsp)
}

// DeleteDhcpOptionsWithResponse request returning *DeleteDhcpOptionsResponse
func (c *ClientWithResponses) DeleteDhcpOptionsWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteDhcpOptionsResponse, error) {
	rsp, err := c.DeleteDhcpOptions(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDhcpOptionsResponse(rsp)
}

// ReadDhcpOptionsByIdWithResponse request returning *ReadDhcpOptionsByIdResponse
func (c *ClientWithResponses) ReadDhcpOptionsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadDhcpOptionsByIdResponse, error) {
	rsp, err := c.ReadDhcpOptionsById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadDhcpOptionsByIdResponse(rsp)
}

// ReadFlexibleGpusWithResponse request returning *ReadFlexibleGpusResponse
func (c *ClientWithResponses) ReadFlexibleGpusWithResponse(ctx context.Context, spaceId SpaceId, params *ReadFlexibleGpusParams, reqEditors ...RequestEditorFn) (*ReadFlexibleGpusResponse, error) {
	rsp, err := c.ReadFlexibleGpus(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadFlexibleGpusResponse(rsp)
}

// CreateFlexibleGpuWithBodyWithResponse request with arbitrary body returning *CreateFlexibleGpuResponse
func (c *ClientWithResponses) CreateFlexibleGpuWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFlexibleGpuResponse, error) {
	rsp, err := c.CreateFlexibleGpuWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFlexibleGpuResponse(rsp)
}

func (c *ClientWithResponses) CreateFlexibleGpuWithResponse(ctx context.Context, spaceId SpaceId, body CreateFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFlexibleGpuResponse, error) {
	rsp, err := c.CreateFlexibleGpu(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFlexibleGpuResponse(rsp)
}

// DeleteFlexibleGpuWithResponse request returning *DeleteFlexibleGpuResponse
func (c *ClientWithResponses) DeleteFlexibleGpuWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteFlexibleGpuResponse, error) {
	rsp, err := c.DeleteFlexibleGpu(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFlexibleGpuResponse(rsp)
}

// ReadFlexibleGpusByIdWithResponse request returning *ReadFlexibleGpusByIdResponse
func (c *ClientWithResponses) ReadFlexibleGpusByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadFlexibleGpusByIdResponse, error) {
	rsp, err := c.ReadFlexibleGpusById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadFlexibleGpusByIdResponse(rsp)
}

// UpdateFlexibleGpuWithBodyWithResponse request with arbitrary body returning *UpdateFlexibleGpuResponse
func (c *ClientWithResponses) UpdateFlexibleGpuWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFlexibleGpuResponse, error) {
	rsp, err := c.UpdateFlexibleGpuWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFlexibleGpuResponse(rsp)
}

func (c *ClientWithResponses) UpdateFlexibleGpuWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFlexibleGpuResponse, error) {
	rsp, err := c.UpdateFlexibleGpu(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFlexibleGpuResponse(rsp)
}

// LinkFlexibleGpuWithBodyWithResponse request with arbitrary body returning *LinkFlexibleGpuResponse
func (c *ClientWithResponses) LinkFlexibleGpuWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkFlexibleGpuResponse, error) {
	rsp, err := c.LinkFlexibleGpuWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkFlexibleGpuResponse(rsp)
}

func (c *ClientWithResponses) LinkFlexibleGpuWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkFlexibleGpuResponse, error) {
	rsp, err := c.LinkFlexibleGpu(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkFlexibleGpuResponse(rsp)
}

// UnlinkFlexibleGpuWithResponse request returning *UnlinkFlexibleGpuResponse
func (c *ClientWithResponses) UnlinkFlexibleGpuWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*UnlinkFlexibleGpuResponse, error) {
	rsp, err := c.UnlinkFlexibleGpu(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkFlexibleGpuResponse(rsp)
}

// ReadImagesWithResponse request returning *ReadImagesResponse
func (c *ClientWithResponses) ReadImagesWithResponse(ctx context.Context, spaceId SpaceId, params *ReadImagesParams, reqEditors ...RequestEditorFn) (*ReadImagesResponse, error) {
	rsp, err := c.ReadImages(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadImagesResponse(rsp)
}

// CreateImageWithBodyWithResponse request with arbitrary body returning *CreateImageResponse
func (c *ClientWithResponses) CreateImageWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateImageResponse, error) {
	rsp, err := c.CreateImageWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateImageResponse(rsp)
}

func (c *ClientWithResponses) CreateImageWithResponse(ctx context.Context, spaceId SpaceId, body CreateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateImageResponse, error) {
	rsp, err := c.CreateImage(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateImageResponse(rsp)
}

// DeleteImageWithResponse request returning *DeleteImageResponse
func (c *ClientWithResponses) DeleteImageWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteImageResponse, error) {
	rsp, err := c.DeleteImage(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteImageResponse(rsp)
}

// ReadImagesByIdWithResponse request returning *ReadImagesByIdResponse
func (c *ClientWithResponses) ReadImagesByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadImagesByIdResponse, error) {
	rsp, err := c.ReadImagesById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadImagesByIdResponse(rsp)
}

// UpdateImageWithBodyWithResponse request with arbitrary body returning *UpdateImageResponse
func (c *ClientWithResponses) UpdateImageWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateImageResponse, error) {
	rsp, err := c.UpdateImageWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateImageResponse(rsp)
}

func (c *ClientWithResponses) UpdateImageWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateImageResponse, error) {
	rsp, err := c.UpdateImage(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateImageResponse(rsp)
}

// ReadInternetGatewaysWithResponse request returning *ReadInternetGatewaysResponse
func (c *ClientWithResponses) ReadInternetGatewaysWithResponse(ctx context.Context, spaceId SpaceId, params *ReadInternetGatewaysParams, reqEditors ...RequestEditorFn) (*ReadInternetGatewaysResponse, error) {
	rsp, err := c.ReadInternetGateways(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadInternetGatewaysResponse(rsp)
}

// CreateInternetGatewayWithResponse request returning *CreateInternetGatewayResponse
func (c *ClientWithResponses) CreateInternetGatewayWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*CreateInternetGatewayResponse, error) {
	rsp, err := c.CreateInternetGateway(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateInternetGatewayResponse(rsp)
}

// DeleteInternetGatewayWithResponse request returning *DeleteInternetGatewayResponse
func (c *ClientWithResponses) DeleteInternetGatewayWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteInternetGatewayResponse, error) {
	rsp, err := c.DeleteInternetGateway(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInternetGatewayResponse(rsp)
}

// ReadInternetGatewaysByIdWithResponse request returning *ReadInternetGatewaysByIdResponse
func (c *ClientWithResponses) ReadInternetGatewaysByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadInternetGatewaysByIdResponse, error) {
	rsp, err := c.ReadInternetGatewaysById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadInternetGatewaysByIdResponse(rsp)
}

// LinkInternetGatewayWithBodyWithResponse request with arbitrary body returning *LinkInternetGatewayResponse
func (c *ClientWithResponses) LinkInternetGatewayWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkInternetGatewayResponse, error) {
	rsp, err := c.LinkInternetGatewayWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkInternetGatewayResponse(rsp)
}

func (c *ClientWithResponses) LinkInternetGatewayWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkInternetGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkInternetGatewayResponse, error) {
	rsp, err := c.LinkInternetGateway(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkInternetGatewayResponse(rsp)
}

// UnlinkInternetGatewayWithBodyWithResponse request with arbitrary body returning *UnlinkInternetGatewayResponse
func (c *ClientWithResponses) UnlinkInternetGatewayWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkInternetGatewayResponse, error) {
	rsp, err := c.UnlinkInternetGatewayWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkInternetGatewayResponse(rsp)
}

func (c *ClientWithResponses) UnlinkInternetGatewayWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkInternetGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkInternetGatewayResponse, error) {
	rsp, err := c.UnlinkInternetGateway(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkInternetGatewayResponse(rsp)
}

// ReadKeypairsWithResponse request returning *ReadKeypairsResponse
func (c *ClientWithResponses) ReadKeypairsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadKeypairsParams, reqEditors ...RequestEditorFn) (*ReadKeypairsResponse, error) {
	rsp, err := c.ReadKeypairs(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadKeypairsResponse(rsp)
}

// CreateKeypairWithBodyWithResponse request with arbitrary body returning *CreateKeypairResponse
func (c *ClientWithResponses) CreateKeypairWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeypairResponse, error) {
	rsp, err := c.CreateKeypairWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeypairResponse(rsp)
}

func (c *ClientWithResponses) CreateKeypairWithResponse(ctx context.Context, spaceId SpaceId, body CreateKeypairJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeypairResponse, error) {
	rsp, err := c.CreateKeypair(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeypairResponse(rsp)
}

// DeleteKeypairWithResponse request returning *DeleteKeypairResponse
func (c *ClientWithResponses) DeleteKeypairWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteKeypairResponse, error) {
	rsp, err := c.DeleteKeypair(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteKeypairResponse(rsp)
}

// ReadKeypairsByIdWithResponse request returning *ReadKeypairsByIdResponse
func (c *ClientWithResponses) ReadKeypairsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadKeypairsByIdResponse, error) {
	rsp, err := c.ReadKeypairsById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadKeypairsByIdResponse(rsp)
}

// ReadListenerRulesWithResponse request returning *ReadListenerRulesResponse
func (c *ClientWithResponses) ReadListenerRulesWithResponse(ctx context.Context, spaceId SpaceId, params *ReadListenerRulesParams, reqEditors ...RequestEditorFn) (*ReadListenerRulesResponse, error) {
	rsp, err := c.ReadListenerRules(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadListenerRulesResponse(rsp)
}

// CreateListenerRuleWithBodyWithResponse request with arbitrary body returning *CreateListenerRuleResponse
func (c *ClientWithResponses) CreateListenerRuleWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateListenerRuleResponse, error) {
	rsp, err := c.CreateListenerRuleWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateListenerRuleResponse(rsp)
}

func (c *ClientWithResponses) CreateListenerRuleWithResponse(ctx context.Context, spaceId SpaceId, body CreateListenerRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateListenerRuleResponse, error) {
	rsp, err := c.CreateListenerRule(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateListenerRuleResponse(rsp)
}

// DeleteListenerRuleWithResponse request returning *DeleteListenerRuleResponse
func (c *ClientWithResponses) DeleteListenerRuleWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteListenerRuleResponse, error) {
	rsp, err := c.DeleteListenerRule(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteListenerRuleResponse(rsp)
}

// ReadListenerRulesByIdWithResponse request returning *ReadListenerRulesByIdResponse
func (c *ClientWithResponses) ReadListenerRulesByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadListenerRulesByIdResponse, error) {
	rsp, err := c.ReadListenerRulesById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadListenerRulesByIdResponse(rsp)
}

// UpdateListenerRuleWithBodyWithResponse request with arbitrary body returning *UpdateListenerRuleResponse
func (c *ClientWithResponses) UpdateListenerRuleWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateListenerRuleResponse, error) {
	rsp, err := c.UpdateListenerRuleWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateListenerRuleResponse(rsp)
}

func (c *ClientWithResponses) UpdateListenerRuleWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateListenerRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateListenerRuleResponse, error) {
	rsp, err := c.UpdateListenerRule(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateListenerRuleResponse(rsp)
}

// ReadLoadBalancersWithResponse request returning *ReadLoadBalancersResponse
func (c *ClientWithResponses) ReadLoadBalancersWithResponse(ctx context.Context, spaceId SpaceId, params *ReadLoadBalancersParams, reqEditors ...RequestEditorFn) (*ReadLoadBalancersResponse, error) {
	rsp, err := c.ReadLoadBalancers(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadLoadBalancersResponse(rsp)
}

// CreateLoadBalancerWithBodyWithResponse request with arbitrary body returning *CreateLoadBalancerResponse
func (c *ClientWithResponses) CreateLoadBalancerWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLoadBalancerResponse, error) {
	rsp, err := c.CreateLoadBalancerWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLoadBalancerResponse(rsp)
}

func (c *ClientWithResponses) CreateLoadBalancerWithResponse(ctx context.Context, spaceId SpaceId, body CreateLoadBalancerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLoadBalancerResponse, error) {
	rsp, err := c.CreateLoadBalancer(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLoadBalancerResponse(rsp)
}

// DeleteLoadBalancerWithResponse request returning *DeleteLoadBalancerResponse
func (c *ClientWithResponses) DeleteLoadBalancerWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerResponse, error) {
	rsp, err := c.DeleteLoadBalancer(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLoadBalancerResponse(rsp)
}

// ReadLoadBalancersByIdWithResponse request returning *ReadLoadBalancersByIdResponse
func (c *ClientWithResponses) ReadLoadBalancersByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadLoadBalancersByIdResponse, error) {
	rsp, err := c.ReadLoadBalancersById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadLoadBalancersByIdResponse(rsp)
}

// UpdateLoadBalancerWithBodyWithResponse request with arbitrary body returning *UpdateLoadBalancerResponse
func (c *ClientWithResponses) UpdateLoadBalancerWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLoadBalancerResponse, error) {
	rsp, err := c.UpdateLoadBalancerWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLoadBalancerResponse(rsp)
}

func (c *ClientWithResponses) UpdateLoadBalancerWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateLoadBalancerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLoadBalancerResponse, error) {
	rsp, err := c.UpdateLoadBalancer(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLoadBalancerResponse(rsp)
}

// LinkLoadBalancerBackendMachinesWithBodyWithResponse request with arbitrary body returning *LinkLoadBalancerBackendMachinesResponse
func (c *ClientWithResponses) LinkLoadBalancerBackendMachinesWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkLoadBalancerBackendMachinesResponse, error) {
	rsp, err := c.LinkLoadBalancerBackendMachinesWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkLoadBalancerBackendMachinesResponse(rsp)
}

func (c *ClientWithResponses) LinkLoadBalancerBackendMachinesWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkLoadBalancerBackendMachinesJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkLoadBalancerBackendMachinesResponse, error) {
	rsp, err := c.LinkLoadBalancerBackendMachines(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkLoadBalancerBackendMachinesResponse(rsp)
}

// UnlinkLoadBalancerBackendMachinesWithBodyWithResponse request with arbitrary body returning *UnlinkLoadBalancerBackendMachinesResponse
func (c *ClientWithResponses) UnlinkLoadBalancerBackendMachinesWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkLoadBalancerBackendMachinesResponse, error) {
	rsp, err := c.UnlinkLoadBalancerBackendMachinesWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkLoadBalancerBackendMachinesResponse(rsp)
}

func (c *ClientWithResponses) UnlinkLoadBalancerBackendMachinesWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkLoadBalancerBackendMachinesJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkLoadBalancerBackendMachinesResponse, error) {
	rsp, err := c.UnlinkLoadBalancerBackendMachines(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkLoadBalancerBackendMachinesResponse(rsp)
}

// DeleteLoadBalancerListenersWithBodyWithResponse request with arbitrary body returning *DeleteLoadBalancerListenersResponse
func (c *ClientWithResponses) DeleteLoadBalancerListenersWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerListenersResponse, error) {
	rsp, err := c.DeleteLoadBalancerListenersWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLoadBalancerListenersResponse(rsp)
}

func (c *ClientWithResponses) DeleteLoadBalancerListenersWithResponse(ctx context.Context, spaceId SpaceId, id string, body DeleteLoadBalancerListenersJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerListenersResponse, error) {
	rsp, err := c.DeleteLoadBalancerListeners(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLoadBalancerListenersResponse(rsp)
}

// CreateLoadBalancerListenersWithBodyWithResponse request with arbitrary body returning *CreateLoadBalancerListenersResponse
func (c *ClientWithResponses) CreateLoadBalancerListenersWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLoadBalancerListenersResponse, error) {
	rsp, err := c.CreateLoadBalancerListenersWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLoadBalancerListenersResponse(rsp)
}

func (c *ClientWithResponses) CreateLoadBalancerListenersWithResponse(ctx context.Context, spaceId SpaceId, id string, body CreateLoadBalancerListenersJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLoadBalancerListenersResponse, error) {
	rsp, err := c.CreateLoadBalancerListeners(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLoadBalancerListenersResponse(rsp)
}

// DeleteLoadBalancerPolicyWithBodyWithResponse request with arbitrary body returning *DeleteLoadBalancerPolicyResponse
func (c *ClientWithResponses) DeleteLoadBalancerPolicyWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerPolicyResponse, error) {
	rsp, err := c.DeleteLoadBalancerPolicyWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLoadBalancerPolicyResponse(rsp)
}

func (c *ClientWithResponses) DeleteLoadBalancerPolicyWithResponse(ctx context.Context, spaceId SpaceId, id string, body DeleteLoadBalancerPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerPolicyResponse, error) {
	rsp, err := c.DeleteLoadBalancerPolicy(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLoadBalancerPolicyResponse(rsp)
}

// CreateLoadBalancerPolicyWithBodyWithResponse request with arbitrary body returning *CreateLoadBalancerPolicyResponse
func (c *ClientWithResponses) CreateLoadBalancerPolicyWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLoadBalancerPolicyResponse, error) {
	rsp, err := c.CreateLoadBalancerPolicyWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLoadBalancerPolicyResponse(rsp)
}

func (c *ClientWithResponses) CreateLoadBalancerPolicyWithResponse(ctx context.Context, spaceId SpaceId, id string, body CreateLoadBalancerPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLoadBalancerPolicyResponse, error) {
	rsp, err := c.CreateLoadBalancerPolicy(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLoadBalancerPolicyResponse(rsp)
}

// ReadVmsHealthWithBodyWithResponse request with arbitrary body returning *ReadVmsHealthResponse
func (c *ClientWithResponses) ReadVmsHealthWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReadVmsHealthResponse, error) {
	rsp, err := c.ReadVmsHealthWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVmsHealthResponse(rsp)
}

func (c *ClientWithResponses) ReadVmsHealthWithResponse(ctx context.Context, spaceId SpaceId, id string, body ReadVmsHealthJSONRequestBody, reqEditors ...RequestEditorFn) (*ReadVmsHealthResponse, error) {
	rsp, err := c.ReadVmsHealth(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVmsHealthResponse(rsp)
}

// ReadLoadBalancerTagsWithBodyWithResponse request with arbitrary body returning *ReadLoadBalancerTagsResponse
func (c *ClientWithResponses) ReadLoadBalancerTagsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReadLoadBalancerTagsResponse, error) {
	rsp, err := c.ReadLoadBalancerTagsWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadLoadBalancerTagsResponse(rsp)
}

func (c *ClientWithResponses) ReadLoadBalancerTagsWithResponse(ctx context.Context, spaceId SpaceId, body ReadLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReadLoadBalancerTagsResponse, error) {
	rsp, err := c.ReadLoadBalancerTags(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadLoadBalancerTagsResponse(rsp)
}

// ReadNatGatewayWithResponse request returning *ReadNatGatewayResponse
func (c *ClientWithResponses) ReadNatGatewayWithResponse(ctx context.Context, spaceId SpaceId, params *ReadNatGatewayParams, reqEditors ...RequestEditorFn) (*ReadNatGatewayResponse, error) {
	rsp, err := c.ReadNatGateway(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadNatGatewayResponse(rsp)
}

// CreateNatGatewayWithBodyWithResponse request with arbitrary body returning *CreateNatGatewayResponse
func (c *ClientWithResponses) CreateNatGatewayWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNatGatewayResponse, error) {
	rsp, err := c.CreateNatGatewayWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNatGatewayResponse(rsp)
}

func (c *ClientWithResponses) CreateNatGatewayWithResponse(ctx context.Context, spaceId SpaceId, body CreateNatGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNatGatewayResponse, error) {
	rsp, err := c.CreateNatGateway(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNatGatewayResponse(rsp)
}

// DeleteNatGatewayWithResponse request returning *DeleteNatGatewayResponse
func (c *ClientWithResponses) DeleteNatGatewayWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteNatGatewayResponse, error) {
	rsp, err := c.DeleteNatGateway(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNatGatewayResponse(rsp)
}

// ReadNatGatewayByIdWithResponse request returning *ReadNatGatewayByIdResponse
func (c *ClientWithResponses) ReadNatGatewayByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadNatGatewayByIdResponse, error) {
	rsp, err := c.ReadNatGatewayById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadNatGatewayByIdResponse(rsp)
}

// ReadNicsWithResponse request returning *ReadNicsResponse
func (c *ClientWithResponses) ReadNicsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadNicsParams, reqEditors ...RequestEditorFn) (*ReadNicsResponse, error) {
	rsp, err := c.ReadNics(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadNicsResponse(rsp)
}

// CreateNicWithBodyWithResponse request with arbitrary body returning *CreateNicResponse
func (c *ClientWithResponses) CreateNicWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNicResponse, error) {
	rsp, err := c.CreateNicWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNicResponse(rsp)
}

func (c *ClientWithResponses) CreateNicWithResponse(ctx context.Context, spaceId SpaceId, body CreateNicJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNicResponse, error) {
	rsp, err := c.CreateNic(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNicResponse(rsp)
}

// DeleteNicWithResponse request returning *DeleteNicResponse
func (c *ClientWithResponses) DeleteNicWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteNicResponse, error) {
	rsp, err := c.DeleteNic(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNicResponse(rsp)
}

// ReadNicsByIdWithResponse request returning *ReadNicsByIdResponse
func (c *ClientWithResponses) ReadNicsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadNicsByIdResponse, error) {
	rsp, err := c.ReadNicsById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadNicsByIdResponse(rsp)
}

// UpdateNicWithBodyWithResponse request with arbitrary body returning *UpdateNicResponse
func (c *ClientWithResponses) UpdateNicWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNicResponse, error) {
	rsp, err := c.UpdateNicWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNicResponse(rsp)
}

func (c *ClientWithResponses) UpdateNicWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateNicJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNicResponse, error) {
	rsp, err := c.UpdateNic(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNicResponse(rsp)
}

// LinkPrivateIpsWithBodyWithResponse request with arbitrary body returning *LinkPrivateIpsResponse
func (c *ClientWithResponses) LinkPrivateIpsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkPrivateIpsResponse, error) {
	rsp, err := c.LinkPrivateIpsWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkPrivateIpsResponse(rsp)
}

func (c *ClientWithResponses) LinkPrivateIpsWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkPrivateIpsJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkPrivateIpsResponse, error) {
	rsp, err := c.LinkPrivateIps(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkPrivateIpsResponse(rsp)
}

// UnlinkPrivateIpsWithBodyWithResponse request with arbitrary body returning *UnlinkPrivateIpsResponse
func (c *ClientWithResponses) UnlinkPrivateIpsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkPrivateIpsResponse, error) {
	rsp, err := c.UnlinkPrivateIpsWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkPrivateIpsResponse(rsp)
}

func (c *ClientWithResponses) UnlinkPrivateIpsWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkPrivateIpsJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkPrivateIpsResponse, error) {
	rsp, err := c.UnlinkPrivateIps(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkPrivateIpsResponse(rsp)
}

// LinkNicWithBodyWithResponse request with arbitrary body returning *LinkNicResponse
func (c *ClientWithResponses) LinkNicWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkNicResponse, error) {
	rsp, err := c.LinkNicWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkNicResponse(rsp)
}

func (c *ClientWithResponses) LinkNicWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkNicJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkNicResponse, error) {
	rsp, err := c.LinkNic(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkNicResponse(rsp)
}

// UnlinkNicWithBodyWithResponse request with arbitrary body returning *UnlinkNicResponse
func (c *ClientWithResponses) UnlinkNicWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkNicResponse, error) {
	rsp, err := c.UnlinkNicWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkNicResponse(rsp)
}

func (c *ClientWithResponses) UnlinkNicWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkNicJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkNicResponse, error) {
	rsp, err := c.UnlinkNic(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkNicResponse(rsp)
}

// ReadPublicIpRangesWithResponse request returning *ReadPublicIpRangesResponse
func (c *ClientWithResponses) ReadPublicIpRangesWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*ReadPublicIpRangesResponse, error) {
	rsp, err := c.ReadPublicIpRanges(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadPublicIpRangesResponse(rsp)
}

// ReadPublicIpsWithResponse request returning *ReadPublicIpsResponse
func (c *ClientWithResponses) ReadPublicIpsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadPublicIpsParams, reqEditors ...RequestEditorFn) (*ReadPublicIpsResponse, error) {
	rsp, err := c.ReadPublicIps(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadPublicIpsResponse(rsp)
}

// CreatePublicIpWithResponse request returning *CreatePublicIpResponse
func (c *ClientWithResponses) CreatePublicIpWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*CreatePublicIpResponse, error) {
	rsp, err := c.CreatePublicIp(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePublicIpResponse(rsp)
}

// DeletePublicIpWithResponse request returning *DeletePublicIpResponse
func (c *ClientWithResponses) DeletePublicIpWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeletePublicIpResponse, error) {
	rsp, err := c.DeletePublicIp(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePublicIpResponse(rsp)
}

// ReadPublicIpsByIdWithResponse request returning *ReadPublicIpsByIdResponse
func (c *ClientWithResponses) ReadPublicIpsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadPublicIpsByIdResponse, error) {
	rsp, err := c.ReadPublicIpsById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadPublicIpsByIdResponse(rsp)
}

// LinkPublicIpWithBodyWithResponse request with arbitrary body returning *LinkPublicIpResponse
func (c *ClientWithResponses) LinkPublicIpWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkPublicIpResponse, error) {
	rsp, err := c.LinkPublicIpWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkPublicIpResponse(rsp)
}

func (c *ClientWithResponses) LinkPublicIpWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkPublicIpJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkPublicIpResponse, error) {
	rsp, err := c.LinkPublicIp(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkPublicIpResponse(rsp)
}

// UnlinkPublicIpWithBodyWithResponse request with arbitrary body returning *UnlinkPublicIpResponse
func (c *ClientWithResponses) UnlinkPublicIpWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkPublicIpResponse, error) {
	rsp, err := c.UnlinkPublicIpWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkPublicIpResponse(rsp)
}

func (c *ClientWithResponses) UnlinkPublicIpWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkPublicIpJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkPublicIpResponse, error) {
	rsp, err := c.UnlinkPublicIp(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkPublicIpResponse(rsp)
}

// ReadRouteTablesWithResponse request returning *ReadRouteTablesResponse
func (c *ClientWithResponses) ReadRouteTablesWithResponse(ctx context.Context, spaceId SpaceId, params *ReadRouteTablesParams, reqEditors ...RequestEditorFn) (*ReadRouteTablesResponse, error) {
	rsp, err := c.ReadRouteTables(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadRouteTablesResponse(rsp)
}

// CreateRouteTableWithBodyWithResponse request with arbitrary body returning *CreateRouteTableResponse
func (c *ClientWithResponses) CreateRouteTableWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRouteTableResponse, error) {
	rsp, err := c.CreateRouteTableWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRouteTableResponse(rsp)
}

func (c *ClientWithResponses) CreateRouteTableWithResponse(ctx context.Context, spaceId SpaceId, body CreateRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRouteTableResponse, error) {
	rsp, err := c.CreateRouteTable(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRouteTableResponse(rsp)
}

// DeleteRouteTableWithResponse request returning *DeleteRouteTableResponse
func (c *ClientWithResponses) DeleteRouteTableWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteRouteTableResponse, error) {
	rsp, err := c.DeleteRouteTable(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRouteTableResponse(rsp)
}

// ReadRouteTablesByIdWithResponse request returning *ReadRouteTablesByIdResponse
func (c *ClientWithResponses) ReadRouteTablesByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadRouteTablesByIdResponse, error) {
	rsp, err := c.ReadRouteTablesById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadRouteTablesByIdResponse(rsp)
}

// UpdateRouteTableRoutePropagationWithBodyWithResponse request with arbitrary body returning *UpdateRouteTableRoutePropagationResponse
func (c *ClientWithResponses) UpdateRouteTableRoutePropagationWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRouteTableRoutePropagationResponse, error) {
	rsp, err := c.UpdateRouteTableRoutePropagationWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRouteTableRoutePropagationResponse(rsp)
}

func (c *ClientWithResponses) UpdateRouteTableRoutePropagationWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateRouteTableRoutePropagationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRouteTableRoutePropagationResponse, error) {
	rsp, err := c.UpdateRouteTableRoutePropagation(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRouteTableRoutePropagationResponse(rsp)
}

// DeleteRouteWithBodyWithResponse request with arbitrary body returning *DeleteRouteResponse
func (c *ClientWithResponses) DeleteRouteWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteRouteResponse, error) {
	rsp, err := c.DeleteRouteWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRouteResponse(rsp)
}

func (c *ClientWithResponses) DeleteRouteWithResponse(ctx context.Context, spaceId SpaceId, id string, body DeleteRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteRouteResponse, error) {
	rsp, err := c.DeleteRoute(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRouteResponse(rsp)
}

// CreateRouteWithBodyWithResponse request with arbitrary body returning *CreateRouteResponse
func (c *ClientWithResponses) CreateRouteWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRouteResponse, error) {
	rsp, err := c.CreateRouteWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRouteResponse(rsp)
}

func (c *ClientWithResponses) CreateRouteWithResponse(ctx context.Context, spaceId SpaceId, id string, body CreateRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRouteResponse, error) {
	rsp, err := c.CreateRoute(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRouteResponse(rsp)
}

// UpdateRouteWithBodyWithResponse request with arbitrary body returning *UpdateRouteResponse
func (c *ClientWithResponses) UpdateRouteWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRouteResponse, error) {
	rsp, err := c.UpdateRouteWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRouteResponse(rsp)
}

func (c *ClientWithResponses) UpdateRouteWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRouteResponse, error) {
	rsp, err := c.UpdateRoute(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRouteResponse(rsp)
}

// LinkRouteTableWithBodyWithResponse request with arbitrary body returning *LinkRouteTableResponse
func (c *ClientWithResponses) LinkRouteTableWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkRouteTableResponse, error) {
	rsp, err := c.LinkRouteTableWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkRouteTableResponse(rsp)
}

func (c *ClientWithResponses) LinkRouteTableWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkRouteTableResponse, error) {
	rsp, err := c.LinkRouteTable(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkRouteTableResponse(rsp)
}

// UnlinkRouteTableWithBodyWithResponse request with arbitrary body returning *UnlinkRouteTableResponse
func (c *ClientWithResponses) UnlinkRouteTableWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkRouteTableResponse, error) {
	rsp, err := c.UnlinkRouteTableWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkRouteTableResponse(rsp)
}

func (c *ClientWithResponses) UnlinkRouteTableWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkRouteTableResponse, error) {
	rsp, err := c.UnlinkRouteTable(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkRouteTableResponse(rsp)
}

// ReadSecurityGroupsWithResponse request returning *ReadSecurityGroupsResponse
func (c *ClientWithResponses) ReadSecurityGroupsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadSecurityGroupsParams, reqEditors ...RequestEditorFn) (*ReadSecurityGroupsResponse, error) {
	rsp, err := c.ReadSecurityGroups(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadSecurityGroupsResponse(rsp)
}

// CreateSecurityGroupWithBodyWithResponse request with arbitrary body returning *CreateSecurityGroupResponse
func (c *ClientWithResponses) CreateSecurityGroupWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSecurityGroupResponse, error) {
	rsp, err := c.CreateSecurityGroupWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSecurityGroupResponse(rsp)
}

func (c *ClientWithResponses) CreateSecurityGroupWithResponse(ctx context.Context, spaceId SpaceId, body CreateSecurityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSecurityGroupResponse, error) {
	rsp, err := c.CreateSecurityGroup(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSecurityGroupResponse(rsp)
}

// DeleteSecurityGroupWithResponse request returning *DeleteSecurityGroupResponse
func (c *ClientWithResponses) DeleteSecurityGroupWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteSecurityGroupResponse, error) {
	rsp, err := c.DeleteSecurityGroup(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSecurityGroupResponse(rsp)
}

// ReadSecurityGroupsByIdWithResponse request returning *ReadSecurityGroupsByIdResponse
func (c *ClientWithResponses) ReadSecurityGroupsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadSecurityGroupsByIdResponse, error) {
	rsp, err := c.ReadSecurityGroupsById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadSecurityGroupsByIdResponse(rsp)
}

// DeleteSecurityGroupRuleWithBodyWithResponse request with arbitrary body returning *DeleteSecurityGroupRuleResponse
func (c *ClientWithResponses) DeleteSecurityGroupRuleWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteSecurityGroupRuleResponse, error) {
	rsp, err := c.DeleteSecurityGroupRuleWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSecurityGroupRuleResponse(rsp)
}

func (c *ClientWithResponses) DeleteSecurityGroupRuleWithResponse(ctx context.Context, spaceId SpaceId, id string, body DeleteSecurityGroupRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteSecurityGroupRuleResponse, error) {
	rsp, err := c.DeleteSecurityGroupRule(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSecurityGroupRuleResponse(rsp)
}

// CreateSecurityGroupRuleWithBodyWithResponse request with arbitrary body returning *CreateSecurityGroupRuleResponse
func (c *ClientWithResponses) CreateSecurityGroupRuleWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSecurityGroupRuleResponse, error) {
	rsp, err := c.CreateSecurityGroupRuleWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSecurityGroupRuleResponse(rsp)
}

func (c *ClientWithResponses) CreateSecurityGroupRuleWithResponse(ctx context.Context, spaceId SpaceId, id string, body CreateSecurityGroupRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSecurityGroupRuleResponse, error) {
	rsp, err := c.CreateSecurityGroupRule(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSecurityGroupRuleResponse(rsp)
}

// ReadServerCertificatesWithResponse request returning *ReadServerCertificatesResponse
func (c *ClientWithResponses) ReadServerCertificatesWithResponse(ctx context.Context, spaceId SpaceId, params *ReadServerCertificatesParams, reqEditors ...RequestEditorFn) (*ReadServerCertificatesResponse, error) {
	rsp, err := c.ReadServerCertificates(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadServerCertificatesResponse(rsp)
}

// CreateServerCertificateWithBodyWithResponse request with arbitrary body returning *CreateServerCertificateResponse
func (c *ClientWithResponses) CreateServerCertificateWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServerCertificateResponse, error) {
	rsp, err := c.CreateServerCertificateWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServerCertificateResponse(rsp)
}

func (c *ClientWithResponses) CreateServerCertificateWithResponse(ctx context.Context, spaceId SpaceId, body CreateServerCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServerCertificateResponse, error) {
	rsp, err := c.CreateServerCertificate(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServerCertificateResponse(rsp)
}

// DeleteServerCertificateWithResponse request returning *DeleteServerCertificateResponse
func (c *ClientWithResponses) DeleteServerCertificateWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteServerCertificateResponse, error) {
	rsp, err := c.DeleteServerCertificate(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServerCertificateResponse(rsp)
}

// UpdateServerCertificateWithBodyWithResponse request with arbitrary body returning *UpdateServerCertificateResponse
func (c *ClientWithResponses) UpdateServerCertificateWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServerCertificateResponse, error) {
	rsp, err := c.UpdateServerCertificateWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServerCertificateResponse(rsp)
}

func (c *ClientWithResponses) UpdateServerCertificateWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateServerCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServerCertificateResponse, error) {
	rsp, err := c.UpdateServerCertificate(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServerCertificateResponse(rsp)
}

// ReadSnapshotsWithResponse request returning *ReadSnapshotsResponse
func (c *ClientWithResponses) ReadSnapshotsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadSnapshotsParams, reqEditors ...RequestEditorFn) (*ReadSnapshotsResponse, error) {
	rsp, err := c.ReadSnapshots(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadSnapshotsResponse(rsp)
}

// CreateSnapshotWithBodyWithResponse request with arbitrary body returning *CreateSnapshotResponse
func (c *ClientWithResponses) CreateSnapshotWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSnapshotResponse, error) {
	rsp, err := c.CreateSnapshotWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSnapshotResponse(rsp)
}

func (c *ClientWithResponses) CreateSnapshotWithResponse(ctx context.Context, spaceId SpaceId, body CreateSnapshotJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSnapshotResponse, error) {
	rsp, err := c.CreateSnapshot(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSnapshotResponse(rsp)
}

// DeleteSnapshotWithResponse request returning *DeleteSnapshotResponse
func (c *ClientWithResponses) DeleteSnapshotWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteSnapshotResponse, error) {
	rsp, err := c.DeleteSnapshot(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSnapshotResponse(rsp)
}

// ReadSnapshotsByIdWithResponse request returning *ReadSnapshotsByIdResponse
func (c *ClientWithResponses) ReadSnapshotsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadSnapshotsByIdResponse, error) {
	rsp, err := c.ReadSnapshotsById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadSnapshotsByIdResponse(rsp)
}

// ReadSubnetsWithResponse request returning *ReadSubnetsResponse
func (c *ClientWithResponses) ReadSubnetsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadSubnetsParams, reqEditors ...RequestEditorFn) (*ReadSubnetsResponse, error) {
	rsp, err := c.ReadSubnets(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadSubnetsResponse(rsp)
}

// CreateSubnetWithBodyWithResponse request with arbitrary body returning *CreateSubnetResponse
func (c *ClientWithResponses) CreateSubnetWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSubnetResponse, error) {
	rsp, err := c.CreateSubnetWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSubnetResponse(rsp)
}

func (c *ClientWithResponses) CreateSubnetWithResponse(ctx context.Context, spaceId SpaceId, body CreateSubnetJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSubnetResponse, error) {
	rsp, err := c.CreateSubnet(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSubnetResponse(rsp)
}

// DeleteSubnetWithResponse request returning *DeleteSubnetResponse
func (c *ClientWithResponses) DeleteSubnetWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteSubnetResponse, error) {
	rsp, err := c.DeleteSubnet(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSubnetResponse(rsp)
}

// ReadSubnetsByIdWithResponse request returning *ReadSubnetsByIdResponse
func (c *ClientWithResponses) ReadSubnetsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadSubnetsByIdResponse, error) {
	rsp, err := c.ReadSubnetsById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadSubnetsByIdResponse(rsp)
}

// UpdateSubnetWithBodyWithResponse request with arbitrary body returning *UpdateSubnetResponse
func (c *ClientWithResponses) UpdateSubnetWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSubnetResponse, error) {
	rsp, err := c.UpdateSubnetWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSubnetResponse(rsp)
}

func (c *ClientWithResponses) UpdateSubnetWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateSubnetJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSubnetResponse, error) {
	rsp, err := c.UpdateSubnet(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSubnetResponse(rsp)
}

// ReadTagsWithResponse request returning *ReadTagsResponse
func (c *ClientWithResponses) ReadTagsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadTagsParams, reqEditors ...RequestEditorFn) (*ReadTagsResponse, error) {
	rsp, err := c.ReadTags(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadTagsResponse(rsp)
}

// ReadVirtualGatewaysWithResponse request returning *ReadVirtualGatewaysResponse
func (c *ClientWithResponses) ReadVirtualGatewaysWithResponse(ctx context.Context, spaceId SpaceId, params *ReadVirtualGatewaysParams, reqEditors ...RequestEditorFn) (*ReadVirtualGatewaysResponse, error) {
	rsp, err := c.ReadVirtualGateways(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVirtualGatewaysResponse(rsp)
}

// CreateVirtualGatewayWithBodyWithResponse request with arbitrary body returning *CreateVirtualGatewayResponse
func (c *ClientWithResponses) CreateVirtualGatewayWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVirtualGatewayResponse, error) {
	rsp, err := c.CreateVirtualGatewayWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVirtualGatewayResponse(rsp)
}

func (c *ClientWithResponses) CreateVirtualGatewayWithResponse(ctx context.Context, spaceId SpaceId, body CreateVirtualGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVirtualGatewayResponse, error) {
	rsp, err := c.CreateVirtualGateway(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVirtualGatewayResponse(rsp)
}

// DeleteVirtualGatewayWithResponse request returning *DeleteVirtualGatewayResponse
func (c *ClientWithResponses) DeleteVirtualGatewayWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteVirtualGatewayResponse, error) {
	rsp, err := c.DeleteVirtualGateway(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVirtualGatewayResponse(rsp)
}

// ReadVirtualGatewaysByIdWithResponse request returning *ReadVirtualGatewaysByIdResponse
func (c *ClientWithResponses) ReadVirtualGatewaysByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadVirtualGatewaysByIdResponse, error) {
	rsp, err := c.ReadVirtualGatewaysById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVirtualGatewaysByIdResponse(rsp)
}

// LinkVirtualGatewayToVpcWithBodyWithResponse request with arbitrary body returning *LinkVirtualGatewayToVpcResponse
func (c *ClientWithResponses) LinkVirtualGatewayToVpcWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkVirtualGatewayToVpcResponse, error) {
	rsp, err := c.LinkVirtualGatewayToVpcWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkVirtualGatewayToVpcResponse(rsp)
}

func (c *ClientWithResponses) LinkVirtualGatewayToVpcWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkVirtualGatewayToVpcJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkVirtualGatewayToVpcResponse, error) {
	rsp, err := c.LinkVirtualGatewayToVpc(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkVirtualGatewayToVpcResponse(rsp)
}

// UnlinkVirtualGatewayToVpcWithBodyWithResponse request with arbitrary body returning *UnlinkVirtualGatewayToVpcResponse
func (c *ClientWithResponses) UnlinkVirtualGatewayToVpcWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkVirtualGatewayToVpcResponse, error) {
	rsp, err := c.UnlinkVirtualGatewayToVpcWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkVirtualGatewayToVpcResponse(rsp)
}

func (c *ClientWithResponses) UnlinkVirtualGatewayToVpcWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkVirtualGatewayToVpcJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkVirtualGatewayToVpcResponse, error) {
	rsp, err := c.UnlinkVirtualGatewayToVpc(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkVirtualGatewayToVpcResponse(rsp)
}

// ReadVmsWithResponse request returning *ReadVmsResponse
func (c *ClientWithResponses) ReadVmsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadVmsParams, reqEditors ...RequestEditorFn) (*ReadVmsResponse, error) {
	rsp, err := c.ReadVms(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVmsResponse(rsp)
}

// CreateVmsWithBodyWithResponse request with arbitrary body returning *CreateVmsResponse
func (c *ClientWithResponses) CreateVmsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVmsResponse, error) {
	rsp, err := c.CreateVmsWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVmsResponse(rsp)
}

func (c *ClientWithResponses) CreateVmsWithResponse(ctx context.Context, spaceId SpaceId, body CreateVmsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVmsResponse, error) {
	rsp, err := c.CreateVms(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVmsResponse(rsp)
}

// ReadVmsStateWithResponse request returning *ReadVmsStateResponse
func (c *ClientWithResponses) ReadVmsStateWithResponse(ctx context.Context, spaceId SpaceId, params *ReadVmsStateParams, reqEditors ...RequestEditorFn) (*ReadVmsStateResponse, error) {
	rsp, err := c.ReadVmsState(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVmsStateResponse(rsp)
}

// DeleteVmsWithResponse request returning *DeleteVmsResponse
func (c *ClientWithResponses) DeleteVmsWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteVmsResponse, error) {
	rsp, err := c.DeleteVms(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVmsResponse(rsp)
}

// ReadVmsByIdWithResponse request returning *ReadVmsByIdResponse
func (c *ClientWithResponses) ReadVmsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadVmsByIdResponse, error) {
	rsp, err := c.ReadVmsById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVmsByIdResponse(rsp)
}

// UpdateVmWithBodyWithResponse request with arbitrary body returning *UpdateVmResponse
func (c *ClientWithResponses) UpdateVmWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVmResponse, error) {
	rsp, err := c.UpdateVmWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVmResponse(rsp)
}

func (c *ClientWithResponses) UpdateVmWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateVmJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVmResponse, error) {
	rsp, err := c.UpdateVm(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVmResponse(rsp)
}

// ReadAdminPasswordWithResponse request returning *ReadAdminPasswordResponse
func (c *ClientWithResponses) ReadAdminPasswordWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadAdminPasswordResponse, error) {
	rsp, err := c.ReadAdminPassword(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadAdminPasswordResponse(rsp)
}

// ReadConsoleOutputWithResponse request returning *ReadConsoleOutputResponse
func (c *ClientWithResponses) ReadConsoleOutputWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadConsoleOutputResponse, error) {
	rsp, err := c.ReadConsoleOutput(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadConsoleOutputResponse(rsp)
}

// RebootVmWithResponse request returning *RebootVmResponse
func (c *ClientWithResponses) RebootVmWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*RebootVmResponse, error) {
	rsp, err := c.RebootVm(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRebootVmResponse(rsp)
}

// StartVmWithResponse request returning *StartVmResponse
func (c *ClientWithResponses) StartVmWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*StartVmResponse, error) {
	rsp, err := c.StartVm(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartVmResponse(rsp)
}

// StopVmWithBodyWithResponse request with arbitrary body returning *StopVmResponse
func (c *ClientWithResponses) StopVmWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StopVmResponse, error) {
	rsp, err := c.StopVmWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopVmResponse(rsp)
}

func (c *ClientWithResponses) StopVmWithResponse(ctx context.Context, spaceId SpaceId, id string, body StopVmJSONRequestBody, reqEditors ...RequestEditorFn) (*StopVmResponse, error) {
	rsp, err := c.StopVm(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopVmResponse(rsp)
}

// ReadVolumesWithResponse request returning *ReadVolumesResponse
func (c *ClientWithResponses) ReadVolumesWithResponse(ctx context.Context, spaceId SpaceId, params *ReadVolumesParams, reqEditors ...RequestEditorFn) (*ReadVolumesResponse, error) {
	rsp, err := c.ReadVolumes(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVolumesResponse(rsp)
}

// CreateVolumeWithBodyWithResponse request with arbitrary body returning *CreateVolumeResponse
func (c *ClientWithResponses) CreateVolumeWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVolumeResponse, error) {
	rsp, err := c.CreateVolumeWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVolumeResponse(rsp)
}

func (c *ClientWithResponses) CreateVolumeWithResponse(ctx context.Context, spaceId SpaceId, body CreateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVolumeResponse, error) {
	rsp, err := c.CreateVolume(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVolumeResponse(rsp)
}

// DeleteVolumeWithResponse request returning *DeleteVolumeResponse
func (c *ClientWithResponses) DeleteVolumeWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteVolumeResponse, error) {
	rsp, err := c.DeleteVolume(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVolumeResponse(rsp)
}

// ReadVolumesByIdWithResponse request returning *ReadVolumesByIdResponse
func (c *ClientWithResponses) ReadVolumesByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadVolumesByIdResponse, error) {
	rsp, err := c.ReadVolumesById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVolumesByIdResponse(rsp)
}

// UpdateVolumeWithBodyWithResponse request with arbitrary body returning *UpdateVolumeResponse
func (c *ClientWithResponses) UpdateVolumeWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVolumeResponse, error) {
	rsp, err := c.UpdateVolumeWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVolumeResponse(rsp)
}

func (c *ClientWithResponses) UpdateVolumeWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVolumeResponse, error) {
	rsp, err := c.UpdateVolume(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVolumeResponse(rsp)
}

// LinkVolumeWithBodyWithResponse request with arbitrary body returning *LinkVolumeResponse
func (c *ClientWithResponses) LinkVolumeWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkVolumeResponse, error) {
	rsp, err := c.LinkVolumeWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkVolumeResponse(rsp)
}

func (c *ClientWithResponses) LinkVolumeWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkVolumeResponse, error) {
	rsp, err := c.LinkVolume(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkVolumeResponse(rsp)
}

// UnlinkVolumeWithBodyWithResponse request with arbitrary body returning *UnlinkVolumeResponse
func (c *ClientWithResponses) UnlinkVolumeWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkVolumeResponse, error) {
	rsp, err := c.UnlinkVolumeWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkVolumeResponse(rsp)
}

func (c *ClientWithResponses) UnlinkVolumeWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkVolumeResponse, error) {
	rsp, err := c.UnlinkVolume(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkVolumeResponse(rsp)
}

// ReadVpcPeeringsWithResponse request returning *ReadVpcPeeringsResponse
func (c *ClientWithResponses) ReadVpcPeeringsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadVpcPeeringsParams, reqEditors ...RequestEditorFn) (*ReadVpcPeeringsResponse, error) {
	rsp, err := c.ReadVpcPeerings(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVpcPeeringsResponse(rsp)
}

// CreateVpcPeeringWithBodyWithResponse request with arbitrary body returning *CreateVpcPeeringResponse
func (c *ClientWithResponses) CreateVpcPeeringWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVpcPeeringResponse, error) {
	rsp, err := c.CreateVpcPeeringWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVpcPeeringResponse(rsp)
}

func (c *ClientWithResponses) CreateVpcPeeringWithResponse(ctx context.Context, spaceId SpaceId, body CreateVpcPeeringJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVpcPeeringResponse, error) {
	rsp, err := c.CreateVpcPeering(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVpcPeeringResponse(rsp)
}

// DeleteVpcPeeringWithResponse request returning *DeleteVpcPeeringResponse
func (c *ClientWithResponses) DeleteVpcPeeringWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteVpcPeeringResponse, error) {
	rsp, err := c.DeleteVpcPeering(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVpcPeeringResponse(rsp)
}

// ReadVpcPeeringsByIdWithResponse request returning *ReadVpcPeeringsByIdResponse
func (c *ClientWithResponses) ReadVpcPeeringsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadVpcPeeringsByIdResponse, error) {
	rsp, err := c.ReadVpcPeeringsById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVpcPeeringsByIdResponse(rsp)
}

// AcceptVpcPeeringWithResponse request returning *AcceptVpcPeeringResponse
func (c *ClientWithResponses) AcceptVpcPeeringWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*AcceptVpcPeeringResponse, error) {
	rsp, err := c.AcceptVpcPeering(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcceptVpcPeeringResponse(rsp)
}

// RejectVpcPeeringWithResponse request returning *RejectVpcPeeringResponse
func (c *ClientWithResponses) RejectVpcPeeringWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*RejectVpcPeeringResponse, error) {
	rsp, err := c.RejectVpcPeering(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRejectVpcPeeringResponse(rsp)
}

// ReadVpcsWithResponse request returning *ReadVpcsResponse
func (c *ClientWithResponses) ReadVpcsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadVpcsParams, reqEditors ...RequestEditorFn) (*ReadVpcsResponse, error) {
	rsp, err := c.ReadVpcs(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVpcsResponse(rsp)
}

// CreateVpcWithBodyWithResponse request with arbitrary body returning *CreateVpcResponse
func (c *ClientWithResponses) CreateVpcWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVpcResponse, error) {
	rsp, err := c.CreateVpcWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVpcResponse(rsp)
}

func (c *ClientWithResponses) CreateVpcWithResponse(ctx context.Context, spaceId SpaceId, body CreateVpcJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVpcResponse, error) {
	rsp, err := c.CreateVpc(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVpcResponse(rsp)
}

// DeleteVpcWithResponse request returning *DeleteVpcResponse
func (c *ClientWithResponses) DeleteVpcWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteVpcResponse, error) {
	rsp, err := c.DeleteVpc(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVpcResponse(rsp)
}

// ReadVpcsByIdWithResponse request returning *ReadVpcsByIdResponse
func (c *ClientWithResponses) ReadVpcsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadVpcsByIdResponse, error) {
	rsp, err := c.ReadVpcsById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVpcsByIdResponse(rsp)
}

// UpdateVpcWithBodyWithResponse request with arbitrary body returning *UpdateVpcResponse
func (c *ClientWithResponses) UpdateVpcWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVpcResponse, error) {
	rsp, err := c.UpdateVpcWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVpcResponse(rsp)
}

func (c *ClientWithResponses) UpdateVpcWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateVpcJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVpcResponse, error) {
	rsp, err := c.UpdateVpc(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVpcResponse(rsp)
}

// ReadVpnConnectionsWithResponse request returning *ReadVpnConnectionsResponse
func (c *ClientWithResponses) ReadVpnConnectionsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadVpnConnectionsParams, reqEditors ...RequestEditorFn) (*ReadVpnConnectionsResponse, error) {
	rsp, err := c.ReadVpnConnections(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVpnConnectionsResponse(rsp)
}

// CreateVpnConnectionWithBodyWithResponse request with arbitrary body returning *CreateVpnConnectionResponse
func (c *ClientWithResponses) CreateVpnConnectionWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVpnConnectionResponse, error) {
	rsp, err := c.CreateVpnConnectionWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVpnConnectionResponse(rsp)
}

func (c *ClientWithResponses) CreateVpnConnectionWithResponse(ctx context.Context, spaceId SpaceId, body CreateVpnConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVpnConnectionResponse, error) {
	rsp, err := c.CreateVpnConnection(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVpnConnectionResponse(rsp)
}

// DeleteVpnConnectionWithResponse request returning *DeleteVpnConnectionResponse
func (c *ClientWithResponses) DeleteVpnConnectionWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteVpnConnectionResponse, error) {
	rsp, err := c.DeleteVpnConnection(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVpnConnectionResponse(rsp)
}

// ReadVpnConnectionsByIdWithResponse request returning *ReadVpnConnectionsByIdResponse
func (c *ClientWithResponses) ReadVpnConnectionsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadVpnConnectionsByIdResponse, error) {
	rsp, err := c.ReadVpnConnectionsById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVpnConnectionsByIdResponse(rsp)
}

// UpdateVpnConnectionWithBodyWithResponse request with arbitrary body returning *UpdateVpnConnectionResponse
func (c *ClientWithResponses) UpdateVpnConnectionWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVpnConnectionResponse, error) {
	rsp, err := c.UpdateVpnConnectionWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVpnConnectionResponse(rsp)
}

func (c *ClientWithResponses) UpdateVpnConnectionWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateVpnConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVpnConnectionResponse, error) {
	rsp, err := c.UpdateVpnConnection(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVpnConnectionResponse(rsp)
}

// DeleteVpnConnectionRouteWithBodyWithResponse request with arbitrary body returning *DeleteVpnConnectionRouteResponse
func (c *ClientWithResponses) DeleteVpnConnectionRouteWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteVpnConnectionRouteResponse, error) {
	rsp, err := c.DeleteVpnConnectionRouteWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVpnConnectionRouteResponse(rsp)
}

func (c *ClientWithResponses) DeleteVpnConnectionRouteWithResponse(ctx context.Context, spaceId SpaceId, id string, body DeleteVpnConnectionRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteVpnConnectionRouteResponse, error) {
	rsp, err := c.DeleteVpnConnectionRoute(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVpnConnectionRouteResponse(rsp)
}

// CreateVpnConnectionRouteWithBodyWithResponse request with arbitrary body returning *CreateVpnConnectionRouteResponse
func (c *ClientWithResponses) CreateVpnConnectionRouteWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVpnConnectionRouteResponse, error) {
	rsp, err := c.CreateVpnConnectionRouteWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVpnConnectionRouteResponse(rsp)
}

func (c *ClientWithResponses) CreateVpnConnectionRouteWithResponse(ctx context.Context, spaceId SpaceId, id string, body CreateVpnConnectionRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVpnConnectionRouteResponse, error) {
	rsp, err := c.CreateVpnConnectionRoute(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVpnConnectionRouteResponse(rsp)
}

// JsonWebKeysWithResponse request returning *JsonWebKeysResponse
func (c *ClientWithResponses) JsonWebKeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*JsonWebKeysResponse, error) {
	rsp, err := c.JsonWebKeys(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJsonWebKeysResponse(rsp)
}

// DiscoverOidcConfigurationWithResponse request returning *DiscoverOidcConfigurationResponse
func (c *ClientWithResponses) DiscoverOidcConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DiscoverOidcConfigurationResponse, error) {
	rsp, err := c.DiscoverOidcConfiguration(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDiscoverOidcConfigurationResponse(rsp)
}

// GetWebAuthnJavaScriptWithResponse request returning *GetWebAuthnJavaScriptResponse
func (c *ClientWithResponses) GetWebAuthnJavaScriptWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWebAuthnJavaScriptResponse, error) {
	rsp, err := c.GetWebAuthnJavaScript(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebAuthnJavaScriptResponse(rsp)
}

// CreateAdminServiceAccountSpaceWithBodyWithResponse request with arbitrary body returning *CreateAdminServiceAccountSpaceResponse
func (c *ClientWithResponses) CreateAdminServiceAccountSpaceWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAdminServiceAccountSpaceResponse, error) {
	rsp, err := c.CreateAdminServiceAccountSpaceWithBody(ctx, organisationId, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAdminServiceAccountSpaceResponse(rsp)
}

func (c *ClientWithResponses) CreateAdminServiceAccountSpaceWithResponse(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, body CreateAdminServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAdminServiceAccountSpaceResponse, error) {
	rsp, err := c.CreateAdminServiceAccountSpace(ctx, organisationId, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAdminServiceAccountSpaceResponse(rsp)
}

// AuthorizeWithResponse request returning *AuthorizeResponse
func (c *ClientWithResponses) AuthorizeWithResponse(ctx context.Context, params *AuthorizeParams, reqEditors ...RequestEditorFn) (*AuthorizeResponse, error) {
	rsp, err := c.Authorize(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthorizeResponse(rsp)
}

// ConsentWithResponse request returning *ConsentResponse
func (c *ClientWithResponses) ConsentWithResponse(ctx context.Context, params *ConsentParams, reqEditors ...RequestEditorFn) (*ConsentResponse, error) {
	rsp, err := c.Consent(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConsentResponse(rsp)
}

// GetFlowErrorWithResponse request returning *GetFlowErrorResponse
func (c *ClientWithResponses) GetFlowErrorWithResponse(ctx context.Context, params *GetFlowErrorParams, reqEditors ...RequestEditorFn) (*GetFlowErrorResponse, error) {
	rsp, err := c.GetFlowError(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFlowErrorResponse(rsp)
}

// UpdateLoginFlowWithBodyWithResponse request with arbitrary body returning *UpdateLoginFlowResponse
func (c *ClientWithResponses) UpdateLoginFlowWithBodyWithResponse(ctx context.Context, params *UpdateLoginFlowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLoginFlowResponse, error) {
	rsp, err := c.UpdateLoginFlowWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLoginFlowResponse(rsp)
}

func (c *ClientWithResponses) UpdateLoginFlowWithResponse(ctx context.Context, params *UpdateLoginFlowParams, body UpdateLoginFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLoginFlowResponse, error) {
	rsp, err := c.UpdateLoginFlow(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLoginFlowResponse(rsp)
}

func (c *ClientWithResponses) UpdateLoginFlowWithFormdataBodyWithResponse(ctx context.Context, params *UpdateLoginFlowParams, body UpdateLoginFlowFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateLoginFlowResponse, error) {
	rsp, err := c.UpdateLoginFlowWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLoginFlowResponse(rsp)
}

// CreateNativeLoginFlowWithResponse request returning *CreateNativeLoginFlowResponse
func (c *ClientWithResponses) CreateNativeLoginFlowWithResponse(ctx context.Context, params *CreateNativeLoginFlowParams, reqEditors ...RequestEditorFn) (*CreateNativeLoginFlowResponse, error) {
	rsp, err := c.CreateNativeLoginFlow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNativeLoginFlowResponse(rsp)
}

// CreateBrowserLoginFlowWithResponse request returning *CreateBrowserLoginFlowResponse
func (c *ClientWithResponses) CreateBrowserLoginFlowWithResponse(ctx context.Context, params *CreateBrowserLoginFlowParams, reqEditors ...RequestEditorFn) (*CreateBrowserLoginFlowResponse, error) {
	rsp, err := c.CreateBrowserLoginFlow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBrowserLoginFlowResponse(rsp)
}

// GetLoginFlowWithResponse request returning *GetLoginFlowResponse
func (c *ClientWithResponses) GetLoginFlowWithResponse(ctx context.Context, params *GetLoginFlowParams, reqEditors ...RequestEditorFn) (*GetLoginFlowResponse, error) {
	rsp, err := c.GetLoginFlow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLoginFlowResponse(rsp)
}

// UpdateLogoutFlowWithResponse request returning *UpdateLogoutFlowResponse
func (c *ClientWithResponses) UpdateLogoutFlowWithResponse(ctx context.Context, params *UpdateLogoutFlowParams, reqEditors ...RequestEditorFn) (*UpdateLogoutFlowResponse, error) {
	rsp, err := c.UpdateLogoutFlow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLogoutFlowResponse(rsp)
}

// PerformNativeLogoutWithBodyWithResponse request with arbitrary body returning *PerformNativeLogoutResponse
func (c *ClientWithResponses) PerformNativeLogoutWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PerformNativeLogoutResponse, error) {
	rsp, err := c.PerformNativeLogoutWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePerformNativeLogoutResponse(rsp)
}

func (c *ClientWithResponses) PerformNativeLogoutWithResponse(ctx context.Context, body PerformNativeLogoutJSONRequestBody, reqEditors ...RequestEditorFn) (*PerformNativeLogoutResponse, error) {
	rsp, err := c.PerformNativeLogout(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePerformNativeLogoutResponse(rsp)
}

// CreateBrowserLogoutFlowWithResponse request returning *CreateBrowserLogoutFlowResponse
func (c *ClientWithResponses) CreateBrowserLogoutFlowWithResponse(ctx context.Context, params *CreateBrowserLogoutFlowParams, reqEditors ...RequestEditorFn) (*CreateBrowserLogoutFlowResponse, error) {
	rsp, err := c.CreateBrowserLogoutFlow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBrowserLogoutFlowResponse(rsp)
}

// InitRecoveryFlowWithResponse request returning *InitRecoveryFlowResponse
func (c *ClientWithResponses) InitRecoveryFlowWithResponse(ctx context.Context, params *InitRecoveryFlowParams, reqEditors ...RequestEditorFn) (*InitRecoveryFlowResponse, error) {
	rsp, err := c.InitRecoveryFlow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInitRecoveryFlowResponse(rsp)
}

// UpdateRecoveryFlowWithBodyWithResponse request with arbitrary body returning *UpdateRecoveryFlowResponse
func (c *ClientWithResponses) UpdateRecoveryFlowWithBodyWithResponse(ctx context.Context, params *UpdateRecoveryFlowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRecoveryFlowResponse, error) {
	rsp, err := c.UpdateRecoveryFlowWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRecoveryFlowResponse(rsp)
}

func (c *ClientWithResponses) UpdateRecoveryFlowWithResponse(ctx context.Context, params *UpdateRecoveryFlowParams, body UpdateRecoveryFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRecoveryFlowResponse, error) {
	rsp, err := c.UpdateRecoveryFlow(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRecoveryFlowResponse(rsp)
}

func (c *ClientWithResponses) UpdateRecoveryFlowWithFormdataBodyWithResponse(ctx context.Context, params *UpdateRecoveryFlowParams, body UpdateRecoveryFlowFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateRecoveryFlowResponse, error) {
	rsp, err := c.UpdateRecoveryFlowWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRecoveryFlowResponse(rsp)
}

// CreateNativeRecoveryFlowWithResponse request returning *CreateNativeRecoveryFlowResponse
func (c *ClientWithResponses) CreateNativeRecoveryFlowWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CreateNativeRecoveryFlowResponse, error) {
	rsp, err := c.CreateNativeRecoveryFlow(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNativeRecoveryFlowResponse(rsp)
}

// CreateBrowserRecoveryFlowWithResponse request returning *CreateBrowserRecoveryFlowResponse
func (c *ClientWithResponses) CreateBrowserRecoveryFlowWithResponse(ctx context.Context, params *CreateBrowserRecoveryFlowParams, reqEditors ...RequestEditorFn) (*CreateBrowserRecoveryFlowResponse, error) {
	rsp, err := c.CreateBrowserRecoveryFlow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBrowserRecoveryFlowResponse(rsp)
}

// GetRecoveryFlowWithResponse request returning *GetRecoveryFlowResponse
func (c *ClientWithResponses) GetRecoveryFlowWithResponse(ctx context.Context, params *GetRecoveryFlowParams, reqEditors ...RequestEditorFn) (*GetRecoveryFlowResponse, error) {
	rsp, err := c.GetRecoveryFlow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRecoveryFlowResponse(rsp)
}

// UpdateRegistrationFlowWithBodyWithResponse request with arbitrary body returning *UpdateRegistrationFlowResponse
func (c *ClientWithResponses) UpdateRegistrationFlowWithBodyWithResponse(ctx context.Context, params *UpdateRegistrationFlowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRegistrationFlowResponse, error) {
	rsp, err := c.UpdateRegistrationFlowWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRegistrationFlowResponse(rsp)
}

func (c *ClientWithResponses) UpdateRegistrationFlowWithResponse(ctx context.Context, params *UpdateRegistrationFlowParams, body UpdateRegistrationFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRegistrationFlowResponse, error) {
	rsp, err := c.UpdateRegistrationFlow(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRegistrationFlowResponse(rsp)
}

func (c *ClientWithResponses) UpdateRegistrationFlowWithFormdataBodyWithResponse(ctx context.Context, params *UpdateRegistrationFlowParams, body UpdateRegistrationFlowFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateRegistrationFlowResponse, error) {
	rsp, err := c.UpdateRegistrationFlowWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRegistrationFlowResponse(rsp)
}

// CreateNativeRegistrationFlowWithResponse request returning *CreateNativeRegistrationFlowResponse
func (c *ClientWithResponses) CreateNativeRegistrationFlowWithResponse(ctx context.Context, params *CreateNativeRegistrationFlowParams, reqEditors ...RequestEditorFn) (*CreateNativeRegistrationFlowResponse, error) {
	rsp, err := c.CreateNativeRegistrationFlow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNativeRegistrationFlowResponse(rsp)
}

// CreateBrowserRegistrationFlowWithResponse request returning *CreateBrowserRegistrationFlowResponse
func (c *ClientWithResponses) CreateBrowserRegistrationFlowWithResponse(ctx context.Context, params *CreateBrowserRegistrationFlowParams, reqEditors ...RequestEditorFn) (*CreateBrowserRegistrationFlowResponse, error) {
	rsp, err := c.CreateBrowserRegistrationFlow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBrowserRegistrationFlowResponse(rsp)
}

// GetRegistrationFlowWithResponse request returning *GetRegistrationFlowResponse
func (c *ClientWithResponses) GetRegistrationFlowWithResponse(ctx context.Context, params *GetRegistrationFlowParams, reqEditors ...RequestEditorFn) (*GetRegistrationFlowResponse, error) {
	rsp, err := c.GetRegistrationFlow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRegistrationFlowResponse(rsp)
}

// UpdateSettingsFloWithBodyWithResponse request with arbitrary body returning *UpdateSettingsFloResponse
func (c *ClientWithResponses) UpdateSettingsFloWithBodyWithResponse(ctx context.Context, params *UpdateSettingsFloParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSettingsFloResponse, error) {
	rsp, err := c.UpdateSettingsFloWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSettingsFloResponse(rsp)
}

func (c *ClientWithResponses) UpdateSettingsFloWithResponse(ctx context.Context, params *UpdateSettingsFloParams, body UpdateSettingsFloJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSettingsFloResponse, error) {
	rsp, err := c.UpdateSettingsFlo(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSettingsFloResponse(rsp)
}

func (c *ClientWithResponses) UpdateSettingsFloWithFormdataBodyWithResponse(ctx context.Context, params *UpdateSettingsFloParams, body UpdateSettingsFloFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateSettingsFloResponse, error) {
	rsp, err := c.UpdateSettingsFloWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSettingsFloResponse(rsp)
}

// CreateNativeSettingsFlowWithResponse request returning *CreateNativeSettingsFlowResponse
func (c *ClientWithResponses) CreateNativeSettingsFlowWithResponse(ctx context.Context, params *CreateNativeSettingsFlowParams, reqEditors ...RequestEditorFn) (*CreateNativeSettingsFlowResponse, error) {
	rsp, err := c.CreateNativeSettingsFlow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNativeSettingsFlowResponse(rsp)
}

// CreateBrowserSettingsFlowWithResponse request returning *CreateBrowserSettingsFlowResponse
func (c *ClientWithResponses) CreateBrowserSettingsFlowWithResponse(ctx context.Context, params *CreateBrowserSettingsFlowParams, reqEditors ...RequestEditorFn) (*CreateBrowserSettingsFlowResponse, error) {
	rsp, err := c.CreateBrowserSettingsFlow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBrowserSettingsFlowResponse(rsp)
}

// GetSettingsFlowWithResponse request returning *GetSettingsFlowResponse
func (c *ClientWithResponses) GetSettingsFlowWithResponse(ctx context.Context, params *GetSettingsFlowParams, reqEditors ...RequestEditorFn) (*GetSettingsFlowResponse, error) {
	rsp, err := c.GetSettingsFlow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSettingsFlowResponse(rsp)
}

// UpdateVerificationFlowWithBodyWithResponse request with arbitrary body returning *UpdateVerificationFlowResponse
func (c *ClientWithResponses) UpdateVerificationFlowWithBodyWithResponse(ctx context.Context, params *UpdateVerificationFlowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVerificationFlowResponse, error) {
	rsp, err := c.UpdateVerificationFlowWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVerificationFlowResponse(rsp)
}

func (c *ClientWithResponses) UpdateVerificationFlowWithResponse(ctx context.Context, params *UpdateVerificationFlowParams, body UpdateVerificationFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVerificationFlowResponse, error) {
	rsp, err := c.UpdateVerificationFlow(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVerificationFlowResponse(rsp)
}

func (c *ClientWithResponses) UpdateVerificationFlowWithFormdataBodyWithResponse(ctx context.Context, params *UpdateVerificationFlowParams, body UpdateVerificationFlowFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateVerificationFlowResponse, error) {
	rsp, err := c.UpdateVerificationFlowWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVerificationFlowResponse(rsp)
}

// CreateNativeVerificationFlowWithResponse request returning *CreateNativeVerificationFlowResponse
func (c *ClientWithResponses) CreateNativeVerificationFlowWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CreateNativeVerificationFlowResponse, error) {
	rsp, err := c.CreateNativeVerificationFlow(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNativeVerificationFlowResponse(rsp)
}

// CreateBrowserVerificationFlowWithResponse request returning *CreateBrowserVerificationFlowResponse
func (c *ClientWithResponses) CreateBrowserVerificationFlowWithResponse(ctx context.Context, params *CreateBrowserVerificationFlowParams, reqEditors ...RequestEditorFn) (*CreateBrowserVerificationFlowResponse, error) {
	rsp, err := c.CreateBrowserVerificationFlow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBrowserVerificationFlowResponse(rsp)
}

// GetVerificationFlowWithResponse request returning *GetVerificationFlowResponse
func (c *ClientWithResponses) GetVerificationFlowWithResponse(ctx context.Context, params *GetVerificationFlowParams, reqEditors ...RequestEditorFn) (*GetVerificationFlowResponse, error) {
	rsp, err := c.GetVerificationFlow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVerificationFlowResponse(rsp)
}

// DisableMyOtherSessionsWithResponse request returning *DisableMyOtherSessionsResponse
func (c *ClientWithResponses) DisableMyOtherSessionsWithResponse(ctx context.Context, params *DisableMyOtherSessionsParams, reqEditors ...RequestEditorFn) (*DisableMyOtherSessionsResponse, error) {
	rsp, err := c.DisableMyOtherSessions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisableMyOtherSessionsResponse(rsp)
}

// ListMySessionsWithResponse request returning *ListMySessionsResponse
func (c *ClientWithResponses) ListMySessionsWithResponse(ctx context.Context, params *ListMySessionsParams, reqEditors ...RequestEditorFn) (*ListMySessionsResponse, error) {
	rsp, err := c.ListMySessions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMySessionsResponse(rsp)
}

// ExchangeSessionTokenWithResponse request returning *ExchangeSessionTokenResponse
func (c *ClientWithResponses) ExchangeSessionTokenWithResponse(ctx context.Context, params *ExchangeSessionTokenParams, reqEditors ...RequestEditorFn) (*ExchangeSessionTokenResponse, error) {
	rsp, err := c.ExchangeSessionToken(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExchangeSessionTokenResponse(rsp)
}

// ToSessionWithResponse request returning *ToSessionResponse
func (c *ClientWithResponses) ToSessionWithResponse(ctx context.Context, params *ToSessionParams, reqEditors ...RequestEditorFn) (*ToSessionResponse, error) {
	rsp, err := c.ToSession(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToSessionResponse(rsp)
}

// IntrospectWithBodyWithResponse request with arbitrary body returning *IntrospectResponse
func (c *ClientWithResponses) IntrospectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IntrospectResponse, error) {
	rsp, err := c.IntrospectWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIntrospectResponse(rsp)
}

func (c *ClientWithResponses) IntrospectWithFormdataBodyWithResponse(ctx context.Context, body IntrospectFormdataRequestBody, reqEditors ...RequestEditorFn) (*IntrospectResponse, error) {
	rsp, err := c.IntrospectWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIntrospectResponse(rsp)
}

// ListOrganisationsIdentityWithResponse request returning *ListOrganisationsIdentityResponse
func (c *ClientWithResponses) ListOrganisationsIdentityWithResponse(ctx context.Context, params *ListOrganisationsIdentityParams, reqEditors ...RequestEditorFn) (*ListOrganisationsIdentityResponse, error) {
	rsp, err := c.ListOrganisationsIdentity(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListOrganisationsIdentityResponse(rsp)
}

// GetIAMGranularPolicyOrganisationWithResponse request returning *GetIAMGranularPolicyOrganisationResponse
func (c *ClientWithResponses) GetIAMGranularPolicyOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, reqEditors ...RequestEditorFn) (*GetIAMGranularPolicyOrganisationResponse, error) {
	rsp, err := c.GetIAMGranularPolicyOrganisation(ctx, organisationId, subjectType, subjectId, objectType, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIAMGranularPolicyOrganisationResponse(rsp)
}

// SetIAMGranularPolicyOrganisationWithBodyWithResponse request with arbitrary body returning *SetIAMGranularPolicyOrganisationResponse
func (c *ClientWithResponses) SetIAMGranularPolicyOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetIAMGranularPolicyOrganisationResponse, error) {
	rsp, err := c.SetIAMGranularPolicyOrganisationWithBody(ctx, organisationId, subjectType, subjectId, objectType, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetIAMGranularPolicyOrganisationResponse(rsp)
}

func (c *ClientWithResponses) SetIAMGranularPolicyOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, body SetIAMGranularPolicyOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*SetIAMGranularPolicyOrganisationResponse, error) {
	rsp, err := c.SetIAMGranularPolicyOrganisation(ctx, organisationId, subjectType, subjectId, objectType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetIAMGranularPolicyOrganisationResponse(rsp)
}

// GetIAMPolicyOrganisationWithResponse request returning *GetIAMPolicyOrganisationResponse
func (c *ClientWithResponses) GetIAMPolicyOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, reqEditors ...RequestEditorFn) (*GetIAMPolicyOrganisationResponse, error) {
	rsp, err := c.GetIAMPolicyOrganisation(ctx, organisationId, subjectType, subjectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIAMPolicyOrganisationResponse(rsp)
}

// SetIAMPolicyOrganisationWithBodyWithResponse request with arbitrary body returning *SetIAMPolicyOrganisationResponse
func (c *ClientWithResponses) SetIAMPolicyOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetIAMPolicyOrganisationResponse, error) {
	rsp, err := c.SetIAMPolicyOrganisationWithBody(ctx, organisationId, subjectType, subjectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetIAMPolicyOrganisationResponse(rsp)
}

func (c *ClientWithResponses) SetIAMPolicyOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, body SetIAMPolicyOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*SetIAMPolicyOrganisationResponse, error) {
	rsp, err := c.SetIAMPolicyOrganisation(ctx, organisationId, subjectType, subjectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetIAMPolicyOrganisationResponse(rsp)
}

// ListPermissionsOrganisationWithResponse request returning *ListPermissionsOrganisationResponse
func (c *ClientWithResponses) ListPermissionsOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, params *ListPermissionsOrganisationParams, reqEditors ...RequestEditorFn) (*ListPermissionsOrganisationResponse, error) {
	rsp, err := c.ListPermissionsOrganisation(ctx, organisationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPermissionsOrganisationResponse(rsp)
}

// GetPermissionOrganisationWithResponse request returning *GetPermissionOrganisationResponse
func (c *ClientWithResponses) GetPermissionOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, permissionUuid PermissionUuid, reqEditors ...RequestEditorFn) (*GetPermissionOrganisationResponse, error) {
	rsp, err := c.GetPermissionOrganisation(ctx, organisationId, permissionUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPermissionOrganisationResponse(rsp)
}

// ListRolesOrganisationWithResponse request returning *ListRolesOrganisationResponse
func (c *ClientWithResponses) ListRolesOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, params *ListRolesOrganisationParams, reqEditors ...RequestEditorFn) (*ListRolesOrganisationResponse, error) {
	rsp, err := c.ListRolesOrganisation(ctx, organisationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRolesOrganisationResponse(rsp)
}

// CreateRoleOrganisationWithBodyWithResponse request with arbitrary body returning *CreateRoleOrganisationResponse
func (c *ClientWithResponses) CreateRoleOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRoleOrganisationResponse, error) {
	rsp, err := c.CreateRoleOrganisationWithBody(ctx, organisationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRoleOrganisationResponse(rsp)
}

func (c *ClientWithResponses) CreateRoleOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, body CreateRoleOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRoleOrganisationResponse, error) {
	rsp, err := c.CreateRoleOrganisation(ctx, organisationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRoleOrganisationResponse(rsp)
}

// DeleteRoleOrganisationWithResponse request returning *DeleteRoleOrganisationResponse
func (c *ClientWithResponses) DeleteRoleOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*DeleteRoleOrganisationResponse, error) {
	rsp, err := c.DeleteRoleOrganisation(ctx, organisationId, roleUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRoleOrganisationResponse(rsp)
}

// GetRoleOrganisationWithResponse request returning *GetRoleOrganisationResponse
func (c *ClientWithResponses) GetRoleOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*GetRoleOrganisationResponse, error) {
	rsp, err := c.GetRoleOrganisation(ctx, organisationId, roleUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRoleOrganisationResponse(rsp)
}

// UpdateRoleOrganisationWithBodyWithResponse request with arbitrary body returning *UpdateRoleOrganisationResponse
func (c *ClientWithResponses) UpdateRoleOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRoleOrganisationResponse, error) {
	rsp, err := c.UpdateRoleOrganisationWithBody(ctx, organisationId, roleUuid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRoleOrganisationResponse(rsp)
}

func (c *ClientWithResponses) UpdateRoleOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, body UpdateRoleOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRoleOrganisationResponse, error) {
	rsp, err := c.UpdateRoleOrganisation(ctx, organisationId, roleUuid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRoleOrganisationResponse(rsp)
}

// RemoveRolePermissionsOrganisationWithBodyWithResponse request with arbitrary body returning *RemoveRolePermissionsOrganisationResponse
func (c *ClientWithResponses) RemoveRolePermissionsOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveRolePermissionsOrganisationResponse, error) {
	rsp, err := c.RemoveRolePermissionsOrganisationWithBody(ctx, organisationId, roleUuid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveRolePermissionsOrganisationResponse(rsp)
}

func (c *ClientWithResponses) RemoveRolePermissionsOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, body RemoveRolePermissionsOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveRolePermissionsOrganisationResponse, error) {
	rsp, err := c.RemoveRolePermissionsOrganisation(ctx, organisationId, roleUuid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveRolePermissionsOrganisationResponse(rsp)
}

// GetRolePermissionsOrganisationWithResponse request returning *GetRolePermissionsOrganisationResponse
func (c *ClientWithResponses) GetRolePermissionsOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*GetRolePermissionsOrganisationResponse, error) {
	rsp, err := c.GetRolePermissionsOrganisation(ctx, organisationId, roleUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRolePermissionsOrganisationResponse(rsp)
}

// AddRolePermissionsOrganisationWithBodyWithResponse request with arbitrary body returning *AddRolePermissionsOrganisationResponse
func (c *ClientWithResponses) AddRolePermissionsOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddRolePermissionsOrganisationResponse, error) {
	rsp, err := c.AddRolePermissionsOrganisationWithBody(ctx, organisationId, roleUuid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddRolePermissionsOrganisationResponse(rsp)
}

func (c *ClientWithResponses) AddRolePermissionsOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, body AddRolePermissionsOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*AddRolePermissionsOrganisationResponse, error) {
	rsp, err := c.AddRolePermissionsOrganisation(ctx, organisationId, roleUuid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddRolePermissionsOrganisationResponse(rsp)
}

// ListServiceAccountOrganisationWithBodyWithResponse request with arbitrary body returning *ListServiceAccountOrganisationResponse
func (c *ClientWithResponses) ListServiceAccountOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, params *ListServiceAccountOrganisationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListServiceAccountOrganisationResponse, error) {
	rsp, err := c.ListServiceAccountOrganisationWithBody(ctx, organisationId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListServiceAccountOrganisationResponse(rsp)
}

func (c *ClientWithResponses) ListServiceAccountOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, params *ListServiceAccountOrganisationParams, body ListServiceAccountOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*ListServiceAccountOrganisationResponse, error) {
	rsp, err := c.ListServiceAccountOrganisation(ctx, organisationId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListServiceAccountOrganisationResponse(rsp)
}

// CreateServiceAccountOrganisationWithBodyWithResponse request with arbitrary body returning *CreateServiceAccountOrganisationResponse
func (c *ClientWithResponses) CreateServiceAccountOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceAccountOrganisationResponse, error) {
	rsp, err := c.CreateServiceAccountOrganisationWithBody(ctx, organisationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceAccountOrganisationResponse(rsp)
}

func (c *ClientWithResponses) CreateServiceAccountOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, body CreateServiceAccountOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceAccountOrganisationResponse, error) {
	rsp, err := c.CreateServiceAccountOrganisation(ctx, organisationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceAccountOrganisationResponse(rsp)
}

// DeleteServiceAccountOrganisationWithResponse request returning *DeleteServiceAccountOrganisationResponse
func (c *ClientWithResponses) DeleteServiceAccountOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*DeleteServiceAccountOrganisationResponse, error) {
	rsp, err := c.DeleteServiceAccountOrganisation(ctx, organisationId, serviceAccountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServiceAccountOrganisationResponse(rsp)
}

// GetServiceAccountOrganisationWithResponse request returning *GetServiceAccountOrganisationResponse
func (c *ClientWithResponses) GetServiceAccountOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*GetServiceAccountOrganisationResponse, error) {
	rsp, err := c.GetServiceAccountOrganisation(ctx, organisationId, serviceAccountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServiceAccountOrganisationResponse(rsp)
}

// UpdateServiceAccountOrganisationWithBodyWithResponse request with arbitrary body returning *UpdateServiceAccountOrganisationResponse
func (c *ClientWithResponses) UpdateServiceAccountOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServiceAccountOrganisationResponse, error) {
	rsp, err := c.UpdateServiceAccountOrganisationWithBody(ctx, organisationId, serviceAccountId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServiceAccountOrganisationResponse(rsp)
}

func (c *ClientWithResponses) UpdateServiceAccountOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, body UpdateServiceAccountOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServiceAccountOrganisationResponse, error) {
	rsp, err := c.UpdateServiceAccountOrganisation(ctx, organisationId, serviceAccountId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServiceAccountOrganisationResponse(rsp)
}

// GetACLServiceAccountOrganisationWithResponse request returning *GetACLServiceAccountOrganisationResponse
func (c *ClientWithResponses) GetACLServiceAccountOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, params *GetACLServiceAccountOrganisationParams, reqEditors ...RequestEditorFn) (*GetACLServiceAccountOrganisationResponse, error) {
	rsp, err := c.GetACLServiceAccountOrganisation(ctx, organisationId, serviceAccountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetACLServiceAccountOrganisationResponse(rsp)
}

// DeleteACLServiceAccountOrganisationBulkWithBodyWithResponse request with arbitrary body returning *DeleteACLServiceAccountOrganisationBulkResponse
func (c *ClientWithResponses) DeleteACLServiceAccountOrganisationBulkWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteACLServiceAccountOrganisationBulkResponse, error) {
	rsp, err := c.DeleteACLServiceAccountOrganisationBulkWithBody(ctx, organisationId, serviceAccountId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteACLServiceAccountOrganisationBulkResponse(rsp)
}

func (c *ClientWithResponses) DeleteACLServiceAccountOrganisationBulkWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, body DeleteACLServiceAccountOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteACLServiceAccountOrganisationBulkResponse, error) {
	rsp, err := c.DeleteACLServiceAccountOrganisationBulk(ctx, organisationId, serviceAccountId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteACLServiceAccountOrganisationBulkResponse(rsp)
}

// CreateACLServiceAccountOrganisationBulkWithBodyWithResponse request with arbitrary body returning *CreateACLServiceAccountOrganisationBulkResponse
func (c *ClientWithResponses) CreateACLServiceAccountOrganisationBulkWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateACLServiceAccountOrganisationBulkResponse, error) {
	rsp, err := c.CreateACLServiceAccountOrganisationBulkWithBody(ctx, organisationId, serviceAccountId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateACLServiceAccountOrganisationBulkResponse(rsp)
}

func (c *ClientWithResponses) CreateACLServiceAccountOrganisationBulkWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, body CreateACLServiceAccountOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateACLServiceAccountOrganisationBulkResponse, error) {
	rsp, err := c.CreateACLServiceAccountOrganisationBulk(ctx, organisationId, serviceAccountId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateACLServiceAccountOrganisationBulkResponse(rsp)
}

// ListSpacesOfServiceAccountWithResponse request returning *ListSpacesOfServiceAccountResponse
func (c *ClientWithResponses) ListSpacesOfServiceAccountWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, params *ListSpacesOfServiceAccountParams, reqEditors ...RequestEditorFn) (*ListSpacesOfServiceAccountResponse, error) {
	rsp, err := c.ListSpacesOfServiceAccount(ctx, organisationId, serviceAccountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSpacesOfServiceAccountResponse(rsp)
}

// ListSpacesIdentityWithResponse request returning *ListSpacesIdentityResponse
func (c *ClientWithResponses) ListSpacesIdentityWithResponse(ctx context.Context, organisationId OrganisationId, params *ListSpacesIdentityParams, reqEditors ...RequestEditorFn) (*ListSpacesIdentityResponse, error) {
	rsp, err := c.ListSpacesIdentity(ctx, organisationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSpacesIdentityResponse(rsp)
}

// ListUserOrganisationWithBodyWithResponse request with arbitrary body returning *ListUserOrganisationResponse
func (c *ClientWithResponses) ListUserOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, params *ListUserOrganisationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListUserOrganisationResponse, error) {
	rsp, err := c.ListUserOrganisationWithBody(ctx, organisationId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserOrganisationResponse(rsp)
}

func (c *ClientWithResponses) ListUserOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, params *ListUserOrganisationParams, body ListUserOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*ListUserOrganisationResponse, error) {
	rsp, err := c.ListUserOrganisation(ctx, organisationId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserOrganisationResponse(rsp)
}

// CreateUserOrganisationWithBodyWithResponse request with arbitrary body returning *CreateUserOrganisationResponse
func (c *ClientWithResponses) CreateUserOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserOrganisationResponse, error) {
	rsp, err := c.CreateUserOrganisationWithBody(ctx, organisationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserOrganisationResponse(rsp)
}

func (c *ClientWithResponses) CreateUserOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, body CreateUserOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserOrganisationResponse, error) {
	rsp, err := c.CreateUserOrganisation(ctx, organisationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserOrganisationResponse(rsp)
}

// DeleteUserOrganisationWithResponse request returning *DeleteUserOrganisationResponse
func (c *ClientWithResponses) DeleteUserOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, reqEditors ...RequestEditorFn) (*DeleteUserOrganisationResponse, error) {
	rsp, err := c.DeleteUserOrganisation(ctx, organisationId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserOrganisationResponse(rsp)
}

// GetUserOrganisationWithResponse request returning *GetUserOrganisationResponse
func (c *ClientWithResponses) GetUserOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, reqEditors ...RequestEditorFn) (*GetUserOrganisationResponse, error) {
	rsp, err := c.GetUserOrganisation(ctx, organisationId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserOrganisationResponse(rsp)
}

// PatchUserStateOrganisationWithBodyWithResponse request with arbitrary body returning *PatchUserStateOrganisationResponse
func (c *ClientWithResponses) PatchUserStateOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchUserStateOrganisationResponse, error) {
	rsp, err := c.PatchUserStateOrganisationWithBody(ctx, organisationId, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchUserStateOrganisationResponse(rsp)
}

func (c *ClientWithResponses) PatchUserStateOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, body PatchUserStateOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchUserStateOrganisationResponse, error) {
	rsp, err := c.PatchUserStateOrganisation(ctx, organisationId, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchUserStateOrganisationResponse(rsp)
}

// UpdateUserOrganisationWithBodyWithResponse request with arbitrary body returning *UpdateUserOrganisationResponse
func (c *ClientWithResponses) UpdateUserOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserOrganisationResponse, error) {
	rsp, err := c.UpdateUserOrganisationWithBody(ctx, organisationId, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserOrganisationResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, body UpdateUserOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserOrganisationResponse, error) {
	rsp, err := c.UpdateUserOrganisation(ctx, organisationId, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserOrganisationResponse(rsp)
}

// GetACLUserOrganisationWithResponse request returning *GetACLUserOrganisationResponse
func (c *ClientWithResponses) GetACLUserOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, params *GetACLUserOrganisationParams, reqEditors ...RequestEditorFn) (*GetACLUserOrganisationResponse, error) {
	rsp, err := c.GetACLUserOrganisation(ctx, organisationId, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetACLUserOrganisationResponse(rsp)
}

// DeleteACLUserOrganisationBulkWithBodyWithResponse request with arbitrary body returning *DeleteACLUserOrganisationBulkResponse
func (c *ClientWithResponses) DeleteACLUserOrganisationBulkWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteACLUserOrganisationBulkResponse, error) {
	rsp, err := c.DeleteACLUserOrganisationBulkWithBody(ctx, organisationId, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteACLUserOrganisationBulkResponse(rsp)
}

func (c *ClientWithResponses) DeleteACLUserOrganisationBulkWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, body DeleteACLUserOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteACLUserOrganisationBulkResponse, error) {
	rsp, err := c.DeleteACLUserOrganisationBulk(ctx, organisationId, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteACLUserOrganisationBulkResponse(rsp)
}

// CreateACLUserOrganisationBulkWithBodyWithResponse request with arbitrary body returning *CreateACLUserOrganisationBulkResponse
func (c *ClientWithResponses) CreateACLUserOrganisationBulkWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateACLUserOrganisationBulkResponse, error) {
	rsp, err := c.CreateACLUserOrganisationBulkWithBody(ctx, organisationId, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateACLUserOrganisationBulkResponse(rsp)
}

func (c *ClientWithResponses) CreateACLUserOrganisationBulkWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, body CreateACLUserOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateACLUserOrganisationBulkResponse, error) {
	rsp, err := c.CreateACLUserOrganisationBulk(ctx, organisationId, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateACLUserOrganisationBulkResponse(rsp)
}

// RecoverUserOrganisationWithResponse request returning *RecoverUserOrganisationResponse
func (c *ClientWithResponses) RecoverUserOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, reqEditors ...RequestEditorFn) (*RecoverUserOrganisationResponse, error) {
	rsp, err := c.RecoverUserOrganisation(ctx, organisationId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRecoverUserOrganisationResponse(rsp)
}

// ListSpacesOfUserWithResponse request returning *ListSpacesOfUserResponse
func (c *ClientWithResponses) ListSpacesOfUserWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, params *ListSpacesOfUserParams, reqEditors ...RequestEditorFn) (*ListSpacesOfUserResponse, error) {
	rsp, err := c.ListSpacesOfUser(ctx, organisationId, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSpacesOfUserResponse(rsp)
}

// RevokeWithBodyWithResponse request with arbitrary body returning *RevokeResponse
func (c *ClientWithResponses) RevokeWithBodyWithResponse(ctx context.Context, params *RevokeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevokeResponse, error) {
	rsp, err := c.RevokeWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokeResponse(rsp)
}

func (c *ClientWithResponses) RevokeWithFormdataBodyWithResponse(ctx context.Context, params *RevokeParams, body RevokeFormdataRequestBody, reqEditors ...RequestEditorFn) (*RevokeResponse, error) {
	rsp, err := c.RevokeWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokeResponse(rsp)
}

// GetIAMGranularPolicySpaceWithResponse request returning *GetIAMGranularPolicySpaceResponse
func (c *ClientWithResponses) GetIAMGranularPolicySpaceWithResponse(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, reqEditors ...RequestEditorFn) (*GetIAMGranularPolicySpaceResponse, error) {
	rsp, err := c.GetIAMGranularPolicySpace(ctx, spaceId, subjectType, subjectId, objectType, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIAMGranularPolicySpaceResponse(rsp)
}

// SetIAMGranularPolicySpaceWithBodyWithResponse request with arbitrary body returning *SetIAMGranularPolicySpaceResponse
func (c *ClientWithResponses) SetIAMGranularPolicySpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetIAMGranularPolicySpaceResponse, error) {
	rsp, err := c.SetIAMGranularPolicySpaceWithBody(ctx, spaceId, subjectType, subjectId, objectType, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetIAMGranularPolicySpaceResponse(rsp)
}

func (c *ClientWithResponses) SetIAMGranularPolicySpaceWithResponse(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, objectType ObjectType, body SetIAMGranularPolicySpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*SetIAMGranularPolicySpaceResponse, error) {
	rsp, err := c.SetIAMGranularPolicySpace(ctx, spaceId, subjectType, subjectId, objectType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetIAMGranularPolicySpaceResponse(rsp)
}

// GetIAMPolicySpaceWithResponse request returning *GetIAMPolicySpaceResponse
func (c *ClientWithResponses) GetIAMPolicySpaceWithResponse(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, reqEditors ...RequestEditorFn) (*GetIAMPolicySpaceResponse, error) {
	rsp, err := c.GetIAMPolicySpace(ctx, spaceId, subjectType, subjectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIAMPolicySpaceResponse(rsp)
}

// SetIAMPolicySpaceWithBodyWithResponse request with arbitrary body returning *SetIAMPolicySpaceResponse
func (c *ClientWithResponses) SetIAMPolicySpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetIAMPolicySpaceResponse, error) {
	rsp, err := c.SetIAMPolicySpaceWithBody(ctx, spaceId, subjectType, subjectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetIAMPolicySpaceResponse(rsp)
}

func (c *ClientWithResponses) SetIAMPolicySpaceWithResponse(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, body SetIAMPolicySpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*SetIAMPolicySpaceResponse, error) {
	rsp, err := c.SetIAMPolicySpace(ctx, spaceId, subjectType, subjectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetIAMPolicySpaceResponse(rsp)
}

// ListPermissionsSpaceWithResponse request returning *ListPermissionsSpaceResponse
func (c *ClientWithResponses) ListPermissionsSpaceWithResponse(ctx context.Context, spaceId SpaceId, params *ListPermissionsSpaceParams, reqEditors ...RequestEditorFn) (*ListPermissionsSpaceResponse, error) {
	rsp, err := c.ListPermissionsSpace(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPermissionsSpaceResponse(rsp)
}

// GetPermissionSpaceWithResponse request returning *GetPermissionSpaceResponse
func (c *ClientWithResponses) GetPermissionSpaceWithResponse(ctx context.Context, spaceId SpaceId, permissionUuid PermissionUuid, reqEditors ...RequestEditorFn) (*GetPermissionSpaceResponse, error) {
	rsp, err := c.GetPermissionSpace(ctx, spaceId, permissionUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPermissionSpaceResponse(rsp)
}

// ListRolesSpaceWithResponse request returning *ListRolesSpaceResponse
func (c *ClientWithResponses) ListRolesSpaceWithResponse(ctx context.Context, spaceId SpaceId, params *ListRolesSpaceParams, reqEditors ...RequestEditorFn) (*ListRolesSpaceResponse, error) {
	rsp, err := c.ListRolesSpace(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRolesSpaceResponse(rsp)
}

// CreateRoleSpaceWithBodyWithResponse request with arbitrary body returning *CreateRoleSpaceResponse
func (c *ClientWithResponses) CreateRoleSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRoleSpaceResponse, error) {
	rsp, err := c.CreateRoleSpaceWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRoleSpaceResponse(rsp)
}

func (c *ClientWithResponses) CreateRoleSpaceWithResponse(ctx context.Context, spaceId SpaceId, body CreateRoleSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRoleSpaceResponse, error) {
	rsp, err := c.CreateRoleSpace(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRoleSpaceResponse(rsp)
}

// DeleteRoleSpaceWithResponse request returning *DeleteRoleSpaceResponse
func (c *ClientWithResponses) DeleteRoleSpaceWithResponse(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*DeleteRoleSpaceResponse, error) {
	rsp, err := c.DeleteRoleSpace(ctx, spaceId, roleUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRoleSpaceResponse(rsp)
}

// GetRoleSpaceWithResponse request returning *GetRoleSpaceResponse
func (c *ClientWithResponses) GetRoleSpaceWithResponse(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*GetRoleSpaceResponse, error) {
	rsp, err := c.GetRoleSpace(ctx, spaceId, roleUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRoleSpaceResponse(rsp)
}

// UpdateRoleSpaceWithBodyWithResponse request with arbitrary body returning *UpdateRoleSpaceResponse
func (c *ClientWithResponses) UpdateRoleSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRoleSpaceResponse, error) {
	rsp, err := c.UpdateRoleSpaceWithBody(ctx, spaceId, roleUuid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRoleSpaceResponse(rsp)
}

func (c *ClientWithResponses) UpdateRoleSpaceWithResponse(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, body UpdateRoleSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRoleSpaceResponse, error) {
	rsp, err := c.UpdateRoleSpace(ctx, spaceId, roleUuid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRoleSpaceResponse(rsp)
}

// RemoveRolePermissionsSpaceWithBodyWithResponse request with arbitrary body returning *RemoveRolePermissionsSpaceResponse
func (c *ClientWithResponses) RemoveRolePermissionsSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveRolePermissionsSpaceResponse, error) {
	rsp, err := c.RemoveRolePermissionsSpaceWithBody(ctx, spaceId, roleUuid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveRolePermissionsSpaceResponse(rsp)
}

func (c *ClientWithResponses) RemoveRolePermissionsSpaceWithResponse(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, body RemoveRolePermissionsSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveRolePermissionsSpaceResponse, error) {
	rsp, err := c.RemoveRolePermissionsSpace(ctx, spaceId, roleUuid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveRolePermissionsSpaceResponse(rsp)
}

// GetRolePermissionsSpaceWithResponse request returning *GetRolePermissionsSpaceResponse
func (c *ClientWithResponses) GetRolePermissionsSpaceWithResponse(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*GetRolePermissionsSpaceResponse, error) {
	rsp, err := c.GetRolePermissionsSpace(ctx, spaceId, roleUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRolePermissionsSpaceResponse(rsp)
}

// AddRolePermissionsSpaceWithBodyWithResponse request with arbitrary body returning *AddRolePermissionsSpaceResponse
func (c *ClientWithResponses) AddRolePermissionsSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddRolePermissionsSpaceResponse, error) {
	rsp, err := c.AddRolePermissionsSpaceWithBody(ctx, spaceId, roleUuid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddRolePermissionsSpaceResponse(rsp)
}

func (c *ClientWithResponses) AddRolePermissionsSpaceWithResponse(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, body AddRolePermissionsSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*AddRolePermissionsSpaceResponse, error) {
	rsp, err := c.AddRolePermissionsSpace(ctx, spaceId, roleUuid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddRolePermissionsSpaceResponse(rsp)
}

// ListServiceAccountSpaceWithBodyWithResponse request with arbitrary body returning *ListServiceAccountSpaceResponse
func (c *ClientWithResponses) ListServiceAccountSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, params *ListServiceAccountSpaceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListServiceAccountSpaceResponse, error) {
	rsp, err := c.ListServiceAccountSpaceWithBody(ctx, spaceId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListServiceAccountSpaceResponse(rsp)
}

func (c *ClientWithResponses) ListServiceAccountSpaceWithResponse(ctx context.Context, spaceId SpaceId, params *ListServiceAccountSpaceParams, body ListServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*ListServiceAccountSpaceResponse, error) {
	rsp, err := c.ListServiceAccountSpace(ctx, spaceId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListServiceAccountSpaceResponse(rsp)
}

// CreateServiceAccountSpaceWithBodyWithResponse request with arbitrary body returning *CreateServiceAccountSpaceResponse
func (c *ClientWithResponses) CreateServiceAccountSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceAccountSpaceResponse, error) {
	rsp, err := c.CreateServiceAccountSpaceWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceAccountSpaceResponse(rsp)
}

func (c *ClientWithResponses) CreateServiceAccountSpaceWithResponse(ctx context.Context, spaceId SpaceId, body CreateServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceAccountSpaceResponse, error) {
	rsp, err := c.CreateServiceAccountSpace(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceAccountSpaceResponse(rsp)
}

// DeleteServiceAccountSpaceWithResponse request returning *DeleteServiceAccountSpaceResponse
func (c *ClientWithResponses) DeleteServiceAccountSpaceWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*DeleteServiceAccountSpaceResponse, error) {
	rsp, err := c.DeleteServiceAccountSpace(ctx, spaceId, serviceAccountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServiceAccountSpaceResponse(rsp)
}

// GetServiceAccountSpaceWithResponse request returning *GetServiceAccountSpaceResponse
func (c *ClientWithResponses) GetServiceAccountSpaceWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*GetServiceAccountSpaceResponse, error) {
	rsp, err := c.GetServiceAccountSpace(ctx, spaceId, serviceAccountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServiceAccountSpaceResponse(rsp)
}

// AssignServiceAccountToSpaceWithResponse request returning *AssignServiceAccountToSpaceResponse
func (c *ClientWithResponses) AssignServiceAccountToSpaceWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*AssignServiceAccountToSpaceResponse, error) {
	rsp, err := c.AssignServiceAccountToSpace(ctx, spaceId, serviceAccountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignServiceAccountToSpaceResponse(rsp)
}

// UpdateServiceAccountSpaceWithBodyWithResponse request with arbitrary body returning *UpdateServiceAccountSpaceResponse
func (c *ClientWithResponses) UpdateServiceAccountSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServiceAccountSpaceResponse, error) {
	rsp, err := c.UpdateServiceAccountSpaceWithBody(ctx, spaceId, serviceAccountId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServiceAccountSpaceResponse(rsp)
}

func (c *ClientWithResponses) UpdateServiceAccountSpaceWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, body UpdateServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServiceAccountSpaceResponse, error) {
	rsp, err := c.UpdateServiceAccountSpace(ctx, spaceId, serviceAccountId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServiceAccountSpaceResponse(rsp)
}

// GetACLServiceAccountSpaceWithResponse request returning *GetACLServiceAccountSpaceResponse
func (c *ClientWithResponses) GetACLServiceAccountSpaceWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, params *GetACLServiceAccountSpaceParams, reqEditors ...RequestEditorFn) (*GetACLServiceAccountSpaceResponse, error) {
	rsp, err := c.GetACLServiceAccountSpace(ctx, spaceId, serviceAccountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetACLServiceAccountSpaceResponse(rsp)
}

// DeleteACLServiceAccountSpaceBulkWithBodyWithResponse request with arbitrary body returning *DeleteACLServiceAccountSpaceBulkResponse
func (c *ClientWithResponses) DeleteACLServiceAccountSpaceBulkWithBodyWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteACLServiceAccountSpaceBulkResponse, error) {
	rsp, err := c.DeleteACLServiceAccountSpaceBulkWithBody(ctx, spaceId, serviceAccountId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteACLServiceAccountSpaceBulkResponse(rsp)
}

func (c *ClientWithResponses) DeleteACLServiceAccountSpaceBulkWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, body DeleteACLServiceAccountSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteACLServiceAccountSpaceBulkResponse, error) {
	rsp, err := c.DeleteACLServiceAccountSpaceBulk(ctx, spaceId, serviceAccountId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteACLServiceAccountSpaceBulkResponse(rsp)
}

// CreateACLServiceAccountSpaceBulkWithBodyWithResponse request with arbitrary body returning *CreateACLServiceAccountSpaceBulkResponse
func (c *ClientWithResponses) CreateACLServiceAccountSpaceBulkWithBodyWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateACLServiceAccountSpaceBulkResponse, error) {
	rsp, err := c.CreateACLServiceAccountSpaceBulkWithBody(ctx, spaceId, serviceAccountId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateACLServiceAccountSpaceBulkResponse(rsp)
}

func (c *ClientWithResponses) CreateACLServiceAccountSpaceBulkWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, body CreateACLServiceAccountSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateACLServiceAccountSpaceBulkResponse, error) {
	rsp, err := c.CreateACLServiceAccountSpaceBulk(ctx, spaceId, serviceAccountId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateACLServiceAccountSpaceBulkResponse(rsp)
}

// ListUserSpaceWithBodyWithResponse request with arbitrary body returning *ListUserSpaceResponse
func (c *ClientWithResponses) ListUserSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, params *ListUserSpaceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListUserSpaceResponse, error) {
	rsp, err := c.ListUserSpaceWithBody(ctx, spaceId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserSpaceResponse(rsp)
}

func (c *ClientWithResponses) ListUserSpaceWithResponse(ctx context.Context, spaceId SpaceId, params *ListUserSpaceParams, body ListUserSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*ListUserSpaceResponse, error) {
	rsp, err := c.ListUserSpace(ctx, spaceId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserSpaceResponse(rsp)
}

// CreateUserSpaceWithBodyWithResponse request with arbitrary body returning *CreateUserSpaceResponse
func (c *ClientWithResponses) CreateUserSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserSpaceResponse, error) {
	rsp, err := c.CreateUserSpaceWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserSpaceResponse(rsp)
}

func (c *ClientWithResponses) CreateUserSpaceWithResponse(ctx context.Context, spaceId SpaceId, body CreateUserSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserSpaceResponse, error) {
	rsp, err := c.CreateUserSpace(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserSpaceResponse(rsp)
}

// UnassignUserSpaceWithResponse request returning *UnassignUserSpaceResponse
func (c *ClientWithResponses) UnassignUserSpaceWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*UnassignUserSpaceResponse, error) {
	rsp, err := c.UnassignUserSpace(ctx, spaceId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignUserSpaceResponse(rsp)
}

// GetUserSpaceWithResponse request returning *GetUserSpaceResponse
func (c *ClientWithResponses) GetUserSpaceWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*GetUserSpaceResponse, error) {
	rsp, err := c.GetUserSpace(ctx, spaceId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserSpaceResponse(rsp)
}

// PatchUserStateSpaceWithBodyWithResponse request with arbitrary body returning *PatchUserStateSpaceResponse
func (c *ClientWithResponses) PatchUserStateSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchUserStateSpaceResponse, error) {
	rsp, err := c.PatchUserStateSpaceWithBody(ctx, spaceId, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchUserStateSpaceResponse(rsp)
}

func (c *ClientWithResponses) PatchUserStateSpaceWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, body PatchUserStateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchUserStateSpaceResponse, error) {
	rsp, err := c.PatchUserStateSpace(ctx, spaceId, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchUserStateSpaceResponse(rsp)
}

// AssignUserToSpaceWithResponse request returning *AssignUserToSpaceResponse
func (c *ClientWithResponses) AssignUserToSpaceWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*AssignUserToSpaceResponse, error) {
	rsp, err := c.AssignUserToSpace(ctx, spaceId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignUserToSpaceResponse(rsp)
}

// UpdateUserSpaceWithBodyWithResponse request with arbitrary body returning *UpdateUserSpaceResponse
func (c *ClientWithResponses) UpdateUserSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserSpaceResponse, error) {
	rsp, err := c.UpdateUserSpaceWithBody(ctx, spaceId, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserSpaceResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserSpaceWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, body UpdateUserSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserSpaceResponse, error) {
	rsp, err := c.UpdateUserSpace(ctx, spaceId, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserSpaceResponse(rsp)
}

// GetACLUserSpaceWithResponse request returning *GetACLUserSpaceResponse
func (c *ClientWithResponses) GetACLUserSpaceWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, params *GetACLUserSpaceParams, reqEditors ...RequestEditorFn) (*GetACLUserSpaceResponse, error) {
	rsp, err := c.GetACLUserSpace(ctx, spaceId, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetACLUserSpaceResponse(rsp)
}

// DeleteACLUserSpaceBulkWithBodyWithResponse request with arbitrary body returning *DeleteACLUserSpaceBulkResponse
func (c *ClientWithResponses) DeleteACLUserSpaceBulkWithBodyWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteACLUserSpaceBulkResponse, error) {
	rsp, err := c.DeleteACLUserSpaceBulkWithBody(ctx, spaceId, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteACLUserSpaceBulkResponse(rsp)
}

func (c *ClientWithResponses) DeleteACLUserSpaceBulkWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, body DeleteACLUserSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteACLUserSpaceBulkResponse, error) {
	rsp, err := c.DeleteACLUserSpaceBulk(ctx, spaceId, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteACLUserSpaceBulkResponse(rsp)
}

// CreateACLUserSpaceBulkWithBodyWithResponse request with arbitrary body returning *CreateACLUserSpaceBulkResponse
func (c *ClientWithResponses) CreateACLUserSpaceBulkWithBodyWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateACLUserSpaceBulkResponse, error) {
	rsp, err := c.CreateACLUserSpaceBulkWithBody(ctx, spaceId, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateACLUserSpaceBulkResponse(rsp)
}

func (c *ClientWithResponses) CreateACLUserSpaceBulkWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, body CreateACLUserSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateACLUserSpaceBulkResponse, error) {
	rsp, err := c.CreateACLUserSpaceBulk(ctx, spaceId, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateACLUserSpaceBulkResponse(rsp)
}

// RecoverUserSpaceWithResponse request returning *RecoverUserSpaceResponse
func (c *ClientWithResponses) RecoverUserSpaceWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*RecoverUserSpaceResponse, error) {
	rsp, err := c.RecoverUserSpace(ctx, spaceId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRecoverUserSpaceResponse(rsp)
}

// TokenWithBodyWithResponse request with arbitrary body returning *TokenResponse
func (c *ClientWithResponses) TokenWithBodyWithResponse(ctx context.Context, params *TokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TokenResponse, error) {
	rsp, err := c.TokenWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTokenResponse(rsp)
}

func (c *ClientWithResponses) TokenWithFormdataBodyWithResponse(ctx context.Context, params *TokenParams, body TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*TokenResponse, error) {
	rsp, err := c.TokenWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTokenResponse(rsp)
}

// GetUserInfoWithResponse request returning *GetUserInfoResponse
func (c *ClientWithResponses) GetUserInfoWithResponse(ctx context.Context, params *GetUserInfoParams, reqEditors ...RequestEditorFn) (*GetUserInfoResponse, error) {
	rsp, err := c.GetUserInfo(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserInfoResponse(rsp)
}

// HealthcheckWithResponse request returning *HealthcheckResponse
func (c *ClientWithResponses) HealthcheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthcheckResponse, error) {
	rsp, err := c.Healthcheck(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHealthcheckResponse(rsp)
}

// ListKubernetesClustersWithResponse request returning *ListKubernetesClustersResponse
func (c *ClientWithResponses) ListKubernetesClustersWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*ListKubernetesClustersResponse, error) {
	rsp, err := c.ListKubernetesClusters(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListKubernetesClustersResponse(rsp)
}

// CreateKubernetesClusterWithBodyWithResponse request with arbitrary body returning *CreateKubernetesClusterResponse
func (c *ClientWithResponses) CreateKubernetesClusterWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKubernetesClusterResponse, error) {
	rsp, err := c.CreateKubernetesClusterWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKubernetesClusterResponse(rsp)
}

func (c *ClientWithResponses) CreateKubernetesClusterWithResponse(ctx context.Context, spaceId SpaceId, body CreateKubernetesClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKubernetesClusterResponse, error) {
	rsp, err := c.CreateKubernetesCluster(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKubernetesClusterResponse(rsp)
}

// DeleteKubernetesClusterByIdWithResponse request returning *DeleteKubernetesClusterByIdResponse
func (c *ClientWithResponses) DeleteKubernetesClusterByIdWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*DeleteKubernetesClusterByIdResponse, error) {
	rsp, err := c.DeleteKubernetesClusterById(ctx, spaceId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteKubernetesClusterByIdResponse(rsp)
}

// GetKubernetesClusterByIdWithResponse request returning *GetKubernetesClusterByIdResponse
func (c *ClientWithResponses) GetKubernetesClusterByIdWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*GetKubernetesClusterByIdResponse, error) {
	rsp, err := c.GetKubernetesClusterById(ctx, spaceId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKubernetesClusterByIdResponse(rsp)
}

// GetKubeConfigWithResponse request returning *GetKubeConfigResponse
func (c *ClientWithResponses) GetKubeConfigWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*GetKubeConfigResponse, error) {
	rsp, err := c.GetKubeConfig(ctx, spaceId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKubeConfigResponse(rsp)
}

// UpgradeMastersWithBodyWithResponse request with arbitrary body returning *UpgradeMastersResponse
func (c *ClientWithResponses) UpgradeMastersWithBodyWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpgradeMastersResponse, error) {
	rsp, err := c.UpgradeMastersWithBody(ctx, spaceId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpgradeMastersResponse(rsp)
}

func (c *ClientWithResponses) UpgradeMastersWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, body UpgradeMastersJSONRequestBody, reqEditors ...RequestEditorFn) (*UpgradeMastersResponse, error) {
	rsp, err := c.UpgradeMasters(ctx, spaceId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpgradeMastersResponse(rsp)
}

// AddNodesWithBodyWithResponse request with arbitrary body returning *AddNodesResponse
func (c *ClientWithResponses) AddNodesWithBodyWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddNodesResponse, error) {
	rsp, err := c.AddNodesWithBody(ctx, spaceId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddNodesResponse(rsp)
}

func (c *ClientWithResponses) AddNodesWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, body AddNodesJSONRequestBody, reqEditors ...RequestEditorFn) (*AddNodesResponse, error) {
	rsp, err := c.AddNodes(ctx, spaceId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddNodesResponse(rsp)
}

// RemoveNodesWithBodyWithResponse request with arbitrary body returning *RemoveNodesResponse
func (c *ClientWithResponses) RemoveNodesWithBodyWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveNodesResponse, error) {
	rsp, err := c.RemoveNodesWithBody(ctx, spaceId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNodesResponse(rsp)
}

func (c *ClientWithResponses) RemoveNodesWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, body RemoveNodesJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveNodesResponse, error) {
	rsp, err := c.RemoveNodes(ctx, spaceId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveNodesResponse(rsp)
}

// UpgradeNodesWithBodyWithResponse request with arbitrary body returning *UpgradeNodesResponse
func (c *ClientWithResponses) UpgradeNodesWithBodyWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpgradeNodesResponse, error) {
	rsp, err := c.UpgradeNodesWithBody(ctx, spaceId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpgradeNodesResponse(rsp)
}

func (c *ClientWithResponses) UpgradeNodesWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, body UpgradeNodesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpgradeNodesResponse, error) {
	rsp, err := c.UpgradeNodes(ctx, spaceId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpgradeNodesResponse(rsp)
}

// ListOperationWithResponse request returning *ListOperationResponse
func (c *ClientWithResponses) ListOperationWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*ListOperationResponse, error) {
	rsp, err := c.ListOperation(ctx, spaceId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListOperationResponse(rsp)
}

// GetPrivateKeyWithResponse request returning *GetPrivateKeyResponse
func (c *ClientWithResponses) GetPrivateKeyWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*GetPrivateKeyResponse, error) {
	rsp, err := c.GetPrivateKey(ctx, spaceId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPrivateKeyResponse(rsp)
}

// GetClusterStatusWithResponse request returning *GetClusterStatusResponse
func (c *ClientWithResponses) GetClusterStatusWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*GetClusterStatusResponse, error) {
	rsp, err := c.GetClusterStatus(ctx, spaceId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterStatusResponse(rsp)
}

// UpdateNodesWithResponse request returning *UpdateNodesResponse
func (c *ClientWithResponses) UpdateNodesWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*UpdateNodesResponse, error) {
	rsp, err := c.UpdateNodes(ctx, spaceId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNodesResponse(rsp)
}

// GetOperationByIdWithResponse request returning *GetOperationByIdResponse
func (c *ClientWithResponses) GetOperationByIdWithResponse(ctx context.Context, spaceId SpaceId, operationId OperationId, params *GetOperationByIdParams, reqEditors ...RequestEditorFn) (*GetOperationByIdResponse, error) {
	rsp, err := c.GetOperationById(ctx, spaceId, operationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOperationByIdResponse(rsp)
}

// ListClustersWithResponse request returning *ListClustersResponse
func (c *ClientWithResponses) ListClustersWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*ListClustersResponse, error) {
	rsp, err := c.ListClusters(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListClustersResponse(rsp)
}

// CreateClusterWithBodyWithResponse request with arbitrary body returning *CreateClusterResponse
func (c *ClientWithResponses) CreateClusterWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error) {
	rsp, err := c.CreateClusterWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClusterResponse(rsp)
}

func (c *ClientWithResponses) CreateClusterWithResponse(ctx context.Context, spaceId SpaceId, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error) {
	rsp, err := c.CreateCluster(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClusterResponse(rsp)
}

// DeleteClusterWithResponse request returning *DeleteClusterResponse
func (c *ClientWithResponses) DeleteClusterWithResponse(ctx context.Context, spaceId SpaceId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*DeleteClusterResponse, error) {
	rsp, err := c.DeleteCluster(ctx, spaceId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClusterResponse(rsp)
}

// GetClusterWithResponse request returning *GetClusterResponse
func (c *ClientWithResponses) GetClusterWithResponse(ctx context.Context, spaceId SpaceId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*GetClusterResponse, error) {
	rsp, err := c.GetCluster(ctx, spaceId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterResponse(rsp)
}

// UpdateClusterWithBodyWithResponse request with arbitrary body returning *UpdateClusterResponse
func (c *ClientWithResponses) UpdateClusterWithBodyWithResponse(ctx context.Context, spaceId SpaceId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error) {
	rsp, err := c.UpdateClusterWithBody(ctx, spaceId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClusterResponse(rsp)
}

func (c *ClientWithResponses) UpdateClusterWithResponse(ctx context.Context, spaceId SpaceId, clusterId ClusterId, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error) {
	rsp, err := c.UpdateCluster(ctx, spaceId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClusterResponse(rsp)
}

// ListNodepoolsWithResponse request returning *ListNodepoolsResponse
func (c *ClientWithResponses) ListNodepoolsWithResponse(ctx context.Context, spaceId SpaceId, clusterId ClusterId, reqEditors ...RequestEditorFn) (*ListNodepoolsResponse, error) {
	rsp, err := c.ListNodepools(ctx, spaceId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListNodepoolsResponse(rsp)
}

// CreateNodePoolWithBodyWithResponse request with arbitrary body returning *CreateNodePoolResponse
func (c *ClientWithResponses) CreateNodePoolWithBodyWithResponse(ctx context.Context, spaceId SpaceId, clusterId ClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNodePoolResponse, error) {
	rsp, err := c.CreateNodePoolWithBody(ctx, spaceId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNodePoolResponse(rsp)
}

func (c *ClientWithResponses) CreateNodePoolWithResponse(ctx context.Context, spaceId SpaceId, clusterId ClusterId, body CreateNodePoolJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNodePoolResponse, error) {
	rsp, err := c.CreateNodePool(ctx, spaceId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNodePoolResponse(rsp)
}

// DeleteNodePoolWithResponse request returning *DeleteNodePoolResponse
func (c *ClientWithResponses) DeleteNodePoolWithResponse(ctx context.Context, spaceId SpaceId, clusterId ClusterId, nodePoolName NodepoolName, reqEditors ...RequestEditorFn) (*DeleteNodePoolResponse, error) {
	rsp, err := c.DeleteNodePool(ctx, spaceId, clusterId, nodePoolName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNodePoolResponse(rsp)
}

// UpdateNodepoolWithBodyWithResponse request with arbitrary body returning *UpdateNodepoolResponse
func (c *ClientWithResponses) UpdateNodepoolWithBodyWithResponse(ctx context.Context, spaceId SpaceId, clusterId ClusterId, nodePoolName NodepoolName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNodepoolResponse, error) {
	rsp, err := c.UpdateNodepoolWithBody(ctx, spaceId, clusterId, nodePoolName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNodepoolResponse(rsp)
}

func (c *ClientWithResponses) UpdateNodepoolWithResponse(ctx context.Context, spaceId SpaceId, clusterId ClusterId, nodePoolName NodepoolName, body UpdateNodepoolJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNodepoolResponse, error) {
	rsp, err := c.UpdateNodepool(ctx, spaceId, clusterId, nodePoolName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNodepoolResponse(rsp)
}

// ListOperationsWithResponse request returning *ListOperationsResponse
func (c *ClientWithResponses) ListOperationsWithResponse(ctx context.Context, spaceId SpaceId, params *ListOperationsParams, reqEditors ...RequestEditorFn) (*ListOperationsResponse, error) {
	rsp, err := c.ListOperations(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListOperationsResponse(rsp)
}

// GetOperationWithResponse request returning *GetOperationResponse
func (c *ClientWithResponses) GetOperationWithResponse(ctx context.Context, spaceId SpaceId, id IdUuid, reqEditors ...RequestEditorFn) (*GetOperationResponse, error) {
	rsp, err := c.GetOperation(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOperationResponse(rsp)
}

// ListVersionsWithResponse request returning *ListVersionsResponse
func (c *ClientWithResponses) ListVersionsWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*ListVersionsResponse, error) {
	rsp, err := c.ListVersions(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVersionsResponse(rsp)
}

// ListSpacesWithBodyWithResponse request with arbitrary body returning *ListSpacesResponse
func (c *ClientWithResponses) ListSpacesWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, params *ListSpacesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListSpacesResponse, error) {
	rsp, err := c.ListSpacesWithBody(ctx, organisationId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSpacesResponse(rsp)
}

func (c *ClientWithResponses) ListSpacesWithResponse(ctx context.Context, organisationId OrganisationId, params *ListSpacesParams, body ListSpacesJSONRequestBody, reqEditors ...RequestEditorFn) (*ListSpacesResponse, error) {
	rsp, err := c.ListSpaces(ctx, organisationId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSpacesResponse(rsp)
}

// CreateSpaceWithBodyWithResponse request with arbitrary body returning *CreateSpaceResponse
func (c *ClientWithResponses) CreateSpaceWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpaceResponse, error) {
	rsp, err := c.CreateSpaceWithBody(ctx, organisationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpaceResponse(rsp)
}

func (c *ClientWithResponses) CreateSpaceWithResponse(ctx context.Context, organisationId OrganisationId, body CreateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpaceResponse, error) {
	rsp, err := c.CreateSpace(ctx, organisationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpaceResponse(rsp)
}

// DeleteSpaceWithResponse request returning *DeleteSpaceResponse
func (c *ClientWithResponses) DeleteSpaceWithResponse(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, reqEditors ...RequestEditorFn) (*DeleteSpaceResponse, error) {
	rsp, err := c.DeleteSpace(ctx, organisationId, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSpaceResponse(rsp)
}

// GetSpaceByIdWithResponse request returning *GetSpaceByIdResponse
func (c *ClientWithResponses) GetSpaceByIdWithResponse(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, reqEditors ...RequestEditorFn) (*GetSpaceByIdResponse, error) {
	rsp, err := c.GetSpaceById(ctx, organisationId, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpaceByIdResponse(rsp)
}

// UpdateSpaceWithBodyWithResponse request with arbitrary body returning *UpdateSpaceResponse
func (c *ClientWithResponses) UpdateSpaceWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSpaceResponse, error) {
	rsp, err := c.UpdateSpaceWithBody(ctx, organisationId, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSpaceResponse(rsp)
}

func (c *ClientWithResponses) UpdateSpaceWithResponse(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, body UpdateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSpaceResponse, error) {
	rsp, err := c.UpdateSpace(ctx, organisationId, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSpaceResponse(rsp)
}

// ParseDeleteLoadBalancerTagsResponse parses an HTTP response from a DeleteLoadBalancerTagsWithResponse call
func ParseDeleteLoadBalancerTagsResponse(rsp *http.Response) (*DeleteLoadBalancerTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLoadBalancerTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateLoadBalancerTagsResponse parses an HTTP response from a CreateLoadBalancerTagsWithResponse call
func ParseCreateLoadBalancerTagsResponse(rsp *http.Response) (*CreateLoadBalancerTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLoadBalancerTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteTagsResponse parses an HTTP response from a DeleteTagsWithResponse call
func ParseDeleteTagsResponse(rsp *http.Response) (*DeleteTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateTagsResponse parses an HTTP response from a CreateTagsWithResponse call
func ParseCreateTagsResponse(rsp *http.Response) (*CreateTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadClientGatewaysResponse parses an HTTP response from a ReadClientGatewaysWithResponse call
func ParseReadClientGatewaysResponse(rsp *http.Response) (*ReadClientGatewaysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadClientGatewaysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadClientGatewaysResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateClientGatewayResponse parses an HTTP response from a CreateClientGatewayWithResponse call
func ParseCreateClientGatewayResponse(rsp *http.Response) (*CreateClientGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateClientGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateClientGatewayResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteClientGatewayResponse parses an HTTP response from a DeleteClientGatewayWithResponse call
func ParseDeleteClientGatewayResponse(rsp *http.Response) (*DeleteClientGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClientGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadClientGatewaysByIdResponse parses an HTTP response from a ReadClientGatewaysByIdWithResponse call
func ParseReadClientGatewaysByIdResponse(rsp *http.Response) (*ReadClientGatewaysByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadClientGatewaysByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadClientGatewaysByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadDhcpOptionsResponse parses an HTTP response from a ReadDhcpOptionsWithResponse call
func ParseReadDhcpOptionsResponse(rsp *http.Response) (*ReadDhcpOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadDhcpOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadDhcpOptionsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateDhcpOptionsResponse parses an HTTP response from a CreateDhcpOptionsWithResponse call
func ParseCreateDhcpOptionsResponse(rsp *http.Response) (*CreateDhcpOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDhcpOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateDhcpOptionsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteDhcpOptionsResponse parses an HTTP response from a DeleteDhcpOptionsWithResponse call
func ParseDeleteDhcpOptionsResponse(rsp *http.Response) (*DeleteDhcpOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDhcpOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadDhcpOptionsByIdResponse parses an HTTP response from a ReadDhcpOptionsByIdWithResponse call
func ParseReadDhcpOptionsByIdResponse(rsp *http.Response) (*ReadDhcpOptionsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadDhcpOptionsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadDhcpOptionsByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadFlexibleGpusResponse parses an HTTP response from a ReadFlexibleGpusWithResponse call
func ParseReadFlexibleGpusResponse(rsp *http.Response) (*ReadFlexibleGpusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadFlexibleGpusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadFlexibleGpusResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateFlexibleGpuResponse parses an HTTP response from a CreateFlexibleGpuWithResponse call
func ParseCreateFlexibleGpuResponse(rsp *http.Response) (*CreateFlexibleGpuResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFlexibleGpuResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateFlexibleGpuResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteFlexibleGpuResponse parses an HTTP response from a DeleteFlexibleGpuWithResponse call
func ParseDeleteFlexibleGpuResponse(rsp *http.Response) (*DeleteFlexibleGpuResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFlexibleGpuResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadFlexibleGpusByIdResponse parses an HTTP response from a ReadFlexibleGpusByIdWithResponse call
func ParseReadFlexibleGpusByIdResponse(rsp *http.Response) (*ReadFlexibleGpusByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadFlexibleGpusByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadFlexibleGpusByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateFlexibleGpuResponse parses an HTTP response from a UpdateFlexibleGpuWithResponse call
func ParseUpdateFlexibleGpuResponse(rsp *http.Response) (*UpdateFlexibleGpuResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateFlexibleGpuResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateFlexibleGpuResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseLinkFlexibleGpuResponse parses an HTTP response from a LinkFlexibleGpuWithResponse call
func ParseLinkFlexibleGpuResponse(rsp *http.Response) (*LinkFlexibleGpuResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkFlexibleGpuResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnlinkFlexibleGpuResponse parses an HTTP response from a UnlinkFlexibleGpuWithResponse call
func ParseUnlinkFlexibleGpuResponse(rsp *http.Response) (*UnlinkFlexibleGpuResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkFlexibleGpuResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadImagesResponse parses an HTTP response from a ReadImagesWithResponse call
func ParseReadImagesResponse(rsp *http.Response) (*ReadImagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadImagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadImagesResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateImageResponse parses an HTTP response from a CreateImageWithResponse call
func ParseCreateImageResponse(rsp *http.Response) (*CreateImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateImageResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteImageResponse parses an HTTP response from a DeleteImageWithResponse call
func ParseDeleteImageResponse(rsp *http.Response) (*DeleteImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadImagesByIdResponse parses an HTTP response from a ReadImagesByIdWithResponse call
func ParseReadImagesByIdResponse(rsp *http.Response) (*ReadImagesByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadImagesByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadImagesByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateImageResponse parses an HTTP response from a UpdateImageWithResponse call
func ParseUpdateImageResponse(rsp *http.Response) (*UpdateImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateImageResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadInternetGatewaysResponse parses an HTTP response from a ReadInternetGatewaysWithResponse call
func ParseReadInternetGatewaysResponse(rsp *http.Response) (*ReadInternetGatewaysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadInternetGatewaysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadInternetGatewaysResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateInternetGatewayResponse parses an HTTP response from a CreateInternetGatewayWithResponse call
func ParseCreateInternetGatewayResponse(rsp *http.Response) (*CreateInternetGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateInternetGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateInternetGatewayResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteInternetGatewayResponse parses an HTTP response from a DeleteInternetGatewayWithResponse call
func ParseDeleteInternetGatewayResponse(rsp *http.Response) (*DeleteInternetGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteInternetGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadInternetGatewaysByIdResponse parses an HTTP response from a ReadInternetGatewaysByIdWithResponse call
func ParseReadInternetGatewaysByIdResponse(rsp *http.Response) (*ReadInternetGatewaysByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadInternetGatewaysByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadInternetGatewaysByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseLinkInternetGatewayResponse parses an HTTP response from a LinkInternetGatewayWithResponse call
func ParseLinkInternetGatewayResponse(rsp *http.Response) (*LinkInternetGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkInternetGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnlinkInternetGatewayResponse parses an HTTP response from a UnlinkInternetGatewayWithResponse call
func ParseUnlinkInternetGatewayResponse(rsp *http.Response) (*UnlinkInternetGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkInternetGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadKeypairsResponse parses an HTTP response from a ReadKeypairsWithResponse call
func ParseReadKeypairsResponse(rsp *http.Response) (*ReadKeypairsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadKeypairsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadKeypairsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateKeypairResponse parses an HTTP response from a CreateKeypairWithResponse call
func ParseCreateKeypairResponse(rsp *http.Response) (*CreateKeypairResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateKeypairResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateKeypairResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteKeypairResponse parses an HTTP response from a DeleteKeypairWithResponse call
func ParseDeleteKeypairResponse(rsp *http.Response) (*DeleteKeypairResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteKeypairResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadKeypairsByIdResponse parses an HTTP response from a ReadKeypairsByIdWithResponse call
func ParseReadKeypairsByIdResponse(rsp *http.Response) (*ReadKeypairsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadKeypairsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadKeypairsByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadListenerRulesResponse parses an HTTP response from a ReadListenerRulesWithResponse call
func ParseReadListenerRulesResponse(rsp *http.Response) (*ReadListenerRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadListenerRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadListenerRulesResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateListenerRuleResponse parses an HTTP response from a CreateListenerRuleWithResponse call
func ParseCreateListenerRuleResponse(rsp *http.Response) (*CreateListenerRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateListenerRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateListenerRuleResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteListenerRuleResponse parses an HTTP response from a DeleteListenerRuleWithResponse call
func ParseDeleteListenerRuleResponse(rsp *http.Response) (*DeleteListenerRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteListenerRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadListenerRulesByIdResponse parses an HTTP response from a ReadListenerRulesByIdWithResponse call
func ParseReadListenerRulesByIdResponse(rsp *http.Response) (*ReadListenerRulesByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadListenerRulesByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadListenerRulesByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateListenerRuleResponse parses an HTTP response from a UpdateListenerRuleWithResponse call
func ParseUpdateListenerRuleResponse(rsp *http.Response) (*UpdateListenerRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateListenerRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateListenerRuleResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadLoadBalancersResponse parses an HTTP response from a ReadLoadBalancersWithResponse call
func ParseReadLoadBalancersResponse(rsp *http.Response) (*ReadLoadBalancersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadLoadBalancersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadLoadBalancersResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateLoadBalancerResponse parses an HTTP response from a CreateLoadBalancerWithResponse call
func ParseCreateLoadBalancerResponse(rsp *http.Response) (*CreateLoadBalancerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLoadBalancerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateLoadBalancerResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteLoadBalancerResponse parses an HTTP response from a DeleteLoadBalancerWithResponse call
func ParseDeleteLoadBalancerResponse(rsp *http.Response) (*DeleteLoadBalancerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLoadBalancerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadLoadBalancersByIdResponse parses an HTTP response from a ReadLoadBalancersByIdWithResponse call
func ParseReadLoadBalancersByIdResponse(rsp *http.Response) (*ReadLoadBalancersByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadLoadBalancersByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadLoadBalancersByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateLoadBalancerResponse parses an HTTP response from a UpdateLoadBalancerWithResponse call
func ParseUpdateLoadBalancerResponse(rsp *http.Response) (*UpdateLoadBalancerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateLoadBalancerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateLoadBalancerResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseLinkLoadBalancerBackendMachinesResponse parses an HTTP response from a LinkLoadBalancerBackendMachinesWithResponse call
func ParseLinkLoadBalancerBackendMachinesResponse(rsp *http.Response) (*LinkLoadBalancerBackendMachinesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkLoadBalancerBackendMachinesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnlinkLoadBalancerBackendMachinesResponse parses an HTTP response from a UnlinkLoadBalancerBackendMachinesWithResponse call
func ParseUnlinkLoadBalancerBackendMachinesResponse(rsp *http.Response) (*UnlinkLoadBalancerBackendMachinesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkLoadBalancerBackendMachinesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteLoadBalancerListenersResponse parses an HTTP response from a DeleteLoadBalancerListenersWithResponse call
func ParseDeleteLoadBalancerListenersResponse(rsp *http.Response) (*DeleteLoadBalancerListenersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLoadBalancerListenersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateLoadBalancerListenersResponse parses an HTTP response from a CreateLoadBalancerListenersWithResponse call
func ParseCreateLoadBalancerListenersResponse(rsp *http.Response) (*CreateLoadBalancerListenersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLoadBalancerListenersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateLoadBalancerListenersResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteLoadBalancerPolicyResponse parses an HTTP response from a DeleteLoadBalancerPolicyWithResponse call
func ParseDeleteLoadBalancerPolicyResponse(rsp *http.Response) (*DeleteLoadBalancerPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLoadBalancerPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateLoadBalancerPolicyResponse parses an HTTP response from a CreateLoadBalancerPolicyWithResponse call
func ParseCreateLoadBalancerPolicyResponse(rsp *http.Response) (*CreateLoadBalancerPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLoadBalancerPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateLoadBalancerPolicyResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadVmsHealthResponse parses an HTTP response from a ReadVmsHealthWithResponse call
func ParseReadVmsHealthResponse(rsp *http.Response) (*ReadVmsHealthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVmsHealthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVmsHealthResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadLoadBalancerTagsResponse parses an HTTP response from a ReadLoadBalancerTagsWithResponse call
func ParseReadLoadBalancerTagsResponse(rsp *http.Response) (*ReadLoadBalancerTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadLoadBalancerTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadLoadBalancerTagsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadNatGatewayResponse parses an HTTP response from a ReadNatGatewayWithResponse call
func ParseReadNatGatewayResponse(rsp *http.Response) (*ReadNatGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadNatGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadNatGatewayResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateNatGatewayResponse parses an HTTP response from a CreateNatGatewayWithResponse call
func ParseCreateNatGatewayResponse(rsp *http.Response) (*CreateNatGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNatGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateNatGatewayResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteNatGatewayResponse parses an HTTP response from a DeleteNatGatewayWithResponse call
func ParseDeleteNatGatewayResponse(rsp *http.Response) (*DeleteNatGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNatGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadNatGatewayByIdResponse parses an HTTP response from a ReadNatGatewayByIdWithResponse call
func ParseReadNatGatewayByIdResponse(rsp *http.Response) (*ReadNatGatewayByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadNatGatewayByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadNatGatewayByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadNicsResponse parses an HTTP response from a ReadNicsWithResponse call
func ParseReadNicsResponse(rsp *http.Response) (*ReadNicsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadNicsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadNicsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateNicResponse parses an HTTP response from a CreateNicWithResponse call
func ParseCreateNicResponse(rsp *http.Response) (*CreateNicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateNicResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteNicResponse parses an HTTP response from a DeleteNicWithResponse call
func ParseDeleteNicResponse(rsp *http.Response) (*DeleteNicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadNicsByIdResponse parses an HTTP response from a ReadNicsByIdWithResponse call
func ParseReadNicsByIdResponse(rsp *http.Response) (*ReadNicsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadNicsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadNicsByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateNicResponse parses an HTTP response from a UpdateNicWithResponse call
func ParseUpdateNicResponse(rsp *http.Response) (*UpdateNicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateNicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateNicResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseLinkPrivateIpsResponse parses an HTTP response from a LinkPrivateIpsWithResponse call
func ParseLinkPrivateIpsResponse(rsp *http.Response) (*LinkPrivateIpsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkPrivateIpsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnlinkPrivateIpsResponse parses an HTTP response from a UnlinkPrivateIpsWithResponse call
func ParseUnlinkPrivateIpsResponse(rsp *http.Response) (*UnlinkPrivateIpsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkPrivateIpsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseLinkNicResponse parses an HTTP response from a LinkNicWithResponse call
func ParseLinkNicResponse(rsp *http.Response) (*LinkNicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkNicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinkNicResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnlinkNicResponse parses an HTTP response from a UnlinkNicWithResponse call
func ParseUnlinkNicResponse(rsp *http.Response) (*UnlinkNicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkNicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadPublicIpRangesResponse parses an HTTP response from a ReadPublicIpRangesWithResponse call
func ParseReadPublicIpRangesResponse(rsp *http.Response) (*ReadPublicIpRangesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadPublicIpRangesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadPublicIpRangesResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadPublicIpsResponse parses an HTTP response from a ReadPublicIpsWithResponse call
func ParseReadPublicIpsResponse(rsp *http.Response) (*ReadPublicIpsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadPublicIpsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadPublicIpsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreatePublicIpResponse parses an HTTP response from a CreatePublicIpWithResponse call
func ParseCreatePublicIpResponse(rsp *http.Response) (*CreatePublicIpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePublicIpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreatePublicIpResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeletePublicIpResponse parses an HTTP response from a DeletePublicIpWithResponse call
func ParseDeletePublicIpResponse(rsp *http.Response) (*DeletePublicIpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePublicIpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadPublicIpsByIdResponse parses an HTTP response from a ReadPublicIpsByIdWithResponse call
func ParseReadPublicIpsByIdResponse(rsp *http.Response) (*ReadPublicIpsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadPublicIpsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadPublicIpsByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseLinkPublicIpResponse parses an HTTP response from a LinkPublicIpWithResponse call
func ParseLinkPublicIpResponse(rsp *http.Response) (*LinkPublicIpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkPublicIpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinkPublicIpResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnlinkPublicIpResponse parses an HTTP response from a UnlinkPublicIpWithResponse call
func ParseUnlinkPublicIpResponse(rsp *http.Response) (*UnlinkPublicIpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkPublicIpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadRouteTablesResponse parses an HTTP response from a ReadRouteTablesWithResponse call
func ParseReadRouteTablesResponse(rsp *http.Response) (*ReadRouteTablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadRouteTablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadRouteTablesResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateRouteTableResponse parses an HTTP response from a CreateRouteTableWithResponse call
func ParseCreateRouteTableResponse(rsp *http.Response) (*CreateRouteTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRouteTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateRouteTableResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteRouteTableResponse parses an HTTP response from a DeleteRouteTableWithResponse call
func ParseDeleteRouteTableResponse(rsp *http.Response) (*DeleteRouteTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRouteTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadRouteTablesByIdResponse parses an HTTP response from a ReadRouteTablesByIdWithResponse call
func ParseReadRouteTablesByIdResponse(rsp *http.Response) (*ReadRouteTablesByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadRouteTablesByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadRouteTablesByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateRouteTableRoutePropagationResponse parses an HTTP response from a UpdateRouteTableRoutePropagationWithResponse call
func ParseUpdateRouteTableRoutePropagationResponse(rsp *http.Response) (*UpdateRouteTableRoutePropagationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRouteTableRoutePropagationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateRouteTableRoutePropagationResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteRouteResponse parses an HTTP response from a DeleteRouteWithResponse call
func ParseDeleteRouteResponse(rsp *http.Response) (*DeleteRouteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRouteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateRouteResponse parses an HTTP response from a CreateRouteWithResponse call
func ParseCreateRouteResponse(rsp *http.Response) (*CreateRouteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRouteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateRouteResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateRouteResponse parses an HTTP response from a UpdateRouteWithResponse call
func ParseUpdateRouteResponse(rsp *http.Response) (*UpdateRouteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRouteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateRouteResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseLinkRouteTableResponse parses an HTTP response from a LinkRouteTableWithResponse call
func ParseLinkRouteTableResponse(rsp *http.Response) (*LinkRouteTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkRouteTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinkRouteTableResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnlinkRouteTableResponse parses an HTTP response from a UnlinkRouteTableWithResponse call
func ParseUnlinkRouteTableResponse(rsp *http.Response) (*UnlinkRouteTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkRouteTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadSecurityGroupsResponse parses an HTTP response from a ReadSecurityGroupsWithResponse call
func ParseReadSecurityGroupsResponse(rsp *http.Response) (*ReadSecurityGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadSecurityGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadSecurityGroupsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateSecurityGroupResponse parses an HTTP response from a CreateSecurityGroupWithResponse call
func ParseCreateSecurityGroupResponse(rsp *http.Response) (*CreateSecurityGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSecurityGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateSecurityGroupResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSecurityGroupResponse parses an HTTP response from a DeleteSecurityGroupWithResponse call
func ParseDeleteSecurityGroupResponse(rsp *http.Response) (*DeleteSecurityGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSecurityGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadSecurityGroupsByIdResponse parses an HTTP response from a ReadSecurityGroupsByIdWithResponse call
func ParseReadSecurityGroupsByIdResponse(rsp *http.Response) (*ReadSecurityGroupsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadSecurityGroupsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadSecurityGroupsByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSecurityGroupRuleResponse parses an HTTP response from a DeleteSecurityGroupRuleWithResponse call
func ParseDeleteSecurityGroupRuleResponse(rsp *http.Response) (*DeleteSecurityGroupRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSecurityGroupRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateSecurityGroupRuleResponse parses an HTTP response from a CreateSecurityGroupRuleWithResponse call
func ParseCreateSecurityGroupRuleResponse(rsp *http.Response) (*CreateSecurityGroupRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSecurityGroupRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateSecurityGroupRuleResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadServerCertificatesResponse parses an HTTP response from a ReadServerCertificatesWithResponse call
func ParseReadServerCertificatesResponse(rsp *http.Response) (*ReadServerCertificatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadServerCertificatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadServerCertificatesResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateServerCertificateResponse parses an HTTP response from a CreateServerCertificateWithResponse call
func ParseCreateServerCertificateResponse(rsp *http.Response) (*CreateServerCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServerCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateServerCertificateResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteServerCertificateResponse parses an HTTP response from a DeleteServerCertificateWithResponse call
func ParseDeleteServerCertificateResponse(rsp *http.Response) (*DeleteServerCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServerCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateServerCertificateResponse parses an HTTP response from a UpdateServerCertificateWithResponse call
func ParseUpdateServerCertificateResponse(rsp *http.Response) (*UpdateServerCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateServerCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest UpdateServerCertificateResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadSnapshotsResponse parses an HTTP response from a ReadSnapshotsWithResponse call
func ParseReadSnapshotsResponse(rsp *http.Response) (*ReadSnapshotsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadSnapshotsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadSnapshotsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateSnapshotResponse parses an HTTP response from a CreateSnapshotWithResponse call
func ParseCreateSnapshotResponse(rsp *http.Response) (*CreateSnapshotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSnapshotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateSnapshotResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSnapshotResponse parses an HTTP response from a DeleteSnapshotWithResponse call
func ParseDeleteSnapshotResponse(rsp *http.Response) (*DeleteSnapshotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSnapshotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadSnapshotsByIdResponse parses an HTTP response from a ReadSnapshotsByIdWithResponse call
func ParseReadSnapshotsByIdResponse(rsp *http.Response) (*ReadSnapshotsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadSnapshotsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadSnapshotsByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadSubnetsResponse parses an HTTP response from a ReadSubnetsWithResponse call
func ParseReadSubnetsResponse(rsp *http.Response) (*ReadSubnetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadSubnetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadSubnetsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateSubnetResponse parses an HTTP response from a CreateSubnetWithResponse call
func ParseCreateSubnetResponse(rsp *http.Response) (*CreateSubnetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSubnetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateSubnetResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSubnetResponse parses an HTTP response from a DeleteSubnetWithResponse call
func ParseDeleteSubnetResponse(rsp *http.Response) (*DeleteSubnetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSubnetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadSubnetsByIdResponse parses an HTTP response from a ReadSubnetsByIdWithResponse call
func ParseReadSubnetsByIdResponse(rsp *http.Response) (*ReadSubnetsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadSubnetsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadSubnetsByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateSubnetResponse parses an HTTP response from a UpdateSubnetWithResponse call
func ParseUpdateSubnetResponse(rsp *http.Response) (*UpdateSubnetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSubnetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateSubnetResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadTagsResponse parses an HTTP response from a ReadTagsWithResponse call
func ParseReadTagsResponse(rsp *http.Response) (*ReadTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadTagsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadVirtualGatewaysResponse parses an HTTP response from a ReadVirtualGatewaysWithResponse call
func ParseReadVirtualGatewaysResponse(rsp *http.Response) (*ReadVirtualGatewaysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVirtualGatewaysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVirtualGatewaysResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateVirtualGatewayResponse parses an HTTP response from a CreateVirtualGatewayWithResponse call
func ParseCreateVirtualGatewayResponse(rsp *http.Response) (*CreateVirtualGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVirtualGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateVirtualGatewayResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteVirtualGatewayResponse parses an HTTP response from a DeleteVirtualGatewayWithResponse call
func ParseDeleteVirtualGatewayResponse(rsp *http.Response) (*DeleteVirtualGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVirtualGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadVirtualGatewaysByIdResponse parses an HTTP response from a ReadVirtualGatewaysByIdWithResponse call
func ParseReadVirtualGatewaysByIdResponse(rsp *http.Response) (*ReadVirtualGatewaysByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVirtualGatewaysByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVirtualGatewaysByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseLinkVirtualGatewayToVpcResponse parses an HTTP response from a LinkVirtualGatewayToVpcWithResponse call
func ParseLinkVirtualGatewayToVpcResponse(rsp *http.Response) (*LinkVirtualGatewayToVpcResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkVirtualGatewayToVpcResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinkVirtualGatewayToVpcResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnlinkVirtualGatewayToVpcResponse parses an HTTP response from a UnlinkVirtualGatewayToVpcWithResponse call
func ParseUnlinkVirtualGatewayToVpcResponse(rsp *http.Response) (*UnlinkVirtualGatewayToVpcResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkVirtualGatewayToVpcResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadVmsResponse parses an HTTP response from a ReadVmsWithResponse call
func ParseReadVmsResponse(rsp *http.Response) (*ReadVmsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVmsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVmsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateVmsResponse parses an HTTP response from a CreateVmsWithResponse call
func ParseCreateVmsResponse(rsp *http.Response) (*CreateVmsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVmsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateVmsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadVmsStateResponse parses an HTTP response from a ReadVmsStateWithResponse call
func ParseReadVmsStateResponse(rsp *http.Response) (*ReadVmsStateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVmsStateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVmsStateResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteVmsResponse parses an HTTP response from a DeleteVmsWithResponse call
func ParseDeleteVmsResponse(rsp *http.Response) (*DeleteVmsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVmsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadVmsByIdResponse parses an HTTP response from a ReadVmsByIdWithResponse call
func ParseReadVmsByIdResponse(rsp *http.Response) (*ReadVmsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVmsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVmsByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateVmResponse parses an HTTP response from a UpdateVmWithResponse call
func ParseUpdateVmResponse(rsp *http.Response) (*UpdateVmResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVmResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateVmResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadAdminPasswordResponse parses an HTTP response from a ReadAdminPasswordWithResponse call
func ParseReadAdminPasswordResponse(rsp *http.Response) (*ReadAdminPasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadAdminPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadAdminPasswordResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadConsoleOutputResponse parses an HTTP response from a ReadConsoleOutputWithResponse call
func ParseReadConsoleOutputResponse(rsp *http.Response) (*ReadConsoleOutputResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadConsoleOutputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadConsoleOutputResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseRebootVmResponse parses an HTTP response from a RebootVmWithResponse call
func ParseRebootVmResponse(rsp *http.Response) (*RebootVmResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RebootVmResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseStartVmResponse parses an HTTP response from a StartVmWithResponse call
func ParseStartVmResponse(rsp *http.Response) (*StartVmResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartVmResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StartVmResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseStopVmResponse parses an HTTP response from a StopVmWithResponse call
func ParseStopVmResponse(rsp *http.Response) (*StopVmResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StopVmResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StopVmResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadVolumesResponse parses an HTTP response from a ReadVolumesWithResponse call
func ParseReadVolumesResponse(rsp *http.Response) (*ReadVolumesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVolumesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVolumesResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateVolumeResponse parses an HTTP response from a CreateVolumeWithResponse call
func ParseCreateVolumeResponse(rsp *http.Response) (*CreateVolumeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateVolumeResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteVolumeResponse parses an HTTP response from a DeleteVolumeWithResponse call
func ParseDeleteVolumeResponse(rsp *http.Response) (*DeleteVolumeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadVolumesByIdResponse parses an HTTP response from a ReadVolumesByIdWithResponse call
func ParseReadVolumesByIdResponse(rsp *http.Response) (*ReadVolumesByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVolumesByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVolumesByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateVolumeResponse parses an HTTP response from a UpdateVolumeWithResponse call
func ParseUpdateVolumeResponse(rsp *http.Response) (*UpdateVolumeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateVolumeResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseLinkVolumeResponse parses an HTTP response from a LinkVolumeWithResponse call
func ParseLinkVolumeResponse(rsp *http.Response) (*LinkVolumeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkVolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnlinkVolumeResponse parses an HTTP response from a UnlinkVolumeWithResponse call
func ParseUnlinkVolumeResponse(rsp *http.Response) (*UnlinkVolumeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkVolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadVpcPeeringsResponse parses an HTTP response from a ReadVpcPeeringsWithResponse call
func ParseReadVpcPeeringsResponse(rsp *http.Response) (*ReadVpcPeeringsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVpcPeeringsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVpcPeeringsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateVpcPeeringResponse parses an HTTP response from a CreateVpcPeeringWithResponse call
func ParseCreateVpcPeeringResponse(rsp *http.Response) (*CreateVpcPeeringResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVpcPeeringResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateVpcPeeringResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteVpcPeeringResponse parses an HTTP response from a DeleteVpcPeeringWithResponse call
func ParseDeleteVpcPeeringResponse(rsp *http.Response) (*DeleteVpcPeeringResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVpcPeeringResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadVpcPeeringsByIdResponse parses an HTTP response from a ReadVpcPeeringsByIdWithResponse call
func ParseReadVpcPeeringsByIdResponse(rsp *http.Response) (*ReadVpcPeeringsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVpcPeeringsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVpcPeeringsByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseAcceptVpcPeeringResponse parses an HTTP response from a AcceptVpcPeeringWithResponse call
func ParseAcceptVpcPeeringResponse(rsp *http.Response) (*AcceptVpcPeeringResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AcceptVpcPeeringResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AcceptVpcPeeringResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseRejectVpcPeeringResponse parses an HTTP response from a RejectVpcPeeringWithResponse call
func ParseRejectVpcPeeringResponse(rsp *http.Response) (*RejectVpcPeeringResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RejectVpcPeeringResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadVpcsResponse parses an HTTP response from a ReadVpcsWithResponse call
func ParseReadVpcsResponse(rsp *http.Response) (*ReadVpcsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVpcsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVpcsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateVpcResponse parses an HTTP response from a CreateVpcWithResponse call
func ParseCreateVpcResponse(rsp *http.Response) (*CreateVpcResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVpcResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateVpcResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteVpcResponse parses an HTTP response from a DeleteVpcWithResponse call
func ParseDeleteVpcResponse(rsp *http.Response) (*DeleteVpcResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVpcResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadVpcsByIdResponse parses an HTTP response from a ReadVpcsByIdWithResponse call
func ParseReadVpcsByIdResponse(rsp *http.Response) (*ReadVpcsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVpcsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVpcsByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateVpcResponse parses an HTTP response from a UpdateVpcWithResponse call
func ParseUpdateVpcResponse(rsp *http.Response) (*UpdateVpcResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVpcResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateVpcResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadVpnConnectionsResponse parses an HTTP response from a ReadVpnConnectionsWithResponse call
func ParseReadVpnConnectionsResponse(rsp *http.Response) (*ReadVpnConnectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVpnConnectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVpnConnectionsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateVpnConnectionResponse parses an HTTP response from a CreateVpnConnectionWithResponse call
func ParseCreateVpnConnectionResponse(rsp *http.Response) (*CreateVpnConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVpnConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateVpnConnectionResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteVpnConnectionResponse parses an HTTP response from a DeleteVpnConnectionWithResponse call
func ParseDeleteVpnConnectionResponse(rsp *http.Response) (*DeleteVpnConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVpnConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadVpnConnectionsByIdResponse parses an HTTP response from a ReadVpnConnectionsByIdWithResponse call
func ParseReadVpnConnectionsByIdResponse(rsp *http.Response) (*ReadVpnConnectionsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVpnConnectionsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVpnConnectionsByIdResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateVpnConnectionResponse parses an HTTP response from a UpdateVpnConnectionWithResponse call
func ParseUpdateVpnConnectionResponse(rsp *http.Response) (*UpdateVpnConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVpnConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateVpnConnectionResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteVpnConnectionRouteResponse parses an HTTP response from a DeleteVpnConnectionRouteWithResponse call
func ParseDeleteVpnConnectionRouteResponse(rsp *http.Response) (*DeleteVpnConnectionRouteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVpnConnectionRouteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateVpnConnectionRouteResponse parses an HTTP response from a CreateVpnConnectionRouteWithResponse call
func ParseCreateVpnConnectionRouteResponse(rsp *http.Response) (*CreateVpnConnectionRouteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVpnConnectionRouteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseJsonWebKeysResponse parses an HTTP response from a JsonWebKeysWithResponse call
func ParseJsonWebKeysResponse(rsp *http.Response) (*JsonWebKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JsonWebKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JsonWebKeysResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorOauth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorOauth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDiscoverOidcConfigurationResponse parses an HTTP response from a DiscoverOidcConfigurationWithResponse call
func ParseDiscoverOidcConfigurationResponse(rsp *http.Response) (*DiscoverOidcConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DiscoverOidcConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OidcConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorOauth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetWebAuthnJavaScriptResponse parses an HTTP response from a GetWebAuthnJavaScriptWithResponse call
func ParseGetWebAuthnJavaScriptResponse(rsp *http.Response) (*GetWebAuthnJavaScriptResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWebAuthnJavaScriptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebAuthnJavaScriptResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateAdminServiceAccountSpaceResponse parses an HTTP response from a CreateAdminServiceAccountSpaceWithResponse call
func ParseCreateAdminServiceAccountSpaceResponse(rsp *http.Response) (*CreateAdminServiceAccountSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAdminServiceAccountSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateServiceAccount201ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseAuthorizeResponse parses an HTTP response from a AuthorizeWithResponse call
func ParseAuthorizeResponse(rsp *http.Response) (*AuthorizeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthorizeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorOauth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorOauth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorOauth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorOauth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseConsentResponse parses an HTTP response from a ConsentWithResponse call
func ParseConsentResponse(rsp *http.Response) (*ConsentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConsentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetFlowErrorResponse parses an HTTP response from a GetFlowErrorWithResponse call
func ParseGetFlowErrorResponse(rsp *http.Response) (*GetFlowErrorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFlowErrorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FlowError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateLoginFlowResponse parses an HTTP response from a UpdateLoginFlowWithResponse call
func ParseUpdateLoginFlowResponse(rsp *http.Response) (*UpdateLoginFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateLoginFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessfulNativeLogin
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest LoginFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorBrowserLocationChangeRequired
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateNativeLoginFlowResponse parses an HTTP response from a CreateNativeLoginFlowWithResponse call
func ParseCreateNativeLoginFlowResponse(rsp *http.Response) (*CreateNativeLoginFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNativeLoginFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoginFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBrowserLoginFlowResponse parses an HTTP response from a CreateBrowserLoginFlowWithResponse call
func ParseCreateBrowserLoginFlowResponse(rsp *http.Response) (*CreateBrowserLoginFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBrowserLoginFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoginFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLoginFlowResponse parses an HTTP response from a GetLoginFlowWithResponse call
func ParseGetLoginFlowResponse(rsp *http.Response) (*GetLoginFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLoginFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoginFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateLogoutFlowResponse parses an HTTP response from a UpdateLogoutFlowWithResponse call
func ParseUpdateLogoutFlowResponse(rsp *http.Response) (*UpdateLogoutFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateLogoutFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePerformNativeLogoutResponse parses an HTTP response from a PerformNativeLogoutWithResponse call
func ParsePerformNativeLogoutResponse(rsp *http.Response) (*PerformNativeLogoutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PerformNativeLogoutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBrowserLogoutFlowResponse parses an HTTP response from a CreateBrowserLogoutFlowWithResponse call
func ParseCreateBrowserLogoutFlowResponse(rsp *http.Response) (*CreateBrowserLogoutFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBrowserLogoutFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogoutFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseInitRecoveryFlowResponse parses an HTTP response from a InitRecoveryFlowWithResponse call
func ParseInitRecoveryFlowResponse(rsp *http.Response) (*InitRecoveryFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InitRecoveryFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecoveryFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RecoveryFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorBrowserLocationChangeRequired
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateRecoveryFlowResponse parses an HTTP response from a UpdateRecoveryFlowWithResponse call
func ParseUpdateRecoveryFlowResponse(rsp *http.Response) (*UpdateRecoveryFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRecoveryFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecoveryFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RecoveryFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorBrowserLocationChangeRequired
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateNativeRecoveryFlowResponse parses an HTTP response from a CreateNativeRecoveryFlowWithResponse call
func ParseCreateNativeRecoveryFlowResponse(rsp *http.Response) (*CreateNativeRecoveryFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNativeRecoveryFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecoveryFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBrowserRecoveryFlowResponse parses an HTTP response from a CreateBrowserRecoveryFlowWithResponse call
func ParseCreateBrowserRecoveryFlowResponse(rsp *http.Response) (*CreateBrowserRecoveryFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBrowserRecoveryFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecoveryFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRecoveryFlowResponse parses an HTTP response from a GetRecoveryFlowWithResponse call
func ParseGetRecoveryFlowResponse(rsp *http.Response) (*GetRecoveryFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRecoveryFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecoveryFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateRegistrationFlowResponse parses an HTTP response from a UpdateRegistrationFlowWithResponse call
func ParseUpdateRegistrationFlowResponse(rsp *http.Response) (*UpdateRegistrationFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRegistrationFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessfulNativeRegistration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RegistrationFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorBrowserLocationChangeRequired
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateNativeRegistrationFlowResponse parses an HTTP response from a CreateNativeRegistrationFlowWithResponse call
func ParseCreateNativeRegistrationFlowResponse(rsp *http.Response) (*CreateNativeRegistrationFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNativeRegistrationFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RegistrationFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBrowserRegistrationFlowResponse parses an HTTP response from a CreateBrowserRegistrationFlowWithResponse call
func ParseCreateBrowserRegistrationFlowResponse(rsp *http.Response) (*CreateBrowserRegistrationFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBrowserRegistrationFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RegistrationFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRegistrationFlowResponse parses an HTTP response from a GetRegistrationFlowWithResponse call
func ParseGetRegistrationFlowResponse(rsp *http.Response) (*GetRegistrationFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRegistrationFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RegistrationFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateSettingsFloResponse parses an HTTP response from a UpdateSettingsFloWithResponse call
func ParseUpdateSettingsFloResponse(rsp *http.Response) (*UpdateSettingsFloResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSettingsFloResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SettingsFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest SettingsFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorBrowserLocationChangeRequired
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateNativeSettingsFlowResponse parses an HTTP response from a CreateNativeSettingsFlowWithResponse call
func ParseCreateNativeSettingsFlowResponse(rsp *http.Response) (*CreateNativeSettingsFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNativeSettingsFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SettingsFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBrowserSettingsFlowResponse parses an HTTP response from a CreateBrowserSettingsFlowWithResponse call
func ParseCreateBrowserSettingsFlowResponse(rsp *http.Response) (*CreateBrowserSettingsFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBrowserSettingsFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SettingsFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSettingsFlowResponse parses an HTTP response from a GetSettingsFlowWithResponse call
func ParseGetSettingsFlowResponse(rsp *http.Response) (*GetSettingsFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSettingsFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SettingsFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateVerificationFlowResponse parses an HTTP response from a UpdateVerificationFlowWithResponse call
func ParseUpdateVerificationFlowResponse(rsp *http.Response) (*UpdateVerificationFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVerificationFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VerificationFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest VerificationFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateNativeVerificationFlowResponse parses an HTTP response from a CreateNativeVerificationFlowWithResponse call
func ParseCreateNativeVerificationFlowResponse(rsp *http.Response) (*CreateNativeVerificationFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNativeVerificationFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VerificationFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBrowserVerificationFlowResponse parses an HTTP response from a CreateBrowserVerificationFlowWithResponse call
func ParseCreateBrowserVerificationFlowResponse(rsp *http.Response) (*CreateBrowserVerificationFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBrowserVerificationFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VerificationFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetVerificationFlowResponse parses an HTTP response from a GetVerificationFlowWithResponse call
func ParseGetVerificationFlowResponse(rsp *http.Response) (*GetVerificationFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVerificationFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VerificationFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDisableMyOtherSessionsResponse parses an HTTP response from a DisableMyOtherSessionsWithResponse call
func ParseDisableMyOtherSessionsResponse(rsp *http.Response) (*DisableMyOtherSessionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DisableMyOtherSessionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteMySessionsCount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListMySessionsResponse parses an HTTP response from a ListMySessionsWithResponse call
func ParseListMySessionsResponse(rsp *http.Response) (*ListMySessionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMySessionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListMySessionsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseExchangeSessionTokenResponse parses an HTTP response from a ExchangeSessionTokenWithResponse call
func ParseExchangeSessionTokenResponse(rsp *http.Response) (*ExchangeSessionTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExchangeSessionTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessfulNativeLogin
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseToSessionResponse parses an HTTP response from a ToSessionWithResponse call
func ParseToSessionResponse(rsp *http.Response) (*ToSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ToSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Session
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseIntrospectResponse parses an HTTP response from a IntrospectWithResponse call
func ParseIntrospectResponse(rsp *http.Response) (*IntrospectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IntrospectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IntrospectResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorOauth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListOrganisationsIdentityResponse parses an HTTP response from a ListOrganisationsIdentityWithResponse call
func ParseListOrganisationsIdentityResponse(rsp *http.Response) (*ListOrganisationsIdentityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListOrganisationsIdentityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListUserOrganisations200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetIAMGranularPolicyOrganisationResponse parses an HTTP response from a GetIAMGranularPolicyOrganisationWithResponse call
func ParseGetIAMGranularPolicyOrganisationResponse(rsp *http.Response) (*GetIAMGranularPolicyOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIAMGranularPolicyOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetIAMGranularPolicy200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseSetIAMGranularPolicyOrganisationResponse parses an HTTP response from a SetIAMGranularPolicyOrganisationWithResponse call
func ParseSetIAMGranularPolicyOrganisationResponse(rsp *http.Response) (*SetIAMGranularPolicyOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetIAMGranularPolicyOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetIAMPolicyOrganisationResponse parses an HTTP response from a GetIAMPolicyOrganisationWithResponse call
func ParseGetIAMPolicyOrganisationResponse(rsp *http.Response) (*GetIAMPolicyOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIAMPolicyOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetIAMPolicy200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseSetIAMPolicyOrganisationResponse parses an HTTP response from a SetIAMPolicyOrganisationWithResponse call
func ParseSetIAMPolicyOrganisationResponse(rsp *http.Response) (*SetIAMPolicyOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetIAMPolicyOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListPermissionsOrganisationResponse parses an HTTP response from a ListPermissionsOrganisationWithResponse call
func ParseListPermissionsOrganisationResponse(rsp *http.Response) (*ListPermissionsOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPermissionsOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPermissions200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetPermissionOrganisationResponse parses an HTTP response from a GetPermissionOrganisationWithResponse call
func ParseGetPermissionOrganisationResponse(rsp *http.Response) (*GetPermissionOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPermissionOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPermission200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListRolesOrganisationResponse parses an HTTP response from a ListRolesOrganisationWithResponse call
func ParseListRolesOrganisationResponse(rsp *http.Response) (*ListRolesOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRolesOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListRoles200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateRoleOrganisationResponse parses an HTTP response from a CreateRoleOrganisationWithResponse call
func ParseCreateRoleOrganisationResponse(rsp *http.Response) (*CreateRoleOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRoleOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateRole200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteRoleOrganisationResponse parses an HTTP response from a DeleteRoleOrganisationWithResponse call
func ParseDeleteRoleOrganisationResponse(rsp *http.Response) (*DeleteRoleOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRoleOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetRoleOrganisationResponse parses an HTTP response from a GetRoleOrganisationWithResponse call
func ParseGetRoleOrganisationResponse(rsp *http.Response) (*GetRoleOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRoleOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetRole200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateRoleOrganisationResponse parses an HTTP response from a UpdateRoleOrganisationWithResponse call
func ParseUpdateRoleOrganisationResponse(rsp *http.Response) (*UpdateRoleOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRoleOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseRemoveRolePermissionsOrganisationResponse parses an HTTP response from a RemoveRolePermissionsOrganisationWithResponse call
func ParseRemoveRolePermissionsOrganisationResponse(rsp *http.Response) (*RemoveRolePermissionsOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveRolePermissionsOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetRolePermissionsOrganisationResponse parses an HTTP response from a GetRolePermissionsOrganisationWithResponse call
func ParseGetRolePermissionsOrganisationResponse(rsp *http.Response) (*GetRolePermissionsOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRolePermissionsOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetRolePermissions200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseAddRolePermissionsOrganisationResponse parses an HTTP response from a AddRolePermissionsOrganisationWithResponse call
func ParseAddRolePermissionsOrganisationResponse(rsp *http.Response) (*AddRolePermissionsOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddRolePermissionsOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListServiceAccountOrganisationResponse parses an HTTP response from a ListServiceAccountOrganisationWithResponse call
func ParseListServiceAccountOrganisationResponse(rsp *http.Response) (*ListServiceAccountOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListServiceAccountOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListServiceAccount200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateServiceAccountOrganisationResponse parses an HTTP response from a CreateServiceAccountOrganisationWithResponse call
func ParseCreateServiceAccountOrganisationResponse(rsp *http.Response) (*CreateServiceAccountOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServiceAccountOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateServiceAccount201ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteServiceAccountOrganisationResponse parses an HTTP response from a DeleteServiceAccountOrganisationWithResponse call
func ParseDeleteServiceAccountOrganisationResponse(rsp *http.Response) (*DeleteServiceAccountOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServiceAccountOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetServiceAccountOrganisationResponse parses an HTTP response from a GetServiceAccountOrganisationWithResponse call
func ParseGetServiceAccountOrganisationResponse(rsp *http.Response) (*GetServiceAccountOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceAccountOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetServiceAccount200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateServiceAccountOrganisationResponse parses an HTTP response from a UpdateServiceAccountOrganisationWithResponse call
func ParseUpdateServiceAccountOrganisationResponse(rsp *http.Response) (*UpdateServiceAccountOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateServiceAccountOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateServiceAccount200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetACLServiceAccountOrganisationResponse parses an HTTP response from a GetACLServiceAccountOrganisationWithResponse call
func ParseGetACLServiceAccountOrganisationResponse(rsp *http.Response) (*GetACLServiceAccountOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetACLServiceAccountOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetACL200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteACLServiceAccountOrganisationBulkResponse parses an HTTP response from a DeleteACLServiceAccountOrganisationBulkWithResponse call
func ParseDeleteACLServiceAccountOrganisationBulkResponse(rsp *http.Response) (*DeleteACLServiceAccountOrganisationBulkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteACLServiceAccountOrganisationBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateACLServiceAccountOrganisationBulkResponse parses an HTTP response from a CreateACLServiceAccountOrganisationBulkWithResponse call
func ParseCreateACLServiceAccountOrganisationBulkResponse(rsp *http.Response) (*CreateACLServiceAccountOrganisationBulkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateACLServiceAccountOrganisationBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListSpacesOfServiceAccountResponse parses an HTTP response from a ListSpacesOfServiceAccountWithResponse call
func ParseListSpacesOfServiceAccountResponse(rsp *http.Response) (*ListSpacesOfServiceAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSpacesOfServiceAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListSpacesServiceAccount200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListSpacesIdentityResponse parses an HTTP response from a ListSpacesIdentityWithResponse call
func ParseListSpacesIdentityResponse(rsp *http.Response) (*ListSpacesIdentityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSpacesIdentityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListSpacesIdentity200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListUserOrganisationResponse parses an HTTP response from a ListUserOrganisationWithResponse call
func ParseListUserOrganisationResponse(rsp *http.Response) (*ListUserOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUserOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListUser200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateUserOrganisationResponse parses an HTTP response from a CreateUserOrganisationWithResponse call
func ParseCreateUserOrganisationResponse(rsp *http.Response) (*CreateUserOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateUser201ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteUserOrganisationResponse parses an HTTP response from a DeleteUserOrganisationWithResponse call
func ParseDeleteUserOrganisationResponse(rsp *http.Response) (*DeleteUserOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetUserOrganisationResponse parses an HTTP response from a GetUserOrganisationWithResponse call
func ParseGetUserOrganisationResponse(rsp *http.Response) (*GetUserOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetUser200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParsePatchUserStateOrganisationResponse parses an HTTP response from a PatchUserStateOrganisationWithResponse call
func ParsePatchUserStateOrganisationResponse(rsp *http.Response) (*PatchUserStateOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchUserStateOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PatchUserState200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateUserOrganisationResponse parses an HTTP response from a UpdateUserOrganisationWithResponse call
func ParseUpdateUserOrganisationResponse(rsp *http.Response) (*UpdateUserOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateUser200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetACLUserOrganisationResponse parses an HTTP response from a GetACLUserOrganisationWithResponse call
func ParseGetACLUserOrganisationResponse(rsp *http.Response) (*GetACLUserOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetACLUserOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetACL200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteACLUserOrganisationBulkResponse parses an HTTP response from a DeleteACLUserOrganisationBulkWithResponse call
func ParseDeleteACLUserOrganisationBulkResponse(rsp *http.Response) (*DeleteACLUserOrganisationBulkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteACLUserOrganisationBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateACLUserOrganisationBulkResponse parses an HTTP response from a CreateACLUserOrganisationBulkWithResponse call
func ParseCreateACLUserOrganisationBulkResponse(rsp *http.Response) (*CreateACLUserOrganisationBulkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateACLUserOrganisationBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseRecoverUserOrganisationResponse parses an HTTP response from a RecoverUserOrganisationWithResponse call
func ParseRecoverUserOrganisationResponse(rsp *http.Response) (*RecoverUserOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RecoverUserOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecoverUser200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListSpacesOfUserResponse parses an HTTP response from a ListSpacesOfUserWithResponse call
func ParseListSpacesOfUserResponse(rsp *http.Response) (*ListSpacesOfUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSpacesOfUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListSpacesUser200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseRevokeResponse parses an HTTP response from a RevokeWithResponse call
func ParseRevokeResponse(rsp *http.Response) (*RevokeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevokeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorOauth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorOauth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetIAMGranularPolicySpaceResponse parses an HTTP response from a GetIAMGranularPolicySpaceWithResponse call
func ParseGetIAMGranularPolicySpaceResponse(rsp *http.Response) (*GetIAMGranularPolicySpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIAMGranularPolicySpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetIAMGranularPolicy200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseSetIAMGranularPolicySpaceResponse parses an HTTP response from a SetIAMGranularPolicySpaceWithResponse call
func ParseSetIAMGranularPolicySpaceResponse(rsp *http.Response) (*SetIAMGranularPolicySpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetIAMGranularPolicySpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetIAMPolicySpaceResponse parses an HTTP response from a GetIAMPolicySpaceWithResponse call
func ParseGetIAMPolicySpaceResponse(rsp *http.Response) (*GetIAMPolicySpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIAMPolicySpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetIAMPolicy200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseSetIAMPolicySpaceResponse parses an HTTP response from a SetIAMPolicySpaceWithResponse call
func ParseSetIAMPolicySpaceResponse(rsp *http.Response) (*SetIAMPolicySpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetIAMPolicySpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListPermissionsSpaceResponse parses an HTTP response from a ListPermissionsSpaceWithResponse call
func ParseListPermissionsSpaceResponse(rsp *http.Response) (*ListPermissionsSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPermissionsSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPermissions200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetPermissionSpaceResponse parses an HTTP response from a GetPermissionSpaceWithResponse call
func ParseGetPermissionSpaceResponse(rsp *http.Response) (*GetPermissionSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPermissionSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPermission200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListRolesSpaceResponse parses an HTTP response from a ListRolesSpaceWithResponse call
func ParseListRolesSpaceResponse(rsp *http.Response) (*ListRolesSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRolesSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListRoles200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateRoleSpaceResponse parses an HTTP response from a CreateRoleSpaceWithResponse call
func ParseCreateRoleSpaceResponse(rsp *http.Response) (*CreateRoleSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRoleSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateRole200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteRoleSpaceResponse parses an HTTP response from a DeleteRoleSpaceWithResponse call
func ParseDeleteRoleSpaceResponse(rsp *http.Response) (*DeleteRoleSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRoleSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetRoleSpaceResponse parses an HTTP response from a GetRoleSpaceWithResponse call
func ParseGetRoleSpaceResponse(rsp *http.Response) (*GetRoleSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRoleSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetRole200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateRoleSpaceResponse parses an HTTP response from a UpdateRoleSpaceWithResponse call
func ParseUpdateRoleSpaceResponse(rsp *http.Response) (*UpdateRoleSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRoleSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseRemoveRolePermissionsSpaceResponse parses an HTTP response from a RemoveRolePermissionsSpaceWithResponse call
func ParseRemoveRolePermissionsSpaceResponse(rsp *http.Response) (*RemoveRolePermissionsSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveRolePermissionsSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetRolePermissionsSpaceResponse parses an HTTP response from a GetRolePermissionsSpaceWithResponse call
func ParseGetRolePermissionsSpaceResponse(rsp *http.Response) (*GetRolePermissionsSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRolePermissionsSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetRolePermissions200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseAddRolePermissionsSpaceResponse parses an HTTP response from a AddRolePermissionsSpaceWithResponse call
func ParseAddRolePermissionsSpaceResponse(rsp *http.Response) (*AddRolePermissionsSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddRolePermissionsSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListServiceAccountSpaceResponse parses an HTTP response from a ListServiceAccountSpaceWithResponse call
func ParseListServiceAccountSpaceResponse(rsp *http.Response) (*ListServiceAccountSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListServiceAccountSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListServiceAccount200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateServiceAccountSpaceResponse parses an HTTP response from a CreateServiceAccountSpaceWithResponse call
func ParseCreateServiceAccountSpaceResponse(rsp *http.Response) (*CreateServiceAccountSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServiceAccountSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateServiceAccount201ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteServiceAccountSpaceResponse parses an HTTP response from a DeleteServiceAccountSpaceWithResponse call
func ParseDeleteServiceAccountSpaceResponse(rsp *http.Response) (*DeleteServiceAccountSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServiceAccountSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetServiceAccountSpaceResponse parses an HTTP response from a GetServiceAccountSpaceWithResponse call
func ParseGetServiceAccountSpaceResponse(rsp *http.Response) (*GetServiceAccountSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceAccountSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetServiceAccount200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseAssignServiceAccountToSpaceResponse parses an HTTP response from a AssignServiceAccountToSpaceWithResponse call
func ParseAssignServiceAccountToSpaceResponse(rsp *http.Response) (*AssignServiceAccountToSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignServiceAccountToSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateServiceAccountSpaceResponse parses an HTTP response from a UpdateServiceAccountSpaceWithResponse call
func ParseUpdateServiceAccountSpaceResponse(rsp *http.Response) (*UpdateServiceAccountSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateServiceAccountSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateServiceAccount200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetACLServiceAccountSpaceResponse parses an HTTP response from a GetACLServiceAccountSpaceWithResponse call
func ParseGetACLServiceAccountSpaceResponse(rsp *http.Response) (*GetACLServiceAccountSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetACLServiceAccountSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetACL200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteACLServiceAccountSpaceBulkResponse parses an HTTP response from a DeleteACLServiceAccountSpaceBulkWithResponse call
func ParseDeleteACLServiceAccountSpaceBulkResponse(rsp *http.Response) (*DeleteACLServiceAccountSpaceBulkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteACLServiceAccountSpaceBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateACLServiceAccountSpaceBulkResponse parses an HTTP response from a CreateACLServiceAccountSpaceBulkWithResponse call
func ParseCreateACLServiceAccountSpaceBulkResponse(rsp *http.Response) (*CreateACLServiceAccountSpaceBulkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateACLServiceAccountSpaceBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListUserSpaceResponse parses an HTTP response from a ListUserSpaceWithResponse call
func ParseListUserSpaceResponse(rsp *http.Response) (*ListUserSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUserSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListUser200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateUserSpaceResponse parses an HTTP response from a CreateUserSpaceWithResponse call
func ParseCreateUserSpaceResponse(rsp *http.Response) (*CreateUserSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateUser201ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnassignUserSpaceResponse parses an HTTP response from a UnassignUserSpaceWithResponse call
func ParseUnassignUserSpaceResponse(rsp *http.Response) (*UnassignUserSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnassignUserSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetUserSpaceResponse parses an HTTP response from a GetUserSpaceWithResponse call
func ParseGetUserSpaceResponse(rsp *http.Response) (*GetUserSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetUser200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParsePatchUserStateSpaceResponse parses an HTTP response from a PatchUserStateSpaceWithResponse call
func ParsePatchUserStateSpaceResponse(rsp *http.Response) (*PatchUserStateSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchUserStateSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PatchUserState200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseAssignUserToSpaceResponse parses an HTTP response from a AssignUserToSpaceWithResponse call
func ParseAssignUserToSpaceResponse(rsp *http.Response) (*AssignUserToSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignUserToSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateUserSpaceResponse parses an HTTP response from a UpdateUserSpaceWithResponse call
func ParseUpdateUserSpaceResponse(rsp *http.Response) (*UpdateUserSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateUser200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetACLUserSpaceResponse parses an HTTP response from a GetACLUserSpaceWithResponse call
func ParseGetACLUserSpaceResponse(rsp *http.Response) (*GetACLUserSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetACLUserSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetACL200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteACLUserSpaceBulkResponse parses an HTTP response from a DeleteACLUserSpaceBulkWithResponse call
func ParseDeleteACLUserSpaceBulkResponse(rsp *http.Response) (*DeleteACLUserSpaceBulkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteACLUserSpaceBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateACLUserSpaceBulkResponse parses an HTTP response from a CreateACLUserSpaceBulkWithResponse call
func ParseCreateACLUserSpaceBulkResponse(rsp *http.Response) (*CreateACLUserSpaceBulkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateACLUserSpaceBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseRecoverUserSpaceResponse parses an HTTP response from a RecoverUserSpaceWithResponse call
func ParseRecoverUserSpaceResponse(rsp *http.Response) (*RecoverUserSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RecoverUserSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecoverUser200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseTokenResponse parses an HTTP response from a TokenWithResponse call
func ParseTokenResponse(rsp *http.Response) (*TokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorOauth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorOauth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorOauth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserInfoResponse parses an HTTP response from a GetUserInfoWithResponse call
func ParseGetUserInfoResponse(rsp *http.Response) (*GetUserInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetUserInfo200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorOauth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseHealthcheckResponse parses an HTTP response from a HealthcheckWithResponse call
func ParseHealthcheckResponse(rsp *http.Response) (*HealthcheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HealthcheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListKubernetesClustersResponse parses an HTTP response from a ListKubernetesClustersWithResponse call
func ParseListKubernetesClustersResponse(rsp *http.Response) (*ListKubernetesClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListKubernetesClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterList200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateKubernetesClusterResponse parses an HTTP response from a CreateKubernetesClusterWithResponse call
func ParseCreateKubernetesClusterResponse(rsp *http.Response) (*CreateKubernetesClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateKubernetesClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Operation202ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteKubernetesClusterByIdResponse parses an HTTP response from a DeleteKubernetesClusterByIdWithResponse call
func ParseDeleteKubernetesClusterByIdResponse(rsp *http.Response) (*DeleteKubernetesClusterByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteKubernetesClusterByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Operation202ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetKubernetesClusterByIdResponse parses an HTTP response from a GetKubernetesClusterByIdWithResponse call
func ParseGetKubernetesClusterByIdResponse(rsp *http.Response) (*GetKubernetesClusterByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKubernetesClusterByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Cluster200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetKubeConfigResponse parses an HTTP response from a GetKubeConfigWithResponse call
func ParseGetKubeConfigResponse(rsp *http.Response) (*GetKubeConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKubeConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpgradeMastersResponse parses an HTTP response from a UpgradeMastersWithResponse call
func ParseUpgradeMastersResponse(rsp *http.Response) (*UpgradeMastersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpgradeMastersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Operation202ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseAddNodesResponse parses an HTTP response from a AddNodesWithResponse call
func ParseAddNodesResponse(rsp *http.Response) (*AddNodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddNodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Operation202ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseRemoveNodesResponse parses an HTTP response from a RemoveNodesWithResponse call
func ParseRemoveNodesResponse(rsp *http.Response) (*RemoveNodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveNodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Operation202ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpgradeNodesResponse parses an HTTP response from a UpgradeNodesWithResponse call
func ParseUpgradeNodesResponse(rsp *http.Response) (*UpgradeNodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpgradeNodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Operation202ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListOperationResponse parses an HTTP response from a ListOperationWithResponse call
func ParseListOperationResponse(rsp *http.Response) (*ListOperationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListOperationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OperationList200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetPrivateKeyResponse parses an HTTP response from a GetPrivateKeyWithResponse call
func ParseGetPrivateKeyResponse(rsp *http.Response) (*GetPrivateKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPrivateKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetClusterStatusResponse parses an HTTP response from a GetClusterStatusWithResponse call
func ParseGetClusterStatusResponse(rsp *http.Response) (*GetClusterStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterStatusResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateNodesResponse parses an HTTP response from a UpdateNodesWithResponse call
func ParseUpdateNodesResponse(rsp *http.Response) (*UpdateNodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateNodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Operation202ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetOperationByIdResponse parses an HTTP response from a GetOperationByIdWithResponse call
func ParseGetOperationByIdResponse(rsp *http.Response) (*GetOperationByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOperationByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Operation200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListClustersResponse parses an HTTP response from a ListClustersWithResponse call
func ParseListClustersResponse(rsp *http.Response) (*ListClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClustersResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateClusterResponse parses an HTTP response from a CreateClusterWithResponse call
func ParseCreateClusterResponse(rsp *http.Response) (*CreateClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ClusterCreateResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteClusterResponse parses an HTTP response from a DeleteClusterWithResponse call
func ParseDeleteClusterResponse(rsp *http.Response) (*DeleteClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ClusterDeleteResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetClusterResponse parses an HTTP response from a GetClusterWithResponse call
func ParseGetClusterResponse(rsp *http.Response) (*GetClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterGetResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateClusterResponse parses an HTTP response from a UpdateClusterWithResponse call
func ParseUpdateClusterResponse(rsp *http.Response) (*UpdateClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterGetResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListNodepoolsResponse parses an HTTP response from a ListNodepoolsWithResponse call
func ParseListNodepoolsResponse(rsp *http.Response) (*ListNodepoolsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListNodepoolsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NodepoolsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateNodePoolResponse parses an HTTP response from a CreateNodePoolWithResponse call
func ParseCreateNodePoolResponse(rsp *http.Response) (*CreateNodePoolResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNodePoolResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest NodepoolCreateResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteNodePoolResponse parses an HTTP response from a DeleteNodePoolWithResponse call
func ParseDeleteNodePoolResponse(rsp *http.Response) (*DeleteNodePoolResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNodePoolResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest NodepoolDeleteResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateNodepoolResponse parses an HTTP response from a UpdateNodepoolWithResponse call
func ParseUpdateNodepoolResponse(rsp *http.Response) (*UpdateNodepoolResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateNodepoolResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest UpdateNodeCountResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListOperationsResponse parses an HTTP response from a ListOperationsWithResponse call
func ParseListOperationsResponse(rsp *http.Response) (*ListOperationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListOperationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OperationsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetOperationResponse parses an HTTP response from a GetOperationWithResponse call
func ParseGetOperationResponse(rsp *http.Response) (*GetOperationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOperationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OperationResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListVersionsResponse parses an HTTP response from a ListVersionsWithResponse call
func ParseListVersionsResponse(rsp *http.Response) (*ListVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VersionsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListSpacesResponse parses an HTTP response from a ListSpacesWithResponse call
func ParseListSpacesResponse(rsp *http.Response) (*ListSpacesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSpacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListSpaces200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateSpaceResponse parses an HTTP response from a CreateSpaceWithResponse call
func ParseCreateSpaceResponse(rsp *http.Response) (*CreateSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateSpace200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSpaceResponse parses an HTTP response from a DeleteSpaceWithResponse call
func ParseDeleteSpaceResponse(rsp *http.Response) (*DeleteSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetSpaceByIdResponse parses an HTTP response from a GetSpaceByIdWithResponse call
func ParseGetSpaceByIdResponse(rsp *http.Response) (*GetSpaceByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpaceByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetSpaceById200ResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateSpaceResponse parses an HTTP response from a UpdateSpaceWithResponse call
func ParseUpdateSpaceResponse(rsp *http.Response) (*UpdateSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}
