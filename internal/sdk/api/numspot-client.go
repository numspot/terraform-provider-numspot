// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BasicAuthScopes  = "BasicAuth.Scopes"
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for ActiveState.
const (
	ActiveStateCREATING   ActiveState = "CREATING"
	ActiveStateDELETING   ActiveState = "DELETING"
	ActiveStatePENDING    ActiveState = "PENDING"
	ActiveStateREPAIRING  ActiveState = "REPAIRING"
	ActiveStateRUNNING    ActiveState = "RUNNING"
	ActiveStateSUSPENDING ActiveState = "SUSPENDING"
)

// Defines values for AuthenticatorAssuranceLevel.
const (
	Aal0 AuthenticatorAssuranceLevel = "aal0"
	Aal1 AuthenticatorAssuranceLevel = "aal1"
	Aal2 AuthenticatorAssuranceLevel = "aal2"
	Aal3 AuthenticatorAssuranceLevel = "aal3"
)

// Defines values for AvailabilityZoneName.
const (
	CloudgouvEuWest1a AvailabilityZoneName = "cloudgouv-eu-west-1a"
	CloudgouvEuWest1b AvailabilityZoneName = "cloudgouv-eu-west-1b"
	CloudgouvEuWest1c AvailabilityZoneName = "cloudgouv-eu-west-1c"
	EuWest2a          AvailabilityZoneName = "eu-west-2a"
	EuWest2b          AvailabilityZoneName = "eu-west-2b"
)

// Defines values for ContinueWithRecoveryUiAction.
const (
	ShowRecoveryUi ContinueWithRecoveryUiAction = "show_recovery_ui"
)

// Defines values for ContinueWithSetSessionTokenAction.
const (
	SetSessionToken ContinueWithSetSessionTokenAction = "set_session_token"
)

// Defines values for ContinueWithSettingsUiAction.
const (
	ShowSettingsUi ContinueWithSettingsUiAction = "show_settings_ui"
)

// Defines values for ContinueWithVerificationUiAction.
const (
	ShowVerificationUi ContinueWithVerificationUiAction = "show_verification_ui"
)

// Defines values for CreateVmsPerformance.
const (
	CreateVmsPerformanceHigh    CreateVmsPerformance = "high"
	CreateVmsPerformanceHighest CreateVmsPerformance = "highest"
	CreateVmsPerformanceMedium  CreateVmsPerformance = "medium"
)

// Defines values for ErrorDocumentationUrl.
const (
	HttpsportalApiNumspotComerrorsAmbiguousGranularPermissionElements ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#ambiguous_granular_permission_elements"
	HttpsportalApiNumspotComerrorsAmbiguousPermissionElements         ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#ambiguous_permission_elements"
	HttpsportalApiNumspotComerrorsAmbiguousRoleElements               ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#ambiguous_role_elements"
	HttpsportalApiNumspotComerrorsDuplicateResource                   ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#duplicate_resource"
	HttpsportalApiNumspotComerrorsDuplicateRole                       ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#duplicate_role"
	HttpsportalApiNumspotComerrorsForbidden                           ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#forbidden"
	HttpsportalApiNumspotComerrorsForbiddenAccess                     ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#forbidden_access"
	HttpsportalApiNumspotComerrorsIdentityNotFound                    ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#identity_not_found"
	HttpsportalApiNumspotComerrorsInactiveToken                       ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#inactive_token"
	HttpsportalApiNumspotComerrorsInternalServerError                 ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#internal_server_error"
	HttpsportalApiNumspotComerrorsInvalidParameter                    ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#invalid_parameter"
	HttpsportalApiNumspotComerrorsMethodNotAllowed                    ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#method_not_allowed"
	HttpsportalApiNumspotComerrorsMissingRoles                        ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#missing_roles"
	HttpsportalApiNumspotComerrorsNamespaceNotFound                   ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#namespace_not_found"
	HttpsportalApiNumspotComerrorsNotInTenantRoles                    ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#not_in_tenant_roles"
	HttpsportalApiNumspotComerrorsPermissionNotFound                  ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#permission_not_found"
	HttpsportalApiNumspotComerrorsResourceNotFound                    ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#resource_not_found"
	HttpsportalApiNumspotComerrorsRoleNotFound                        ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#role_not_found"
	HttpsportalApiNumspotComerrorsUnauthenticatedAccess               ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#unauthenticated_access"
	HttpsportalApiNumspotComerrorsUnexpectedTokenUsage                ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#unexpected_token_usage"
	HttpsportalApiNumspotComerrorsUriTooLong                          ErrorDocumentationUrl = "https://portal.api.numspot.com/errors#uri_too_long"
)

// Defines values for Gpu.
const (
	GpuA10080 Gpu = "A100-80"
	GpuP100   Gpu = "P100"
	GpuP6     Gpu = "P6"
	GpuV100   Gpu = "V100"
)

// Defines values for IdentityState.
const (
	Active   IdentityState = "active"
	Inactive IdentityState = "inactive"
)

// Defines values for IdentityCredentialsType.
const (
	IdentityCredentialsTypeCode         IdentityCredentialsType = "code"
	IdentityCredentialsTypeCodeRecovery IdentityCredentialsType = "code_recovery"
	IdentityCredentialsTypeLinkRecovery IdentityCredentialsType = "link_recovery"
	IdentityCredentialsTypeLookupSecret IdentityCredentialsType = "lookup_secret"
	IdentityCredentialsTypeOidc         IdentityCredentialsType = "oidc"
	IdentityCredentialsTypePassword     IdentityCredentialsType = "password"
	IdentityCredentialsTypeTotp         IdentityCredentialsType = "totp"
	IdentityCredentialsTypeWebauthn     IdentityCredentialsType = "webauthn"
)

// Defines values for ImmutableSpaceStatus.
const (
	ImmutableSpaceStatusFAILED  ImmutableSpaceStatus = "FAILED"
	ImmutableSpaceStatusQUEUED  ImmutableSpaceStatus = "QUEUED"
	ImmutableSpaceStatusREADY   ImmutableSpaceStatus = "READY"
	ImmutableSpaceStatusRUNNING ImmutableSpaceStatus = "RUNNING"
)

// Defines values for KubernetesClusterStateHealth.
const (
	KubernetesClusterStateHealthKO KubernetesClusterStateHealth = "KO"
	KubernetesClusterStateHealthOK KubernetesClusterStateHealth = "OK"
)

// Defines values for KubernetesNodePoolGpuType.
const (
	KubernetesNodePoolGpuTypeA10080 KubernetesNodePoolGpuType = "A100-80"
	KubernetesNodePoolGpuTypeP100   KubernetesNodePoolGpuType = "P100"
	KubernetesNodePoolGpuTypeP6     KubernetesNodePoolGpuType = "P6"
	KubernetesNodePoolGpuTypeV100   KubernetesNodePoolGpuType = "V100"
)

// Defines values for KubernetesNodeProfileName.
const (
	KubernetesNodeProfileNameLARGE     KubernetesNodeProfileName = "LARGE"
	KubernetesNodeProfileNameMEDIUM    KubernetesNodeProfileName = "MEDIUM"
	KubernetesNodeProfileNameMEDIUMGPU KubernetesNodeProfileName = "MEDIUM_GPU"
	KubernetesNodeProfileNameSMALL     KubernetesNodeProfileName = "SMALL"
	KubernetesNodeProfileNameVERYLARGE KubernetesNodeProfileName = "VERY_LARGE"
	KubernetesNodeProfileNameVERYSMALL KubernetesNodeProfileName = "VERY_SMALL"
)

// Defines values for KubernetesNodeStatusStatus.
const (
	KubernetesNodeStatusStatusFAILED KubernetesNodeStatusStatus = "FAILED"
	KubernetesNodeStatusStatusOK     KubernetesNodeStatusStatus = "OK"
)

// Defines values for KubernetesOperationType.
const (
	KubernetesOperationTypeADDWORKERS     KubernetesOperationType = "ADD_WORKERS"
	KubernetesOperationTypeCREATECLUSTER  KubernetesOperationType = "CREATE_CLUSTER"
	KubernetesOperationTypeDELETECLUSTER  KubernetesOperationType = "DELETE_CLUSTER"
	KubernetesOperationTypeREMOVEWORKERS  KubernetesOperationType = "REMOVE_WORKERS"
	KubernetesOperationTypeUPDATENODES    KubernetesOperationType = "UPDATE_NODES"
	KubernetesOperationTypeUPGRADEMASTERS KubernetesOperationType = "UPGRADE_MASTERS"
	KubernetesOperationTypeUPGRADEWORKERS KubernetesOperationType = "UPGRADE_WORKERS"
)

// Defines values for LoginFlowActive.
const (
	LoginFlowActiveCode         LoginFlowActive = "code"
	LoginFlowActiveCodeRecovery LoginFlowActive = "code_recovery"
	LoginFlowActiveLinkRecovery LoginFlowActive = "link_recovery"
	LoginFlowActiveLookupSecret LoginFlowActive = "lookup_secret"
	LoginFlowActiveOidc         LoginFlowActive = "oidc"
	LoginFlowActivePassword     LoginFlowActive = "password"
	LoginFlowActiveTotp         LoginFlowActive = "totp"
	LoginFlowActiveWebauthn     LoginFlowActive = "webauthn"
)

// Defines values for NodeProfile.
const (
	NodeProfileLARGE     NodeProfile = "LARGE"
	NodeProfileMEDIUM    NodeProfile = "MEDIUM"
	NodeProfileSMALL     NodeProfile = "SMALL"
	NodeProfileVERYLARGE NodeProfile = "VERY_LARGE"
)

// Defines values for OperationTypes.
const (
	OperationTypesCREATECLUSTER  OperationTypes = "CREATE_CLUSTER"
	OperationTypesCREATENODEPOOL OperationTypes = "CREATE_NODE_POOL"
	OperationTypesDELETECLUSTER  OperationTypes = "DELETE_CLUSTER"
	OperationTypesDELETENODEPOOL OperationTypes = "DELETE_NODE_POOL"
	OperationTypesUPDATENODEPOOL OperationTypes = "UPDATE_NODE_POOL"
)

// Defines values for PostgresBackupDeleteOption.
const (
	DELETEALL              PostgresBackupDeleteOption = "DELETE_ALL"
	KEEPNEWESTINDEFINITELY PostgresBackupDeleteOption = "KEEP_NEWEST_INDEFINITELY"
)

// Defines values for PostgresBackupStatus.
const (
	PostgresBackupStatusCREATED  PostgresBackupStatus = "CREATED"
	PostgresBackupStatusCREATING PostgresBackupStatus = "CREATING"
	PostgresBackupStatusDELETING PostgresBackupStatus = "DELETING"
	PostgresBackupStatusERROR    PostgresBackupStatus = "ERROR"
	PostgresBackupStatusFAILED   PostgresBackupStatus = "FAILED"
)

// Defines values for PostgresClusterCatalogItemType.
const (
	INTEGER PostgresClusterCatalogItemType = "INTEGER"
	STRING  PostgresClusterCatalogItemType = "STRING"
)

// Defines values for PostgresClusterMaintenanceScheduleType.
const (
	UPDATE PostgresClusterMaintenanceScheduleType = "UPDATE"
)

// Defines values for PostgresClusterOperationName.
const (
	CREATE        PostgresClusterOperationName = "CREATE"
	DELETE        PostgresClusterOperationName = "DELETE"
	MODIFY        PostgresClusterOperationName = "MODIFY"
	RESETPASSWORD PostgresClusterOperationName = "RESET_PASSWORD"
)

// Defines values for PostgresClusterOperationResult.
const (
	PostgresClusterOperationResultFAILED     PostgresClusterOperationResult = "FAILED"
	PostgresClusterOperationResultINPROGRESS PostgresClusterOperationResult = "IN_PROGRESS"
	PostgresClusterOperationResultSUCCEEDED  PostgresClusterOperationResult = "SUCCEEDED"
)

// Defines values for PostgresClusterStatus.
const (
	PostgresClusterStatusCONFIGURING PostgresClusterStatus = "CONFIGURING"
	PostgresClusterStatusCREATING    PostgresClusterStatus = "CREATING"
	PostgresClusterStatusDELETED     PostgresClusterStatus = "DELETED"
	PostgresClusterStatusDELETING    PostgresClusterStatus = "DELETING"
	PostgresClusterStatusERROR       PostgresClusterStatus = "ERROR"
	PostgresClusterStatusFAILED      PostgresClusterStatus = "FAILED"
	PostgresClusterStatusREADY       PostgresClusterStatus = "READY"
)

// Defines values for PostgresNodeConfigurationPerformanceLevel.
const (
	HIGH    PostgresNodeConfigurationPerformanceLevel = "HIGH"
	HIGHEST PostgresNodeConfigurationPerformanceLevel = "HIGHEST"
	MEDIUM  PostgresNodeConfigurationPerformanceLevel = "MEDIUM"
)

// Defines values for PostgresVolumeGp2Type.
const (
	GP2 PostgresVolumeGp2Type = "GP2"
)

// Defines values for PostgresVolumeIo1Type.
const (
	IO1 PostgresVolumeIo1Type = "IO1"
)

// Defines values for RestingState.
const (
	RestingStateACCEPTED  RestingState = "ACCEPTED"
	RestingStateACTIVE    RestingState = "ACTIVE"
	RestingStateCANCELLED RestingState = "CANCELLED"
	RestingStateDELETED   RestingState = "DELETED"
	RestingStateFAILED    RestingState = "FAILED"
	RestingStateSUCCEEDED RestingState = "SUCCEEDED"
	RestingStateSUSPENDED RestingState = "SUSPENDED"
	RestingStateVERIFIED  RestingState = "VERIFIED"
)

// Defines values for SessionAuthenticationMethodMethod.
const (
	SessionAuthenticationMethodMethodCode             SessionAuthenticationMethodMethod = "code"
	SessionAuthenticationMethodMethodCodeRecovery     SessionAuthenticationMethodMethod = "code_recovery"
	SessionAuthenticationMethodMethodLinkRecovery     SessionAuthenticationMethodMethod = "link_recovery"
	SessionAuthenticationMethodMethodLookupSecret     SessionAuthenticationMethodMethod = "lookup_secret"
	SessionAuthenticationMethodMethodOidc             SessionAuthenticationMethodMethod = "oidc"
	SessionAuthenticationMethodMethodPassword         SessionAuthenticationMethodMethod = "password"
	SessionAuthenticationMethodMethodTotp             SessionAuthenticationMethodMethod = "totp"
	SessionAuthenticationMethodMethodV06LegacySession SessionAuthenticationMethodMethod = "v0.6_legacy_session"
	SessionAuthenticationMethodMethodWebauthn         SessionAuthenticationMethodMethod = "webauthn"
)

// Defines values for SpaceStatus.
const (
	FAILED  SpaceStatus = "FAILED"
	QUEUED  SpaceStatus = "QUEUED"
	READY   SpaceStatus = "READY"
	RUNNING SpaceStatus = "RUNNING"
)

// Defines values for SubjectType.
const (
	ServiceAccounts SubjectType = "serviceAccounts"
	Users           SubjectType = "users"
)

// Defines values for TenantType.
const (
	TenantTypeOrganisation TenantType = "organisation"
	TenantTypeSpace        TenantType = "space"
)

// Defines values for UiNodeGroup.
const (
	UiNodeGroupCode         UiNodeGroup = "code"
	UiNodeGroupDefault      UiNodeGroup = "default"
	UiNodeGroupLink         UiNodeGroup = "link"
	UiNodeGroupLookupSecret UiNodeGroup = "lookup_secret"
	UiNodeGroupOidc         UiNodeGroup = "oidc"
	UiNodeGroupPassword     UiNodeGroup = "password"
	UiNodeGroupProfile      UiNodeGroup = "profile"
	UiNodeGroupTotp         UiNodeGroup = "totp"
	UiNodeGroupWebauthn     UiNodeGroup = "webauthn"
)

// Defines values for UiNodeType.
const (
	UiNodeTypeA      UiNodeType = "a"
	UiNodeTypeImg    UiNodeType = "img"
	UiNodeTypeInput  UiNodeType = "input"
	UiNodeTypeScript UiNodeType = "script"
	UiNodeTypeText   UiNodeType = "text"
)

// Defines values for UiNodeInputAttributesAutocomplete.
const (
	UiNodeInputAttributesAutocompleteCurrentPassword UiNodeInputAttributesAutocomplete = "current-password"
	UiNodeInputAttributesAutocompleteEmail           UiNodeInputAttributesAutocomplete = "email"
	UiNodeInputAttributesAutocompleteNewPassword     UiNodeInputAttributesAutocomplete = "new-password"
	UiNodeInputAttributesAutocompleteOneTimeCode     UiNodeInputAttributesAutocomplete = "one-time-code"
	UiNodeInputAttributesAutocompleteTel             UiNodeInputAttributesAutocomplete = "tel"
	UiNodeInputAttributesAutocompleteUrl             UiNodeInputAttributesAutocomplete = "url"
)

// Defines values for UiNodeInputAttributesType.
const (
	UiNodeInputAttributesTypeButton        UiNodeInputAttributesType = "button"
	UiNodeInputAttributesTypeCheckbox      UiNodeInputAttributesType = "checkbox"
	UiNodeInputAttributesTypeDate          UiNodeInputAttributesType = "date"
	UiNodeInputAttributesTypeDatetimeLocal UiNodeInputAttributesType = "datetime-local"
	UiNodeInputAttributesTypeEmail         UiNodeInputAttributesType = "email"
	UiNodeInputAttributesTypeHidden        UiNodeInputAttributesType = "hidden"
	UiNodeInputAttributesTypeNumber        UiNodeInputAttributesType = "number"
	UiNodeInputAttributesTypePassword      UiNodeInputAttributesType = "password"
	UiNodeInputAttributesTypeSubmit        UiNodeInputAttributesType = "submit"
	UiNodeInputAttributesTypeTel           UiNodeInputAttributesType = "tel"
	UiNodeInputAttributesTypeText          UiNodeInputAttributesType = "text"
	UiNodeInputAttributesTypeUrl           UiNodeInputAttributesType = "url"
)

// Defines values for UiTextType.
const (
	UiTextTypeError   UiTextType = "error"
	UiTextTypeInfo    UiTextType = "info"
	UiTextTypeSuccess UiTextType = "success"
)

// Defines values for UpdateRecoveryFlowWithCodeMethodMethod.
const (
	UpdateRecoveryFlowWithCodeMethodMethodCode UpdateRecoveryFlowWithCodeMethodMethod = "code"
	UpdateRecoveryFlowWithCodeMethodMethodLink UpdateRecoveryFlowWithCodeMethodMethod = "link"
)

// Defines values for UpdateRecoveryFlowWithLinkMethodMethod.
const (
	UpdateRecoveryFlowWithLinkMethodMethodCode UpdateRecoveryFlowWithLinkMethodMethod = "code"
	UpdateRecoveryFlowWithLinkMethodMethodLink UpdateRecoveryFlowWithLinkMethodMethod = "link"
)

// Defines values for UpdateVmPerformance.
const (
	UpdateVmPerformanceHigh    UpdateVmPerformance = "high"
	UpdateVmPerformanceHighest UpdateVmPerformance = "highest"
	UpdateVmPerformanceMedium  UpdateVmPerformance = "medium"
)

// Defines values for VerifiableIdentityAddressVia.
const (
	VerifiableIdentityAddressViaEmail VerifiableIdentityAddressVia = "email"
	VerifiableIdentityAddressViaSms   VerifiableIdentityAddressVia = "sms"
)

// ACL defines model for ACL.
type ACL struct {
	// PermissionId id of the permission
	PermissionId openapi_types.UUID `json:"permissionId"`

	// Resource Type of the resource being accessed
	Resource string `json:"resource"`

	// ResourceId Unique identifier of a resource
	ResourceId string `json:"resourceId"`

	// Service Name of the service making the call
	Service string `json:"service"`

	// Subresource Specific type of the subresource within the main resource
	Subresource *string `json:"subresource,omitempty"`
}

// ACLList List of ACLs.
type ACLList struct {
	Items []ACL `json:"items"`
}

// ACLPaginatedList defines model for ACLPaginatedList.
type ACLPaginatedList struct {
	Items []ACL `json:"items"`

	// NextPageToken This token is used to retrieve the next page. If this field is omitted, there are no subsequent pages.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// TotalSize Equivalent to int32
	TotalSize *Int `json:"totalSize,omitempty"`
}

// AKSK defines model for AKSK.
type AKSK struct {
	Ak string `json:"ak"`
	Sk string `json:"sk"`
}

// Access Permissions for the resource.
type Access struct {
	// IsPublic A global permission for all accounts.<br />
	// (Request) Set this parameter to true to make the resource public (if the parent parameter is `Additions`) or to make the resource private (if the parent parameter is `Removals`).<br />
	// (Response) If true, the resource is public. If false, the resource is private.
	IsPublic *bool `json:"isPublic,omitempty"`
}

// AccessCreation Information about the permissions for the resource.<br />
// Specify either the `Additions` or the `Removals` parameter.
type AccessCreation struct {
	// Additions Permissions for the resource.
	Additions *Access `json:"additions,omitempty"`

	// Removals Permissions for the resource.
	Removals *Access `json:"removals,omitempty"`
}

// ActiveState Active states are lifecycle states that typically resolve on their own into a single expected resting state. Note: Remember only to expose states that are useful to customers. Active states are valuable only if the resource will be in that state for a sufficient period of time. If state changes are immediate, active states are not necessary.
type ActiveState string

// ApplicationStickyCookiePolicy Information about the stickiness policy.
type ApplicationStickyCookiePolicy struct {
	// CookieName The name of the application cookie used for stickiness.
	CookieName *string `json:"cookieName,omitempty"`

	// PolicyName The mnemonic name for the policy being created. The name must be unique within a set of policies for this load balancer.
	PolicyName *string `json:"policyName,omitempty"`
}

// AuthenticatorAssuranceLevel The authenticator assurance level can be one of "aal1", "aal2", or "aal3". A higher number means that it is harder
// for an attacker to compromise the account.
// Generally, "aal1" implies that one authentication factor was used while AAL2 implies that two factors (password + TOTP) have been used.
type AuthenticatorAssuranceLevel string

// AvailabilityZoneName List of all Availability Zones name.
type AvailabilityZoneName string

// BackendVmHealth Information about the health of a back-end VM.
type BackendVmHealth struct {
	// Description The description of the state of the back-end VM.
	Description *string `json:"description,omitempty"`

	// State The state of the back-end VM (`InService` \| `OutOfService` \| `Unknown`).
	State *string `json:"state,omitempty"`

	// StateReason Information about the cause of `OutOfService` VMs.<br />
	//  Specifically, whether the cause is Elastic Load Balancing or the VM (`ELB` \| `Instance` \| `N/A`).
	StateReason *string `json:"stateReason,omitempty"`

	// VmId The ID of the back-end VM.
	VmId *string `json:"vmId,omitempty"`
}

// BadRequestError defines model for BadRequestError.
type BadRequestError struct {
	// Detail Human-readable explanation specific to this occurrence of the problem.
	Detail   *string `json:"detail,omitempty"`
	Instance *Url    `json:"instance,omitempty"`

	// Title Human-readable summary of the problem type.
	Title string `json:"title"`

	// Type Documentation URL for the domain error
	Type ErrorDocumentationUrl `json:"type"`

	// Violations Array of violations to provide a per-field detail.
	Violations *[]Violation `json:"violations,omitempty"`
}

// BlockDeviceMappingCreated Information about the created block device mapping.
type BlockDeviceMappingCreated struct {
	// Bsu Information about the created BSU volume.
	Bsu *BsuCreated `json:"bsu,omitempty"`

	// DeviceName The name of the device.
	DeviceName *string `json:"deviceName,omitempty"`
}

// BlockDeviceMappingImage One or more parameters used to automatically set up volumes when the VM is created.
type BlockDeviceMappingImage struct {
	// Bsu Information about the BSU volume to create.
	Bsu *BsuToCreate `json:"bsu,omitempty"`

	// DeviceName The device name for the volume. For a root device, you must use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, and the second `X` is a letter between `a` and `z`).
	DeviceName *string `json:"deviceName,omitempty"`

	// VirtualDeviceName The name of the virtual device (`ephemeralN`).
	VirtualDeviceName *string `json:"virtualDeviceName,omitempty"`
}

// BlockDeviceMappingVmCreation Information about the block device mapping.
type BlockDeviceMappingVmCreation struct {
	// Bsu Information about the BSU volume to create.
	Bsu *BsuToCreate `json:"bsu,omitempty"`

	// DeviceName The device name for the volume. For a root device, you must use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, and the second `X` is a letter between `a` and `z`).
	DeviceName *string `json:"deviceName,omitempty"`

	// NoDevice Removes the device which is included in the block device mapping of the Image.
	NoDevice *string `json:"noDevice,omitempty"`

	// VirtualDeviceName The name of the virtual device (`ephemeralN`).
	VirtualDeviceName *string `json:"virtualDeviceName,omitempty"`
}

// BlockDeviceMappingVmUpdate Information about the block device mapping.
type BlockDeviceMappingVmUpdate struct {
	// Bsu Information about the BSU volume.
	Bsu *BsuToUpdateVm `json:"bsu,omitempty"`

	// DeviceName The device name for the volume. For a root device, you must use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, and the second `X` is a letter between `a` and `z`).
	DeviceName *string `json:"deviceName,omitempty"`

	// NoDevice Removes the device which is included in the block device mapping of the Image.
	NoDevice *string `json:"noDevice,omitempty"`

	// VirtualDeviceName The name of the virtual device (`ephemeralN`).
	VirtualDeviceName *string `json:"virtualDeviceName,omitempty"`
}

// BsuCreated Information about the created BSU volume.
type BsuCreated struct {
	// DeleteOnVmDeletion If true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.
	DeleteOnVmDeletion *bool `json:"deleteOnVmDeletion,omitempty"`

	// LinkDate The date and time of attachment of the volume to the VM, in ISO 8601 date-time format.
	LinkDate *time.Time `json:"linkDate,omitempty"`

	// State The state of the volume.
	State *string `json:"state,omitempty"`

	// VolumeId The ID of the volume.
	VolumeId *string `json:"volumeId,omitempty"`
}

// BsuToCreate Information about the BSU volume to create.
type BsuToCreate struct {
	// DeleteOnVmDeletion By default or if set to true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.
	DeleteOnVmDeletion *bool `json:"deleteOnVmDeletion,omitempty"`

	// Iops The number of I/O operations per second (IOPS). This parameter must be specified only if you create an `io1` volume. The maximum number of IOPS allowed for `io1` volumes is `13000` with a maximum performance ratio of 300 IOPS per gibibyte.
	Iops *int `json:"iops,omitempty"`

	// SnapshotId The ID of the snapshot used to create the volume.
	SnapshotId *string `json:"snapshotId,omitempty"`

	// VolumeSize The size of the volume, in gibibytes (GiB).<br />
	// If you specify a snapshot ID, the volume size must be at least equal to the snapshot size.<br />
	// If you specify a snapshot ID but no volume size, the volume is created with a size similar to the snapshot one.
	VolumeSize *int `json:"volumeSize,omitempty"`

	// VolumeType The type of the volume (`standard` \| `io1` \| `gp2`). If not specified in the request, a `standard` volume is created.<br />
	VolumeType *string `json:"volumeType,omitempty"`
}

// BsuToUpdateVm Information about the BSU volume.
type BsuToUpdateVm struct {
	// DeleteOnVmDeletion If set to true, the volume is deleted when terminating the VM. If set to false, the volume is not deleted when terminating the VM.
	DeleteOnVmDeletion *bool `json:"deleteOnVmDeletion,omitempty"`

	// VolumeId The ID of the volume.
	VolumeId *string `json:"volumeId,omitempty"`
}

// Cidr Type defining a CIDR (Classless Inter-Domain Routing) according to the CIDR syntax defined in RFC 4632
type Cidr = string

// ClientGateway Information about the client gateway.
type ClientGateway struct {
	// BgpAsn The Autonomous System Number (ASN) used by the Border Gateway Protocol (BGP) to find the path to your client gateway through the Internet.
	BgpAsn int `json:"bgpAsn"`

	// ConnectionType The type of communication tunnel used by the client gateway (only `ipsec.1` is supported).
	ConnectionType string `json:"connectionType"`

	// Id The ID of the client gateway.
	Id string `json:"id"`

	// PublicIp The public IPv4 address of the client gateway (must be a fixed address into a NATed network).
	PublicIp string `json:"publicIp"`

	// State The state of the client gateway (`pending` \| `available` \| `deleting` \| `deleted`).
	State string `json:"state"`
}

// ClientGateways Information about one or more ClientGateways.
type ClientGateways struct {
	Items []ClientGateway `json:"items"`
}

// ComputeBridge The bridge object representation between two compute VPCs.
type ComputeBridge struct {
	// DestinationIpRange Type defining a CIDR (Classless Inter-Domain Routing) according to the CIDR syntax defined in RFC 4632
	DestinationIpRange Cidr               `json:"destinationIpRange"`
	GatewayId          string             `json:"gatewayId"`
	Id                 openapi_types.UUID `json:"id"`

	// SourceIpRange Type defining a CIDR (Classless Inter-Domain Routing) according to the CIDR syntax defined in RFC 4632
	SourceIpRange Cidr `json:"sourceIpRange"`
}

// ComputeBridges List of compute bridges.
type ComputeBridges struct {
	Items []ComputeBridge `json:"items"`
}

// ContinueWith defines model for ContinueWith.
type ContinueWith struct {
	union json.RawMessage
}

// ContinueWithRecoveryUi Indicates, that the UI flow could be continued by showing a recovery ui
type ContinueWithRecoveryUi struct {
	// Action Action will always be `show_recovery_ui`
	// show_recovery_ui ContinueWithActionShowRecoveryUIString
	Action ContinueWithRecoveryUiAction `json:"action"`
	Flow   ContinueWithRecoveryUiFlow   `json:"flow"`
}

// ContinueWithRecoveryUiAction Action will always be `show_recovery_ui`
// show_recovery_ui ContinueWithActionShowRecoveryUIString
type ContinueWithRecoveryUiAction string

// ContinueWithRecoveryUiFlow defines model for ContinueWithRecoveryUiFlow.
type ContinueWithRecoveryUiFlow struct {
	// Id The ID of the recovery flow
	Id openapi_types.UUID `json:"id"`

	// Url The URL of the recovery flow
	Url *string `json:"url,omitempty"`
}

// ContinueWithSetSessionToken Indicates that a session was issued, and the application should use this token for authenticated requests
type ContinueWithSetSessionToken struct {
	// Action Action will always be `set_session_token`
	// set_session_token ContinueWithActionSetSessionTokenString
	Action ContinueWithSetSessionTokenAction `json:"action"`

	// SessionToken Token is the token of the session
	SessionToken string `json:"session_token"`
}

// ContinueWithSetSessionTokenAction Action will always be `set_session_token`
// set_session_token ContinueWithActionSetSessionTokenString
type ContinueWithSetSessionTokenAction string

// ContinueWithSettingsUi Indicates, that the UI flow could be continued by showing a settings ui
type ContinueWithSettingsUi struct {
	// Action Action will always be `show_settings_ui`
	// show_settings_ui ContinueWithActionShowSettingsUIString
	Action ContinueWithSettingsUiAction `json:"action"`
	Flow   ContinueWithSettingsUiFlow   `json:"flow"`
}

// ContinueWithSettingsUiAction Action will always be `show_settings_ui`
// show_settings_ui ContinueWithActionShowSettingsUIString
type ContinueWithSettingsUiAction string

// ContinueWithSettingsUiFlow defines model for ContinueWithSettingsUiFlow.
type ContinueWithSettingsUiFlow struct {
	// Id The ID of the settings flow
	Id openapi_types.UUID `json:"id"`
}

// ContinueWithVerificationUi Indicates, that the UI flow could be continued by showing a verification ui
type ContinueWithVerificationUi struct {
	// Action Action will always be `show_verification_ui`
	// show_verification_ui ContinueWithActionShowVerificationUIString
	Action ContinueWithVerificationUiAction `json:"action"`
	Flow   ContinueWithVerificationUiFlow   `json:"flow"`
}

// ContinueWithVerificationUiAction Action will always be `show_verification_ui`
// show_verification_ui ContinueWithActionShowVerificationUIString
type ContinueWithVerificationUiAction string

// ContinueWithVerificationUiFlow defines model for ContinueWithVerificationUiFlow.
type ContinueWithVerificationUiFlow struct {
	// Id The ID of the verification flow
	Id openapi_types.UUID `json:"id"`

	// Url The URL of the verification flow
	Url *string `json:"url,omitempty"`

	// VerifiableAddress The address that should be verified in this flow
	VerifiableAddress string `json:"verifiable_address"`
}

// CreateClientGateway Create a Client Gateway.
type CreateClientGateway struct {
	// BgpAsn The Autonomous System Number (ASN) used by the Border Gateway Protocol (BGP) to find the path to your client gateway through the Internet. <br/>
	// This number must be between `1` and `4294967295`. If you do not have an ASN, you can choose one between 64512 and 65534, or between 4200000000 and 4294967294.
	BgpAsn int `json:"bgpAsn"`

	// ConnectionType The communication protocol used to establish tunnel with your client gateway (only `ipsec.1` is supported).
	ConnectionType string `json:"connectionType"`

	// PublicIp The public fixed IPv4 address of your client gateway.
	PublicIp string `json:"publicIp"`
}

// CreateComputeBridge Schema request to bridge two compute VPCs.
type CreateComputeBridge struct {
	// DestinationVpcId Destination VPC identifier.
	DestinationVpcId string `json:"destinationVpcId"`

	// SourceVpcId Source VPC identifier.
	SourceVpcId string `json:"sourceVpcId"`
}

// CreateDhcpOptions defines model for CreateDhcpOptions.
type CreateDhcpOptions struct {
	// DomainName Specify a domain name (for example, `MyCompany.com`). You can specify only one domain name. You must specify at least one of the following parameters: `DomainName`, `DomainNameServers`, `LogServers`, or `NtpServers`.
	DomainName *string `json:"domainName,omitempty"`

	// DomainNameServers The IPs of domain name servers. You must specify at least one of the following parameters: `DomainName`, `DomainNameServers`, `LogServers`, or `NtpServers`.
	DomainNameServers *[]string `json:"domainNameServers,omitempty"`

	// LogServers The IPs of the log servers. You must specify at least one of the following parameters: `DomainName`, `DomainNameServers`, `LogServers`, or `NtpServers`.
	LogServers *[]string `json:"logServers,omitempty"`

	// NtpServers The IPs of the Network Time Protocol (NTP) servers. You must specify at least one of the following parameters: `DomainName`, `DomainNameServers`, `LogServers`, or `NtpServers`.
	NtpServers *[]string `json:"ntpServers,omitempty"`
}

// CreateDirectLink Create a Direct Link.
type CreateDirectLink struct {
	// Bandwidth The bandwidth of the DirectLink (`1Gbps` \| `10Gbps`).
	Bandwidth string `json:"bandwidth"`

	// Location The code of the requested location for the DirectLink, returned by the [ReadLocations](#readlocations) method.
	Location string `json:"location"`

	// Name The name of the DirectLink.
	Name string `json:"name"`
}

// CreateDirectLinkInterface Create a Direct Link Interface.
type CreateDirectLinkInterface struct {
	// BgpAsn The BGP (Border Gateway Protocol) ASN (Autonomous System Number) on the customer's side of the DirectLink interface. This number must be between `64512` and `65534`.
	BgpAsn int `json:"bgpAsn"`

	// BgpKey The BGP authentication key.
	BgpKey *string `json:"bgpKey,omitempty"`

	// ClientPrivateIp The IP on the customer's side of the DirectLink interface.
	ClientPrivateIp *string `json:"clientPrivateIp,omitempty"`

	// DirectLinkId The ID of the existing DirectLink for which you want to create the DirectLink interface.
	DirectLinkId string `json:"directLinkId"`

	// Name The name of the DirectLink interface.
	Name string `json:"name"`

	// NumspotPrivateIp The IP on the NumSpot side of the DirectLink interface.
	NumspotPrivateIp *string `json:"numspotPrivateIp,omitempty"`

	// VirtualGatewayId The ID of the target virtual gateway.
	VirtualGatewayId string `json:"virtualGatewayId"`

	// Vlan The VLAN number associated with the DirectLink interface. This number must be unique and be between `2` and `4094`.
	Vlan int `json:"vlan"`
}

// CreateFlexibleGpu defines model for CreateFlexibleGpu.
type CreateFlexibleGpu struct {
	// AvailabilityZoneName The Subregion in which you want to create the fGPU.
	AvailabilityZoneName string `json:"availabilityZoneName"`

	// DeleteOnVmDeletion If true, the fGPU is deleted when the VM is terminated.
	DeleteOnVmDeletion *bool `json:"deleteOnVmDeletion,omitempty"`

	// Generation The processor generation that the fGPU must be compatible with. If not specified, the oldest possible processor generation is selected (as provided by [ReadFlexibleGpuCatalog](#readflexiblegpucatalog) for the specified model of fGPU).
	Generation *string `json:"generation,omitempty"`

	// ModelName The model of fGPU you want to allocate.
	ModelName string `json:"modelName"`
}

// CreateHybridBridge Schema request to bridge a managed service and a compute VPC.
type CreateHybridBridge struct {
	ManagedServiceId openapi_types.UUID `json:"managedServiceId"`
	VpcId            string             `json:"vpcId"`
}

// CreateImage defines model for CreateImage.
type CreateImage struct {
	// Architecture **(when registering from a snapshot, or from a bucket without using a manifest file)** The architecture of the Image (`i386` or `x84_64`).
	Architecture *string `json:"architecture,omitempty"`

	// BlockDeviceMappings **(when registering from a snapshot, or from a bucket without using a manifest file)** One or more block device mappings.
	BlockDeviceMappings *[]BlockDeviceMappingImage `json:"blockDeviceMappings,omitempty"`

	// Description A description for the new Image.
	Description *string `json:"description,omitempty"`

	// Name A unique name for the new Image.<br />
	// Constraints: 3-128 alphanumeric characters, underscores (`_`), spaces (` `), parentheses (`()`), slashes (`/`), periods (`.`), or dashes (`-`).
	Name *string `json:"name,omitempty"`

	// NoReboot **(when creating from a VM)** If false, the VM shuts down before creating the Image and then reboots. If true, the VM does not.
	NoReboot *bool `json:"noReboot,omitempty"`

	// ProductCodes The product codes associated with the Image.
	ProductCodes *[]string `json:"productCodes,omitempty"`

	// RootDeviceName **(when registering from a snapshot, or from a bucket without using a manifest file)** The name of the root device for the new Image.
	RootDeviceName *string `json:"rootDeviceName,omitempty"`

	// SourceImageId **(when copying an Image)** The ID of the Image you want to copy.
	SourceImageId *string `json:"sourceImageId,omitempty"`

	// SourceRegionName **(when copying an Image)** The name of the source Region (always the same as the Region of your account).
	SourceRegionName *string `json:"sourceRegionName,omitempty"`

	// VmId **(when creating from a VM)** The ID of the VM from which you want to create the Image.
	VmId *string `json:"vmId,omitempty"`
}

// CreateKeypair Information about the created keypair.
type CreateKeypair struct {
	// Fingerprint The MD5 public key fingerprint, as specified in section 4 of RFC 4716.
	Fingerprint *string `json:"fingerprint,omitempty"`

	// Name The name of the keypair.
	Name *string `json:"name,omitempty"`

	// PrivateKey The private key, returned only if you are creating a keypair (not if you are importing). When you save this private key in a .rsa file, make sure you replace the `\n` escape sequences with real line breaks.
	PrivateKey *string `json:"privateKey,omitempty"`

	// Type The type of the keypair (`ssh-rsa`, `ssh-ed25519`, `ecdsa-sha2-nistp256`, `ecdsa-sha2-nistp384`, or `ecdsa-sha2-nistp521`).
	Type *string `json:"type,omitempty"`
}

// CreateKeypairRequestSchema defines model for CreateKeypairRequestSchema.
type CreateKeypairRequestSchema struct {
	// Name A unique name for the keypair, with a maximum length of 32 alphanumeric characters and dashes (-).
	Name string `json:"name"`

	// PublicKey The public key to import in your account, if you are importing an existing keypair. This value must be Base64-encoded.
	PublicKey *string `json:"publicKey,omitempty"`
}

// CreateListenerRule defines model for CreateListenerRule.
type CreateListenerRule struct {
	// Listener Information about the load balancer.
	Listener LoadBalancerLight `json:"listener"`

	// ListenerRule Information about the listener rule.
	ListenerRule ListenerRuleForCreation `json:"listenerRule"`

	// VmIds The IDs of the backend VMs.
	VmIds []string `json:"vmIds"`
}

// CreateLoadBalancer defines model for CreateLoadBalancer.
type CreateLoadBalancer struct {
	// Listeners One or more listeners to create.
	Listeners []ListenerForCreation `json:"listeners"`

	// Name The unique name of the load balancer (32 alphanumeric or hyphen characters maximum, but cannot start or end with a hyphen).
	Name string `json:"name"`

	// PublicIp (internet-facing only) The public IP you want to associate with the load balancer. If not specified, a public IP owned by NumSpot is associated.
	PublicIp *string `json:"publicIp,omitempty"`

	// SecurityGroups (Vpc only) One or more IDs of security groups you want to assign to the load balancer. If not specified, the default security group of the Vpc is assigned to the load balancer.
	SecurityGroups *[]string `json:"securityGroups,omitempty"`

	// Subnets (Vpc only) The ID of the Subnet in which you want to create the load balancer. Regardless of this Subnet, the load balancer can distribute traffic to all Subnets. This parameter is required in a Vpc.
	Subnets []string `json:"subnets"`

	// Tags One or more tags assigned to the load balancer.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// Type The type of load balancer: `internet-facing` or `internal`. Use this parameter only for load balancers in a Vpc.
	Type *string `json:"type,omitempty"`
}

// CreateLoadBalancerListeners defines model for CreateLoadBalancerListeners.
type CreateLoadBalancerListeners struct {
	// Listeners One or more listeners for the load balancer.
	Listeners []ListenerForCreation `json:"listeners"`
}

// CreateLoadBalancerPolicy defines model for CreateLoadBalancerPolicy.
type CreateLoadBalancerPolicy struct {
	// CookieExpirationPeriod The lifetime of the cookie, in seconds. If not specified, the default value of this parameter is `1`, which means that the sticky session lasts for the duration of the browser session.
	CookieExpirationPeriod *int `json:"cookieExpirationPeriod,omitempty"`

	// CookieName The name of the application cookie used for stickiness. This parameter is required if you create a stickiness policy based on an application-generated cookie.
	CookieName *string `json:"cookieName,omitempty"`

	// PolicyName The name of the policy, with a maximum length of 32 alphanumeric characters and dashes (-). Must be unique.
	PolicyName string `json:"policyName"`

	// PolicyType The type of stickiness policy you want to create: `app` or `load_balancer`.
	PolicyType string `json:"policyType"`
}

// CreateLoadBalancerTags defines model for CreateLoadBalancerTags.
type CreateLoadBalancerTags struct {
	// Names One or more load balancer names.
	Names []string `json:"names"`

	// Tags One or more tags to add to the specified load balancers.
	Tags []ResourceTag `json:"tags"`
}

// CreateManagedServicesBridge Schema request to bridge two managed services.
type CreateManagedServicesBridge struct {
	// DestinationManagedServiceId Managed service destination identifier
	DestinationManagedServiceId openapi_types.UUID `json:"destinationManagedServiceId"`

	// SourceManagedServiceId Managed service source identifier
	SourceManagedServiceId openapi_types.UUID `json:"sourceManagedServiceId"`
}

// CreateNatGateway defines model for CreateNatGateway.
type CreateNatGateway struct {
	// PublicIpId The allocation ID of the public IP to associate with the NAT gateway.<br />
	// If the public IP is already associated with another resource, you must first disassociate it.
	PublicIpId string `json:"publicIpId"`

	// SubnetId The ID of the Subnet in which you want to create the NAT gateway.
	SubnetId string `json:"subnetId"`
}

// CreateNic defines model for CreateNic.
type CreateNic struct {
	// Description A description for the NIC.
	Description *string `json:"description,omitempty"`

	// PrivateIps The primary private IP for the NIC.<br />
	// This IP must be within the IP range of the Subnet that you specify with the `SubnetId` attribute.<br />
	// If you do not specify this attribute, a random private IP is selected within the IP range of the Subnet.
	PrivateIps *[]PrivateIpLight `json:"privateIps,omitempty"`

	// SecurityGroupIds One or more IDs of security groups for the NIC.
	SecurityGroupIds *[]string `json:"securityGroupIds,omitempty"`

	// SubnetId The ID of the Subnet in which you want to create the NIC.
	SubnetId string `json:"subnetId"`
}

// CreateRoute defines model for CreateRoute.
type CreateRoute struct {
	// DestinationIpRange The IP range used for the destination match, in CIDR notation (for example, `10.0.0.0/24`).
	DestinationIpRange string `json:"destinationIpRange"`

	// GatewayId The ID of an Internet gateway or virtual gateway attached to your Vpc.
	GatewayId *string `json:"gatewayId,omitempty"`

	// NatGatewayId The ID of a NAT gateway.
	NatGatewayId *string `json:"natGatewayId,omitempty"`

	// NicId The ID of a NIC.
	NicId *string `json:"nicId,omitempty"`

	// VmId The ID of a NAT VM in your Vpc (attached to exactly one NIC).
	VmId *string `json:"vmId,omitempty"`

	// VpcPeeringId The ID of a Vpc peering.
	VpcPeeringId *string `json:"vpcPeeringId,omitempty"`
}

// CreateRouteTable defines model for CreateRouteTable.
type CreateRouteTable struct {
	// VpcId The ID of the Vpc for which you want to create a route table.
	VpcId string `json:"vpcId"`
}

// CreateSecurityGroup defines model for CreateSecurityGroup.
type CreateSecurityGroup struct {
	// Description A description for the security group.<br />
	// This description can contain between 1 and 255 characters. Allowed characters are `a-z`, `A-Z`, `0-9`, accented letters, spaces, and `_.-:/()#,@[]+=&;{}!$*`.
	Description string `json:"description"`

	// Name The name of the security group.<br />
	// This name must not start with `sg-`.<br />
	// This name must be unique and contain between 1 and 255 characters. Allowed characters are `a-z`, `A-Z`, `0-9`, spaces, and `_.-:/()#,@[]+=&;{}!$*`.
	Name string `json:"name"`

	// VpcId The ID of the Vpc for the security group.
	VpcId string `json:"vpcId"`
}

// CreateSecurityGroupRule defines model for CreateSecurityGroupRule.
type CreateSecurityGroupRule struct {
	// Flow The direction of the flow: `Inbound` or `Outbound`. You can specify `Outbound` for Vpcs only.
	Flow string `json:"flow"`

	// FromPortRange The beginning of the port range for the TCP and UDP protocols, or an ICMP type number. If you specify this parameter, you cannot specify the `Rules` parameter and its subparameters.
	FromPortRange *int `json:"fromPortRange,omitempty"`

	// IpProtocol The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all protocols). By default, `-1`. In a Vpc, this can also be an IP protocol number. For more information, see the [IANA.org website](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml). If you specify this parameter, you cannot specify the `Rules` parameter and its subparameters.
	IpProtocol *string `json:"ipProtocol,omitempty"`

	// IpRange The IP range for the security group rule, in CIDR notation (for example, 10.0.0.0/16). If you specify this parameter, you cannot specify the `Rules` parameter and its subparameters.
	IpRange *string `json:"ipRange,omitempty"`

	// Rules Information about the security group rule to create. If you specify this parent parameter and its subparameters, you cannot specify the following parent parameters: `FromPortRange`, `IpProtocol`, `IpRange`, and `ToPortRange`.
	Rules *[]SecurityGroupRule `json:"rules,omitempty"`

	// SecurityGroupNameToLink The ID of a source or destination security group that you want to link to the security group of the rule.
	SecurityGroupNameToLink *string `json:"securityGroupNameToLink,omitempty"`

	// ToPortRange The end of the port range for the TCP and UDP protocols, or an ICMP code number. If you specify this parameter, you cannot specify the `Rules` parameter and its subparameters.
	ToPortRange *int `json:"toPortRange,omitempty"`
}

// CreateServerCertificate defines model for CreateServerCertificate.
type CreateServerCertificate struct {
	// Body The PEM-encoded X509 certificate.
	Body string `json:"body"`

	// Chain The PEM-encoded intermediate certification authorities.
	Chain *string `json:"chain,omitempty"`

	// Name A unique name for the certificate, with a maximum length of 32 alphanumeric characters and dashes (-)
	Name string `json:"name"`

	// Path The path to the server certificate, set to a slash (/) if not specified.
	Path *string `json:"path,omitempty"`

	// PrivateKey The PEM-encoded private key matching the certificate.
	PrivateKey string `json:"privateKey"`
}

// CreateSnapshot defines model for CreateSnapshot.
type CreateSnapshot struct {
	// Description A description for the snapshot.
	Description *string `json:"description,omitempty"`

	// SourceRegionName **(when copying a snapshot)** The name of the source Region, which must be the same as the Region of your account.
	SourceRegionName *string `json:"sourceRegionName,omitempty"`

	// SourceSnapshotId **(when copying a snapshot)** The ID of the snapshot you want to copy.
	SourceSnapshotId *string `json:"sourceSnapshotId,omitempty"`

	// VolumeId **(when creating from a volume)** The ID of the volume you want to create a snapshot of.
	VolumeId *string `json:"volumeId,omitempty"`
}

// CreateSpace defines model for CreateSpace.
type CreateSpace struct {
	// Description Space description
	Description string `json:"description"`

	// Name Space name
	Name string `json:"name"`
}

// CreateSubnet defines model for CreateSubnet.
type CreateSubnet struct {
	// AvailabilityZoneName The name of the Subregion in which you want to create the Subnet.
	AvailabilityZoneName *string `json:"availabilityZoneName,omitempty"`

	// IpRange The IP range in the Subnet, in CIDR notation (for example, `10.0.0.0/16`).<br />
	// The IP range of the Subnet can be either the same as the Vpc one if you create only a single Subnet in this Net, or a subset of the Vpc one. In case of several Subnets in a Vpc, their IP ranges must not overlap. The smallest Subnet you can create uses a /29 netmask (eight IPs).
	IpRange string `json:"ipRange"`

	// VpcId The ID of the Vpc for which you want to create a Subnet.
	VpcId string `json:"vpcId"`
}

// CreateTags defines model for CreateTags.
type CreateTags struct {
	// ResourceIds One or more resource IDs.
	ResourceIds []string `json:"resourceIds"`

	// Tags One or more tags to add to the specified resources.
	Tags []ResourceTag `json:"tags"`
}

// CreateVPNConnection Create a VPN Connection.
type CreateVPNConnection struct {
	ClientGatewayId Uuid `json:"clientGatewayId"`

	// ConnectionType The type of VPN connection (only `ipsec.1` is supported).
	ConnectionType string `json:"connectionType"`

	// StaticRoutesOnly By default or if false, the VPN connection uses dynamic routing with Border Gateway Protocol (BGP). If true, routing is controlled using static routes. For more information about how to create and delete static routes, see [CreateVpnConnectionRoute](#createvpnconnectionroute) and [DeleteVpnConnectionRoute](#deletevpnconnectionroute).
	StaticRoutesOnly *bool `json:"staticRoutesOnly,omitempty"`
	VirtualGatewayId Uuid  `json:"virtualGatewayId"`
}

// CreateVPNConnectionRoute Create a VPN Connection Route.
type CreateVPNConnectionRoute struct {
	// DestinationIpRange The network prefix of the route, in CIDR notation (for example, `10.12.0.0/16`).
	DestinationIpRange string `json:"destinationIpRange"`
}

// CreateVirtualGateway Create a Virtual Gateway.
type CreateVirtualGateway struct {
	// ConnectionType The type of VPN connection supported by the virtual gateway (only `ipsec.1` is supported).
	ConnectionType string `json:"connectionType"`
}

// CreateVms defines model for CreateVms.
type CreateVms struct {
	// BlockDeviceMappings One or more block device mappings.
	BlockDeviceMappings *[]BlockDeviceMappingVmCreation `json:"blockDeviceMappings,omitempty"`

	// BootOnCreation By default or if true, the VM is started on creation. If false, the VM is stopped on creation.
	BootOnCreation *bool `json:"bootOnCreation,omitempty"`

	// BsuOptimized This parameter is not available. It is present in our API for the sake of historical compatibility with AWS.
	BsuOptimized *bool `json:"bsuOptimized,omitempty"`

	// ClientToken A unique identifier which enables you to manage the idempotency.
	ClientToken *string `json:"clientToken,omitempty"`

	// DeletionProtection If true, you cannot delete the VM unless you change this parameter back to false.
	DeletionProtection *bool `json:"deletionProtection,omitempty"`

	// ImageId The ID of the Image used to create the VM. You can find the list of OMIs by calling the [ReadImages](#readimages) method.
	ImageId string `json:"imageId"`

	// KeypairName The name of the keypair.
	KeypairName *string `json:"keypairName,omitempty"`

	// NestedVirtualization (dedicated tenancy only) If true, nested virtualization is enabled. If false, it is disabled.
	NestedVirtualization *bool `json:"nestedVirtualization,omitempty"`

	// Performance The performance of the VM (`medium` \| `high` \|  `highest`). By default, `high`. This parameter is ignored if you specify a performance flag directly in the `type` parameter.
	Performance *CreateVmsPerformance `json:"performance,omitempty"`

	// Placement Information about the placement of the VM.
	Placement *Placement `json:"placement,omitempty"`

	// PrivateIps One or more private IPs of the VM.
	PrivateIps *[]string `json:"privateIps,omitempty"`

	// SecurityGroupIds One or more IDs of security group for the VMs.
	SecurityGroupIds *[]string `json:"securityGroupIds,omitempty"`

	// SecurityGroups One or more names of security groups for the VMs.
	SecurityGroups *[]string `json:"securityGroups,omitempty"`

	// SubnetId The ID of the Subnet in which you want to create the VM. If you specify this parameter, you must not specify the `Nics` parameter.
	SubnetId string `json:"subnetId"`

	// Type The type of VM.
	Type string `json:"type"`

	// UserData Data or script used to add a specific configuration to the VM. It must be Base64-encoded and is limited to 500 kibibytes (KiB).
	UserData *string `json:"userData,omitempty"`

	// VmInitiatedShutdownBehavior The VM behavior when you stop it. By default or if set to `stop`, the VM stops. If set to `restart`, the VM stops then automatically restarts. If set to `terminate`, the VM stops and is terminated.
	VmInitiatedShutdownBehavior *string `json:"vmInitiatedShutdownBehavior,omitempty"`
}

// CreateVmsPerformance The performance of the VM (`medium` \| `high` \|  `highest`). By default, `high`. This parameter is ignored if you specify a performance flag directly in the `type` parameter.
type CreateVmsPerformance string

// CreateVolume defines model for CreateVolume.
type CreateVolume struct {
	// AvailabilityZoneName The Subregion in which you want to create the volume.
	AvailabilityZoneName string `json:"availabilityZoneName"`

	// Iops The number of I/O operations per second (IOPS). This parameter must be specified only if you create an `io1` volume. The maximum number of IOPS allowed for `io1` volumes is `13000` with a maximum performance ratio of 300 IOPS per gibibyte.
	Iops *int `json:"iops,omitempty"`

	// Size The size of the volume, in gibibytes (GiB). The maximum allowed size for a volume is 14901 GiB. This parameter is required if the volume is not created from a snapshot (`SnapshotId` unspecified).
	Size *int `json:"size,omitempty"`

	// SnapshotId The ID of the snapshot from which you want to create the volume.
	SnapshotId *string `json:"snapshotId,omitempty"`

	// Type The type of volume you want to create (`io1` \| `gp2` \ | `standard`). If not specified, a `standard` volume is created.<br />
	Type *string `json:"type,omitempty"`
}

// CreateVpc defines model for CreateVpc.
type CreateVpc struct {
	// IpRange The IP range for the Vpc, in CIDR notation (for example, `10.0.0.0/16`).
	IpRange string `json:"ipRange"`

	// Tenancy The tenancy options for the VMs:<br />
	// - `default` if a VM created in a Vpc can be launched with any tenancy.<br />
	// - `dedicated` if it can be launched with dedicated tenancy VMs running on single-tenant hardware.<br />
	// - `dedicated group ID`: if it can be launched in a dedicated group on single-tenant hardware.
	Tenancy *string `json:"tenancy,omitempty"`
}

// CreatedServiceAccount defines model for CreatedServiceAccount.
type CreatedServiceAccount struct {
	// Id Service account ID
	Id string `json:"id"`

	// Name Service Accounts name
	Name string `json:"name"`

	// Secret Service account secret.
	Secret string `json:"secret"`

	// TokenDuration Set access token duration
	TokenDuration *string `json:"tokenDuration,omitempty"`
}

// CredentialSupportedDraft00 Includes information about the supported verifiable credentials.
type CredentialSupportedDraft00 struct {
	// CryptographicBindingMethodsSupported OpenID Connect Verifiable Credentials Cryptographic Binding Methods Supported
	//
	// Contains a list of cryptographic binding methods supported for signing the proof.
	CryptographicBindingMethodsSupported *[]string `json:"cryptographic_binding_methods_supported,omitempty"`

	// CryptographicSuitesSupported OpenID Connect Verifiable Credentials Cryptographic Suites Supported
	//
	// Contains a list of cryptographic suites methods supported for signing the proof.
	CryptographicSuitesSupported *[]string `json:"cryptographic_suites_supported,omitempty"`

	// Format OpenID Connect Verifiable Credentials Format
	//
	// Contains the format that is supported by this authorization server.
	Format *string `json:"format,omitempty"`

	// Types OpenID Connect Verifiable Credentials Types
	//
	// Contains the types of verifiable credentials supported.
	Types *[]string `json:"types,omitempty"`
}

// DateTime defines model for DateTime.
type DateTime = time.Time

// DeleteLoadBalancerListeners defines model for DeleteLoadBalancerListeners.
type DeleteLoadBalancerListeners struct {
	// LoadBalancerPorts One or more port numbers of the listeners you want to delete.
	LoadBalancerPorts []int `json:"loadBalancerPorts"`
}

// DeleteLoadBalancerPolicy defines model for DeleteLoadBalancerPolicy.
type DeleteLoadBalancerPolicy struct {
	// PolicyName The name of the policy you want to delete.
	PolicyName string `json:"policyName"`
}

// DeleteLoadBalancerTags defines model for DeleteLoadBalancerTags.
type DeleteLoadBalancerTags struct {
	// Names One or more load balancer names.
	Names []string `json:"names"`

	// Tags One or more tags to delete from the load balancers.
	Tags []ResourceLoadBalancerTag `json:"tags"`
}

// DeleteRoute defines model for DeleteRoute.
type DeleteRoute struct {
	// DestinationIpRange The exact IP range for the route.
	DestinationIpRange string `json:"destinationIpRange"`
}

// DeleteSecurityGroupRule defines model for DeleteSecurityGroupRule.
type DeleteSecurityGroupRule struct {
	// Flow The direction of the flow: `Inbound` or `Outbound`. You can specify `Outbound` for Vpcs only.
	Flow string `json:"flow"`

	// FromPortRange The beginning of the port range for the TCP and UDP protocols, or an ICMP type number.
	FromPortRange *int `json:"fromPortRange,omitempty"`

	// IpProtocol The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all protocols). By default, `-1`. In a Vpc, this can also be an IP protocol number. For more information, see the [IANA.org website](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
	IpProtocol *string `json:"ipProtocol,omitempty"`

	// IpRange The IP range for the security group rule, in CIDR notation (for example, `10.0.0.0/16`).
	IpRange *string `json:"ipRange,omitempty"`

	// Rules One or more rules you want to delete from the security group.
	Rules *[]SecurityGroupRule `json:"rules,omitempty"`

	// SecurityGroupNameToUnlink The ID of the source security group. If you are in the Public Cloud, you can also specify the name of the source security group.
	SecurityGroupNameToUnlink *string `json:"securityGroupNameToUnlink,omitempty"`

	// ToPortRange The end of the port range for the TCP and UDP protocols, or an ICMP code number.
	ToPortRange *int `json:"toPortRange,omitempty"`
}

// DeleteTags defines model for DeleteTags.
type DeleteTags struct {
	// ResourceIds One or more resource IDs.
	ResourceIds []string `json:"resourceIds"`

	// Tags One or more tags to delete (if you set a tag value, only the tags matching exactly this value are deleted).
	Tags []ResourceTag `json:"tags"`
}

// DeleteVPNConnectionRoute Delete a VPN Connection Route.
type DeleteVPNConnectionRoute struct {
	// DestinationIpRange The network prefix of the route to delete, in CIDR notation (for example, `10.12.0.0/16`).
	DestinationIpRange string `json:"destinationIpRange"`
}

// DhcpOptionsSet Information about the DHCP options set.
type DhcpOptionsSet struct {
	// Default If true, the DHCP options set is a default one. If false, it is not.
	Default *bool `json:"default,omitempty"`

	// DomainName The domain name.
	DomainName *string `json:"domainName,omitempty"`

	// DomainNameServers One or more IPs for the domain name servers.
	DomainNameServers *[]string `json:"domainNameServers,omitempty"`

	// Id The ID of the DHCP options set.
	Id *string `json:"id,omitempty"`

	// LogServers One or more IPs for the log servers.
	LogServers *[]string `json:"logServers,omitempty"`

	// NtpServers One or more IPs for the NTP servers.
	NtpServers *[]string `json:"ntpServers,omitempty"`

	// Tags One or more tags associated with the DHCP options set.
	Tags *[]ResourceTag `json:"tags,omitempty"`
}

// DirectLink Information about the DirectLink.
type DirectLink struct {
	// Bandwidth The physical link bandwidth (either 1 Gbps or 10 Gbps).
	Bandwidth string `json:"bandwidth"`

	// Id The ID of the DirectLink (for example, `dxcon-xxxxxxxx`).
	Id string `json:"id"`

	// Location The datacenter where the DirectLink is located.
	Location string `json:"location"`

	// Name The name of the DirectLink.
	Name string `json:"name"`

	// RegionName The Region in which the DirectLink has been created.
	RegionName string `json:"regionName"`

	// State The state of the DirectLink.<br />
	// * `requested`: The DirectLink is requested but the request has not been validated yet.<br />
	// * `pending`: The DirectLink request has been validated. It remains in the `pending` state until you establish the physical link.<br />
	// * `available`: The physical link is established and the connection is ready to use.<br />
	//  * `deleting`: The deletion process is in progress.<br />
	// * `deleted`: The DirectLink is deleted.
	State string `json:"state"`
}

// DirectLinkInterface Information about the DirectLink interfaces.
type DirectLinkInterface struct {
	// BgpAsn The BGP (Border Gateway Protocol) ASN (Autonomous System Number) on the customer's side of the DirectLink interface.
	BgpAsn int `json:"bgpAsn"`

	// ClientPrivateIp The IP on the customer's side of the DirectLink interface.
	ClientPrivateIp string `json:"clientPrivateIp"`

	// DirectLinkId The ID of the DirectLink.
	DirectLinkId string `json:"directLinkId"`

	// DirectLinkInterfaceName The name of the DirectLink interface.
	DirectLinkInterfaceName string `json:"directLinkInterfaceName"`

	// Id The ID of the DirectLink interface.
	Id string `json:"id"`

	// InterfaceType The type of the DirectLink interface (always `private`).
	InterfaceType string `json:"interfaceType"`

	// Location The datacenter where the DirectLink interface is located.
	Location string `json:"location"`

	// Mtu The maximum transmission unit (MTU) of the DirectLink interface, in bytes (always `1500`).
	Mtu int `json:"mtu"`

	// NumspotPrivateIp The IP on the NumSpot side of the DirectLink interface.
	NumspotPrivateIp string `json:"numspotPrivateIp"`

	// State The state of the DirectLink interface (`pending` \| `available` \| `deleting` \| `deleted` \| `confirming` \| `rejected` \| `expired`).
	State string `json:"state"`

	// VirtualGatewayId The ID of the target virtual gateway.
	VirtualGatewayId string `json:"virtualGatewayId"`

	// Vlan The VLAN number associated with the DirectLink interface.
	Vlan int `json:"vlan"`
}

// DirectLinkInterfaces Information about one or more DirectLink interfaces.
type DirectLinkInterfaces struct {
	Items []DirectLinkInterface `json:"items"`
}

// DirectLinks Information about one or more DirectLinks.
type DirectLinks struct {
	Items []DirectLink `json:"items"`
}

// Email defines model for Email.
type Email = openapi_types.Email

// Error For HTTP errors, we implement the https://datatracker.ietf.org/doc/html/rfc9457
type Error struct {
	// Detail Human-readable explanation specific to this occurrence of the problem.
	Detail   *string `json:"detail,omitempty"`
	Instance *Url    `json:"instance,omitempty"`

	// Title Human-readable summary of the problem type.
	Title string `json:"title"`

	// Type Documentation URL for the domain error
	Type ErrorDocumentationUrl `json:"type"`
}

// ErrorBrowserLocationChangeRequired defines model for ErrorBrowserLocationChangeRequired.
type ErrorBrowserLocationChangeRequired struct {
	// Error The standard  JSON API error format.
	Error *ErrorGeneric `json:"error,omitempty"`

	// RedirectBrowserTo Points to where to redirect the user to next.
	RedirectBrowserTo *string `json:"redirect_browser_to,omitempty"`
}

// ErrorDocumentationUrl Documentation URL for the domain error
type ErrorDocumentationUrl string

// ErrorGeneric The standard  JSON API error format.
type ErrorGeneric struct {
	Error GenericError `json:"error"`
}

// ErrorOauth2 defines model for ErrorOauth2.
type ErrorOauth2 struct {
	// Error The error type.
	Error string `json:"error"`

	// ErrorDescription A human-readable explanation specific to this occurrence of the problem.
	ErrorDescription *string `json:"error_description,omitempty"`
}

// FlexibleGpu Information about the flexible GPU (fGPU).
type FlexibleGpu struct {
	// AvailabilityZoneName The Subregion where the fGPU is located.
	AvailabilityZoneName *string `json:"availabilityZoneName,omitempty"`

	// DeleteOnVmDeletion If true, the fGPU is deleted when the VM is terminated.
	DeleteOnVmDeletion *bool `json:"deleteOnVmDeletion,omitempty"`

	// Generation The compatible processor generation.
	Generation *string `json:"generation,omitempty"`

	// Id The ID of the fGPU.
	Id *string `json:"id,omitempty"`

	// ModelName The model of fGPU.
	ModelName *string `json:"modelName,omitempty"`

	// State The state of the fGPU (`allocated` \| `attaching` \| `attached` \| `detaching`).
	State *string `json:"state,omitempty"`

	// VmId The ID of the VM the fGPU is attached to, if any.
	VmId *string `json:"vmId,omitempty"`
}

// FlowError defines model for FlowError.
type FlowError struct {
	// CreatedAt CreatedAt is a helper struct field for gobuffalo.pop.
	CreatedAt *time.Time              `json:"created_at,omitempty"`
	Error     *map[string]interface{} `json:"error,omitempty"`

	// Id ID of the error container.
	Id openapi_types.UUID `json:"id"`

	// UpdatedAt UpdatedAt is a helper struct field for gobuffalo.pop.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// GenericError defines model for GenericError.
type GenericError struct {
	// Code The status code
	Code *int64 `json:"code,omitempty"`

	// Debug Debug information
	//
	// This field is often not exposed to protect against leaking
	// sensitive information.
	Debug *string `json:"debug,omitempty"`

	// Details Further error details
	Details *map[string]interface{} `json:"details,omitempty"`

	// Id The error ID
	//
	// Useful when trying to identify various errors in application logic.
	Id *string `json:"id,omitempty"`

	// Message Error message
	//
	// The error's message.
	Message string `json:"message"`

	// Reason A human-readable reason for the error
	Reason *string `json:"reason,omitempty"`

	// Request The request ID
	//
	// The request ID is often exposed internally in order to trace
	// errors across service architectures. This is often a UUID.
	Request *string `json:"request,omitempty"`

	// Status The status description
	Status *string `json:"status,omitempty"`
}

// Gpu GPU values
type Gpu string

// HealthCheck Information about the health check configuration.
type HealthCheck struct {
	// CheckInterval The number of seconds between two requests (between `5` and `600` both included).
	CheckInterval int `json:"checkInterval"`

	// HealthyThreshold The number of consecutive successful requests before considering the VM as healthy (between `2` and `10` both included).
	HealthyThreshold int `json:"healthyThreshold"`

	// Path If you use the HTTP or HTTPS protocols, the request URL path.
	Path *string `json:"path,omitempty"`

	// Port The port number (between `1` and `65535`, both included).
	Port int `json:"port"`

	// Protocol The protocol for the URL of the VM (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
	Protocol string `json:"protocol"`

	// Timeout The maximum waiting time for a response before considering the VM as unhealthy, in seconds (between `2` and `60` both included).
	Timeout int `json:"timeout"`

	// UnhealthyThreshold The number of consecutive failed requests before considering the VM as unhealthy (between `2` and `10` both included).
	UnhealthyThreshold int `json:"unhealthyThreshold"`
}

// Healthcheck Type defining Health check from services
type Healthcheck struct {
	// Service The name of the service being health checked.
	Service string `json:"service"`

	// Status The current status of the service, either UP (functional) or DOWN (non-functional).
	Status interface{} `json:"status"`

	// Version The version of the service.
	Version string `json:"version"`
}

// HybridBridge The bridge object representation between a managed service and a standalone compute VPC.
type HybridBridge struct {
	Id openapi_types.UUID `json:"id"`

	// Route The route object representation.
	Route RouteConnectivity `json:"route"`
}

// HybridBridges List of hybrid bridges.
type HybridBridges struct {
	Items []HybridBridge `json:"items"`
}

// IAMPolicy defines model for IAMPolicy.
type IAMPolicy struct {
	// Permissions List of permission UUIDs
	Permissions *[]openapi_types.UUID `json:"permissions,omitempty"`

	// Roles List of role UUIDs
	Roles *[]openapi_types.UUID `json:"roles,omitempty"`
}

// ID defines model for ID.
type ID = int64

// Identity An identity represents a (human) user.
type Identity struct {
	// CreatedAt CreatedAt is a helper struct field for gobuffalo.pop.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Credentials Credentials represents all credentials that can be used for authenticating this identity.
	Credentials *map[string]IdentityCredentials `json:"credentials,omitempty"`

	// Id ID is the identity's unique identifier.
	// The Identity ID can not be changed and can not be chosen. This ensures future
	// compatibility and optimization for distributed stores such as CockroachDB.
	Id             openapi_types.UUID  `json:"id"`
	MetadataAdmin  *NullJsonRawMessage `json:"metadata_admin"`
	MetadataPublic *NullJsonRawMessage `json:"metadata_public"`
	OrganizationId *NullUUID           `json:"organization_id"`

	// RecoveryAddresses RecoveryAddresses contains all the addresses that can be used to recover an identity.
	RecoveryAddresses *[]RecoveryIdentityAddress `json:"recovery_addresses,omitempty"`

	// SchemaId SchemaID is the ID of the JSON Schema to be used for validating the identity's traits.
	SchemaId string `json:"schema_id"`

	// SchemaUrl SchemaURL is the URL of the endpoint where the identity's traits schema can be fetched from.
	SchemaUrl string `json:"schema_url"`

	// State State is the identity's state.
	//
	// This value has currently no effect.
	// active StateActive
	// inactive StateInactive
	State          *IdentityState `json:"state,omitempty"`
	StateChangedAt *NullTime      `json:"state_changed_at"`

	// Traits Traits represent an identity's traits. The identity is able to create, modify, and delete traits in a self-service manner. The input will always be validated against the JSON Schema defined in `schema_url`.
	Traits IdentityTraits `json:"traits"`

	// UpdatedAt UpdatedAt is a helper struct field for gobuffalo.pop.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// VerifiableAddresses VerifiableAddresses contains all the addresses that can be verified by the user.
	VerifiableAddresses *[]VerifiableIdentityAddress `json:"verifiable_addresses,omitempty"`
}

// IdentityState State is the identity's state.
//
// This value has currently no effect.
// active StateActive
// inactive StateInactive
type IdentityState string

// IdentityCredentials Credentials represents a specific credential type
type IdentityCredentials struct {
	// Config JSONRawMessage represents a json.RawMessage that works well with JSON, SQL, and Swagger.
	Config *JSONRawMessage `json:"config,omitempty"`

	// CreatedAt CreatedAt is a helper struct field for gobuffalo.pop.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Identifiers Identifiers represents a list of unique identifiers this credential type matches.
	Identifiers *[]string `json:"identifiers,omitempty"`

	// Type Type discriminates between different types of credentials.
	// password CredentialsTypePassword
	// oidc CredentialsTypeOIDC
	// totp CredentialsTypeTOTP
	// lookup_secret CredentialsTypeLookup
	// webauthn CredentialsTypeWebAuthn
	// code CredentialsTypeCodeAuth
	// link_recovery CredentialsTypeRecoveryLink  CredentialsTypeRecoveryLink is a special credential type linked to the link strategy (recovery flow).  It is not used within the credentials object itself.
	// code_recovery CredentialsTypeRecoveryCode
	Type *IdentityCredentialsType `json:"type,omitempty"`

	// UpdatedAt UpdatedAt is a helper struct field for gobuffalo.pop.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Version Version refers to the version of the credential. Useful when changing the config schema.
	Version *int64 `json:"version,omitempty"`
}

// IdentityCredentialsType Type discriminates between different types of credentials.
// password CredentialsTypePassword
// oidc CredentialsTypeOIDC
// totp CredentialsTypeTOTP
// lookup_secret CredentialsTypeLookup
// webauthn CredentialsTypeWebAuthn
// code CredentialsTypeCodeAuth
// link_recovery CredentialsTypeRecoveryLink  CredentialsTypeRecoveryLink is a special credential type linked to the link strategy (recovery flow).  It is not used within the credentials object itself.
// code_recovery CredentialsTypeRecoveryCode
type IdentityCredentialsType string

// IdentityTraits Traits represent an identity's traits. The identity is able to create, modify, and delete traits in a self-service manner. The input will always be validated against the JSON Schema defined in `schema_url`.
type IdentityTraits = interface{}

// IdentityVerifiableAddressStatus VerifiableAddressStatus must not exceed 16 characters as that is the limitation in the SQL Schema
type IdentityVerifiableAddressStatus = string

// Image Information about the Image.
type Image struct {
	// Access Permissions for the resource.
	Access *Access `json:"access,omitempty"`

	// Architecture The architecture of the Image.
	Architecture *string `json:"architecture,omitempty"`

	// BlockDeviceMappings One or more block device mappings.
	BlockDeviceMappings *[]BlockDeviceMappingImage `json:"blockDeviceMappings,omitempty"`

	// CreationDate The date and time of creation of the Image, in ISO 8601 date-time format.
	CreationDate *time.Time `json:"creationDate,omitempty"`

	// Description The description of the image.
	Description *string `json:"description,omitempty"`

	// Id The ID of the Image.
	Id *string `json:"id,omitempty"`

	// Name The name of the Image.
	Name *string `json:"name,omitempty"`

	// ProductCodes The product codes associated with the Image.
	ProductCodes *[]string `json:"productCodes,omitempty"`

	// RootDeviceName The name of the root device.
	RootDeviceName *string `json:"rootDeviceName,omitempty"`

	// RootDeviceType The type of root device used by the Image (always `bsu`).
	RootDeviceType *string `json:"rootDeviceType,omitempty"`

	// State The state of the Image (`pending` \| `available` \| `failed`).
	State *string `json:"state,omitempty"`

	// StateComment Information about the change of state.
	StateComment *StateComment `json:"stateComment,omitempty"`

	// Tags One or more tags associated with the Image.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// Type The type of the Image.
	Type *string `json:"type,omitempty"`
}

// ImmutableSpace defines model for ImmutableSpace.
type ImmutableSpace struct {
	CreatedOn DateTime `json:"createdOn"`

	// Id Internal ID
	Id openapi_types.UUID `json:"id"`

	// OrganisationId Organisation_id
	OrganisationId openapi_types.UUID `json:"organisationId"`

	// Status status of the space, the space can only be used when the status is ready.
	Status    ImmutableSpaceStatus `json:"status"`
	UpdatedOn DateTime             `json:"updatedOn"`
}

// ImmutableSpaceStatus status of the space, the space can only be used when the status is ready.
type ImmutableSpaceStatus string

// Int Equivalent to int32
type Int = int32

// InternetGateway Information about the Internet gateway.
type InternetGateway struct {
	// Id The ID of the Internet gateway.
	Id *string `json:"id,omitempty"`

	// State The state of the attachment of the Internet gateway to the Vpc (always `available`).
	State *string `json:"state,omitempty"`

	// Tags One or more tags associated with the Internet gateway.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// VpcId The ID of the Vpc attached to the Internet gateway.
	VpcId *string `json:"vpcId,omitempty"`
}

// IntrospectResp defines model for IntrospectResp.
type IntrospectResp struct {
	// Active A boolean value indicating whether the token is active or not.
	Active bool `json:"active"`

	// Aud The intended audience of the token, specifying who the token is intended for.
	Aud *[]string `json:"aud,omitempty"`

	// ClientId The unique identifier of the client application that requested the token.
	ClientId *string `json:"client_id,omitempty"`

	// Exp The expiration time of the token in seconds since the Unix epoch.
	Exp *int `json:"exp,omitempty"`

	// Iat The issued-at time of the token in seconds since the Unix epoch.
	Iat *int `json:"iat,omitempty"`

	// Iss The issuer of the token, identify the authorization server that issued the token.
	Iss *string `json:"iss,omitempty"`

	// Nbf The not-before time of the token in seconds since the Unix epoch, indicating the earliest time the token can be used.
	Nbf *int `json:"nbf,omitempty"`

	// Scope The scope of the token, defining the permissions it grants.
	Scope *string `json:"scope,omitempty"`

	// Sub The subject of the token, typically the user or resource the token is issued for.
	Sub *string `json:"sub,omitempty"`

	// TokenType Indicate the type of the token, such as "Bearer".
	TokenType *string `json:"token_type,omitempty"`

	// TokenUse Specify the intended use of the token, such as "access" or "refresh".
	TokenUse *string `json:"token_use,omitempty"`
}

// JSONRawMessage JSONRawMessage represents a json.RawMessage that works well with JSON, SQL, and Swagger.
type JSONRawMessage = map[string]interface{}

// JsonWebKey defines model for JsonWebKey.
type JsonWebKey struct {
	// Alg The "alg" (algorithm) parameter identifies the algorithm intended for use with the key.  The values used should either be registered in the IANA "JSON Web Signature and Encryption Algorithms" registry established by [JWA] or be a value that contains a Collision-Resistant Name.
	Alg string  `json:"alg"`
	Crv *string `json:"crv,omitempty"`
	D   *string `json:"d,omitempty"`
	Dp  *string `json:"dp,omitempty"`
	Dq  *string `json:"dq,omitempty"`
	E   *string `json:"e,omitempty"`
	K   *string `json:"k,omitempty"`

	// Kid The "kid" (key ID) parameter is used to match a specific key. This is used, for instance, to choose among a set of keys within a JWK Set during key rollover.  The structure of the "kid" value is unspecified. When "kid" values are used within a JWK Set, different keys within the JWK Set SHOULD use distinct "kid" values. (One example in which different keys might use the same "kid" value is if they have different "kty" (key type) values but are considered to be equivalent alternatives by the application using them.)  The "kid" value is a case-sensitive string.
	Kid string `json:"kid"`

	// Kty The "kty" parameter in JSON Web Keys (JWK) specifies the cryptographic algorithm family,such as "RSA" or "EC". It must be a case-sensitive string and is required in a JWK. The value should be registered in the IANA "JSON Web Key Types" registry or be a Collision-Resistant Name
	Kty string  `json:"kty"`
	N   *string `json:"n,omitempty"`
	P   *string `json:"p,omitempty"`
	Q   *string `json:"q,omitempty"`
	Qi  *string `json:"qi,omitempty"`

	// Use Use ("public key use") identifies the intended use of the public key. The "use" parameter is employed to indicate whether a public key is used for encrypting data or verifying the signature on data. Values are commonly "sig" (signature) or "enc" (encryption).
	Use string  `json:"use"`
	X   *string `json:"x,omitempty"`

	// X5c The "x5c" parameter in JSON Web Keys (JWK) includes a chain of one or more PKIX certificates, represented as a JSON array of base64-encoded DER certificate values. The first certificate must contain the key value and must match the public key represented by other JWK members. Additional certificates can follow, with each certifying the previous one. This parameter is optional.
	X5c *[]string `json:"x5c,omitempty"`
	Y   *string   `json:"y,omitempty"`
}

// JsonWebKeySet JSON Web Key Set
type JsonWebKeySet struct {
	// Keys List of JSON Web Keys The value of the "keys" parameter is an array of JSON Web Key (JWK) values. By default, the order of the JWK values within the array does not imply an order of preference among them, although applications  of JWK Sets can choose to assign a meaning to the order for their  purposes, if desired.
	Keys *[]JsonWebKey `json:"keys,omitempty"`
}

// Keypair Information about the keypair.
type Keypair struct {
	// Fingerprint The MD5 public key fingerprint as specified in section 4 of RFC 4716.
	Fingerprint *string `json:"fingerprint,omitempty"`

	// Name The name of the keypair.
	Name *string `json:"name,omitempty"`

	// Type The type of the keypair (`ssh-rsa`, `ssh-ed25519`, `ecdsa-sha2-nistp256`, `ecdsa-sha2-nistp384`, or `ecdsa-sha2-nistp521`).
	Type *string `json:"type,omitempty"`
}

// KubernetesBinaryContent defines model for KubernetesBinaryContent.
type KubernetesBinaryContent = openapi_types.File

// KubernetesClusterConfiguration defines model for KubernetesClusterConfiguration.
type KubernetesClusterConfiguration struct {
	// AvailabilityZone List of all Availability Zones name.
	AvailabilityZone *AvailabilityZoneName `json:"availabilityZone,omitempty"`
	Cidr             string                `json:"cidr"`
	Name             StrictSlugMax63       `json:"name"`

	// NodeCount The number of worker with given profile you want in your cluster initialization
	NodeCount int `json:"nodeCount"`

	// NodeProfile The profile defined the size and caracteristic the created worker will be
	NodeProfile KubernetesNodeProfileName `json:"nodeProfile"`
	Version     SemanticVersion           `json:"version"`
}

// KubernetesClusterInfo defines model for KubernetesClusterInfo.
type KubernetesClusterInfo struct {
	ApiUrl *Url `json:"apiUrl,omitempty"`

	// AvailabilityZone List of all Availability Zones name.
	AvailabilityZone AvailabilityZoneName `json:"availabilityZone"`

	// Cidr The IP network mask handling by the cluster
	Cidr string `json:"cidr"`

	// ClientBastionPublicIP client bastion public ip
	ClientBastionPublicIP string   `json:"clientBastionPublicIP"`
	CreatedAt             DateTime `json:"createdAt"`

	// Description Sample description of the cluster given by the user
	Description string               `json:"description"`
	Id          Uuid                 `json:"id"`
	IngressUrl  *Url                 `json:"ingressUrl,omitempty"`
	Name        StrictSlugMax63      `json:"name"`
	NodePools   []KubernetesNodePool `json:"nodePools"`
	OperationId Uuid                 `json:"operationId"`
	SelfLink    Url                  `json:"selfLink"`
	SpaceId     *Uuid                `json:"spaceId,omitempty"`

	// Status The following is a list of states in common use. APIs should consider prior art when determining state names, and should value local consistency above global consistency in the case of conflicting precedent. It encompasses the two possible kinds of States; Resting and Active.
	Status State `json:"status"`

	// Tags tags associated to the resource
	Tags      []KubernetesTag `json:"tags"`
	UpdatedAt DateTime        `json:"updatedAt"`
	Version   SemanticVersion `json:"version"`
}

// KubernetesClusterState defines model for KubernetesClusterState.
type KubernetesClusterState struct {
	ClusterId *Uuid `json:"clusterId,omitempty"`

	// Health Current health of the cluster
	Health  KubernetesClusterStateHealth `json:"health"`
	Name    StrictSlugMax63              `json:"name"`
	Nodes   []KubernetesNodeStatus       `json:"nodes"`
	SpaceId Uuid                         `json:"spaceId"`
}

// KubernetesClusterStateHealth Current health of the cluster
type KubernetesClusterStateHealth string

// KubernetesListClusters defines model for KubernetesListClusters.
type KubernetesListClusters struct {
	Items []KubernetesClusterInfo `json:"items"`

	// NextPageToken This token is used to retrieve the next page. If this field is omitted, there are no subsequent pages.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// TotalSize Equivalent to int32
	TotalSize *Int `json:"totalSize,omitempty"`
}

// KubernetesListOperations defines model for KubernetesListOperations.
type KubernetesListOperations struct {
	Items []KubernetesOperation `json:"items"`

	// NextPageToken This token is used to retrieve the next page. If this field is omitted, there are no subsequent pages.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// TotalSize Equivalent to int32
	TotalSize Int `json:"totalSize"`
}

// KubernetesMasterUpgrade defines model for KubernetesMasterUpgrade.
type KubernetesMasterUpgrade struct {
	Version SemanticVersion `json:"version"`
}

// KubernetesNodeCPU defines model for KubernetesNodeCPU.
type KubernetesNodeCPU struct {
	// Available available cpu
	Available string `json:"available"`

	// Used used cpu
	Used string `json:"used"`
}

// KubernetesNodeMemory defines model for KubernetesNodeMemory.
type KubernetesNodeMemory struct {
	// Available available memory
	Available string `json:"available"`

	// Used used memory
	Used string `json:"used"`
}

// KubernetesNodePool defines model for KubernetesNodePool.
type KubernetesNodePool struct {
	// GpuType if node profile contains gpu, it indicate which specific GPU is instanciated
	GpuType           *KubernetesNodePoolGpuType `json:"gpuType,omitempty"`
	KubernetesVersion SemanticVersion            `json:"kubernetesVersion"`
	Name              StrictSlugMax63            `json:"name"`

	// NodeCount number of node/worker containing into this node pool
	NodeCount   int                   `json:"nodeCount"`
	NodeProfile KubernetesNodeProfile `json:"nodeProfile"`
}

// KubernetesNodePoolGpuType if node profile contains gpu, it indicate which specific GPU is instanciated
type KubernetesNodePoolGpuType string

// KubernetesNodeProfile defines model for KubernetesNodeProfile.
type KubernetesNodeProfile struct {
	// Cpu amount of vCPU allocated
	Cpu int `json:"cpu"`

	// Memory amount of memory (RAM) allocated, express in Gio
	Memory int             `json:"memory"`
	Name   StrictSlugMax63 `json:"name"`
}

// KubernetesNodeProfileName The profile defined the size and caracteristic the created worker will be
type KubernetesNodeProfileName string

// KubernetesNodeProfiles defines model for KubernetesNodeProfiles.
type KubernetesNodeProfiles struct {
	NodesProfiles []string `json:"nodesProfiles"`
}

// KubernetesNodeStatus defines model for KubernetesNodeStatus.
type KubernetesNodeStatus struct {
	Cpu    KubernetesNodeCPU    `json:"cpu"`
	Memory KubernetesNodeMemory `json:"memory"`

	// Name the name of the node
	Name string `json:"name"`

	// Status status of the node
	Status KubernetesNodeStatusStatus `json:"status"`
}

// KubernetesNodeStatusStatus status of the node
type KubernetesNodeStatusStatus string

// KubernetesOperation defines model for KubernetesOperation.
type KubernetesOperation struct {
	ClusterId Uuid      `json:"clusterId"`
	CreatedAt DateTime  `json:"createdAt"`
	EndedAt   *DateTime `json:"endedAt,omitempty"`

	// Error For HTTP errors, we implement the https://datatracker.ietf.org/doc/html/rfc9457
	Error *Error `json:"error,omitempty"`
	Id    Uuid   `json:"id"`

	// OperationType The type of operation, refer to the domain action involve changes on targeted resources
	OperationType KubernetesOperationType `json:"operationType"`

	// Progress The progression of the current operation
	Progress  string    `json:"progress"`
	SelfLink  Url       `json:"selfLink"`
	StartedAt *DateTime `json:"startedAt,omitempty"`

	// Status The following is a list of states in common use. APIs should consider prior art when determining state names, and should value local consistency above global consistency in the case of conflicting precedent. It encompasses the two possible kinds of States; Resting and Active.
	Status     State            `json:"status"`
	Target     Url              `json:"target"`
	TargetName *StrictSlugMax63 `json:"targetName,omitempty"`
}

// KubernetesOperationType The type of operation, refer to the domain action involve changes on targeted resources
type KubernetesOperationType string

// KubernetesTag defines model for KubernetesTag.
type KubernetesTag struct {
	Key   StrictSlugMax63 `json:"key"`
	Value StrictSlugMax63 `json:"value"`
}

// KubernetesVersions defines model for KubernetesVersions.
type KubernetesVersions struct {
	Versions []string `json:"versions"`
}

// KubernetesWorkerRemoval defines model for KubernetesWorkerRemoval.
type KubernetesWorkerRemoval struct {
	// NodeProfile The profile defined the size and caracteristic the created worker will be
	NodeProfile KubernetesNodeProfileName `json:"nodeProfile"`
}

// KubernetesWorkerUpgrade defines model for KubernetesWorkerUpgrade.
type KubernetesWorkerUpgrade struct {
	Version SemanticVersion `json:"version"`
}

// KubernetesWorkersAddition defines model for KubernetesWorkersAddition.
type KubernetesWorkersAddition struct {
	// NodeCount the number of worker you want add in your cluster when was correctly setup
	NodeCount int `json:"nodeCount"`

	// NodeProfile The profile defined the size and caracteristic the created worker will be
	NodeProfile KubernetesNodeProfileName `json:"nodeProfile"`
	Version     SemanticVersion           `json:"version"`
}

// LinkFlexibleGpu defines model for LinkFlexibleGpu.
type LinkFlexibleGpu struct {
	// VmId The ID of the VM you want to attach the fGPU to.
	VmId string `json:"vmId"`
}

// LinkInternetGateway defines model for LinkInternetGateway.
type LinkInternetGateway struct {
	// VpcId The ID of the Vpc to which you want to attach the Internet gateway.
	VpcId string `json:"vpcId"`
}

// LinkLoadBalancerBackendMachines defines model for LinkLoadBalancerBackendMachines.
type LinkLoadBalancerBackendMachines struct {
	// BackendIps  One or more public IPs of back-end VMs.
	BackendIps *[]string `json:"backendIps,omitempty"`

	// BackendVmIds  One or more IDs of back-end VMs.
	BackendVmIds *[]string `json:"backendVmIds,omitempty"`
}

// LinkNic Information about the NIC attachment.
type LinkNic struct {
	// DeleteOnVmDeletion If true, the NIC is deleted when the VM is terminated.
	DeleteOnVmDeletion *bool `json:"deleteOnVmDeletion,omitempty"`

	// DeviceNumber The device index for the NIC attachment (between `1` and `7`, both included).
	DeviceNumber *int `json:"deviceNumber,omitempty"`

	// Id The ID of the NIC to attach.
	Id *string `json:"id,omitempty"`

	// State The state of the attachment (`attaching` \| `attached` \| `detaching` \| `detached`).
	State *string `json:"state,omitempty"`

	// VmId The ID of the VM.
	VmId *string `json:"vmId,omitempty"`
}

// LinkNicLight Information about the network interface card (NIC).
type LinkNicLight struct {
	// DeleteOnVmDeletion If true, the NIC is deleted when the VM is terminated.
	DeleteOnVmDeletion *bool `json:"deleteOnVmDeletion,omitempty"`

	// DeviceNumber The device index for the NIC attachment (between `1` and `7`, both included).
	DeviceNumber *int `json:"deviceNumber,omitempty"`

	// LinkNicId The ID of the NIC to attach.
	LinkNicId *string `json:"linkNicId,omitempty"`

	// State The state of the attachment (`attaching` \| `attached` \| `detaching` \| `detached`).
	State *string `json:"state,omitempty"`
}

// LinkNicToUpdate Information about the NIC attachment. If you are modifying the `DeleteOnVmDeletion` attribute, you must specify the ID of the NIC attachment.
type LinkNicToUpdate struct {
	// DeleteOnVmDeletion If true, the NIC is deleted when the VM is terminated. If false, the NIC is detached from the VM.
	DeleteOnVmDeletion *bool `json:"deleteOnVmDeletion,omitempty"`

	// LinkNicId The ID of the NIC attachment.
	LinkNicId *string `json:"linkNicId,omitempty"`
}

// LinkPrivateIps defines model for LinkPrivateIps.
type LinkPrivateIps struct {
	// AllowRelink If true, allows an IP that is already assigned to another NIC in the same Subnet to be assigned to the NIC you specified.
	AllowRelink *bool `json:"allowRelink,omitempty"`

	// PrivateIps The secondary private IP or IPs you want to assign to the NIC within the IP range of the Subnet.
	PrivateIps *[]string `json:"privateIps,omitempty"`

	// SecondaryPrivateIpCount The number of secondary private IPs to assign to the NIC.
	SecondaryPrivateIpCount *int `json:"secondaryPrivateIpCount,omitempty"`
}

// LinkPublicIp Information about the public IP association.
type LinkPublicIp struct {
	// Id (Required in a Vpc) The ID representing the association of the public IP with the VM or the NIC.
	Id *string `json:"id,omitempty"`

	// PublicDnsName The name of the public DNS.
	PublicDnsName *string `json:"publicDnsName,omitempty"`

	// PublicIp The public IP associated with the NIC.
	PublicIp *string `json:"publicIp,omitempty"`

	// PublicIpId The allocation ID of the public IP.
	PublicIpId *string `json:"publicIpId,omitempty"`
}

// LinkPublicIpLightForVm Information about the public IP associated with the NIC.
type LinkPublicIpLightForVm struct {
	// PublicDnsName The name of the public DNS.
	PublicDnsName *string `json:"publicDnsName,omitempty"`

	// PublicIp The public IP associated with the NIC.
	PublicIp *string `json:"publicIp,omitempty"`
}

// LinkRouteTable One or more associations between the route table and the Subnets.
type LinkRouteTable struct {
	// Id The ID of the association between the route table and the Subnet.
	Id *string `json:"id,omitempty"`

	// Main If true, the route table is the main one.
	Main *bool `json:"main,omitempty"`

	// RouteTableId The ID of the route table.
	RouteTableId *string `json:"routeTableId,omitempty"`

	// SubnetId The ID of the Subnet.
	SubnetId *string `json:"subnetId,omitempty"`

	// VpcId The ID of the Vpc.
	VpcId *string `json:"vpcId,omitempty"`
}

// LinkUnlinkVirtualGateway Link or Unlink a Virtual Gateway.
type LinkUnlinkVirtualGateway struct {
	// VpcId ID of the VPC to Link or Unlink.
	VpcId string `json:"vpcId"`
}

// LinkVolume defines model for LinkVolume.
type LinkVolume struct {
	// DeviceName The name of the device. For a root device, you must use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, and the second `X` is a letter between `a` and `z`).
	DeviceName string `json:"deviceName"`

	// VmId The ID of the VM you want to attach the volume to.
	VmId string `json:"vmId"`
}

// LinkedVolume Information about volume attachment.
type LinkedVolume struct {
	// DeleteOnVmDeletion If true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.
	DeleteOnVmDeletion *bool `json:"deleteOnVmDeletion,omitempty"`

	// DeviceName The name of the device.
	DeviceName *string `json:"deviceName,omitempty"`

	// Id The ID of the volume.
	Id *string `json:"id,omitempty"`

	// State The state of the attachment of the volume (`attaching` \| `detaching` \| `attached` \| `detached`).
	State *string `json:"state,omitempty"`

	// VmId The ID of the VM.
	VmId *string `json:"vmId,omitempty"`
}

// Listener Information about the listener.
type Listener struct {
	// BackendPort The port on which the back-end VM is listening (between `1` and `65535`, both included).
	BackendPort *int `json:"backendPort,omitempty"`

	// BackendProtocol The protocol for routing traffic to back-end VMs (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
	BackendProtocol *string `json:"backendProtocol,omitempty"`

	// LoadBalancerPort The port on which the load balancer is listening (between `1` and `65535`, both included).
	LoadBalancerPort *int `json:"loadBalancerPort,omitempty"`

	// LoadBalancerProtocol The routing protocol (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
	LoadBalancerProtocol *string `json:"loadBalancerProtocol,omitempty"`

	// PolicyNames The names of the policies. If there are no policies enabled, the list is empty.
	PolicyNames *[]string `json:"policyNames,omitempty"`

	// ServerCertificateId The NumSpot Resource Name of the server certificate.
	ServerCertificateId *string `json:"serverCertificateId,omitempty"`
}

// ListenerForCreation Information about the listener to create.
type ListenerForCreation struct {
	// BackendPort The port on which the back-end VM is listening (between `1` and `65535`, both included).
	BackendPort int `json:"backendPort"`

	// BackendProtocol The protocol for routing traffic to back-end VMs (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
	BackendProtocol *string `json:"backendProtocol,omitempty"`

	// LoadBalancerPort The port on which the load balancer is listening (between `1` and `65535`, both included).
	LoadBalancerPort int `json:"loadBalancerPort"`

	// LoadBalancerProtocol The routing protocol (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
	LoadBalancerProtocol string `json:"loadBalancerProtocol"`

	// ServerCertificateId The server certificate orn
	ServerCertificateId *string `json:"serverCertificateId,omitempty"`
}

// ListenerRule Information about the listener rule.
type ListenerRule struct {
	// Action The type of action for the rule (always `forward`).
	Action *string `json:"action,omitempty"`

	// HostNamePattern A host-name pattern for the rule, with a maximum length of 128 characters. This host-name pattern supports maximum three wildcards, and must not contain any special characters except [-.?].
	HostNamePattern *string `json:"hostNamePattern,omitempty"`

	// Id The ID of the listener rule.
	Id *int `json:"id,omitempty"`

	// ListenerId The ID of the listener.
	ListenerId *int `json:"listenerId,omitempty"`

	// Name A human-readable name for the listener rule.
	Name *string `json:"name,omitempty"`

	// PathPattern A path pattern for the rule, with a maximum length of 128 characters. This path pattern supports maximum three wildcards, and must not contain any special characters except [_-.$/~&quot;'@:+?].
	PathPattern *string `json:"pathPattern,omitempty"`

	// Priority The priority level of the listener rule, between `1` and `19999` both included. Each rule must have a unique priority level. Otherwise, an error is returned.
	Priority *int `json:"priority,omitempty"`

	// VmIds The IDs of the backend VMs.
	VmIds *[]string `json:"vmIds,omitempty"`
}

// ListenerRuleForCreation Information about the listener rule.
type ListenerRuleForCreation struct {
	// Action The type of action for the rule (always `forward`).
	Action *string `json:"action,omitempty"`

	// HostNamePattern A host-name pattern for the rule, with a maximum length of 128 characters. This host-name pattern supports maximum three wildcards, and must not contain any special characters except [-.?].
	HostNamePattern *string `json:"hostNamePattern,omitempty"`

	// ListenerRuleName A human-readable name for the listener rule, with a maximum length of 32 alphanumeric characters and dashes (-).
	ListenerRuleName string `json:"listenerRuleName"`

	// PathPattern A path pattern for the rule, with a maximum length of 128 characters. This path pattern supports maximum three wildcards, and must not contain any special characters except [_-.$/~&quot;'@:+?].
	PathPattern *string `json:"pathPattern,omitempty"`

	// Priority The priority level of the listener rule, between `1` and `19999` both included. Each rule must have a unique priority level. Otherwise, an error is returned.
	Priority int `json:"priority"`
}

// LoadBalancer Information about the load balancer.
type LoadBalancer struct {
	// ApplicationStickyCookiePolicies The stickiness policies defined for the load balancer.
	ApplicationStickyCookiePolicies *[]ApplicationStickyCookiePolicy `json:"applicationStickyCookiePolicies,omitempty"`

	// AvailabilityZoneNames The ID of the Subregion in which the load balancer was created.
	AvailabilityZoneNames *[]string `json:"availabilityZoneNames,omitempty"`

	// BackendIps One or more public IPs of back-end VMs.
	BackendIps *[]string `json:"backendIps,omitempty"`

	// BackendVmIds One or more IDs of back-end VMs for the load balancer.
	BackendVmIds *[]string `json:"backendVmIds,omitempty"`

	// DnsName The DNS name of the load balancer.
	DnsName *string `json:"dnsName,omitempty"`

	// HealthCheck Information about the health check configuration.
	HealthCheck *HealthCheck `json:"healthCheck,omitempty"`

	// Listeners The listeners for the load balancer.
	Listeners *[]Listener `json:"listeners,omitempty"`

	// Name The name of the load balancer.
	Name *string `json:"name,omitempty"`

	// PublicIp (internet-facing only) The public IP associated with the load balancer.
	PublicIp *string `json:"publicIp,omitempty"`

	// SecuredCookies Whether secure cookies are enabled for the load balancer.
	SecuredCookies *bool `json:"securedCookies,omitempty"`

	// SecurityGroups One or more IDs of security groups for the load balancers. Valid only for load balancers in a Vpc.
	SecurityGroups *[]string `json:"securityGroups,omitempty"`

	// StickyCookiePolicies The policies defined for the load balancer.
	StickyCookiePolicies *[]LoadBalancerStickyCookiePolicy `json:"stickyCookiePolicies,omitempty"`

	// Subnets The ID of the Subnet in which the load balancer was created.
	Subnets *[]string `json:"subnets,omitempty"`

	// Tags One or more tags associated with the load balancer.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// Type The type of load balancer. Valid only for load balancers in a Vpc.<br />
	// If `LoadBalancerType` is `internet-facing`, the load balancer has a public DNS name that resolves to a public IP.<br />
	// If `LoadBalancerType` is `internal`, the load balancer has a public DNS name that resolves to a private IP.
	Type *string `json:"type,omitempty"`

	// VpcId The ID of the Vpc for the load balancer.
	VpcId *string `json:"vpcId,omitempty"`
}

// LoadBalancerLight Information about the load balancer.
type LoadBalancerLight struct {
	// LoadBalancerName The name of the load balancer to which the listener is attached.
	LoadBalancerName string `json:"loadBalancerName"`

	// LoadBalancerPort The port of load balancer on which the load balancer is listening (between `1` and `65535` both included).
	LoadBalancerPort int `json:"loadBalancerPort"`
}

// LoadBalancerStickyCookiePolicy Information about the stickiness policy.
type LoadBalancerStickyCookiePolicy struct {
	// CookieExpirationPeriod The time period, in seconds, after which the cookie should be considered stale.<br />
	// If `1`, the stickiness session lasts for the duration of the browser session.
	CookieExpirationPeriod *int `json:"cookieExpirationPeriod,omitempty"`

	// PolicyName The name of the stickiness policy.
	PolicyName *string `json:"policyName,omitempty"`
}

// LoadBalancerTag Information about the load balancer tag.
type LoadBalancerTag struct {
	// Key The key of the tag.
	Key *string `json:"key,omitempty"`

	// Name The name of the load balancer.
	Name *string `json:"name,omitempty"`

	// Value The value of the tag.
	Value *string `json:"value,omitempty"`
}

// Location Locations of your availability zones.
type Location struct {
	LocationCode  string `json:"locationCode"`
	LocationName  string `json:"locationName"`
	Region        string `json:"region"`
	SubRegionName string `json:"subRegionName"`
}

// Locations Locations of your availability zones.
type Locations struct {
	Items []Location `json:"items"`
}

// LoginFlow This object represents a login flow. A login flow is initiated at the "Initiate Login API / Browser Flow"
// endpoint by a client.
//
// Once a login flow is completed successfully, a session cookie or session token will be issued.
type LoginFlow struct {
	// Active The active login method
	//
	// If set contains the login method used. If the flow is new, it is unset.
	// password CredentialsTypePassword
	// oidc CredentialsTypeOIDC
	// totp CredentialsTypeTOTP
	// lookup_secret CredentialsTypeLookup
	// webauthn CredentialsTypeWebAuthn
	// code CredentialsTypeCodeAuth
	// link_recovery CredentialsTypeRecoveryLink  CredentialsTypeRecoveryLink is a special credential type linked to the link strategy (recovery flow).  It is not used within the credentials object itself.
	// code_recovery CredentialsTypeRecoveryCode
	Active *LoginFlowActive `json:"active,omitempty"`

	// CreatedAt CreatedAt is a helper struct field for gobuffalo.pop.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// ExpiresAt ExpiresAt is the time (UTC) when the flow expires. If the user still wishes to log in,
	// a new flow has to be initiated.
	ExpiresAt time.Time `json:"expires_at"`

	// Id ID represents the flow's unique ID. When performing the login flow, this
	// represents the id in the login UI's query parameter: http://<selfservice.flows.login.ui_url>/?flow=<flow_id>
	Id openapi_types.UUID `json:"id"`

	// IssuedAt IssuedAt is the time (UTC) when the flow started.
	IssuedAt             time.Time `json:"issued_at"`
	Oauth2LoginChallenge *string   `json:"oauth2_login_challenge,omitempty"`

	// Oauth2LoginRequest OAuth2LoginRequest struct for OAuth2LoginRequest
	Oauth2LoginRequest *OAuth2LoginRequest `json:"oauth2_login_request,omitempty"`
	OrganizationId     *NullUUID           `json:"organization_id"`

	// Refresh Refresh stores whether this login flow should enforce re-authentication.
	Refresh *bool `json:"refresh,omitempty"`

	// RequestUrl RequestURL is the initial URL that was requested. It can be used
	// to forward information contained in the URL's path or query for example.
	RequestUrl string `json:"request_url"`

	// RequestedAal The authenticator assurance level can be one of "aal1", "aal2", or "aal3". A higher number means that it is harder
	// for an attacker to compromise the account.
	// Generally, "aal1" implies that one authentication factor was used while AAL2 implies that two factors (password + TOTP) have been used.
	RequestedAal *AuthenticatorAssuranceLevel `json:"requested_aal,omitempty"`

	// ReturnTo ReturnTo contains the requested return_to URL.
	ReturnTo *string `json:"return_to,omitempty"`

	// SessionTokenExchangeCode SessionTokenExchangeCode holds the secret code that the client can use to retrieve a session token after the login flow has been completed.
	// This is only set if the client has requested a session token exchange code, and if the flow is of type "api",
	// and only on creating the login flow.
	SessionTokenExchangeCode *string `json:"session_token_exchange_code,omitempty"`

	// State State represents the state of this request:
	//
	// choose_method: ask the user to choose a method to sign in with
	// sent_email: the email has been sent to the user
	// passed_challenge: the request was successful and the login challenge was passed.
	State interface{} `json:"state"`

	// Type The flow type can either be `api` or `browser`.
	Type SelfServiceFlowType `json:"type"`

	// Ui Container represents a HTML Form. The container can work with both HTTP Form and JSON requests.
	Ui UiContainer `json:"ui"`

	// UpdatedAt UpdatedAt is a helper struct field for gobuffalo.pop.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// LoginFlowActive The active login method
//
// If set contains the login method used. If the flow is new, it is unset.
// password CredentialsTypePassword
// oidc CredentialsTypeOIDC
// totp CredentialsTypeTOTP
// lookup_secret CredentialsTypeLookup
// webauthn CredentialsTypeWebAuthn
// code CredentialsTypeCodeAuth
// link_recovery CredentialsTypeRecoveryLink  CredentialsTypeRecoveryLink is a special credential type linked to the link strategy (recovery flow).  It is not used within the credentials object itself.
// code_recovery CredentialsTypeRecoveryCode
type LoginFlowActive string

// LogoutFlow Logout Flow
type LogoutFlow struct {
	// LogoutToken LogoutToken can be used to perform logout using AJAX.
	LogoutToken string `json:"logout_token"`

	// LogoutUrl LogoutURL can be opened in a browser to sign the user out.
	//
	// format: uri
	LogoutUrl string `json:"logout_url"`
}

// MaintenanceEvent Information about the maintenance event.
type MaintenanceEvent struct {
	// Code The code of the event (`system-reboot` \| `system-maintenance`).
	Code *string `json:"code,omitempty"`

	// Description The description of the event.
	Description *string `json:"description,omitempty"`

	// NotAfter The latest scheduled end time for the event.
	NotAfter *openapi_types.Date `json:"notAfter,omitempty"`

	// NotBefore The earliest scheduled start time for the event.
	NotBefore *openapi_types.Date `json:"notBefore,omitempty"`
}

// ManagedServicesBridge The bridge object representation between two managed services.
type ManagedServicesBridge struct {
	Id *openapi_types.UUID `json:"id,omitempty"`
}

// ManagedServicesBridges List of bridges.
type ManagedServicesBridges struct {
	Items []ManagedServicesBridge `json:"items"`
}

// MutableSpace defines model for MutableSpace.
type MutableSpace struct {
	// Description Space description
	Description *string `json:"description,omitempty"`

	// Name Space name
	Name *string `json:"name,omitempty"`
}

// NatGateway Information about the NAT gateway.
type NatGateway struct {
	// Id The ID of the NAT gateway.
	Id *string `json:"id,omitempty"`

	// PublicIps Information about the public IP or IPs associated with the NAT gateway.
	PublicIps *[]PublicIpLight `json:"publicIps,omitempty"`

	// State The state of the NAT gateway (`pending` \| `available` \| `deleting` \| `deleted`).
	State *string `json:"state,omitempty"`

	// SubnetId The ID of the Subnet in which the NAT gateway is.
	SubnetId *string `json:"subnetId,omitempty"`

	// Tags One or more tags associated with the NAT gateway.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// VpcId The ID of the Vpc in which the NAT gateway is.
	VpcId *string `json:"vpcId,omitempty"`
}

// Nic Information about the NIC.
type Nic struct {
	// AvailabilityZoneName The Subregion in which the NIC is located.
	AvailabilityZoneName *string `json:"availabilityZoneName,omitempty"`

	// Description The description of the NIC.
	Description *string `json:"description,omitempty"`

	// Id The ID of the NIC.
	Id *string `json:"id,omitempty"`

	// IsSourceDestChecked (Vpc only) If true, the source/destination check is enabled. If false, it is disabled. This value must be false for a NAT VM to perform network address translation (NAT) in a Vpc.
	IsSourceDestChecked *bool `json:"isSourceDestChecked,omitempty"`

	// LinkNic Information about the NIC attachment.
	LinkNic *LinkNic `json:"linkNic,omitempty"`

	// LinkPublicIp Information about the public IP association.
	LinkPublicIp *LinkPublicIp `json:"linkPublicIp,omitempty"`

	// MacAddress The Media Access Control (MAC) address of the NIC.
	MacAddress *string `json:"macAddress,omitempty"`

	// PrivateDnsName The name of the private DNS.
	PrivateDnsName *string `json:"privateDnsName,omitempty"`

	// PrivateIps The private IPs of the NIC.
	PrivateIps *[]PrivateIp `json:"privateIps,omitempty"`

	// SecurityGroups One or more IDs of security groups for the NIC.
	SecurityGroups *[]SecurityGroupLight `json:"securityGroups,omitempty"`

	// State The state of the NIC (`available` \| `attaching` \| `in-use` \| `detaching`).
	State *string `json:"state,omitempty"`

	// SubnetId The ID of the Subnet.
	SubnetId *string `json:"subnetId,omitempty"`

	// Tags One or more tags associated with the NIC.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// VpcId The ID of the Vpc for the NIC.
	VpcId *string `json:"vpcId,omitempty"`
}

// NicLight Information about the network interface card (NIC).
type NicLight struct {
	// Description The description of the NIC.
	Description *string `json:"description,omitempty"`

	// IsSourceDestChecked (Vpc only) If true, the source/destination check is enabled. If false, it is disabled. This value must be false for a NAT VM to perform network address translation (NAT) in a Vpc.
	IsSourceDestChecked *bool `json:"isSourceDestChecked,omitempty"`

	// LinkNic Information about the network interface card (NIC).
	LinkNic *LinkNicLight `json:"linkNic,omitempty"`

	// LinkPublicIp Information about the public IP associated with the NIC.
	LinkPublicIp *LinkPublicIpLightForVm `json:"linkPublicIp,omitempty"`

	// MacAddress The Media Access Control (MAC) address of the NIC.
	MacAddress *string `json:"macAddress,omitempty"`

	// NicId The ID of the NIC.
	NicId *string `json:"nicId,omitempty"`

	// PrivateDnsName The name of the private DNS.
	PrivateDnsName *string `json:"privateDnsName,omitempty"`

	// PrivateIps The private IP or IPs of the NIC.
	PrivateIps *[]PrivateIpLightForVm `json:"privateIps,omitempty"`

	// SecurityGroups One or more IDs of security groups for the NIC.
	SecurityGroups *[]SecurityGroupLight `json:"securityGroups,omitempty"`

	// State The state of the NIC (`available` \| `attaching` \| `in-use` \| `detaching`).
	State *string `json:"state,omitempty"`

	// SubnetId The ID of the Subnet for the NIC.
	SubnetId *string `json:"subnetId,omitempty"`

	// VpcId The ID of the Vpc for the NIC.
	VpcId *string `json:"vpcId,omitempty"`
}

// NodeProfile Node profiles
type NodeProfile string

// NullJsonRawMessage defines model for NullJsonRawMessage.
type NullJsonRawMessage = interface{}

// NullTime defines model for NullTime.
type NullTime = time.Time

// NullUUID defines model for NullUUID.
type NullUUID = string

// OAuth2Client OAuth2Client OAuth 2.0 Clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
type OAuth2Client struct {
	// AccessTokenStrategy OAuth 2.0 Access Token Strategy  AccessTokenStrategy is the strategy used to generate access tokens. Valid options are `jwt` and `opaque`. `jwt` is a bad idea.
	AccessTokenStrategy *string   `json:"access_token_strategy,omitempty"`
	AllowedCorsOrigins  *[]string `json:"allowed_cors_origins,omitempty"`
	Audience            *[]string `json:"audience,omitempty"`

	// AuthorizationCodeGrantAccessTokenLifespan Specify a time duration in milliseconds, seconds, minutes, hours.
	AuthorizationCodeGrantAccessTokenLifespan *string `json:"authorization_code_grant_access_token_lifespan,omitempty"`

	// AuthorizationCodeGrantIdTokenLifespan Specify a time duration in milliseconds, seconds, minutes, hours.
	AuthorizationCodeGrantIdTokenLifespan *string `json:"authorization_code_grant_id_token_lifespan,omitempty"`

	// AuthorizationCodeGrantRefreshTokenLifespan Specify a time duration in milliseconds, seconds, minutes, hours.
	AuthorizationCodeGrantRefreshTokenLifespan *string `json:"authorization_code_grant_refresh_token_lifespan,omitempty"`

	// BackchannelLogoutSessionRequired OpenID Connect Back-Channel Logout Session Required  Boolean value specifying whether the RP requires that a sid (session ID) Claim be included in the Logout Token to identify the RP session with the OP when the backchannel_logout_uri is used. If omitted, the default value is false.
	BackchannelLogoutSessionRequired *bool `json:"backchannel_logout_session_required,omitempty"`

	// BackchannelLogoutUri OpenID Connect Back-Channel Logout URI  RP URL that will cause the RP to log itself out when sent a Logout Token by the OP.
	BackchannelLogoutUri *string `json:"backchannel_logout_uri,omitempty"`

	// ClientCredentialsGrantAccessTokenLifespan Specify a time duration in milliseconds, seconds, minutes, hours.
	ClientCredentialsGrantAccessTokenLifespan *string `json:"client_credentials_grant_access_token_lifespan,omitempty"`

	// ClientId OAuth 2.0 Client ID  The ID is immutable. If no ID is provided, a UUID4 will be generated.
	ClientId *string `json:"client_id,omitempty"`

	// ClientName OAuth 2.0 Client Name  The human-readable name of the client to be presented to the end-user during authorization.
	ClientName *string `json:"client_name,omitempty"`

	// ClientSecret OAuth 2.0 Client Secret  The secret will be included in the create request as cleartext, and then never again. The secret is kept in hashed format and is not recoverable once lost.
	ClientSecret *string `json:"client_secret,omitempty"`

	// ClientSecretExpiresAt OAuth 2.0 Client Secret Expires At  The field is currently not supported and its value is always 0.
	ClientSecretExpiresAt *int64 `json:"client_secret_expires_at,omitempty"`

	// ClientUri OAuth 2.0 Client URI  ClientURI is a URL string of a web page providing information about the client. If present, the server SHOULD display this URL to the end-user in a clickable fashion.
	ClientUri *string   `json:"client_uri,omitempty"`
	Contacts  *[]string `json:"contacts,omitempty"`

	// CreatedAt OAuth 2.0 Client Creation Date  CreatedAt returns the timestamp of the client's creation.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// FrontchannelLogoutSessionRequired OpenID Connect Front-Channel Logout Session Required  Boolean value specifying whether the RP requires that iss (issuer) and sid (session ID) query parameters be included to identify the RP session with the OP when the frontchannel_logout_uri is used. If omitted, the default value is false.
	FrontchannelLogoutSessionRequired *bool `json:"frontchannel_logout_session_required,omitempty"`

	// FrontchannelLogoutUri OpenID Connect Front-Channel Logout URI  RP URL that will cause the RP to log itself out when rendered in an iframe by the OP. An iss (issuer) query parameter and a sid (session ID) query parameter MAY be included by the OP to enable the RP to validate the request and to determine which of the potentially multiple sessions is to be logged out; if either is included, both MUST be.
	FrontchannelLogoutUri *string   `json:"frontchannel_logout_uri,omitempty"`
	GrantTypes            *[]string `json:"grant_types,omitempty"`

	// ImplicitGrantAccessTokenLifespan Specify a time duration in milliseconds, seconds, minutes, hours.
	ImplicitGrantAccessTokenLifespan *string `json:"implicit_grant_access_token_lifespan,omitempty"`

	// ImplicitGrantIdTokenLifespan Specify a time duration in milliseconds, seconds, minutes, hours.
	ImplicitGrantIdTokenLifespan *string `json:"implicit_grant_id_token_lifespan,omitempty"`

	// Jwks OAuth 2.0 Client JSON Web Key Set  Client's JSON Web Key Set [JWK] document, passed by value. The semantics of the jwks parameter are the same as the jwks_uri parameter, other than that the JWK Set is passed by value, rather than by reference. This parameter is intended only to be used by Clients that, for some reason, are unable to use the jwks_uri parameter, for instance, by native applications that might not have a location to host the contents of the JWK Set. If a Client can use jwks_uri, it MUST NOT use jwks. One significant downside of jwks is that it does not enable key rotation (which jwks_uri does, as described in Section 10 of OpenID Connect Core 1.0 [OpenID.Core]). The jwks_uri and jwks parameters MUST NOT be used together.
	Jwks *interface{} `json:"jwks,omitempty"`

	// JwksUri OAuth 2.0 Client JSON Web Key Set URL  URL for the Client's JSON Web Key Set [JWK] document. If the Client signs requests to the Server, it contains the signing key(s) the Server uses to validate signatures from the Client. The JWK Set MAY also contain the Client's encryption keys(s), which are used by the Server to encrypt responses to the Client. When both signing and encryption keys are made available, a use (Key Use) parameter value is REQUIRED for all keys in the referenced JWK Set to indicate each key's intended usage. Although some algorithms allow the same key to be used for both signatures and encryption, doing so is NOT RECOMMENDED, as it is less secure. The JWK x5c parameter MAY be used to provide X.509 representations of keys provided. When used, the bare key values MUST still be present and MUST match those in the certificate.
	JwksUri *string `json:"jwks_uri,omitempty"`

	// JwtBearerGrantAccessTokenLifespan Specify a time duration in milliseconds, seconds, minutes, hours.
	JwtBearerGrantAccessTokenLifespan *string `json:"jwt_bearer_grant_access_token_lifespan,omitempty"`

	// LogoUri OAuth 2.0 Client Logo URI  A URL string referencing the client's logo.
	LogoUri *string `json:"logo_uri,omitempty"`

	// Owner OAuth 2.0 Client Owner  Owner is a string identifying the owner of the OAuth 2.0 Client.
	Owner *string `json:"owner,omitempty"`

	// PolicyUri OAuth 2.0 Client Policy URI  PolicyURI is a URL string that points to a human-readable privacy policy document that describes how the deployment organization collects, uses, retains, and discloses personal data.
	PolicyUri              *string   `json:"policy_uri,omitempty"`
	PostLogoutRedirectUris *[]string `json:"post_logout_redirect_uris,omitempty"`
	RedirectUris           *[]string `json:"redirect_uris,omitempty"`

	// RefreshTokenGrantAccessTokenLifespan Specify a time duration in milliseconds, seconds, minutes, hours.
	RefreshTokenGrantAccessTokenLifespan *string `json:"refresh_token_grant_access_token_lifespan,omitempty"`

	// RefreshTokenGrantIdTokenLifespan Specify a time duration in milliseconds, seconds, minutes, hours.
	RefreshTokenGrantIdTokenLifespan *string `json:"refresh_token_grant_id_token_lifespan,omitempty"`

	// RefreshTokenGrantRefreshTokenLifespan Specify a time duration in milliseconds, seconds, minutes, hours.
	RefreshTokenGrantRefreshTokenLifespan *string `json:"refresh_token_grant_refresh_token_lifespan,omitempty"`

	// RegistrationAccessToken OpenID Connect Dynamic Client Registration Access Token  RegistrationAccessToken can be used to update, get, or delete the OAuth2 Client. It is sent when creating a client using Dynamic Client Registration.
	RegistrationAccessToken *string `json:"registration_access_token,omitempty"`

	// RegistrationClientUri OpenID Connect Dynamic Client Registration URL  RegistrationClientURI is the URL used to update, get, or delete the OAuth2 Client.
	RegistrationClientUri *string `json:"registration_client_uri,omitempty"`

	// RequestObjectSigningAlg OpenID Connect Request Object Signing Algorithm  JWS [JWS] alg algorithm [JWA] that MUST be used for signing Request Objects sent to the OP. All Request Objects from this Client MUST be rejected, if not signed with this algorithm.
	RequestObjectSigningAlg *string   `json:"request_object_signing_alg,omitempty"`
	RequestUris             *[]string `json:"request_uris,omitempty"`
	ResponseTypes           *[]string `json:"response_types,omitempty"`

	// Scope OAuth 2.0 Client Scope  Scope is a string containing a space-separated list of scope values (as described in Section 3.3 of OAuth 2.0 [RFC6749]) that the client can use when requesting access tokens.
	Scope *string `json:"scope,omitempty"`

	// SectorIdentifierUri OpenID Connect Sector Identifier URI  URL using the https scheme to be used in calculating Pseudonymous Identifiers by the OP. The URL references a file with a single JSON array of redirect_uri values.
	SectorIdentifierUri *string `json:"sector_identifier_uri,omitempty"`

	// SkipConsent SkipConsent skips the consent screen for this client. This field can only be set from the admin API.
	SkipConsent *bool `json:"skip_consent,omitempty"`

	// SkipLogoutConsent SkipLogoutConsent skips the logout consent screen for this client. This field can only be set from the admin API.
	SkipLogoutConsent *bool `json:"skip_logout_consent,omitempty"`

	// SubjectType OpenID Connect Subject Type  The `subject_types_supported` Discovery parameter contains a list of the supported subject_type values for this server. Valid types include `pairwise` and `public`.
	SubjectType *string `json:"subject_type,omitempty"`

	// TokenEndpointAuthMethod OAuth 2.0 Token Endpoint Authentication Method  Requested Client Authentication method for the Token Endpoint. The options are:  `client_secret_basic`: (default) Send `client_id` and `client_secret` as `application/x-www-form-urlencoded` encoded in the HTTP Authorization header. `client_secret_post`: Send `client_id` and `client_secret` as `application/x-www-form-urlencoded` in the HTTP body. `private_key_jwt`: Use JSON Web Tokens to authenticate the client. `none`: Used for public clients (native apps, mobile apps) which can not have secrets.
	TokenEndpointAuthMethod *string `json:"token_endpoint_auth_method,omitempty"`

	// TokenEndpointAuthSigningAlg OAuth 2.0 Token Endpoint Signing Algorithm  Requested Client Authentication signing algorithm for the Token Endpoint.
	TokenEndpointAuthSigningAlg *string `json:"token_endpoint_auth_signing_alg,omitempty"`

	// TosUri OAuth 2.0 Client Terms of Service URI  A URL string pointing to a human-readable terms of service document for the client that describes a contractual relationship between the end-user and the client that the end-user accepts when authorizing the client.
	TosUri *string `json:"tos_uri,omitempty"`

	// UpdatedAt OAuth 2.0 Client Last Update Date  UpdatedAt returns the timestamp of the last update.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// UserinfoSignedResponseAlg OpenID Connect Request Userinfo Signed Response Algorithm  JWS alg algorithm [JWA] REQUIRED for signing UserInfo Responses. If this is specified, the response will be JWT [JWT] serialized, and signed using JWS. The default, if omitted, is for the UserInfo Response to return the Claims as a UTF-8 encoded JSON object using the application/json content-type.
	UserinfoSignedResponseAlg *string `json:"userinfo_signed_response_alg,omitempty"`
}

// OAuth2ConsentRequestOpenIDConnectContext OAuth2ConsentRequestOpenIDConnectContext struct
type OAuth2ConsentRequestOpenIDConnectContext struct {
	// AcrValues ACRValues is the Authentication AuthorizationContext Class Reference requested in the OAuth 2.0 Authorization request. It is a parameter defined by OpenID Connect and expresses which level of authentication (e.g. 2FA) is required.  OpenID Connect defines it as follows: > Requested Authentication AuthorizationContext Class Reference values. Space-separated string that specifies the acr values that the Authorization Server is being requested to use for processing this Authentication Request, with the values appearing in order of preference. The Authentication AuthorizationContext Class satisfied by the authentication performed is returned as the acr Claim Value, as specified in Section 2. The acr Claim is requested as a Voluntary Claim by this parameter.
	AcrValues *[]string `json:"acr_values,omitempty"`

	// Display Display is a string value that specifies how the Authorization Server displays the authentication and consent user interface pages to the End-User. The defined values are: page: The Authorization Server SHOULD display the authentication and consent UI consistent with a full User Agent page view. If the display parameter is not specified, this is the default display mode. popup: The Authorization Server SHOULD display the authentication and consent UI consistent with a popup User Agent window. The popup User Agent window should be of an appropriate size for a login-focused dialog and should not obscure the entire window that it is popping up over. touch: The Authorization Server SHOULD display the authentication and consent UI consistent with a device that leverages a touch interface. wap: The Authorization Server SHOULD display the authentication and consent UI consistent with a \"feature phone\" type display.  The Authorization Server MAY also attempt to detect the capabilities of the User Agent and present an appropriate display.
	Display *string `json:"display,omitempty"`

	// IdTokenHintClaims IDTokenHintClaims are the claims of the ID Token previously issued by the Authorization Server being passed as a hint about the End-User's current or past authenticated session with the Client.
	IdTokenHintClaims *map[string]interface{} `json:"id_token_hint_claims,omitempty"`

	// LoginHint LoginHint hints about the login identifier the End-User might use to log in (if necessary). This hint can be used by an RP if it first asks the End-User for their e-mail address (or other identifier) and then wants to pass that value as a hint to the discovered authorization service. This value MAY also be a phone number in the format specified for the phone_number Claim. The use of this parameter is optional.
	LoginHint *string `json:"login_hint,omitempty"`

	// UiLocales UILocales is the End-User'id preferred languages and scripts for the user interface, represented as a space-separated list of BCP47 [RFC5646] language tag values, ordered by preference. For instance, the value \"fr-CA fr en\" represents a preference for French as spoken in Canada, then French (without a region designation), followed by English (without a region designation). An error SHOULD NOT result if some or all of the requested locales are not supported by the OpenID Provider.
	UiLocales *[]string `json:"ui_locales,omitempty"`
}

// OAuth2LoginRequest OAuth2LoginRequest struct for OAuth2LoginRequest
type OAuth2LoginRequest struct {
	// Challenge ID is the identifier (\"login challenge\") of the login request. It is used to identify the session.
	Challenge *string `json:"challenge,omitempty"`

	// Client OAuth2Client OAuth 2.0 Clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
	Client *OAuth2Client `json:"client,omitempty"`

	// OidcContext OAuth2ConsentRequestOpenIDConnectContext struct
	OidcContext *OAuth2ConsentRequestOpenIDConnectContext `json:"oidc_context,omitempty"`

	// RequestUrl RequestURL is the original OAuth 2.0 Authorization URL requested by the OAuth 2.0 client. It is the URL which initiates the OAuth 2.0 Authorization Code or OAuth 2.0 Implicit flow. This URL is typically not needed, but might come in handy if you want to deal with additional request parameters.
	RequestUrl                   *string   `json:"request_url,omitempty"`
	RequestedAccessTokenAudience *[]string `json:"requested_access_token_audience,omitempty"`
	RequestedScope               *[]string `json:"requested_scope,omitempty"`

	// SessionId SessionID is the login session ID. If the user-agent reuses a login session (via cookie / remember flag) this ID will remain the same. If the user-agent did not have an existing authentication session (e.g. remember is false) this will be a new random value. This value is used as the \"sid\" parameter in the ID Token and in OIDC Front-/Back- channel logout. It's value can generally be used to associate consecutive login requests by a certain user.
	SessionId *string `json:"session_id,omitempty"`

	// Skip Skip, if true, implies that the client has requested the same scopes from the same user previously. If true, you can skip asking the user to grant the requested scopes, and simply forward the user to the redirect URL.  This feature allows you to update / set session information.
	Skip *bool `json:"skip,omitempty"`

	// Subject Subject is the user ID of the end-user that authenticated. Now, that end user needs to grant or deny the scope requested by the OAuth 2.0 client. If this value is set and `skip` is true, you MUST include this subject type when accepting the login request, or the request will fail.
	Subject *string `json:"subject,omitempty"`
}

// OidcConfiguration Includes links to several endpoints and exposes information on supported signature algorithms among others.
type OidcConfiguration struct {
	// AuthorizationEndpoint OAuth 2.0 Authorization Endpoint URL
	AuthorizationEndpoint string `json:"authorization_endpoint"`

	// BackchannelLogoutSessionSupported OpenID Connect Back-Channel Logout Session Required
	// Boolean value specifying whether the OP can pass a sid (session ID) Claim in the Logout Token to identify the RP session with the OP. If supported, the sid Claim is also included in ID Tokens issued by the OP.
	BackchannelLogoutSessionSupported *bool `json:"backchannel_logout_session_supported,omitempty"`

	// BackchannelLogoutSupported OpenID Connect Back-Channel Logout Supported
	// Boolean value specifying whether the OP supports back-channel logout, with true indicating support.
	BackchannelLogoutSupported *bool `json:"backchannel_logout_supported,omitempty"`

	// ClaimsParameterSupported OpenID Connect Claims Parameter Parameter Supported
	// Boolean value specifying whether the OP supports use of the claims parameter, with true indicating support.
	ClaimsParameterSupported *bool `json:"claims_parameter_supported,omitempty"`

	// ClaimsSupported OpenID Connect Supported Claims
	// JSON array containing a list of the Claim Names of the Claims that the OpenID Provider MAY be able to supply values for. Note that for privacy or other reasons, this might not be an exhaustive list.
	ClaimsSupported *[]string `json:"claims_supported,omitempty"`

	// CodeChallengeMethodsSupported OAuth 2.0 PKCE Supported Code Challenge Methods
	// JSON array containing a list of Proof Key for Code Exchange (PKCE) [RFC7636] code challenge methods supported by this authorization server.
	CodeChallengeMethodsSupported *[]string `json:"code_challenge_methods_supported,omitempty"`

	// CredentialsEndpointDraft00 OpenID Connect Verifiable Credentials Endpoint
	//
	// Contains the URL of the Verifiable Credentials Endpoint.
	CredentialsEndpointDraft00 *string `json:"credentials_endpoint_draft_00,omitempty"`

	// CredentialsSupportedDraft00 OpenID Connect Verifiable Credentials Supported
	// JSON array containing a list of the Verifiable Credentials supported by this authorization server.
	CredentialsSupportedDraft00 *[]CredentialSupportedDraft00 `json:"credentials_supported_draft_00,omitempty"`

	// EndSessionEndpoint OpenID Connect End-Session Endpoint
	// An URL provided by the OpenID Provider (OP) that a Relying Party (RP) can redirect to, to initiate a logout process for the End-User at the OP. This is part of the OpenID Connect session management functionality,  allowing for single sign-out across applications.
	EndSessionEndpoint *string `json:"end_session_endpoint,omitempty"`

	// FrontchannelLogoutSessionSupported OpenID Connect Front-Channel Logout Session Required
	// The boolean indicates if the OpenID Provider (OP) can use issuer (iss) and session ID (sid) parameters to identify the Relying Party (RP) session during logout via the  frontchannel_logout_uri. If this is supported, the sid claim is also included in ID Tokens issued by the OP.
	FrontchannelLogoutSessionSupported *bool `json:"frontchannel_logout_session_supported,omitempty"`

	// FrontchannelLogoutSupported OpenID Connect Front-Channel Logout Supported
	// Boolean value specifying whether the OP supports HTTP-based logout, with true indicating support.
	FrontchannelLogoutSupported *bool `json:"frontchannel_logout_supported,omitempty"`

	// GrantTypesSupported OAuth 2.0 Supported Grant Types
	// JSON array containing a list of the OAuth 2.0 Grant Type values that this OP supports.
	GrantTypesSupported *[]string `json:"grant_types_supported,omitempty"`

	// IdTokenSignedResponseAlg OpenID Connect Default ID Token Signing Algorithms
	//
	// Algorithm used to sign OpenID Connect ID Tokens.
	IdTokenSignedResponseAlg []string `json:"id_token_signed_response_alg"`

	// IdTokenSigningAlgValuesSupported OpenID Connect Supported ID Token Signing Algorithms
	//
	// JSON array containing a list of the JWS signing algorithms (alg values) supported by the OP for the ID Token to encode the Claims in a JWT.
	IdTokenSigningAlgValuesSupported []string `json:"id_token_signing_alg_values_supported"`

	// Issuer OpenID Connect Issuer URL
	// An URL using the https scheme with no query or fragment component that the OP asserts as its IssuerURL Identifier. If IssuerURL discovery is supported, this value MUST be identical to the issuer value returned by WebFinger. This also MUST be identical to the iss Claim value in ID Tokens issued from this IssuerURL.
	Issuer string `json:"issuer"`

	// JwksUri OpenID Connect Well-Known JSON Web Keys URL
	// The jwks_uri is the URL for the OpenID Provider's (OP) JSON Web Key Set (JWK) document, which contains the keys used by the Relying Party (RP) to validate the OP's signatures and, optionally, encrypt requests. Each key must specify its use (signing or encryption) for security purposes. The JWK set may include X.509  representations of keys via the x5c parameter, but the bare key values must still be present and match those in the certificate.
	JwksUri string `json:"jwks_uri"`

	// RegistrationEndpoint OpenID Connect Dynamic Client Registration Endpoint URL
	RegistrationEndpoint *string `json:"registration_endpoint,omitempty"`

	// RequestObjectSigningAlgValuesSupported OpenID Connect Supported Request Object Signing Algorithms
	// JSON array containing a list of the JWS signing algorithms (alg values) supported by the OP for Request Objects, which are described in Section 6.1 of OpenID Connect Core 1.0 [OpenID.Core]. These algorithms are used both when the Request Object is passed by value (using the request parameter) and when it is passed by reference (using the request_uri parameter).
	RequestObjectSigningAlgValuesSupported *[]string `json:"request_object_signing_alg_values_supported,omitempty"`

	// RequestParameterSupported OpenID Connect Request Parameter Supported
	// Boolean value specifying whether the OP supports use of the request parameter, with true indicating support.
	RequestParameterSupported *bool `json:"request_parameter_supported,omitempty"`

	// RequestUriParameterSupported OpenID Connect Request URI Parameter Supported
	// Boolean value specifying whether the OP supports use of the request_uri parameter, with true indicating support.
	RequestUriParameterSupported *bool `json:"request_uri_parameter_supported,omitempty"`

	// RequireRequestUriRegistration OpenID Connect Requires Request URI Registration
	// Boolean value specifying whether the OP requires any request_uri values used to be pre-registered using the request_uris registration parameter.
	RequireRequestUriRegistration *bool `json:"require_request_uri_registration,omitempty"`

	// ResponseModesSupported OAuth 2.0 Supported Response Modes
	// JSON array containing a list of the OAuth 2.0 response_mode values that this OP supports.
	ResponseModesSupported *[]string `json:"response_modes_supported,omitempty"`

	// ResponseTypesSupported OAuth 2.0 Supported Response Types
	// JSON array containing a list of the OAuth 2.0 response_type values that this OP supports. Dynamic OpenID Providers MUST support the code, id_token, and the token id_token Response Type values.
	ResponseTypesSupported []string `json:"response_types_supported"`

	// RevocationEndpoint OAuth 2.0 Token Revocation URL
	//
	// URL of the authorization server's OAuth 2.0 revocation endpoint.
	RevocationEndpoint *string `json:"revocation_endpoint,omitempty"`

	// ScopesSupported OAuth 2.0 Supported Scope Values
	// JSON array containing a list of the OAuth 2.0 [RFC6749] scope values that this server supports. The server MUST support the openid scope value. Servers MAY choose not to advertise some supported scope values even when this parameter is used
	ScopesSupported *[]string `json:"scopes_supported,omitempty"`

	// SubjectTypesSupported OpenID Connect Supported Subject Types
	// JSON array containing a list of the Subject Identifier types that this OP supports. Valid types include pairwise and public.
	SubjectTypesSupported []string `json:"subject_types_supported"`

	// TokenEndpoint OAuth 2.0 Token Endpoint URL
	TokenEndpoint string `json:"token_endpoint"`

	// TokenEndpointAuthMethodsSupported OAuth 2.0 Supported Client Authentication Methods
	//
	// JSON array containing a list of Client Authentication methods supported by this Token Endpoint. The options are client_secret_post, client_secret_basic, client_secret_jwt, and private_key_jwt, as described in Section 9 of OpenID Connect Core 1.0
	TokenEndpointAuthMethodsSupported *[]string `json:"token_endpoint_auth_methods_supported,omitempty"`

	// UserinfoEndpoint OpenID Connect Userinfo URL
	//
	// URL of the OP's UserInfo Endpoint.
	UserinfoEndpoint *string `json:"userinfo_endpoint,omitempty"`

	// UserinfoSignedResponseAlg OpenID Connect User Userinfo Signing Algorithm
	//
	// Algorithm used to sign OpenID Connect Userinfo Responses.
	UserinfoSignedResponseAlg []string `json:"userinfo_signed_response_alg"`

	// UserinfoSigningAlgValuesSupported OpenID Connect Supported Userinfo Signing Algorithm
	// JSON array containing a list of the JWS [JWS] signing algorithms (alg values) [JWA] supported by the UserInfo Endpoint to encode the Claims in a JWT [JWT].
	UserinfoSigningAlgValuesSupported *[]string `json:"userinfo_signing_alg_values_supported,omitempty"`
}

// OpenShiftCluster defines model for OpenShiftCluster.
type OpenShiftCluster struct {
	// AvailabilityZoneName List of all Availability Zones name.
	AvailabilityZoneName *AvailabilityZoneName `json:"availabilityZoneName,omitempty"`
	Cidr                 *string               `json:"cidr,omitempty"`
	Description          *string               `json:"description,omitempty"`
	Id                   *Uuid                 `json:"id,omitempty"`
	Name                 *StrictSlugMax63      `json:"name,omitempty"`
	NodePools            *[]OpenShiftNodepool  `json:"nodePools,omitempty"`

	// State Resting states are lifecycle states that, absent user action, are expected to remain indefinitely. However, the user can initiate an action to move a resource in a resting state into certain other states (resting or active).
	State   *RestingState         `json:"state,omitempty"`
	Urls    *OpenShiftClusterUrls `json:"urls,omitempty"`
	Version *SemanticVersion      `json:"version,omitempty"`
}

// OpenShiftClusterCreate defines model for OpenShiftClusterCreate.
type OpenShiftClusterCreate struct {
	// AvailabilityZoneName List of all Availability Zones name.
	AvailabilityZoneName *AvailabilityZoneName `json:"availabilityZoneName,omitempty"`

	// Cidr IP addresses in CIDR notation
	Cidr           string              `json:"cidr"`
	Description    *string             `json:"description,omitempty"`
	Name           StrictSlugMax63     `json:"name"`
	NodePools      []OpenShiftNodepool `json:"nodePools"`
	OcpAdminUserId *Uuid               `json:"ocpAdminUserId,omitempty"`
	Version        SemanticVersion     `json:"version"`
}

// OpenShiftClusterCreated defines model for OpenShiftClusterCreated.
type OpenShiftClusterCreated struct {
	Id        *Uuid               `json:"id,omitempty"`
	Name      *StrictSlugMax63    `json:"name,omitempty"`
	Operation *OpenShiftOperation `json:"operation,omitempty"`
}

// OpenShiftClusterDeleted defines model for OpenShiftClusterDeleted.
type OpenShiftClusterDeleted struct {
	Name      *StrictSlugMax63    `json:"name,omitempty"`
	Operation *OpenShiftOperation `json:"operation,omitempty"`
}

// OpenShiftClusterUpdate defines model for OpenShiftClusterUpdate.
type OpenShiftClusterUpdate struct {
	Description *string          `json:"description,omitempty"`
	Name        *StrictSlugMax63 `json:"name,omitempty"`
}

// OpenShiftClusterUrls defines model for OpenShiftClusterUrls.
type OpenShiftClusterUrls struct {
	Api     *Url `json:"api,omitempty"`
	Console *Url `json:"console,omitempty"`
}

// OpenShiftClusters defines model for OpenShiftClusters.
type OpenShiftClusters struct {
	Items *[]OpenShiftCluster `json:"items,omitempty"`

	// NextPageToken This token is used to retrieve the next page. If this field is omitted, there are no subsequent pages.
	NextPageToken *string `json:"nextPageToken,omitempty"`
	TotalSize     *int    `json:"totalSize,omitempty"`
}

// OpenShiftNodepool defines model for OpenShiftNodepool.
type OpenShiftNodepool struct {
	// AvailabilityZoneName List of all Availability Zones name.
	AvailabilityZoneName *AvailabilityZoneName `json:"availabilityZoneName,omitempty"`

	// Gpu GPU values
	Gpu       *Gpu            `json:"gpu,omitempty"`
	Name      StrictSlugMax63 `json:"name"`
	NodeCount int             `json:"nodeCount"`

	// NodeProfile Node profiles
	NodeProfile NodeProfile `json:"nodeProfile"`
	Tina        *string     `json:"tina,omitempty"`
}

// OpenShiftNodepoolCreated defines model for OpenShiftNodepoolCreated.
type OpenShiftNodepoolCreated struct {
	ClusterId    *Uuid               `json:"clusterId,omitempty"`
	NodePoolName *StrictSlugMax63    `json:"nodePoolName,omitempty"`
	Operation    *OpenShiftOperation `json:"operation,omitempty"`
}

// OpenShiftNodepoolUpdate defines model for OpenShiftNodepoolUpdate.
type OpenShiftNodepoolUpdate struct {
	Count int `json:"count"`
}

// OpenShiftNodepoolUpdated defines model for OpenShiftNodepoolUpdated.
type OpenShiftNodepoolUpdated struct {
	ClusterId    *Uuid               `json:"clusterId,omitempty"`
	NodePoolName *StrictSlugMax63    `json:"nodePoolName,omitempty"`
	Operation    *OpenShiftOperation `json:"operation,omitempty"`
}

// OpenShiftNodepools defines model for OpenShiftNodepools.
type OpenShiftNodepools struct {
	Items *[]OpenShiftNodepool `json:"items,omitempty"`

	// NextPageToken This token is used to retrieve the next page. If this field is omitted, there are no subsequent pages.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// TotalSize Equivalent to int32
	TotalSize *Int `json:"totalSize,omitempty"`
}

// OpenShiftOperation defines model for OpenShiftOperation.
type OpenShiftOperation struct {
	CreateTime *DateTime       `json:"createTime,omitempty"`
	Data       *StringOrObject `json:"data,omitempty"`
	EndTime    *DateTime       `json:"endTime,omitempty"`
	Error      *StringOrObject `json:"error,omitempty"`
	Id         *Uuid           `json:"id,omitempty"`
	Progress   *StringOrObject `json:"progress,omitempty"`
	Result     *StringOrObject `json:"result,omitempty"`
	SelfLink   *Url            `json:"selfLink,omitempty"`
	StartTime  *DateTime       `json:"startTime,omitempty"`

	// Status Resting states are lifecycle states that, absent user action, are expected to remain indefinitely. However, the user can initiate an action to move a resource in a resting state into certain other states (resting or active).
	Status     *RestingState `json:"status,omitempty"`
	TargetLink *Url          `json:"targetLink,omitempty"`

	// Type Operation types
	Type *OperationTypes `json:"type,omitempty"`
}

// OpenShiftOperations defines model for OpenShiftOperations.
type OpenShiftOperations struct {
	Items *[]OpenShiftOperation `json:"items,omitempty"`

	// NextPageToken This token is used to retrieve the next page. If this field is omitted, there are no subsequent pages.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// TotalSize Equivalent to int32
	TotalSize *Int `json:"totalSize,omitempty"`
}

// OpenShiftVersion defines model for OpenShiftVersion.
type OpenShiftVersion struct {
	Name    *StrictSlugMax63 `json:"name,omitempty"`
	Version SemanticVersion  `json:"version"`
}

// OpenShiftVersions defines model for OpenShiftVersions.
type OpenShiftVersions struct {
	Items *[]OpenShiftVersion `json:"items,omitempty"`

	// NextPageToken This token is used to retrieve the next page. If this field is omitted, there are no subsequent pages.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// TotalSize Equivalent to int32
	TotalSize *Int `json:"totalSize,omitempty"`
}

// OperationTypes Operation types
type OperationTypes string

// OrganisationSimple defines model for OrganisationSimple.
type OrganisationSimple struct {
	// Id Organisation identifier
	Id openapi_types.UUID `json:"id"`

	// Name Organisation name
	Name string `json:"name"`
}

// OrganisationSimplePaginatedList defines model for OrganisationSimplePaginatedList.
type OrganisationSimplePaginatedList struct {
	Items []OrganisationSimple `json:"items"`

	// NextPageToken This token is used to retrieve the next page. If this field is omitted, there are no subsequent pages.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// TotalSize Equivalent to int32
	TotalSize *Int `json:"totalSize,omitempty"`
}

// PaginatedList Represent the common attributes of a paginated list, to be used in an allOf with the specific items attribute of the desired type.
type PaginatedList struct {
	// NextPageToken This token is used to retrieve the next page. If this field is omitted, there are no subsequent pages.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// TotalSize Equivalent to int32
	TotalSize *Int `json:"totalSize,omitempty"`
}

// Permission A permission in the <service>[.<resource>.[<subResource>](0,1)](0,1).<action> form
type Permission struct {
	// Action Allowed operation type
	Action string `json:"action"`

	// Description Human-readable description
	Description string `json:"description"`

	// Name Human-readable name
	Name     string  `json:"name"`
	Resource *string `json:"resource,omitempty"`

	// Service Service name
	Service     string  `json:"service"`
	SubResource *string `json:"subResource,omitempty"`
}

// PermissionsPaginatedList defines model for PermissionsPaginatedList.
type PermissionsPaginatedList struct {
	Items []RegisteredPermission `json:"items"`

	// NextPageToken This token is used to retrieve the next page. If this field is omitted, there are no subsequent pages.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// TotalSize Equivalent to int32
	TotalSize *Int `json:"totalSize,omitempty"`
}

// Phase1Options Information about Phase 1 of the Internet Key Exchange (IKE) negotiation. When Phase 1 finishes successfully, peers proceed to Phase 2 negotiations.
type Phase1Options struct {
	// DpdTimeoutAction The action to carry out after a Dead Peer Detection (DPD) timeout occurs.
	DpdTimeoutAction string `json:"dpdTimeoutAction"`

	// DpdTimeoutSeconds The maximum waiting time for a Dead Peer Detection (DPD) response before considering the peer as dead, in seconds.
	DpdTimeoutSeconds int `json:"dpdTimeoutSeconds"`

	// IkeVersions The Internet Key Exchange (IKE) versions allowed for the VPN tunnel.
	IkeVersions []string `json:"ikeVersions"`

	// Phase1DhGroupNumbers The Diffie-Hellman (DH) group numbers allowed for the VPN tunnel for phase 1.
	Phase1DhGroupNumbers []int `json:"phase1DhGroupNumbers"`

	// Phase1EncryptionAlgorithms The encryption algorithms allowed for the VPN tunnel for phase 1.
	Phase1EncryptionAlgorithms []string `json:"phase1EncryptionAlgorithms"`

	// Phase1IntegrityAlgorithms The integrity algorithms allowed for the VPN tunnel for phase 1.
	Phase1IntegrityAlgorithms []string `json:"phase1IntegrityAlgorithms"`

	// Phase1LifetimeSeconds The lifetime for phase 1 of the IKE negotiation process, in seconds.
	Phase1LifetimeSeconds int `json:"phase1LifetimeSeconds"`

	// ReplayWindowSize The number of packets in an IKE replay window.
	ReplayWindowSize int `json:"replayWindowSize"`

	// StartupAction The action to carry out when establishing tunnels for a VPN connection.
	StartupAction string `json:"startupAction"`
}

// Phase2Options Information about Phase 2 of the Internet Key Exchange (IKE) negotiation.
type Phase2Options struct {
	// Phase2DhGroupNumbers The Diffie-Hellman (DH) group numbers allowed for the VPN tunnel for phase 2.
	Phase2DhGroupNumbers []int `json:"phase2DhGroupNumbers"`

	// Phase2EncryptionAlgorithms The encryption algorithms allowed for the VPN tunnel for phase 2.
	Phase2EncryptionAlgorithms []string `json:"phase2EncryptionAlgorithms"`

	// Phase2IntegrityAlgorithms The integrity algorithms allowed for the VPN tunnel for phase 2.
	Phase2IntegrityAlgorithms []string `json:"phase2IntegrityAlgorithms"`

	// Phase2LifetimeSeconds The lifetime for phase 2 of the Internet Key Exchange (IKE) negociation process, in seconds.
	Phase2LifetimeSeconds int `json:"phase2LifetimeSeconds"`

	// PreSharedKey The pre-shared key to establish the initial authentication between the client gateway and the virtual gateway. This key can contain any character except line breaks and double quotes (&quot;).
	PreSharedKey string `json:"preSharedKey"`
}

// Placement Information about the placement of the VM.
type Placement struct {
	// AvailabilityZoneName The name of the Subregion. If you specify this parameter, you must not specify the `Nics` parameter.
	AvailabilityZoneName *string `json:"availabilityZoneName,omitempty"`

	// Tenancy The tenancy of the VM (`default`, `dedicated`, or a dedicated group ID).
	Tenancy *string `json:"tenancy,omitempty"`
}

// PostgresAllowedIpRanges defines model for PostgresAllowedIpRanges.
type PostgresAllowedIpRanges = []string

// PostgresBackupDeleteOption What to do with existing backups, if any, of the cluster upon deleting it.
type PostgresBackupDeleteOption string

// PostgresBackupId A backup unique identifier.
type PostgresBackupId = openapi_types.UUID

// PostgresBackupStatus The last known status of a backup.
//
// - CREATING: means the backup is being created.
// - CREATED: means the backup is created.
// - DELETING: means the backup has been marked for deletion, it will be deleted soon.
// - FAILED: means that an operation went wrong during creation of the backup, see errorMessage for details.
// - ERROR: means that an operation went wrong when tried to update backup, See errorMessage for details
type PostgresBackupStatus string

// PostgresBaseVolume Common properties to all volume types.
type PostgresBaseVolume struct {
	// SizeGiB The size of the volume in GiB.
	SizeGiB int `json:"sizeGiB"`
}

// PostgresCluster defines model for PostgresCluster.
type PostgresCluster struct {
	AllowedIpRanges PostgresAllowedIpRanges `json:"allowedIpRanges"`

	// AutomaticBackup Whether automatic backups are enabled for this cluster
	AutomaticBackup PostgresClusterAutomaticBackup `json:"automaticBackup"`

	// AvailableOperations List of operation names
	AvailableOperations PostgresClusterOperationNames `json:"availableOperations"`

	// CreatedOn When the cluster has been created.
	CreatedOn string `json:"createdOn"`

	// ErrorReason Detailed information regarding what went wrong, available when status is Error.
	ErrorReason *string `json:"errorReason,omitempty"`

	// Host Where connexions to the cluster must be made to.
	Host *string `json:"host,omitempty"`

	// Id A cluster unique identifier.
	Id PostgresClusterId `json:"id"`

	// LastOperationName Name of an operation
	LastOperationName PostgresClusterOperationName `json:"lastOperationName"`

	// LastOperationResult Result of an operation
	LastOperationResult PostgresClusterOperationResult `json:"lastOperationResult"`

	// MaintenanceSchedule Postgres maintenance schedule object. It describes the upcoming maintenance operation for a PostgreSQL cluster, including its timing, type, and potential impact.
	MaintenanceSchedule *PostgresClusterMaintenanceSchedule `json:"maintenanceSchedule,omitempty"`
	Name                StrictSlugMax63                     `json:"name"`

	// NodeConfiguration The configuration used to provision the cluster nodes.
	NodeConfiguration PostgresNodeConfiguration `json:"nodeConfiguration"`

	// Port On which port connexions to the host must be made.
	Port *int `json:"port,omitempty"`

	// Status The last known status of a cluster.
	//
	// - CREATING: means the cluster is being created.
	// - CONFIGURING: means the cluster is being configured according to requested changes.
	// - READY: means the cluster is available and accepts connexions.
	// - FAILED: means that the cluster creation has failed, see errorMessage for details.
	// - DELETING: means the cluster has been marked for deletion, it will be deleted soon.
	// - DELETED: means the cluster has been deleted successfully, it will disappear from query and search results soon.
	// - ERROR: means that an operation went wrong on the cluster, see errorMessage for details.
	Status PostgresClusterStatus `json:"status"`

	// Tags Tags to identify resources
	Tags PostgresTags `json:"tags"`

	// User The name of the user with administration privileges on the cluster.
	User PostgresUser `json:"user"`

	// Volume The configuration for a data storage volume.
	Volume PostgresVolume `json:"volume"`
}

// PostgresClusterAutomaticBackup Whether automatic backups are enabled for this cluster
type PostgresClusterAutomaticBackup = bool

// PostgresClusterBackup defines model for PostgresClusterBackup.
type PostgresClusterBackup struct {
	// ClusterId A cluster unique identifier.
	ClusterId   PostgresClusterId `json:"clusterId"`
	ClusterName StrictSlugMax63   `json:"clusterName"`

	// DataSizeGiB The size of the backup in GiB.
	DataSizeGiB *int `json:"dataSizeGiB,omitempty"`

	// Id A backup unique identifier.
	Id PostgresBackupId `json:"id"`

	// StartedAt When the backup process started.
	StartedAt *string `json:"startedAt,omitempty"`

	// Status The last known status of a backup.
	//
	// - CREATING: means the backup is being created.
	// - CREATED: means the backup is created.
	// - DELETING: means the backup has been marked for deletion, it will be deleted soon.
	// - FAILED: means that an operation went wrong during creation of the backup, see errorMessage for details.
	// - ERROR: means that an operation went wrong when tried to update backup, See errorMessage for details
	Status PostgresBackupStatus `json:"status"`

	// StorageSizeGiB The storage capacity occupied by this backup, in GiB.
	StorageSizeGiB *int `json:"storageSizeGiB,omitempty"`

	// Tags Tags to identify resources
	Tags PostgresTags `json:"tags"`
}

// PostgresClusterCatalogItem defines model for PostgresClusterCatalogItem.
type PostgresClusterCatalogItem struct {
	Description string                         `json:"description"`
	MaxValue    *int                           `json:"maxValue,omitempty"`
	MinValue    *int                           `json:"minValue,omitempty"`
	Name        string                         `json:"name"`
	Type        PostgresClusterCatalogItemType `json:"type"`
	Values      *[]string                      `json:"values,omitempty"`
}

// PostgresClusterCatalogItemType defines model for PostgresClusterCatalogItem.Type.
type PostgresClusterCatalogItemType string

// PostgresClusterId A cluster unique identifier.
type PostgresClusterId = openapi_types.UUID

// PostgresClusterMaintenanceSchedule Postgres maintenance schedule object. It describes the upcoming maintenance operation for a PostgreSQL cluster, including its timing, type, and potential impact.
type PostgresClusterMaintenanceSchedule struct {
	// BeginAt The start date and time of the maintenance window, in ISO 8601 format.
	BeginAt string `json:"beginAt"`

	// EndAt The end date and time of the maintenance window, in ISO 8601 format.
	EndAt string `json:"endAt"`

	// PotentialImpact A description of the potential impact on the cluster's availability and performance during the maintenance window.
	PotentialImpact string `json:"potentialImpact"`

	// Type The type of maintenance operation being performed (e.g., software upgrade, hardware replacement).
	Type PostgresClusterMaintenanceScheduleType `json:"type"`
}

// PostgresClusterMaintenanceScheduleType The type of maintenance operation being performed (e.g., software upgrade, hardware replacement).
type PostgresClusterMaintenanceScheduleType string

// PostgresClusterOperationName Name of an operation
type PostgresClusterOperationName string

// PostgresClusterOperationNames List of operation names
type PostgresClusterOperationNames = []PostgresClusterOperationName

// PostgresClusterOperationResult Result of an operation
type PostgresClusterOperationResult string

// PostgresClusterStatus The last known status of a cluster.
//
// - CREATING: means the cluster is being created.
// - CONFIGURING: means the cluster is being configured according to requested changes.
// - READY: means the cluster is available and accepts connexions.
// - FAILED: means that the cluster creation has failed, see errorMessage for details.
// - DELETING: means the cluster has been marked for deletion, it will be deleted soon.
// - DELETED: means the cluster has been deleted successfully, it will disappear from query and search results soon.
// - ERROR: means that an operation went wrong on the cluster, see errorMessage for details.
type PostgresClusterStatus string

// PostgresClusterWithPassword defines model for PostgresClusterWithPassword.
type PostgresClusterWithPassword struct {
	AllowedIpRanges PostgresAllowedIpRanges `json:"allowedIpRanges"`

	// AutomaticBackup Whether automatic backups are enabled for this cluster
	AutomaticBackup PostgresClusterAutomaticBackup `json:"automaticBackup"`

	// AvailableOperations List of operation names
	AvailableOperations PostgresClusterOperationNames `json:"availableOperations"`

	// CreatedOn When the cluster has been created.
	CreatedOn string `json:"createdOn"`

	// ErrorReason Detailed information regarding what went wrong, available when status is Error.
	ErrorReason *string `json:"errorReason,omitempty"`

	// Host Where connexions to the cluster must be made to.
	Host *string `json:"host,omitempty"`

	// Id A cluster unique identifier.
	Id PostgresClusterId `json:"id"`

	// LastOperationName Name of an operation
	LastOperationName PostgresClusterOperationName `json:"lastOperationName"`

	// LastOperationResult Result of an operation
	LastOperationResult PostgresClusterOperationResult `json:"lastOperationResult"`

	// MaintenanceSchedule Postgres maintenance schedule object. It describes the upcoming maintenance operation for a PostgreSQL cluster, including its timing, type, and potential impact.
	MaintenanceSchedule *PostgresClusterMaintenanceSchedule `json:"maintenanceSchedule,omitempty"`
	Name                StrictSlugMax63                     `json:"name"`

	// NodeConfiguration The configuration used to provision the cluster nodes.
	NodeConfiguration PostgresNodeConfiguration `json:"nodeConfiguration"`

	// Password The password associated with the cluster administration user.
	//
	// **Warning**: Keep it safely, we don't store it in any retrievable way.
	Password string `json:"password"`

	// Port On which port connexions to the host must be made.
	Port *int `json:"port,omitempty"`

	// Status The last known status of a cluster.
	//
	// - CREATING: means the cluster is being created.
	// - CONFIGURING: means the cluster is being configured according to requested changes.
	// - READY: means the cluster is available and accepts connexions.
	// - FAILED: means that the cluster creation has failed, see errorMessage for details.
	// - DELETING: means the cluster has been marked for deletion, it will be deleted soon.
	// - DELETED: means the cluster has been deleted successfully, it will disappear from query and search results soon.
	// - ERROR: means that an operation went wrong on the cluster, see errorMessage for details.
	Status PostgresClusterStatus `json:"status"`

	// Tags Tags to identify resources
	Tags PostgresTags `json:"tags"`

	// User The name of the user with administration privileges on the cluster.
	User PostgresUser `json:"user"`

	// Volume The configuration for a data storage volume.
	Volume PostgresVolume `json:"volume"`
}

// PostgresDuplicatedResourceProblem A problem, compatible with [RFC 9457](https://datatracker.ietf.org/doc/html/rfc9457#name-members-of-a-problem-detail).
type PostgresDuplicatedResourceProblem = PostgresProblem

// PostgresInvalidParameterProblem A problem, compatible with [RFC 9457](https://datatracker.ietf.org/doc/html/rfc9457#name-members-of-a-problem-detail).
type PostgresInvalidParameterProblem = PostgresProblem

// PostgresNodeConfiguration The configuration used to provision the cluster nodes.
type PostgresNodeConfiguration struct {
	// MemorySizeGiB The allocated memory size, in GiB.
	MemorySizeGiB int `json:"memorySizeGiB"`

	// PerformanceLevel The performance level of the VCPUs.
	//
	// - HIGHEST: for computationally intensive applications
	// - HIGH: the performance level may fluctuate slightly over time
	// - MEDIUM: the performance level may fluctuate moderately over time
	PerformanceLevel PostgresNodeConfigurationPerformanceLevel `json:"performanceLevel"`

	// VcpuCount The number of Virtual CPU provisioned.
	VcpuCount int `json:"vcpuCount"`
}

// PostgresNodeConfigurationPerformanceLevel The performance level of the VCPUs.
//
// - HIGHEST: for computationally intensive applications
// - HIGH: the performance level may fluctuate slightly over time
// - MEDIUM: the performance level may fluctuate moderately over time
type PostgresNodeConfigurationPerformanceLevel string

// PostgresProblem A problem, compatible with [RFC 9457](https://datatracker.ietf.org/doc/html/rfc9457#name-members-of-a-problem-detail).
type PostgresProblem struct {
	// Detail Human-readable explanation specific to this occurrence of the problem.
	Detail *string `json:"detail,omitempty"`

	// Title Short, human-readable summary of the problem type.
	Title string `json:"title"`

	// Type Identifier of the problem.
	Type string `json:"type"`
}

// PostgresTag A key-value tag.
type PostgresTag struct {
	// Key The key for the tag, must be unique amongst all tags associated with a given resource.
	Key string `json:"key"`

	// Value The value associated with the tag.
	Value string `json:"value"`
}

// PostgresTagParameter A map of tags.
type PostgresTagParameter = map[string]interface{}

// PostgresTags Tags to identify resources
type PostgresTags = []PostgresTag

// PostgresTimeSlot defines model for PostgresTimeSlot.
type PostgresTimeSlot struct {
	// Begin Time of the day at which the start time slot begins.
	Begin string `json:"begin"`

	// End Time of the day at which the start time slot ends.
	End string `json:"end"`
}

// PostgresUser The name of the user with administration privileges on the cluster.
type PostgresUser = string

// PostgresVolume The configuration for a data storage volume.
type PostgresVolume struct {
	union json.RawMessage
}

// PostgresVolumeGp2 defines model for PostgresVolumeGp2.
type PostgresVolumeGp2 struct {
	// SizeGiB The size of the volume in GiB.
	SizeGiB int `json:"sizeGiB"`

	// Type The type of the volume.
	Type PostgresVolumeGp2Type `json:"type"`
}

// PostgresVolumeGp2Type The type of the volume.
type PostgresVolumeGp2Type string

// PostgresVolumeIo1 defines model for PostgresVolumeIo1.
type PostgresVolumeIo1 struct {
	// Iops The number of IOPS to allocate to the volume.
	Iops int `json:"iops"`

	// SizeGiB The size of the volume in GiB.
	SizeGiB int `json:"sizeGiB"`

	// Type The type of the volume.
	Type PostgresVolumeIo1Type `json:"type"`
}

// PostgresVolumeIo1Type The type of the volume.
type PostgresVolumeIo1Type string

// PrivateIp Information about the private IP.
type PrivateIp struct {
	// IsPrimary If true, the IP is the primary private IP of the NIC.
	IsPrimary *bool `json:"isPrimary,omitempty"`

	// LinkPublicIp Information about the public IP association.
	LinkPublicIp *LinkPublicIp `json:"linkPublicIp,omitempty"`

	// PrivateDnsName The name of the private DNS.
	PrivateDnsName *string `json:"privateDnsName,omitempty"`

	// PrivateIp The private IP of the NIC.
	PrivateIp *string `json:"privateIp,omitempty"`
}

// PrivateIpLight Information about the private IP.
type PrivateIpLight struct {
	// IsPrimary If true, the IP is the primary private IP of the NIC.
	IsPrimary *bool `json:"isPrimary,omitempty"`

	// PrivateIp The private IP of the NIC.
	PrivateIp *string `json:"privateIp,omitempty"`
}

// PrivateIpLightForVm Information about the private IP of the NIC.
type PrivateIpLightForVm struct {
	// IsPrimary If true, the IP is the primary private IP of the NIC.
	IsPrimary *bool `json:"isPrimary,omitempty"`

	// LinkPublicIp Information about the public IP associated with the NIC.
	LinkPublicIp *LinkPublicIpLightForVm `json:"linkPublicIp,omitempty"`

	// PrivateDnsName The name of the private DNS.
	PrivateDnsName *string `json:"privateDnsName,omitempty"`

	// PrivateIp The private IP.
	PrivateIp *string `json:"privateIp,omitempty"`
}

// PublicIp Information about the public IP.
type PublicIp struct {
	// Id The allocation ID of the public IP.
	Id *string `json:"id,omitempty"`

	// LinkPublicIpId (Required in a Vpc) The ID representing the association of the public IP with the VM or the NIC.
	LinkPublicIpId *string `json:"linkPublicIpId,omitempty"`

	// NicId The ID of the NIC the public IP is associated with (if any).
	NicId *string `json:"nicId,omitempty"`

	// PrivateIp The private IP associated with the public IP.
	PrivateIp *string `json:"privateIp,omitempty"`

	// PublicIp The public IP.
	PublicIp *string `json:"publicIp,omitempty"`

	// Tags One or more tags associated with the public IP.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// VmId The ID of the VM the public IP is associated with (if any).
	VmId *string `json:"vmId,omitempty"`
}

// PublicIpLight Information about the public IP.
type PublicIpLight struct {
	// PublicIp The public IP associated with the NAT gateway.
	PublicIp *string `json:"publicIp,omitempty"`

	// PublicIpId The allocation ID of the public IP associated with the NAT gateway.
	PublicIpId *string `json:"publicIpId,omitempty"`
}

// ReadAdminPassword defines model for ReadAdminPassword.
type ReadAdminPassword struct {
	// AdminPassword The password of the VM. After the first boot, returns an empty string.
	AdminPassword *string `json:"adminPassword,omitempty"`

	// VmId The ID of the VM.
	VmId *string `json:"vmId,omitempty"`
}

// ReadConsoleOutput defines model for ReadConsoleOutput.
type ReadConsoleOutput struct {
	// ConsoleOutput The Base64-encoded output of the console. If a command line tool is used, the output is decoded by the tool.
	ConsoleOutput *string `json:"consoleOutput,omitempty"`

	// VmId The ID of the VM.
	VmId *string `json:"vmId,omitempty"`
}

// ReadDhcpOptions defines model for ReadDhcpOptions.
type ReadDhcpOptions struct {
	// Items Information about one or more DHCP options sets.
	Items *[]DhcpOptionsSet `json:"items,omitempty"`
}

// ReadFlexibleGpus defines model for ReadFlexibleGpus.
type ReadFlexibleGpus struct {
	// Items Information about one or more fGPUs.
	Items *[]FlexibleGpu `json:"items,omitempty"`
}

// ReadImages defines model for ReadImages.
type ReadImages struct {
	// Items Information about one or more OMIs.
	Items *[]Image `json:"items,omitempty"`
}

// ReadInternetGateways defines model for ReadInternetGateways.
type ReadInternetGateways struct {
	// Items Information about one or more Internet gateways.
	Items *[]InternetGateway `json:"items,omitempty"`
}

// ReadKeypairs defines model for ReadKeypairs.
type ReadKeypairs struct {
	// Items Information about one or more keypairs.
	Items *[]Keypair `json:"items,omitempty"`
}

// ReadKeypairsById Information about the keypair.
type ReadKeypairsById struct {
	// Fingerprint The MD5 public key fingerprint as specified in section 4 of RFC 4716.
	Fingerprint *string `json:"fingerprint,omitempty"`

	// Name The name of the keypair.
	Name *string `json:"name,omitempty"`

	// Type The type of the keypair (`ssh-rsa`, `ssh-ed25519`, `ecdsa-sha2-nistp256`, `ecdsa-sha2-nistp384`, or `ecdsa-sha2-nistp521`).
	Type *string `json:"type,omitempty"`
}

// ReadListenerRules defines model for ReadListenerRules.
type ReadListenerRules struct {
	// Items The list of the rules to describe.
	Items *[]ListenerRule `json:"items,omitempty"`
}

// ReadLoadBalancerTags defines model for ReadLoadBalancerTags.
type ReadLoadBalancerTags struct {
	// Items Information about one or more load balancer tags.
	Items *[]LoadBalancerTag `json:"items,omitempty"`
}

// ReadLoadBalancers defines model for ReadLoadBalancers.
type ReadLoadBalancers struct {
	// Items Information about one or more load balancers.
	Items *[]LoadBalancer `json:"items,omitempty"`
}

// ReadNatGateway defines model for ReadNatGateway.
type ReadNatGateway struct {
	// Items Information about one or more NAT gateways.
	Items *[]NatGateway `json:"items,omitempty"`
}

// ReadNics defines model for ReadNics.
type ReadNics struct {
	// Items Information about one or more NICs.
	Items *[]Nic `json:"items,omitempty"`
}

// ReadPublicIps defines model for ReadPublicIps.
type ReadPublicIps struct {
	// Items Information about one or more public IPs.
	Items *[]PublicIp `json:"items,omitempty"`
}

// ReadRouteTables defines model for ReadRouteTables.
type ReadRouteTables struct {
	// Items Information about one or more route tables.
	Items *[]RouteTable `json:"items,omitempty"`
}

// ReadSecurityGroups defines model for ReadSecurityGroups.
type ReadSecurityGroups struct {
	// Items Information about one or more security groups.
	Items *[]SecurityGroup `json:"items,omitempty"`
}

// ReadServerCertificates defines model for ReadServerCertificates.
type ReadServerCertificates struct {
	// Items Information about one or more Server certificates.
	Items *[]ServerCertificate `json:"items,omitempty"`
}

// ReadSnapshots defines model for ReadSnapshots.
type ReadSnapshots struct {
	// Items Information about one or more snapshots and their permissions.
	Items *[]Snapshot `json:"items,omitempty"`
}

// ReadSubnets defines model for ReadSubnets.
type ReadSubnets struct {
	// Items Information about one or more Subnets.
	Items *[]Subnet `json:"items,omitempty"`
}

// ReadTags defines model for ReadTags.
type ReadTags struct {
	// Items Information about one or more tags.
	Items *[]Tag `json:"items,omitempty"`
}

// ReadVms defines model for ReadVms.
type ReadVms struct {
	// Items Information about one or more VMs.
	Items *[]Vm `json:"items,omitempty"`
}

// ReadVmsHealth defines model for ReadVmsHealth.
type ReadVmsHealth struct {
	// BackendVmHealth Information about the health of one or more back-end VMs.
	BackendVmHealth *[]BackendVmHealth `json:"backendVmHealth,omitempty"`
}

// ReadVmsState defines model for ReadVmsState.
type ReadVmsState struct {
	// Items Information about one or more VM states.
	Items *[]VmStates `json:"items,omitempty"`
}

// ReadVolumes defines model for ReadVolumes.
type ReadVolumes struct {
	// Items Information about one or more volumes.
	Items *[]Volume `json:"items,omitempty"`
}

// ReadVpcs defines model for ReadVpcs.
type ReadVpcs struct {
	// Items Information about the described Vpcs.
	Items *[]Vpc `json:"items,omitempty"`
}

// RecoveryAddressType RecoveryAddressType must not exceed 16 characters as that is the limitation in the SQL Schema.
type RecoveryAddressType = string

// RecoveryCode defines model for RecoveryCode.
type RecoveryCode struct {
	// Code Recovery code correctly generated
	Code       *string  `json:"code,omitempty"`
	Expiration DateTime `json:"expiration"`

	// Link Recovery link
	Link string `json:"link"`
}

// RecoveryFlow This request is used when an identity wants to recover their account.
type RecoveryFlow struct {
	// Active Active, if set, contains the recovery method that is being used. It is initially not set.
	Active *string `json:"active,omitempty"`

	// ContinueWith Contains possible actions that could follow this flow
	ContinueWith *[]ContinueWith `json:"continue_with,omitempty"`

	// ExpiresAt ExpiresAt is the time (UTC) when the request expires. If the user still wishes to update the setting, a new request has to be initiated.
	ExpiresAt time.Time `json:"expires_at"`

	// Id ID represents the request's unique ID.
	Id openapi_types.UUID `json:"id"`

	// IssuedAt IssuedAt is the time (UTC) when the request occurred.
	IssuedAt time.Time `json:"issued_at"`

	// RequestUrl RequestURL is the initial URL that was requested. It can be used
	// to forward information contained in the URL's path or query for example.
	RequestUrl string `json:"request_url"`

	// ReturnTo ReturnTo contains the requested return_to URL.
	ReturnTo *string `json:"return_to,omitempty"`

	// State State represents the state of this request:
	// choose_method: ask the user to choose a method (e.g. recover account via email)
	// sent_email: the email has been sent to the user
	// passed_challenge: the request was successful and the recovery challenge was passed.
	State interface{} `json:"state"`

	// Type The flow type can either be `api` or `browser`.
	Type SelfServiceFlowType `json:"type"`

	// Ui Container represents a HTML Form. The container can work with both HTTP Form and JSON requests.
	Ui UiContainer `json:"ui"`
}

// RecoveryIdentityAddress defines model for RecoveryIdentityAddress.
type RecoveryIdentityAddress struct {
	// CreatedAt CreatedAt is a helper struct field for gobuffalo.pop.
	CreatedAt *time.Time         `json:"created_at,omitempty"`
	Id        openapi_types.UUID `json:"id"`

	// UpdatedAt UpdatedAt is a helper struct field for gobuffalo.pop.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
	Value     string     `json:"value"`

	// Via RecoveryAddressType must not exceed 16 characters as that is the limitation in the SQL Schema.
	Via RecoveryAddressType `json:"via"`
}

// Registered defines model for Registered.
type Registered struct {
	// CreatedOn creation date
	CreatedOn time.Time `json:"createdOn"`

	// UpdatedOn last update
	UpdatedOn time.Time `json:"updatedOn"`

	// Uuid Internal ID
	Uuid openapi_types.UUID `json:"uuid"`
}

// RegisteredPermission defines model for RegisteredPermission.
type RegisteredPermission struct {
	// Action Allowed operation type
	Action string `json:"action"`

	// CreatedOn creation date
	CreatedOn time.Time `json:"createdOn"`

	// Description Human-readable description
	Description string `json:"description"`

	// Name Human-readable name
	Name     string  `json:"name"`
	Resource *string `json:"resource,omitempty"`

	// Service Service name
	Service     string  `json:"service"`
	SubResource *string `json:"subResource,omitempty"`

	// UpdatedOn last update
	UpdatedOn time.Time `json:"updatedOn"`

	// Uuid Internal ID
	Uuid openapi_types.UUID `json:"uuid"`
}

// RegisteredRole defines model for RegisteredRole.
type RegisteredRole struct {
	// CreatedOn creation date
	CreatedOn time.Time `json:"createdOn"`

	// Custom if its a custom role
	Custom bool `json:"custom"`

	// Description Human-readable description
	Description string `json:"description"`

	// Name Human-readable name
	Name string `json:"name"`

	// TenantType Array of tenant's type
	TenantType []TenantType `json:"tenantType"`

	// UpdatedOn last update
	UpdatedOn time.Time `json:"updatedOn"`

	// Uuid Internal ID
	Uuid openapi_types.UUID `json:"uuid"`
}

// ResourceLoadBalancerTag Information about the tag.
type ResourceLoadBalancerTag struct {
	// Key The key of the tag, with a minimum of 1 character.
	Key *string `json:"key,omitempty"`
}

// ResourceTag Information about the tag.
type ResourceTag struct {
	// Key The key of the tag, with a minimum of 1 character.
	Key string `json:"key"`

	// Value The value of the tag, between 0 and 255 characters.
	Value string `json:"value"`
}

// RestingState Resting states are lifecycle states that, absent user action, are expected to remain indefinitely. However, the user can initiate an action to move a resource in a resting state into certain other states (resting or active).
type RestingState string

// Role A role, linked to 1 or more permissions
type Role struct {
	// Description Human-readable description
	Description string `json:"description"`

	// Name Human-readable name
	Name string `json:"name"`

	// TenantType Array of tenant's type
	TenantType []TenantType `json:"tenantType"`
}

// RolesPaginatedList defines model for RolesPaginatedList.
type RolesPaginatedList struct {
	Items []RegisteredRole `json:"items"`

	// NextPageToken This token is used to retrieve the next page. If this field is omitted, there are no subsequent pages.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// TotalSize Equivalent to int32
	TotalSize *Int `json:"totalSize,omitempty"`
}

// Route Information about the route.
type Route struct {
	// CreationMethod The method used to create the route.
	CreationMethod *string `json:"creationMethod,omitempty"`

	// DestinationIpRange The IP range used for the destination match, in CIDR notation (for example, `10.0.0.0/24`).
	DestinationIpRange *string `json:"destinationIpRange,omitempty"`

	// DestinationServiceId The ID of the NumSpot service.
	DestinationServiceId *string `json:"destinationServiceId,omitempty"`

	// GatewayId The ID of the Internet gateway or virtual gateway attached to the Vpc.
	GatewayId *string `json:"gatewayId,omitempty"`

	// NatGatewayId The ID of a NAT gateway attached to the Vpc.
	NatGatewayId *string `json:"natGatewayId,omitempty"`

	// NicId The ID of the NIC.
	NicId *string `json:"nicId,omitempty"`

	// State The state of a route in the route table (always `active`).
	State *string `json:"state,omitempty"`

	// VmId The ID of a VM specified in a route in the table.
	VmId *string `json:"vmId,omitempty"`

	// VpcPeeringId The ID of the Vpc peering.
	VpcPeeringId *string `json:"vpcPeeringId,omitempty"`
}

// RouteConnectivity The route object representation.
type RouteConnectivity struct {
	// DestinationIpRange Type defining a CIDR (Classless Inter-Domain Routing) according to the CIDR syntax defined in RFC 4632
	DestinationIpRange Cidr   `json:"destinationIpRange"`
	GatewayId          string `json:"gatewayId"`
}

// RouteLight Information about the route.
type RouteLight struct {
	// DestinationIpRange The IP range used for the destination match, in CIDR notation (for example, `10.0.0.0/24`).
	DestinationIpRange string `json:"destinationIpRange"`

	// RouteType The type of route (always `static`).
	RouteType string `json:"routeType"`

	// State The current state of the static route (`pending` \| `available` \| `deleting` \| `deleted`).
	State string `json:"state"`
}

// RoutePropagatingVirtualGateway Information about the route propagating virtual gateway.
type RoutePropagatingVirtualGateway struct {
	// VirtualGatewayId The ID of the virtual gateway.
	VirtualGatewayId *string `json:"virtualGatewayId,omitempty"`
}

// RouteTable Information about the route table.
type RouteTable struct {
	// Id The ID of the route table.
	Id *string `json:"id,omitempty"`

	// LinkRouteTables One or more associations between the route table and Subnets.
	LinkRouteTables *[]LinkRouteTable `json:"linkRouteTables,omitempty"`

	// RoutePropagatingVirtualGateways Information about virtual gateways propagating routes.
	RoutePropagatingVirtualGateways *[]RoutePropagatingVirtualGateway `json:"routePropagatingVirtualGateways,omitempty"`

	// Routes One or more routes in the route table.
	Routes *[]Route `json:"routes,omitempty"`

	// Tags One or more tags associated with the route table.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// VpcId The ID of the Vpc for the route table.
	VpcId *string `json:"vpcId,omitempty"`
}

// SecurityGroup Information about the security group.
type SecurityGroup struct {
	// Description The description of the security group.
	Description *string `json:"description,omitempty"`

	// Id The ID of the security group.
	Id *string `json:"id,omitempty"`

	// InboundRules The inbound rules associated with the security group.
	InboundRules *[]SecurityGroupRule `json:"inboundRules,omitempty"`

	// Name The name of the security group.
	Name *string `json:"name,omitempty"`

	// OutboundRules The outbound rules associated with the security group.
	OutboundRules *[]SecurityGroupRule `json:"outboundRules,omitempty"`

	// Tags One or more tags associated with the security group.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// VpcId The ID of the Vpc for the security group.
	VpcId *string `json:"vpcId,omitempty"`
}

// SecurityGroupLight Information about the security group.
type SecurityGroupLight struct {
	// SecurityGroupId The ID of the security group.
	SecurityGroupId *string `json:"securityGroupId,omitempty"`

	// SecurityGroupName The name of the security group.
	SecurityGroupName *string `json:"securityGroupName,omitempty"`
}

// SecurityGroupRule Information about the security group rule.
type SecurityGroupRule struct {
	// FromPortRange The beginning of the port range for the TCP and UDP protocols, or an ICMP type number.
	FromPortRange *int `json:"fromPortRange,omitempty"`

	// IpProtocol The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all protocols). By default, `-1`. In a Vpc, this can also be an IP protocol number. For more information, see the [IANA.org website](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
	IpProtocol *string `json:"ipProtocol,omitempty"`

	// IpRanges One or more IP ranges for the security group rules, in CIDR notation (for example, `10.0.0.0/16`).
	IpRanges *[]string `json:"ipRanges,omitempty"`

	// SecurityGroupsMembers Information about one or more source or destination security groups.
	SecurityGroupsMembers *[]SecurityGroupsMember `json:"securityGroupsMembers,omitempty"`

	// ServiceIds One or more service IDs to allow traffic from a Vpc to access the corresponding NumSpot services.
	ServiceIds *[]string `json:"serviceIds,omitempty"`

	// ToPortRange The end of the port range for the TCP and UDP protocols, or an ICMP code number.
	ToPortRange *int `json:"toPortRange,omitempty"`
}

// SecurityGroupsMember Information about a source or destination security group.
type SecurityGroupsMember struct {
	// SecurityGroupId The ID of a source or destination security group that you want to link to the security group of the rule.
	SecurityGroupId *string `json:"securityGroupId,omitempty"`

	// SecurityGroupName (Public Cloud only) The name of a source or destination security group that you want to link to the security group of the rule.
	SecurityGroupName *string `json:"securityGroupName,omitempty"`
}

// SelfServiceFlowType The flow type can either be `api` or `browser`.
type SelfServiceFlowType = string

// SemanticVersion defines model for SemanticVersion.
type SemanticVersion = string

// ServerCertificate Information about the Server Certificates.
type ServerCertificate struct {
	// ExpirationDate The date on which the server certificate expires.
	ExpirationDate *string `json:"expirationDate,omitempty"`

	// Id The ID of the server certificate.
	Id *string `json:"id,omitempty"`

	// Name The name of the server certificate.
	Name *string `json:"name,omitempty"`

	// Path The path to the server certificate.
	Path *string `json:"path,omitempty"`

	// UploadDate The date on which the server certificate has been uploaded.
	UploadDate *string `json:"uploadDate,omitempty"`
}

// ServiceAccount defines model for ServiceAccount.
type ServiceAccount struct {
	// Name Service account name
	Name string `json:"name"`

	// TokenDuration Token duration in ISO 8601 format. Default is 24 hours (PT24H). Must be between 1 second (PT1S) and 48 hours (PT48H).
	TokenDuration *string `json:"tokenDuration,omitempty"`
}

// ServiceAccountEdited defines model for ServiceAccountEdited.
type ServiceAccountEdited struct {
	// Id Service account ID
	Id string `json:"id"`

	// Name Service Accounts name
	Name string `json:"name"`

	// TokenDuration Set access token duration
	TokenDuration *string `json:"tokenDuration,omitempty"`
}

// ServiceAccountPaginatedList defines model for ServiceAccountPaginatedList.
type ServiceAccountPaginatedList struct {
	Items []ServiceAccountEdited `json:"items"`

	// NextPageToken This token is used to retrieve the next page. If this field is omitted, there are no subsequent pages.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// TotalSize Equivalent to int32
	TotalSize *Int `json:"totalSize,omitempty"`
}

// Session A Session
type Session struct {
	// Active Active state. If false the session is no longer active.
	Active *bool `json:"active,omitempty"`

	// AuthenticatedAt The Session Authentication Timestamp
	//
	// When this session was authenticated at. If multi-factor authentication was used this
	// is the time when the last factor was authenticated (e.g. the TOTP code challenge was completed).
	AuthenticatedAt *time.Time `json:"authenticated_at,omitempty"`

	// AuthenticationMethods A list of authenticators which were used to authenticate the session.
	AuthenticationMethods *SessionAuthenticationMethods `json:"authentication_methods,omitempty"`

	// AuthenticatorAssuranceLevel The authenticator assurance level can be one of "aal1", "aal2", or "aal3". A higher number means that it is harder
	// for an attacker to compromise the account.
	// Generally, "aal1" implies that one authentication factor was used while AAL2 implies that two factors (password + TOTP) have been used.
	AuthenticatorAssuranceLevel *AuthenticatorAssuranceLevel `json:"authenticator_assurance_level,omitempty"`

	// Devices Devices has history of all endpoints where the session was used
	Devices *[]SessionDevice `json:"devices,omitempty"`

	// ExpiresAt The Session Expiry
	//
	// When this session expires at.
	ExpiresAt *time.Time `json:"expires_at,omitempty"`

	// Id Session ID
	Id openapi_types.UUID `json:"id"`

	// Identity An identity represents a (human) user.
	Identity *Identity `json:"identity,omitempty"`

	// IssuedAt The Session Issuance Timestamp
	//
	// When this session was issued at. Usually equal or close to `authenticated_at`.
	IssuedAt *time.Time `json:"issued_at,omitempty"`

	// Tokenized Tokenized is the tokenized (e.g. JWT) version of the session.
	//
	// It is only set when the `tokenize` query parameter was set to a valid tokenize template during calls to `/session/whoami`.
	Tokenized *string `json:"tokenized,omitempty"`
}

// SessionAuthenticationMethod A singular authenticator used during authentication / login.
type SessionAuthenticationMethod struct {
	// Aal The authenticator assurance level can be one of "aal1", "aal2", or "aal3". A higher number means that it is harder
	// for an attacker to compromise the account.
	// Generally, "aal1" implies that one authentication factor was used while AAL2 implies that two factors (password + TOTP) have been used.
	Aal *AuthenticatorAssuranceLevel `json:"aal,omitempty"`

	// CompletedAt When the authentication challenge was completed.
	CompletedAt *time.Time                         `json:"completed_at,omitempty"`
	Method      *SessionAuthenticationMethodMethod `json:"method,omitempty"`

	// Organization The Organization id used for authentication
	Organization *string `json:"organization,omitempty"`

	// Provider OIDC or SAML provider id used for authentication
	Provider *string `json:"provider,omitempty"`
}

// SessionAuthenticationMethodMethod defines model for SessionAuthenticationMethod.Method.
type SessionAuthenticationMethodMethod string

// SessionAuthenticationMethods A list of authenticators which were used to authenticate the session.
type SessionAuthenticationMethods = []SessionAuthenticationMethod

// SessionDevice Device corresponding to a Session
type SessionDevice struct {
	// Id Device record ID
	Id openapi_types.UUID `json:"id"`

	// IpAddress IPAddress of the client
	IpAddress *string `json:"ip_address,omitempty"`

	// Location Geo Location corresponding to the IP Address
	Location *string `json:"location,omitempty"`

	// UserAgent UserAgent of the client
	UserAgent *string `json:"user_agent,omitempty"`
}

// SettingsFlow This flow is used when an identity wants to update settings
type SettingsFlow struct {
	// Active Active, if set, contains the registration method that is being used. It is initially
	// not set.
	Active *string `json:"active,omitempty"`

	// ContinueWith Contains a list of actions, that could follow this flow
	//
	// It can, for example, contain a reference to the verification flow, created as part of the user's
	// registration.
	ContinueWith *[]ContinueWith `json:"continue_with,omitempty"`

	// ExpiresAt ExpiresAt is the time (UTC) when the flow expires. If the user still wishes to update the setting,
	// a new flow has to be initiated.
	ExpiresAt time.Time `json:"expires_at"`

	// Id ID represents the flow's unique ID. When performing the settings flow, this
	// represents the id in the settings ui's query parameter: http://<selfservice.flows.settings.ui_url>?flow=<id>
	Id openapi_types.UUID `json:"id"`

	// Identity An identity represents a (human) user.
	Identity Identity `json:"identity"`

	// IssuedAt IssuedAt is the time (UTC) when the flow occurred.
	IssuedAt time.Time `json:"issued_at"`

	// RequestUrl RequestURL is the initial URL that was requested. It can be used to forward information contained in the URL's path or query for example.
	RequestUrl string `json:"request_url"`

	// ReturnTo ReturnTo contains the requested return_to URL.
	ReturnTo *string `json:"return_to,omitempty"`

	// State State represents the state of this flow. It knows two states:
	// show_form: No user data has been collected, or it is invalid, and thus the form should be shown.
	// success: Indicates that the settings flow has been updated successfully with the provided data.
	// Done will stay true when repeatedly checking. If set to true, done will revert back to false only
	// when a flow with invalid (e.g. "please use a valid phone number") data was sent.
	State interface{} `json:"state"`

	// Type The flow type can either be `api` or `browser`.
	Type SelfServiceFlowType `json:"type"`

	// Ui Container represents a HTML Form. The container can work with both HTTP Form and JSON requests.
	Ui UiContainer `json:"ui"`
}

// Snapshot Information about the snapshot.
type Snapshot struct {
	// Access Permissions for the resource.
	Access *Access `json:"access,omitempty"`

	// CreationDate The date and time of creation of the snapshot.
	CreationDate *time.Time `json:"creationDate,omitempty"`

	// Description The description of the snapshot.
	Description *string `json:"description,omitempty"`

	// Id The ID of the snapshot.
	Id *string `json:"id,omitempty"`

	// Progress The progress of the snapshot, as a percentage.
	Progress *int `json:"progress,omitempty"`

	// State The state of the snapshot (`in-queue` \| `completed` \| `error`).
	State *string `json:"state,omitempty"`

	// Tags One or more tags associated with the snapshot.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// VolumeId The ID of the volume used to create the snapshot.
	VolumeId *string `json:"volumeId,omitempty"`

	// VolumeSize The size of the volume used to create the snapshot, in gibibytes (GiB).
	VolumeSize *int `json:"volumeSize,omitempty"`
}

// Space defines model for Space.
type Space struct {
	CreatedOn DateTime `json:"createdOn"`

	// Description Space description
	Description string `json:"description"`

	// Id Internal ID
	Id openapi_types.UUID `json:"id"`

	// Name Space name
	Name string `json:"name"`

	// OrganisationId Organisation_id
	OrganisationId openapi_types.UUID `json:"organisationId"`

	// Status status of the space, the space can only be used when the status is ready.
	Status    SpaceStatus `json:"status"`
	UpdatedOn DateTime    `json:"updatedOn"`
}

// SpaceStatus status of the space, the space can only be used when the status is ready.
type SpaceStatus string

// SpacePaginatedList defines model for SpacePaginatedList.
type SpacePaginatedList struct {
	Items []Space `json:"items"`

	// NextPageToken This token is used to retrieve the next page. If this field is omitted, there are no subsequent pages.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// TotalSize Equivalent to int32
	TotalSize *Int `json:"totalSize,omitempty"`
}

// SpaceSimple defines model for SpaceSimple.
type SpaceSimple struct {
	// Id Space identifier
	Id openapi_types.UUID `json:"id"`
}

// SpaceSimplePaginatedList defines model for SpaceSimplePaginatedList.
type SpaceSimplePaginatedList struct {
	Items []SpaceSimple `json:"items"`

	// NextPageToken This token is used to retrieve the next page. If this field is omitted, there are no subsequent pages.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// TotalSize Equivalent to int32
	TotalSize *Int `json:"totalSize,omitempty"`
}

// State The following is a list of states in common use. APIs should consider prior art when determining state names, and should value local consistency above global consistency in the case of conflicting precedent. It encompasses the two possible kinds of States; Resting and Active.
type State = string

// StateComment Information about the change of state.
type StateComment struct {
	// StateCode The code of the change of state.
	StateCode *string `json:"stateCode,omitempty"`

	// StateMessage A message explaining the change of state.
	StateMessage *string `json:"stateMessage,omitempty"`
}

// StopVm defines model for StopVm.
type StopVm struct {
	// ForceStop Forces the VM to stop.
	ForceStop *bool `json:"forceStop,omitempty"`
}

// StrictSlug A strict slug: starts and ends with an alphanumeric character, allows hyphens or underscores in between but not consecutively or at the edges.
type StrictSlug = string

// StrictSlugMax63 defines model for StrictSlugMax63.
type StrictSlugMax63 = string

// StringOrObject defines model for StringOrObject.
type StringOrObject struct {
	union json.RawMessage
}

// StringOrObject0 defines model for .
type StringOrObject0 = string

// StringOrObject1 defines model for .
type StringOrObject1 map[string]interface{}

// SubjectType defines model for SubjectType.
type SubjectType string

// Subnet Information about the Subnet.
type Subnet struct {
	// AvailabilityZoneName The name of the Subregion in which the Subnet is located.
	AvailabilityZoneName *string `json:"availabilityZoneName,omitempty"`

	// AvailableIpsCount The number of available IPs in the Subnets.
	AvailableIpsCount *int `json:"availableIpsCount,omitempty"`

	// Id The ID of the Subnet.
	Id *string `json:"id,omitempty"`

	// IpRange The IP range in the Subnet, in CIDR notation (for example, `10.0.0.0/16`).
	IpRange *string `json:"ipRange,omitempty"`

	// MapPublicIpOnLaunch If true, a public IP is assigned to the network interface cards (NICs) created in the specified Subnet.
	MapPublicIpOnLaunch *bool `json:"mapPublicIpOnLaunch,omitempty"`

	// State The state of the Subnet (`pending` \| `available` \| `deleted`).
	State *string `json:"state,omitempty"`

	// Tags One or more tags associated with the Subnet.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// VpcId The ID of the Vpc in which the Subnet is.
	VpcId *string `json:"vpcId,omitempty"`
}

// SuccessfulNativeLogin The Response for Login Flows via API
type SuccessfulNativeLogin struct {
	// Session A Session
	Session Session `json:"session"`

	// SessionToken The Session Token
	// A session token is equivalent to a session cookie, but it can be sent in the HTTP Authorization
	// Header:
	// Authorization: bearer ${session-token}
	// The session token is only issued for API flows, not for Browser flows!
	SessionToken *string `json:"session_token,omitempty"`
}

// Tag Information about the tag.
type Tag struct {
	// Key The key of the tag, with a minimum of 1 character.
	Key *string `json:"key,omitempty"`

	// ResourceId The ID of the resource.
	ResourceId *string `json:"resourceId,omitempty"`

	// ResourceType The type of the resource.
	ResourceType *string `json:"resourceType,omitempty"`

	// Value The value of the tag, between 0 and 255 characters.
	Value *string `json:"value,omitempty"`
}

// TenantType defines model for TenantType.
type TenantType string

// Token defines model for Token.
type Token struct {
	Token string `json:"token"`
}

// TokenBody defines model for TokenBody.
type TokenBody struct {
	// Token The token to provide.
	Token string `json:"token"`
}

// TokenReq defines model for TokenReq.
type TokenReq struct {
	// ClientId The client id.
	ClientId *openapi_types.UUID `json:"client_id,omitempty"`

	// ClientSecret The client secret.
	ClientSecret *string `json:"client_secret,omitempty"`

	// Code The code authorization.
	Code *string `json:"code,omitempty"`

	// CodeVerifier The code verifier for the PKCE request, that the app originally generated before the authorization request.
	CodeVerifier *string `json:"code_verifier,omitempty"`

	// GrantType The grant type.
	GrantType string `json:"grant_type"`

	// RedirectUri The URLs redirection
	RedirectUri *string `json:"redirect_uri,omitempty"`

	// RefreshToken The refresh Token
	RefreshToken *string `json:"refresh_token,omitempty"`
}

// TokenResp defines model for TokenResp.
type TokenResp struct {
	// AccessToken The access token.
	AccessToken string `json:"access_token"`

	// ExpiresIn The lifetime in seconds of the access token.
	ExpiresIn int `json:"expires_in"`

	// IdToken The id token.
	IdToken *string `json:"id_token,omitempty"`

	// RefreshToken The refresh token.
	RefreshToken *string `json:"refresh_token,omitempty"`

	// TokenType The type of the token issued.
	TokenType string `json:"token_type"`
}

// UiContainer Container represents a HTML Form. The container can work with both HTTP Form and JSON requests.
type UiContainer struct {
	// Action Action should be used as the form action URL `<form action="{{.Action }}" method="post">`.
	Action   string   `json:"action"`
	Messages *UiTexts `json:"messages,omitempty"`

	// Method Method is the form method (e.g. POST)
	Method string  `json:"method"`
	Nodes  UiNodes `json:"nodes"`
}

// UiNode Nodes are represented as HTML elements or their native UI equivalents. For example,
// a node can be an `<img>` tag, or an `<input element>` but also `some plain text`.
type UiNode struct {
	Attributes UiNodeAttributes `json:"attributes"`

	// Group Group specifies which group (e.g. password authenticator) this node belongs to.
	// default DefaultGroup
	// password PasswordGroup
	// oidc OpenIDConnectGroup
	// profile ProfileGroup
	// link LinkGroup
	// code CodeGroup
	// totp TOTPGroup
	// lookup_secret LookupGroup
	// webauthn WebAuthnGroup
	Group    UiNodeGroup `json:"group"`
	Messages UiTexts     `json:"messages"`

	// Meta This might include a label and other information that can optionally
	// be used to render UIs.
	Meta UiNodeMeta `json:"meta"`

	// Type The node's type
	// text Text
	// input Input
	// img Image
	// a Anchor
	// script Script
	Type UiNodeType `json:"type"`
}

// UiNodeGroup Group specifies which group (e.g. password authenticator) this node belongs to.
// default DefaultGroup
// password PasswordGroup
// oidc OpenIDConnectGroup
// profile ProfileGroup
// link LinkGroup
// code CodeGroup
// totp TOTPGroup
// lookup_secret LookupGroup
// webauthn WebAuthnGroup
type UiNodeGroup string

// UiNodeType The node's type
// text Text
// input Input
// img Image
// a Anchor
// script Script
type UiNodeType string

// UiNodeAnchorAttributes defines model for UiNodeAnchorAttributes.
type UiNodeAnchorAttributes struct {
	// Href The link's href (destination) URL.
	//
	// format: uri
	Href string `json:"href"`

	// Id A unique identifier
	Id string `json:"id"`

	// NodeType NodeType represents this node's types. It is a mirror of `node.type` and
	// is primarily used to allow compatibility with OpenAPI 3.0.  In this struct it technically always is "a".
	NodeType string `json:"node_type"`
	Title    UiText `json:"title"`
}

// UiNodeAttributes defines model for UiNodeAttributes.
type UiNodeAttributes struct {
	union json.RawMessage
}

// UiNodeImageAttributes defines model for UiNodeImageAttributes.
type UiNodeImageAttributes struct {
	// Height Height of the image
	Height int64 `json:"height"`

	// Id A unique identifier
	Id string `json:"id"`

	// NodeType NodeType represents this node's types. It is a mirror of `node.type` and
	// is primarily used to allow compatibility with OpenAPI 3.0.  In this struct it technically always is "img".
	NodeType string `json:"node_type"`

	// Src The image's source URL.
	//
	// format: uri
	Src string `json:"src"`

	// Width Width of the image
	Width int64 `json:"width"`
}

// UiNodeInputAttributes InputAttributes represents the attributes of an input node
type UiNodeInputAttributes struct {
	// Autocomplete The autocomplete attribute for the input.
	// email InputAttributeAutocompleteEmail
	// tel InputAttributeAutocompleteTel
	// url InputAttributeAutocompleteUrl
	// current-password InputAttributeAutocompleteCurrentPassword
	// new-password InputAttributeAutocompleteNewPassword
	// one-time-code InputAttributeAutocompleteOneTimeCode
	Autocomplete *UiNodeInputAttributesAutocomplete `json:"autocomplete,omitempty"`

	// Disabled Sets the input's disabled field to true or false.
	Disabled bool    `json:"disabled"`
	Label    *UiText `json:"label,omitempty"`

	// Name The input's element name.
	Name string `json:"name"`

	// NodeType NodeType represents this node's types. It is a mirror of `node.type` and
	// is primarily used to allow compatibility with OpenAPI 3.0.  In this struct it technically always is "input".
	NodeType string `json:"node_type"`

	// Onclick OnClick may contain javascript which should be executed on click. This is primarily
	// used for WebAuthn.
	Onclick *string `json:"onclick,omitempty"`

	// Pattern The input's pattern.
	Pattern *string `json:"pattern,omitempty"`

	// Required Mark this input field as required.
	Required *bool `json:"required,omitempty"`

	// Type The input's element type.
	// text InputAttributeTypeText
	// password InputAttributeTypePassword
	// number InputAttributeTypeNumber
	// checkbox InputAttributeTypeCheckbox
	// hidden InputAttributeTypeHidden
	// email InputAttributeTypeEmail
	// tel InputAttributeTypeTel
	// submit InputAttributeTypeSubmit
	// button InputAttributeTypeButton
	// datetime-local InputAttributeTypeDateTimeLocal
	// date InputAttributeTypeDate
	// url InputAttributeTypeURI
	Type UiNodeInputAttributesType `json:"type"`

	// Value The input's value.
	Value *interface{} `json:"value"`
}

// UiNodeInputAttributesAutocomplete The autocomplete attribute for the input.
// email InputAttributeAutocompleteEmail
// tel InputAttributeAutocompleteTel
// url InputAttributeAutocompleteUrl
// current-password InputAttributeAutocompleteCurrentPassword
// new-password InputAttributeAutocompleteNewPassword
// one-time-code InputAttributeAutocompleteOneTimeCode
type UiNodeInputAttributesAutocomplete string

// UiNodeInputAttributesType The input's element type.
// text InputAttributeTypeText
// password InputAttributeTypePassword
// number InputAttributeTypeNumber
// checkbox InputAttributeTypeCheckbox
// hidden InputAttributeTypeHidden
// email InputAttributeTypeEmail
// tel InputAttributeTypeTel
// submit InputAttributeTypeSubmit
// button InputAttributeTypeButton
// datetime-local InputAttributeTypeDateTimeLocal
// date InputAttributeTypeDate
// url InputAttributeTypeURI
type UiNodeInputAttributesType string

// UiNodeMeta This might include a label and other information that can optionally
// be used to render UIs.
type UiNodeMeta struct {
	Label *UiText `json:"label,omitempty"`
}

// UiNodeScriptAttributes defines model for UiNodeScriptAttributes.
type UiNodeScriptAttributes struct {
	// Async The script async type
	Async bool `json:"async"`

	// Crossorigin The script cross origin policy
	Crossorigin string `json:"crossorigin"`

	// Id A unique identifier
	Id string `json:"id"`

	// Integrity The script's integrity hash
	Integrity string `json:"integrity"`

	// NodeType NodeType represents this node's types. It is a mirror of `node.type` and
	// is primarily used to allow compatibility with OpenAPI 3.0. In this struct it technically always is "script".
	NodeType string `json:"node_type"`

	// Nonce Nonce for CSP
	//
	// A nonce you may want to use to improve your Content Security Policy.
	// You do not have to use this value but if you want to improve your CSP
	// policies you may use it. You can also choose to use your own nonce value!
	Nonce string `json:"nonce"`

	// Referrerpolicy The script referrer policy
	Referrerpolicy string `json:"referrerpolicy"`

	// Src The script source
	Src string `json:"src"`

	// Type The script MIME type
	Type string `json:"type"`
}

// UiNodeTextAttributes defines model for UiNodeTextAttributes.
type UiNodeTextAttributes struct {
	// Id A unique identifier
	Id string `json:"id"`

	// NodeType NodeType represents this node's types. It is a mirror of `node.type` and
	// is primarily used to allow compatibility with OpenAPI 3.0.  In this struct it technically always is "text".
	NodeType string `json:"node_type"`
	Text     UiText `json:"text"`
}

// UiNodes defines model for UiNodes.
type UiNodes = []UiNode

// UiText defines model for UiText.
type UiText struct {
	// Context The message's context. Useful when customizing messages.
	Context *map[string]interface{} `json:"context,omitempty"`
	Id      ID                      `json:"id"`

	// Text The message text. Written in american english.
	Text string `json:"text"`

	// Type The message type.
	// info Info
	// error Error
	// success Success
	Type UiTextType `json:"type"`
}

// UiTextType The message type.
// info Info
// error Error
// success Success
type UiTextType string

// UiTexts defines model for UiTexts.
type UiTexts = []UiText

// UnlinkInternetGateway defines model for UnlinkInternetGateway.
type UnlinkInternetGateway struct {
	// VpcId The ID of the Vpc from which you want to detach the Internet gateway.
	VpcId string `json:"vpcId"`
}

// UnlinkLoadBalancerBackendMachines defines model for UnlinkLoadBalancerBackendMachines.
type UnlinkLoadBalancerBackendMachines struct {
	// BackendIps  One or more public IPs of back-end VMs.
	BackendIps *[]string `json:"backendIps,omitempty"`

	// BackendVmIds  One or more IDs of back-end VMs.
	BackendVmIds *[]string `json:"backendVmIds,omitempty"`
}

// UnlinkNic defines model for UnlinkNic.
type UnlinkNic struct {
	// LinkNicId The ID of the attachment operation.
	LinkNicId string `json:"linkNicId"`
}

// UnlinkPrivateIps defines model for UnlinkPrivateIps.
type UnlinkPrivateIps struct {
	// PrivateIps One or more secondary private IPs you want to unassign from the NIC.
	PrivateIps []string `json:"privateIps"`
}

// UnlinkPublicIp defines model for UnlinkPublicIp.
type UnlinkPublicIp struct {
	// LinkPublicIpId The ID representing the association of the public IP with the VM or the NIC. This parameter is required unless you use the `PublicIp` parameter.
	LinkPublicIpId *string `json:"linkPublicIpId,omitempty"`
}

// UnlinkRouteTable defines model for UnlinkRouteTable.
type UnlinkRouteTable struct {
	// LinkRouteTableId The ID of the association between the route table and the Subnet.
	LinkRouteTableId string `json:"linkRouteTableId"`
}

// UnlinkVolume defines model for UnlinkVolume.
type UnlinkVolume struct {
	// ForceUnlink Forces the detachment of the volume in case of previous failure. Important: This action may damage your data or file systems.
	ForceUnlink *bool `json:"forceUnlink,omitempty"`
}

// UpdateFlexibleGpu defines model for UpdateFlexibleGpu.
type UpdateFlexibleGpu struct {
	// DeleteOnVmDeletion If true, the fGPU is deleted when the VM is terminated.
	DeleteOnVmDeletion *bool `json:"deleteOnVmDeletion,omitempty"`
}

// UpdateImage defines model for UpdateImage.
type UpdateImage struct {
	// AccessCreation Information about the permissions for the resource.<br />
	// Specify either the `Additions` or the `Removals` parameter.
	AccessCreation AccessCreation `json:"accessCreation"`
}

// UpdateListenerRule defines model for UpdateListenerRule.
type UpdateListenerRule struct {
	// HostPattern A host-name pattern for the rule, with a maximum length of 128 characters. This host-name pattern supports maximum three wildcards, and must not contain any special characters except [-.?].
	HostPattern *string `json:"hostPattern"`

	// PathPattern A path pattern for the rule, with a maximum length of 128 characters. This path pattern supports maximum three wildcards, and must not contain any special characters except [_-.$/~&quot;'@:+?].
	PathPattern *string `json:"pathPattern"`
}

// UpdateLoadBalancer defines model for UpdateLoadBalancer.
type UpdateLoadBalancer struct {
	// HealthCheck Information about the health check configuration.
	HealthCheck *HealthCheck `json:"healthCheck,omitempty"`

	// LoadBalancerPort The port on which the load balancer is listening (between `1` and `65535`, both included). This parameter is required if you want to update the server certificate.
	LoadBalancerPort *int `json:"loadBalancerPort,omitempty"`

	// PolicyNames The name of the policy you want to enable for the listener.
	PolicyNames *[]string `json:"policyNames,omitempty"`

	// PublicIp (internet-facing only) The public IP you want to associate with the load balancer. The former public IP of the load balancer is then disassociated. If you specify an empty string and the former public IP belonged to you, it is disassociated and replaced by a public IP owned by NumSpot.
	PublicIp *string `json:"publicIp,omitempty"`

	// SecuredCookies If true, secure cookies are enabled for the load balancer.
	SecuredCookies *bool `json:"securedCookies,omitempty"`

	// SecurityGroups (Vpc only) One or more IDs of security groups you want to assign to the load balancer. You need to specify the already assigned security groups that you want to keep along with the new ones you are assigning. If the list is empty, the default security group of the Vpc is assigned to the load balancer.
	SecurityGroups *[]string `json:"securityGroups,omitempty"`
}

// UpdateLoginFlowBody defines model for UpdateLoginFlowBody.
type UpdateLoginFlowBody struct {
	union json.RawMessage
}

// UpdateLoginFlowWithCodeMethod Update Login flow using the code method
type UpdateLoginFlowWithCodeMethod struct {
	// Code Code is the 6 digits code sent to the user
	Code *string `json:"code,omitempty"`

	// CsrfToken CSRFToken is the anti-CSRF token
	CsrfToken string `json:"csrf_token"`

	// Identifier Identifier is the code identifier
	// The identifier requires that the user has already completed the registration or settings with code flow.
	Identifier *string `json:"identifier,omitempty"`

	// Method Method should be set to "code" when logging in using the code strategy.
	Method string `json:"method"`

	// Resend Resend is set when the user wants to resend the code
	Resend *string `json:"resend,omitempty"`
}

// UpdateLoginFlowWithLookupSecretMethod Update Login Flow with Lookup Secret Method
type UpdateLoginFlowWithLookupSecretMethod struct {
	// CsrfToken Sending the anti-csrf token is only required for browser login flows.
	CsrfToken *string `json:"csrf_token,omitempty"`

	// LookupSecret The lookup secret.
	LookupSecret string `json:"lookup_secret"`

	// Method Method should be set to "lookup_secret" when logging in using the lookup_secret strategy.
	Method string `json:"method"`
}

// UpdateLoginFlowWithOidcMethod Update Login Flow with OpenID Connect Method
type UpdateLoginFlowWithOidcMethod struct {
	// CsrfToken The CSRF Token
	CsrfToken *string `json:"csrf_token,omitempty"`

	// IdToken IDToken is an optional id token provided by an OIDC provider
	//
	// If submitted, it is verified using the OIDC provider's public key set and the claims are used to populate
	// the OIDC credentials of the identity.
	// If the OIDC provider does not store additional claims (such as name, etc.) in the IDToken itself, you can use
	// the `traits` field to populate the identity's traits. Note, that Apple only includes the users email in the IDToken.
	//
	// Supported providers are
	// Apple
	IdToken *string `json:"id_token,omitempty"`

	// IdTokenNonce IDTokenNonce is the nonce, used when generating the IDToken.
	// If the provider supports nonce validation, the nonce will be validated against this value and required.
	IdTokenNonce *string `json:"id_token_nonce,omitempty"`

	// Method Method to use
	//
	// This field must be set to `oidc` when using the oidc method.
	Method string `json:"method"`

	// Provider The provider to register with
	Provider string `json:"provider"`

	// Traits The identity traits. This is a placeholder for the registration flow.
	Traits *map[string]interface{} `json:"traits,omitempty"`

	// UpstreamParameters UpstreamParameters are the parameters that are passed to the upstream identity provider.
	//
	// These parameters are optional and depend on what the upstream identity provider supports.
	// Supported parameters are:
	// `login_hint` (string): The `login_hint` parameter suppresses the account chooser and either pre-fills the email box on the sign-in form, or selects the proper session.
	// `hd` (string): The `hd` parameter limits the login/registration process to a Google Organization, e.g. `mycollege.edu`.
	// `prompt` (string): The `prompt` specifies whether the Authorization Server prompts the End-User for reauthentication and consent, e.g. `select_account`.
	UpstreamParameters *map[string]interface{} `json:"upstream_parameters,omitempty"`
}

// UpdateLoginFlowWithPasswordMethod Update Login Flow with Password Method
type UpdateLoginFlowWithPasswordMethod struct {
	// CsrfToken Sending the anti-csrf token is only required for browser login flows.
	CsrfToken *string `json:"csrf_token,omitempty"`

	// Identifier Identifier is the email or username of the user trying to log in.
	Identifier string `json:"identifier"`

	// Method Method should be set to "password" when logging in using the identifier and password strategy.
	Method string `json:"method"`

	// Password The user's password.
	Password string `json:"password"`

	// PasswordIdentifier Identifier is the email or username of the user trying to log in.
	// This field is deprecated!
	PasswordIdentifier *string `json:"password_identifier,omitempty"`
}

// UpdateLoginFlowWithTotpMethod Update Login Flow with TOTP Method
type UpdateLoginFlowWithTotpMethod struct {
	// CsrfToken Sending the anti-csrf token is only required for browser login flows.
	CsrfToken *string `json:"csrf_token,omitempty"`

	// Method Method should be set to "totp" when logging in using the TOTP strategy.
	Method string `json:"method"`

	// TotpCode The TOTP code.
	TotpCode string `json:"totp_code"`
}

// UpdateLoginFlowWithWebAuthnMethod Update Login Flow with WebAuthn Method
type UpdateLoginFlowWithWebAuthnMethod struct {
	// CsrfToken Sending the anti-csrf token is only required for browser login flows.
	CsrfToken *string `json:"csrf_token,omitempty"`

	// Identifier Identifier is the email or username of the user trying to log in.
	Identifier string `json:"identifier"`

	// Method Method should be set to "webAuthn" when logging in using the WebAuthn strategy.
	Method string `json:"method"`

	// WebauthnLogin Login a WebAuthn Security Key
	//
	// This must contain the ID of the WebAuthN connection.
	WebauthnLogin *string `json:"webauthn_login,omitempty"`
}

// UpdateNic defines model for UpdateNic.
type UpdateNic struct {
	// Description A new description for the NIC.
	Description *string `json:"description,omitempty"`

	// LinkNic Information about the NIC attachment. If you are modifying the `DeleteOnVmDeletion` attribute, you must specify the ID of the NIC attachment.
	LinkNic *LinkNicToUpdate `json:"linkNic,omitempty"`

	// SecurityGroupIds One or more IDs of security groups for the NIC.<br />
	// You must specify at least one group, even if you use the default security group in the Vpc.
	SecurityGroupIds *[]string `json:"securityGroupIds,omitempty"`
}

// UpdateRecoveryFlowBody Update Recovery Flow Request Body
type UpdateRecoveryFlowBody struct {
	union json.RawMessage
}

// UpdateRecoveryFlowWithCodeMethod Update Recovery Flow with Code Method
type UpdateRecoveryFlowWithCodeMethod struct {
	// Code Code from the recovery email
	//
	// If you want to submit a code, use this field, but make sure to _not_ include the email field, as well.
	Code *string `json:"code,omitempty"`

	// CsrfToken Sending the anti-csrf token is only required for browser login flows.
	CsrfToken *string `json:"csrf_token,omitempty"`

	// Email If the email belongs to a valid account, a recovery email will be sent.
	Email *string `json:"email,omitempty"`

	// Method Method is the method that should be used for this recovery flow
	//
	// Allowed values are `link` and `code`.
	// link RecoveryStrategyLink
	// code RecoveryStrategyCode
	Method UpdateRecoveryFlowWithCodeMethodMethod `json:"method"`
}

// UpdateRecoveryFlowWithCodeMethodMethod Method is the method that should be used for this recovery flow
//
// Allowed values are `link` and `code`.
// link RecoveryStrategyLink
// code RecoveryStrategyCode
type UpdateRecoveryFlowWithCodeMethodMethod string

// UpdateRecoveryFlowWithLinkMethod Update Recovery Flow with Link Method
type UpdateRecoveryFlowWithLinkMethod struct {
	// CsrfToken Sending the anti-csrf token is only required for browser login flows.
	CsrfToken *string `json:"csrf_token,omitempty"`

	// Email Email to Recover
	// Needs to be set when initiating the flow. If the email is a registered recovery email, a recovery link will be sent. If the email is not known,a email with details on what happened will be sent instead.
	Email openapi_types.Email `json:"email"`

	// Method Method is the method that should be used for this recovery flow
	//
	// Allowed values are `link` and `code`
	// link RecoveryStrategyLink
	// code RecoveryStrategyCode
	Method UpdateRecoveryFlowWithLinkMethodMethod `json:"method"`
}

// UpdateRecoveryFlowWithLinkMethodMethod Method is the method that should be used for this recovery flow
//
// Allowed values are `link` and `code`
// link RecoveryStrategyLink
// code RecoveryStrategyCode
type UpdateRecoveryFlowWithLinkMethodMethod string

// UpdateRoute defines model for UpdateRoute.
type UpdateRoute struct {
	// DestinationIpRange The IP range used for the destination match, in CIDR notation (for example, `10.0.0.0/24`).
	DestinationIpRange string `json:"destinationIpRange"`

	// GatewayId The ID of an Internet gateway or virtual gateway attached to your Vpc.
	GatewayId *string `json:"gatewayId,omitempty"`

	// NatGatewayId The ID of a NAT gateway.
	NatGatewayId *string `json:"natGatewayId,omitempty"`

	// NicId The ID of a network interface card (NIC).
	NicId *string `json:"nicId,omitempty"`

	// VmId The ID of a NAT VM in your Vpc.
	VmId *string `json:"vmId,omitempty"`

	// VpcPeeringId The ID of a Vpc peering.
	VpcPeeringId *string `json:"vpcPeeringId,omitempty"`
}

// UpdateRouteTableRoutePropagation defines model for UpdateRouteTableRoutePropagation.
type UpdateRouteTableRoutePropagation struct {
	// Enable If true, a virtual gateway can propagate routes to a specified route table of a Vpc. If false, the propagation is disabled.
	Enable bool `json:"enable"`

	// VirtualGatewayId The ID of the virtual gateway.
	VirtualGatewayId string `json:"virtualGatewayId"`
}

// UpdateServerCertificate defines model for UpdateServerCertificate.
type UpdateServerCertificate struct {
	// NewName A new name for the server certificate.
	NewName *string `json:"newName,omitempty"`

	// NewPath A new path for the server certificate.
	NewPath *string `json:"newPath,omitempty"`
}

// UpdateSettingsFlowBody defines model for UpdateSettingsFlowBody.
type UpdateSettingsFlowBody struct {
	union json.RawMessage
}

// UpdateSettingsFlowMethod defines model for UpdateSettingsFlowMethod.
type UpdateSettingsFlowMethod struct {
	// Method Method
	//
	// Should be set to password when trying to update a password.
	Method string `json:"method"`
}

// UpdateSettingsFlowWithPasswordMethod defines model for UpdateSettingsFlowWithPasswordMethod.
type UpdateSettingsFlowWithPasswordMethod struct {
	// CsrfToken CSRFToken is the anti-CSRF token
	CsrfToken *string     `json:"csrf_token,omitempty"`
	Method    interface{} `json:"method"`

	// Password Password is the updated password
	Password string `json:"password"`
}

// UpdateSettingsFlowWithTotpMethod defines model for UpdateSettingsFlowWithTotpMethod.
type UpdateSettingsFlowWithTotpMethod struct {
	// CsrfToken CSRFToken is the anti-CSRF token
	CsrfToken *string     `json:"csrf_token,omitempty"`
	Method    interface{} `json:"method"`

	// TotpCode ValidationTOTP must contain a valid TOTP based on the
	TotpCode *string `json:"totp_code,omitempty"`

	// TotpUnlink UnlinkTOTP if true will remove the TOTP pairing,
	// effectively removing the credential. This can be used
	// to set up a new TOTP device.
	TotpUnlink *bool `json:"totp_unlink,omitempty"`
}

// UpdateSubnet defines model for UpdateSubnet.
type UpdateSubnet struct {
	// MapPublicIpOnLaunch If true, a public IP is assigned to the network interface cards (NICs) created in the specified Subnet.
	MapPublicIpOnLaunch bool `json:"mapPublicIpOnLaunch"`
}

// UpdateVm defines model for UpdateVm.
type UpdateVm struct {
	// BlockDeviceMappings One or more block device mappings of the VM.
	BlockDeviceMappings *[]BlockDeviceMappingVmUpdate `json:"blockDeviceMappings,omitempty"`

	// BsuOptimized This parameter is not available. It is present in our API for the sake of historical compatibility with AWS.
	BsuOptimized *bool `json:"bsuOptimized,omitempty"`

	// DeletionProtection If true, you cannot delete the VM unless you change this parameter back to false.
	DeletionProtection *bool `json:"deletionProtection,omitempty"`

	// IsSourceDestChecked (Vpc only) If true, the source/destination check is enabled. If false, it is disabled. This value must be false for a NAT VM to perform network address translation (NAT) in a Vpc.
	IsSourceDestChecked *bool `json:"isSourceDestChecked,omitempty"`

	// KeypairName The name of a keypair you want to associate with the VM.<br />
	// When you replace the keypair of a VM with another one, the metadata of the VM is modified to reflect the new public key, but the replacement is still not effective in the operating system of the VM. To complete the replacement and effectively apply the new keypair, you need to perform other actions inside the VM.
	KeypairName *string `json:"keypairName,omitempty"`

	// NestedVirtualization (dedicated tenancy only) If true, nested virtualization is enabled. If false, it is disabled.
	NestedVirtualization *bool `json:"nestedVirtualization,omitempty"`

	// Performance The performance of the VM (`medium` \| `high` \|  `highest`).
	Performance *UpdateVmPerformance `json:"performance,omitempty"`

	// SecurityGroupIds One or more IDs of security groups for the VM.
	SecurityGroupIds *[]string `json:"securityGroupIds,omitempty"`

	// Type The type of VM.
	Type *string `json:"type,omitempty"`

	// UserData The Base64-encoded MIME user data, limited to 500 kibibytes (KiB).
	UserData *string `json:"userData,omitempty"`

	// VmInitiatedShutdownBehavior The VM behavior when you stop it. If set to `stop`, the VM stops. If set to `restart`, the VM stops then automatically restarts. If set to `terminate`, the VM stops and is terminated.
	VmInitiatedShutdownBehavior *string `json:"vmInitiatedShutdownBehavior,omitempty"`
}

// UpdateVmPerformance The performance of the VM (`medium` \| `high` \|  `highest`).
type UpdateVmPerformance string

// UpdateVolume defines model for UpdateVolume.
type UpdateVolume struct {
	// Iops **Cold volume**: the new number of I/O operations per second (IOPS). This parameter can be specified only if you update an `io1` volume or if you change the type of the volume for an `io1`. This modification is instantaneous. <br />
	// **Hot volume**: the new number of I/O operations per second (IOPS). This parameter can be specified only if you update an `io1` volume. This modification is not instantaneous. <br /><br />
	//  The maximum number of IOPS allowed for `io1` volumes is `13000` with a maximum performance ratio of 300 IOPS per gibibyte.
	Iops *int `json:"iops,omitempty"`

	// Size **Cold volume**: the new size of the volume, in gibibytes (GiB). This value must be equal to or greater than the current size of the volume. This modification is not instantaneous. <br />
	// **Hot volume**: you cannot change the size of a hot volume.
	Size *int `json:"size,omitempty"`

	// VolumeType **Cold volume**: the new type of the volume (`standard` \ | `io1` \| `gp2`). This modification is instantaneous. If you update to an `io1` volume, you must also specify the `Iops` parameter.<br />
	//  **Hot volume**: you cannot change the type of a hot volume.
	VolumeType *string `json:"volumeType,omitempty"`
}

// UpdateVpc defines model for UpdateVpc.
type UpdateVpc struct {
	// DhcpOptionsSetId The ID of the DHCP options set (or `default` if you want to associate the default one).
	DhcpOptionsSetId string `json:"dhcpOptionsSetId"`
}

// Url defines model for Url.
type Url = string

// User defines model for User.
type User struct {
	Email Email `json:"email"`

	// Firstname Firstname
	Firstname string `json:"firstname"`

	// Lastname Lastname
	Lastname string `json:"lastname"`
}

// UserCreated defines model for UserCreated.
type UserCreated struct {
	// Active Account activation/deactivation state
	Active    bool     `json:"active"`
	CreatedOn DateTime `json:"createdOn"`
	Email     Email    `json:"email"`

	// Firstname Firstname
	Firstname string `json:"firstname"`

	// Id User ID
	Id openapi_types.UUID `json:"id"`

	// Lastname Lastname
	Lastname string `json:"lastname"`
}

// UserCreation defines model for UserCreation.
type UserCreation struct {
	// Active Account activation/deactivation state
	Active    bool     `json:"active"`
	CreatedOn DateTime `json:"createdOn"`

	// Id User ID
	Id openapi_types.UUID `json:"id"`
}

// UserEdited defines model for UserEdited.
type UserEdited struct {
	// Active Account activation/deactivation state
	Active    bool     `json:"active"`
	CreatedOn DateTime `json:"createdOn"`

	// Id User ID
	Id        openapi_types.UUID `json:"id"`
	UpdatedOn DateTime           `json:"updatedOn"`
}

// UserInfo defines model for UserInfo.
type UserInfo struct {
	Email     *string `json:"email,omitempty"`
	Firstname *string `json:"firstname,omitempty"`
	Lastname  *string `json:"lastname,omitempty"`
	Sub       string  `json:"sub"`
}

// UserModified defines model for UserModified.
type UserModified struct {
	// Active Account activation/deactivation state
	Active    bool     `json:"active"`
	CreatedOn DateTime `json:"createdOn"`
	Email     Email    `json:"email"`

	// Firstname Firstname
	Firstname string `json:"firstname"`

	// Id User ID
	Id openapi_types.UUID `json:"id"`

	// Lastname Lastname
	Lastname  string   `json:"lastname"`
	UpdatedOn DateTime `json:"updatedOn"`
}

// UserPaginatedList defines model for UserPaginatedList.
type UserPaginatedList struct {
	Items []UserModified `json:"items"`

	// NextPageToken This token is used to retrieve the next page. If this field is omitted, there are no subsequent pages.
	NextPageToken *string `json:"nextPageToken,omitempty"`

	// TotalSize Equivalent to int32
	TotalSize *Int `json:"totalSize,omitempty"`
}

// UserState defines model for UserState.
type UserState struct {
	// Active Account activation/deactivation state
	Active bool `json:"active"`
}

// UserUpdate defines model for UserUpdate.
type UserUpdate struct {
	// Active Account activation/deactivation state
	Active bool  `json:"active"`
	Email  Email `json:"email"`

	// Firstname Firstname
	Firstname string `json:"firstname"`

	// Lastname Lastname
	Lastname string `json:"lastname"`
}

// Uuid defines model for Uuid.
type Uuid = openapi_types.UUID

// VPNConnection Information about the vpn connection.
type VPNConnection struct {
	// ClientGatewayConfiguration Example configuration for the client gateway.
	ClientGatewayConfiguration string `json:"clientGatewayConfiguration"`
	ClientGatewayId            Uuid   `json:"clientGatewayId"`

	// ConnectionType The type of VPN connection (always `ipsec.1`).
	ConnectionType string `json:"connectionType"`

	// Id The ID of the VPN connection.
	Id string `json:"id"`

	// Routes Information about one or more static routes associated with the VPN connection, if any.
	Routes []RouteLight `json:"routes"`

	// State The state of the VPN connection (`pending` \| `available` \| `deleting` \| `deleted`).
	State string `json:"state"`

	// StaticRoutesOnly If false, the VPN connection uses dynamic routing with Border Gateway Protocol (BGP). If true, routing is controlled using static routes. For more information about how to create and delete static routes, see [CreateVpnConnectionRoute](#createvpnconnectionroute) and [DeleteVpnConnectionRoute](#deletevpnconnectionroute).
	StaticRoutesOnly bool `json:"staticRoutesOnly"`

	// VgwTelemetries Information about the current state of one or more of the VPN tunnels.
	VgwTelemetries   []VgwTelemetry `json:"vgwTelemetries"`
	VirtualGatewayId Uuid           `json:"virtualGatewayId"`

	// VpnOptions Information about the VPN options.
	VpnOptions VpnOptions `json:"vpnOptions"`
}

// VPNConnections Information about one or more VPNConnections.
type VPNConnections struct {
	Items []VPNConnection `json:"items"`
}

// VerifiableIdentityAddress VerifiableAddress is an identity's verifiable address
type VerifiableIdentityAddress struct {
	// CreatedAt When this entry was created
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Id The ID
	Id *openapi_types.UUID `json:"id,omitempty"`

	// Status VerifiableAddressStatus must not exceed 16 characters as that is the limitation in the SQL Schema
	Status IdentityVerifiableAddressStatus `json:"status"`

	// UpdatedAt When this entry was last updated
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Value The address value
	//
	// example foo@user.com
	Value string `json:"value"`

	// Verified Indicates if the address has already been verified
	Verified   bool      `json:"verified"`
	VerifiedAt *NullTime `json:"verified_at"`

	// Via The delivery method
	Via VerifiableIdentityAddressVia `json:"via"`
}

// VerifiableIdentityAddressVia The delivery method
type VerifiableIdentityAddressVia string

// VgwTelemetry Information about the current state of a VPN tunnel.
type VgwTelemetry struct {
	// AcceptedRouteCount The number of routes accepted through BGP (Border Gateway Protocol) route exchanges.
	AcceptedRouteCount int `json:"acceptedRouteCount"`

	// LastStateChangeDate The date and time (UTC) of the latest state update.
	LastStateChangeDate time.Time `json:"lastStateChangeDate"`

	// OutsideIpAddress The IP on the NumSpot side of the tunnel.
	OutsideIpAddress string `json:"outsideIpAddress"`

	// State The state of the IPSEC tunnel (`UP` \| `DOWN`).
	State string `json:"state"`

	// StateDescription A description of the current state of the tunnel.
	StateDescription string `json:"stateDescription"`
}

// Violation defines model for Violation.
type Violation struct {
	// Description A description of why the field is violated.
	Description string `json:"description"`

	// Field The field impacted by the violation.
	Field string `json:"field"`
}

// VirtualGateway Information about the client gateway.
type VirtualGateway struct {
	// ConnectionType The type of VPN connection supported by the virtual gateway (only `ipsec.1` is supported).
	ConnectionType string `json:"connectionType"`

	// Id The ID of the virtual gateway.
	Id string `json:"id"`

	// State The state of the virtual gateway (`pending` \| `available` \| `deleting` \| `deleted`).
	State string `json:"state"`

	// VpcToVirtualGatewayLinks the Vpc to which the virtual gateway is attached.
	VpcToVirtualGatewayLinks []VpcToVirtualGatewayLink `json:"vpcToVirtualGatewayLinks"`
}

// VirtualGateways Information about one or more VirtualGateways.
type VirtualGateways struct {
	Items []VirtualGateway `json:"items"`
}

// Vm Information about the VM.
type Vm struct {
	// Architecture The architecture of the VM (`i386` \| `x86_64`).
	Architecture *string `json:"architecture,omitempty"`

	// BlockDeviceMappings The block device mapping of the VM.
	BlockDeviceMappings *[]BlockDeviceMappingCreated `json:"blockDeviceMappings,omitempty"`

	// BsuOptimized This parameter is not available. It is present in our API for the sake of historical compatibility with AWS.
	BsuOptimized *bool `json:"bsuOptimized,omitempty"`

	// ClientToken The idempotency token provided when launching the VM.
	ClientToken *string `json:"clientToken,omitempty"`

	// CreationDate The date and time of creation of the VM.
	CreationDate *time.Time `json:"creationDate,omitempty"`

	// DeletionProtection If true, you cannot delete the VM unless you change this parameter back to false.
	DeletionProtection *bool `json:"deletionProtection,omitempty"`

	// Hypervisor The hypervisor type of the VMs (`ovm` \| `xen`).
	Hypervisor *string `json:"hypervisor,omitempty"`

	// Id The ID of the VM.
	Id *string `json:"id,omitempty"`

	// ImageId The ID of the Image used to create the VM.
	ImageId *string `json:"imageId,omitempty"`

	// InitiatedShutdownBehavior The VM behavior when you stop it. If set to `stop`, the VM stops. If set to `restart`, the VM stops then automatically restarts. If set to `terminate`, the VM stops and is deleted.
	InitiatedShutdownBehavior *string `json:"initiatedShutdownBehavior,omitempty"`

	// IsSourceDestChecked (Vpc only) If true, the source/destination check is enabled. If false, it is disabled. This value must be false for a NAT VM to perform network address translation (NAT) in a Vpc.
	IsSourceDestChecked *bool `json:"isSourceDestChecked,omitempty"`

	// KeypairName The name of the keypair used when launching the VM.
	KeypairName *string `json:"keypairName,omitempty"`

	// LaunchNumber The number for the VM when launching a group of several VMs (for example, `0`, `1`, `2`, and so on).
	LaunchNumber *int `json:"launchNumber,omitempty"`

	// NestedVirtualization If true, nested virtualization is enabled. If false, it is disabled.
	NestedVirtualization *bool `json:"nestedVirtualization,omitempty"`

	// Nics (Vpc only) The network interface cards (NICs) the VMs are attached to.
	Nics *[]NicLight `json:"nics,omitempty"`

	// OsFamily Indicates the operating system (OS) of the VM.
	OsFamily *string `json:"osFamily,omitempty"`

	// Performance The performance of the VM (`medium` \| `high` \|  `highest`).
	Performance *string `json:"performance,omitempty"`

	// Placement Information about the placement of the VM.
	Placement *Placement `json:"placement,omitempty"`

	// PrivateDnsName The name of the private DNS.
	PrivateDnsName *string `json:"privateDnsName,omitempty"`

	// PrivateIp The primary private IP of the VM.
	PrivateIp *string `json:"privateIp,omitempty"`

	// ProductCodes The product codes associated with the Image used to create the VM.
	ProductCodes *[]string `json:"productCodes,omitempty"`

	// PublicDnsName The name of the public DNS.
	PublicDnsName *string `json:"publicDnsName,omitempty"`

	// PublicIp The public IP of the VM.
	PublicIp *string `json:"publicIp,omitempty"`

	// ReservationId The reservation ID of the VM.
	ReservationId *string `json:"reservationId,omitempty"`

	// RootDeviceName The name of the root device for the VM (for example, `/dev/sda1`).
	RootDeviceName *string `json:"rootDeviceName,omitempty"`

	// RootDeviceType The type of root device used by the VM (always `bsu`).
	RootDeviceType *string `json:"rootDeviceType,omitempty"`

	// SecurityGroups One or more security groups associated with the VM.
	SecurityGroups *[]SecurityGroupLight `json:"securityGroups,omitempty"`

	// State The state of the VM (`pending` \| `running` \| `stopping` \| `stopped` \| `shutting-down` \| `terminated` \| `quarantine`).
	State *string `json:"state,omitempty"`

	// StateReason The reason explaining the current state of the VM.
	StateReason *string `json:"stateReason,omitempty"`

	// SubnetId The ID of the Subnet for the VM.
	SubnetId *string `json:"subnetId,omitempty"`

	// Tags One or more tags associated with the VM.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// Type The type of VM.
	Type *string `json:"type,omitempty"`

	// UserData The Base64-encoded MIME user data.
	UserData *string `json:"userData,omitempty"`

	// VpcId The ID of the Vpc in which the VM is running.
	VpcId *string `json:"vpcId,omitempty"`
}

// VmState Information about the state of the VM.
type VmState struct {
	// CurrentState The current state of the VM (`InService` \| `OutOfService` \| `Unknown`).
	CurrentState *string `json:"currentState,omitempty"`

	// Id The ID of the VM.
	Id *string `json:"id,omitempty"`

	// PreviousState The previous state of the VM (`InService` \| `OutOfService` \| `Unknown`).
	PreviousState *string `json:"previousState,omitempty"`
}

// VmStates Information about the states of the VMs.
type VmStates struct {
	// AvailabilityZoneName The name of the Subregion of the VM.
	AvailabilityZoneName *string `json:"availabilityZoneName,omitempty"`

	// Id The ID of the VM.
	Id *string `json:"id,omitempty"`

	// MaintenanceEvents One or more scheduled events associated with the VM.
	MaintenanceEvents *[]MaintenanceEvent `json:"maintenanceEvents,omitempty"`

	// VmState The state of the VM (`pending` \| `running` \| `stopping` \| `stopped` \| `shutting-down` \| `terminated` \| `quarantine`).
	VmState *string `json:"vmState,omitempty"`
}

// Volume Information about the volume.
type Volume struct {
	// AvailabilityZoneName The Subregion in which the volume was created.
	AvailabilityZoneName *string `json:"availabilityZoneName,omitempty"`

	// CreationDate The date and time of creation of the volume.
	CreationDate *time.Time `json:"creationDate,omitempty"`

	// Id The ID of the volume.
	Id *string `json:"id,omitempty"`

	// Iops The number of I/O operations per second (IOPS):<br />
	// - For `io1` volumes, the number of provisioned IOPS<br />
	// - For `gp2` volumes, the baseline performance of the volume
	Iops *int `json:"iops,omitempty"`

	// LinkedVolumes Information about your volume attachment.
	LinkedVolumes *[]LinkedVolume `json:"linkedVolumes,omitempty"`

	// Size The size of the volume, in gibibytes (GiB).
	Size *int `json:"size,omitempty"`

	// SnapshotId The snapshot from which the volume was created.
	SnapshotId *string `json:"snapshotId,omitempty"`

	// State The state of the volume (`creating` \| `available` \| `in-use` \| `updating` \| `deleting` \| `error`).
	State *string `json:"state,omitempty"`

	// Tags One or more tags associated with the volume.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// Type The type of the volume (`standard` \| `gp2` \| `io1`).
	Type *string `json:"type,omitempty"`
}

// Vpc Information about the Vpc.
type Vpc struct {
	// DhcpOptionsSetId The ID of the DHCP options set (or `default` if you want to associate the default one).
	DhcpOptionsSetId *string `json:"dhcpOptionsSetId,omitempty"`

	// Id The ID of the Vpc.
	Id *string `json:"id,omitempty"`

	// IpRange The IP range for the Vpc, in CIDR notation (for example, `10.0.0.0/16`).
	IpRange *string `json:"ipRange,omitempty"`

	// State The state of the Vpc (`pending` \| `available` \| `deleting`).
	State *string `json:"state,omitempty"`

	// Tags One or more tags associated with the Vpc.
	Tags *[]ResourceTag `json:"tags,omitempty"`

	// Tenancy The VM tenancy in a Vpc.
	Tenancy *string `json:"tenancy,omitempty"`
}

// VpcToVirtualGatewayLink Information about the attachment.
type VpcToVirtualGatewayLink struct {
	// State The state of the attachment (`attaching` \| `attached` \| `detaching` \| `detached`).
	State string `json:"state"`

	// VpcId The ID of the Vpc to which the virtual gateway is attached.
	VpcId string `json:"vpcId"`
}

// VpnOptions Information about the VPN options.
type VpnOptions struct {
	// Phase1Options Information about Phase 1 of the Internet Key Exchange (IKE) negotiation. When Phase 1 finishes successfully, peers proceed to Phase 2 negotiations.
	Phase1Options Phase1Options `json:"phase1Options"`

	// Phase2Options Information about Phase 2 of the Internet Key Exchange (IKE) negotiation.
	Phase2Options Phase2Options `json:"phase2Options"`

	// TunnelInsideIpRange The range of inside IPs for the tunnel. This must be a /30 CIDR block from the 169.254.254.0/24 range.
	TunnelInsideIpRange string `json:"tunnelInsideIpRange"`
}

// WebAuthnJavaScript defines model for WebAuthnJavaScript.
type WebAuthnJavaScript struct {
	CreatedAt      time.Time          `json:"created_at"`
	Id             openapi_types.UUID `json:"id"`
	Name           string             `json:"name"`
	SubscriptionId *NullUUID          `json:"subscription_id"`
	UpdatedAt      time.Time          `json:"updated_at"`
}

// Action defines model for Action.
type Action = string

// Authorization defines model for Authorization.
type Authorization = string

// ConsentChallenge defines model for ConsentChallenge.
type ConsentChallenge = string

// KubernetesClusterId defines model for KubernetesClusterId.
type KubernetesClusterId = Uuid

// ListPermissionsPage defines model for ListPermissionsPage.
type ListPermissionsPage struct {
	// NextToken A page token received from a previous call. Provide this to retrieve the subsequent page.
	NextToken *string `json:"nextToken"`

	// Size The maximum number of items to return. The service may return fewer than this value.
	Size *int32 `json:"size"`
}

// ListPolicyPage defines model for ListPolicyPage.
type ListPolicyPage struct {
	// NextToken A page token received from a previous call. Provide this to retrieve the subsequent page.
	NextToken *string `json:"nextToken,omitempty"`

	// Size The maximum number of items to return. The service may return fewer than this value.
	Size *int32 `json:"size,omitempty"`
}

// ListRolePermissionsPage defines model for ListRolePermissionsPage.
type ListRolePermissionsPage struct {
	// NextToken A page token received from a previous call. Provide this to retrieve the subsequent page.
	NextToken *string `json:"nextToken"`

	// Size The maximum number of items to return. The service may return fewer than this value.
	Size *int32 `json:"size"`
}

// ListRolesPage defines model for ListRolesPage.
type ListRolesPage struct {
	// NextToken A page token received from a previous call. Provide this to retrieve the subsequent page.
	NextToken *string `json:"nextToken"`

	// Size The maximum number of items to return. The service may return fewer than this value.
	Size *int32 `json:"size"`
}

// ListServiceAccounts defines model for ListServiceAccounts.
type ListServiceAccounts struct {
	// NextToken A page token received from a previous call. Provide this to retrieve the subsequent page.
	NextToken *string `json:"nextToken,omitempty"`

	// Size The maximum number of items to return. The service may return fewer than this value.
	Size *int32 `json:"size,omitempty"`
}

// ListSpacesIdentity defines model for ListSpacesIdentity.
type ListSpacesIdentity struct {
	// NextToken A page token received from a previous call. Provide this to retrieve the subsequent page.
	NextToken *string `json:"nextToken,omitempty"`

	// Size The maximum number of items to return. The service may return fewer than this value.
	Size *int32 `json:"size,omitempty"`
}

// ListSpacesOfServiceAccount defines model for ListSpacesOfServiceAccount.
type ListSpacesOfServiceAccount struct {
	// NextToken A page token received from a previous call. Provide this to retrieve the subsequent page.
	NextToken *string `json:"nextToken,omitempty"`

	// Size The maximum number of items to return. The service may return fewer than this value.
	Size *int32 `json:"size,omitempty"`
}

// ListSpacesOfUser defines model for ListSpacesOfUser.
type ListSpacesOfUser struct {
	// NextToken A page token received from a previous call. Provide this to retrieve the subsequent page.
	NextToken *string `json:"nextToken,omitempty"`

	// Size The maximum number of items to return. The service may return fewer than this value.
	Size *int32 `json:"size,omitempty"`
}

// ListSpacesPage defines model for ListSpacesPage.
type ListSpacesPage struct {
	// NextToken A page token received from a previous call. Provide this to retrieve the subsequent page.
	NextToken *string `json:"nextToken,omitempty"`

	// Size The maximum number of items to return. The service may return fewer than this value.
	Size *int32 `json:"size,omitempty"`
}

// ListUser defines model for ListUser.
type ListUser struct {
	// NextToken A page token received from a previous call. Provide this to retrieve the subsequent page.
	NextToken *string `json:"nextToken,omitempty"`

	// Size The maximum number of items to return. The service may return fewer than this value.
	Size *int32 `json:"size,omitempty"`
}

// ListUserOrganisations defines model for ListUserOrganisations.
type ListUserOrganisations struct {
	// NextToken A page token received from a previous call. Provide this to retrieve the subsequent page.
	NextToken *string `json:"nextToken,omitempty"`

	// Size The maximum number of items to return. The service may return fewer than this value.
	Size *int32 `json:"size,omitempty"`
}

// OpenShiftClusterId defines model for OpenShiftClusterId.
type OpenShiftClusterId = Uuid

// OpenShiftNodepoolName defines model for OpenShiftNodepoolName.
type OpenShiftNodepoolName = string

// OpenShiftOperationStatuses defines model for OpenShiftOperationStatuses.
type OpenShiftOperationStatuses = []RestingState

// OpenShiftPage defines model for OpenShiftPage.
type OpenShiftPage struct {
	// NextToken A page token received from a previous call. Provide this to retrieve the subsequent page.
	NextToken *string `json:"nextToken,omitempty"`

	// Size The maximum number of items to return. The service may return fewer than this value.
	Size *int32 `json:"size,omitempty"`
}

// OperationId defines model for OperationId.
type OperationId = openapi_types.UUID

// OrganisationId defines model for OrganisationId.
type OrganisationId = openapi_types.UUID

// PermissionUuid defines model for PermissionUuid.
type PermissionUuid = openapi_types.UUID

// PostgresBackupIdParameter defines model for PostgresBackupIdParameter.
type PostgresBackupIdParameter = openapi_types.UUID

// PostgresClusterIdParameter defines model for PostgresClusterIdParameter.
type PostgresClusterIdParameter = openapi_types.UUID

// PostgresPageParameter defines model for PostgresPageParameter.
type PostgresPageParameter struct {
	// NextToken A page token received from a previous call. Provide this to retrieve the subsequent page.
	NextToken *string `json:"nextToken,omitempty"`

	// Size The maximum number of items to return. The service may return fewer than this value.
	Size *int32 `json:"size,omitempty"`
}

// PostgresTagsParameter A map of tags.
type PostgresTagsParameter = PostgresTagParameter

// QueryClusterId defines model for QueryClusterId.
type QueryClusterId = string

// RequiredAuthorization defines model for RequiredAuthorization.
type RequiredAuthorization = string

// Resource defines model for Resource.
type Resource = string

// ResourceIdentifier defines model for ResourceIdentifier.
type ResourceIdentifier = Uuid

// RoleName defines model for RoleName.
type RoleName = string

// RoleUuid defines model for RoleUuid.
type RoleUuid = openapi_types.UUID

// Service defines model for Service.
type Service = string

// ServiceAccountId defines model for ServiceAccountId.
type ServiceAccountId = openapi_types.UUID

// ServiceAccountName defines model for ServiceAccountName.
type ServiceAccountName = string

// SpaceId defines model for SpaceId.
type SpaceId = openapi_types.UUID

// SubResource defines model for SubResource.
type SubResource = string

// SubjectId defines model for SubjectId.
type SubjectId = openapi_types.UUID

// SubjectTypeParam defines model for SubjectTypeParam.
type SubjectTypeParam = SubjectType

// UserEmail defines model for UserEmail.
type UserEmail = openapi_types.Email

// UserId defines model for UserId.
type UserId = openapi_types.UUID

// Cluster200Response defines model for Cluster200Response.
type Cluster200Response = KubernetesClusterInfo

// ClusterCreate201Response defines model for ClusterCreate201Response.
type ClusterCreate201Response = OpenShiftClusterCreated

// ClusterDelete202Response defines model for ClusterDelete202Response.
type ClusterDelete202Response = OpenShiftClusterDeleted

// ClusterGet200Response defines model for ClusterGet200Response.
type ClusterGet200Response = OpenShiftCluster

// ClusterList200Response defines model for ClusterList200Response.
type ClusterList200Response = KubernetesListClusters

// ClusterState200Response defines model for ClusterState200Response.
type ClusterState200Response = KubernetesClusterState

// Clusters200Response defines model for Clusters200Response.
type Clusters200Response = OpenShiftClusters

// ConvertToken200Response defines model for ConvertToken200Response.
type ConvertToken200Response = AKSK

// CreateClientGateway201Response Information about the client gateway.
type CreateClientGateway201Response = ClientGateway

// CreateComputeBridge201Response The bridge object representation between two compute VPCs.
type CreateComputeBridge201Response = ComputeBridge

// CreateDhcpOptions201Response Information about the DHCP options set.
type CreateDhcpOptions201Response = DhcpOptionsSet

// CreateDirectLink201Response Information about the DirectLink.
type CreateDirectLink201Response = DirectLink

// CreateDirectLinkInterface201Response Information about the DirectLink interfaces.
type CreateDirectLinkInterface201Response = DirectLinkInterface

// CreateFlexibleGpu201Response Information about the flexible GPU (fGPU).
type CreateFlexibleGpu201Response = FlexibleGpu

// CreateHybridBridge201Response The bridge object representation between a managed service and a standalone compute VPC.
type CreateHybridBridge201Response = HybridBridge

// CreateImage201Response Information about the Image.
type CreateImage201Response = Image

// CreateInternetGateway201Response Information about the Internet gateway.
type CreateInternetGateway201Response = InternetGateway

// CreateKeypair201Response Information about the created keypair.
type CreateKeypair201Response = CreateKeypair

// CreateListenerRule201Response Information about the listener rule.
type CreateListenerRule201Response = ListenerRule

// CreateLoadBalancer201Response Information about the load balancer.
type CreateLoadBalancer201Response = LoadBalancer

// CreateLoadBalancerListeners201Response Information about the load balancer.
type CreateLoadBalancerListeners201Response = LoadBalancer

// CreateLoadBalancerPolicy201Response Information about the load balancer.
type CreateLoadBalancerPolicy201Response = LoadBalancer

// CreateManagedServicesBridge201Response The bridge object representation between two managed services.
type CreateManagedServicesBridge201Response = ManagedServicesBridge

// CreateNatGateway201Response Information about the NAT gateway.
type CreateNatGateway201Response = NatGateway

// CreateNic201Response Information about the NIC.
type CreateNic201Response = Nic

// CreatePublicIp201Response Information about the public IP.
type CreatePublicIp201Response = PublicIp

// CreateRoute201Response Information about the route table.
type CreateRoute201Response = RouteTable

// CreateRouteTable201Response Information about the route table.
type CreateRouteTable201Response = RouteTable

// CreateSecurityGroup201Response Information about the security group.
type CreateSecurityGroup201Response = SecurityGroup

// CreateSecurityGroupRule201Response Information about the security group.
type CreateSecurityGroupRule201Response = SecurityGroup

// CreateServerCertificate201Response Information about the Server Certificates.
type CreateServerCertificate201Response = ServerCertificate

// CreateServiceAccount201Response defines model for CreateServiceAccount201Response.
type CreateServiceAccount201Response = CreatedServiceAccount

// CreateSnapshot201Response Information about the snapshot.
type CreateSnapshot201Response = Snapshot

// CreateSpace200Response defines model for CreateSpace200Response.
type CreateSpace200Response = Space

// CreateSubnet201Response Information about the Subnet.
type CreateSubnet201Response = Subnet

// CreateUser201Response defines model for CreateUser201Response.
type CreateUser201Response = UserCreated

// CreateVPNConnection201Response Information about the vpn connection.
type CreateVPNConnection201Response = VPNConnection

// CreateVirtualGateway201Response Information about the client gateway.
type CreateVirtualGateway201Response = VirtualGateway

// CreateVms201Response Information about the VM.
type CreateVms201Response = Vm

// CreateVolume201Response Information about the volume.
type CreateVolume201Response = Volume

// CreateVpc201Response Information about the Vpc.
type CreateVpc201Response = Vpc

// Error400 For HTTP 400 bad request errors, we implement the https://datatracker.ietf.org/doc/html/rfc9457
type Error400 = BadRequestError

// Error401 For HTTP errors, we implement the https://datatracker.ietf.org/doc/html/rfc9457
type Error401 = Error

// Error404 For HTTP errors, we implement the https://datatracker.ietf.org/doc/html/rfc9457
type Error404 = Error

// Error409 For HTTP errors, we implement the https://datatracker.ietf.org/doc/html/rfc9457
type Error409 = Error

// Error500 For HTTP errors, we implement the https://datatracker.ietf.org/doc/html/rfc9457
type Error500 = Error

// GetACL200Response defines model for GetACL200Response.
type GetACL200Response = ACLPaginatedList

// GetIAMPolicy200Response defines model for GetIAMPolicy200Response.
type GetIAMPolicy200Response = IAMPolicy

// GetPermission200Response defines model for GetPermission200Response.
type GetPermission200Response = RegisteredPermission

// GetRole200Response defines model for GetRole200Response.
type GetRole200Response = RegisteredRole

// GetRolePermissions200Response defines model for GetRolePermissions200Response.
type GetRolePermissions200Response = PermissionsPaginatedList

// GetServiceAccount200Response defines model for GetServiceAccount200Response.
type GetServiceAccount200Response = ServiceAccountEdited

// GetSpaceById200Response defines model for GetSpaceById200Response.
type GetSpaceById200Response = Space

// GetUser200Response defines model for GetUser200Response.
type GetUser200Response = UserModified

// GetUserInfo200Response defines model for GetUserInfo200Response.
type GetUserInfo200Response = UserInfo

// GetWebAuthnJavaScript200Response defines model for GetWebAuthnJavaScript200Response.
type GetWebAuthnJavaScript200Response = WebAuthnJavaScript

// Healthcheck200Response Type defining Health check from services
type Healthcheck200Response = Healthcheck

// Introspect200Response defines model for Introspect200Response.
type Introspect200Response = IntrospectResp

// JsonWebKeys200Response JSON Web Key Set
type JsonWebKeys200Response = JsonWebKeySet

// LinkNic200Response defines model for LinkNic200Response.
type LinkNic200Response struct {
	// LinkNicId The ID of the NIC attachment.
	LinkNicId *string `json:"linkNicId,omitempty"`
}

// LinkPublicIp200Response defines model for LinkPublicIp200Response.
type LinkPublicIp200Response struct {
	// LinkPublicIpId (Vpc only) The ID representing the association of the public IP with the VM or the NIC.
	LinkPublicIpId *string `json:"linkPublicIpId,omitempty"`
}

// LinkRouteTable200Response defines model for LinkRouteTable200Response.
type LinkRouteTable200Response struct {
	// LinkRouteTableId The ID of the association between the route table and the Subnet.
	LinkRouteTableId *string `json:"linkRouteTableId,omitempty"`
}

// ListClientGateways200Response Information about one or more ClientGateways.
type ListClientGateways200Response = ClientGateways

// ListComputeBridges200Response List of compute bridges.
type ListComputeBridges200Response = ComputeBridges

// ListDirectLinkInterfaces200Response Information about one or more DirectLink interfaces.
type ListDirectLinkInterfaces200Response = DirectLinkInterfaces

// ListDirectLinks200Response Information about one or more DirectLinks.
type ListDirectLinks200Response = DirectLinks

// ListHybridBridges200Response List of hybrid bridges.
type ListHybridBridges200Response = HybridBridges

// ListManagedServicesBridges200Response List of bridges.
type ListManagedServicesBridges200Response = ManagedServicesBridges

// ListPermissions200Response defines model for ListPermissions200Response.
type ListPermissions200Response = PermissionsPaginatedList

// ListRoles200Response defines model for ListRoles200Response.
type ListRoles200Response = RolesPaginatedList

// ListServiceAccount200Response defines model for ListServiceAccount200Response.
type ListServiceAccount200Response = ServiceAccountPaginatedList

// ListSpaces200Response defines model for ListSpaces200Response.
type ListSpaces200Response = SpacePaginatedList

// ListSpacesIdentity200Response defines model for ListSpacesIdentity200Response.
type ListSpacesIdentity200Response = SpaceSimplePaginatedList

// ListSpacesServiceAccount200Response defines model for ListSpacesServiceAccount200Response.
type ListSpacesServiceAccount200Response = SpaceSimplePaginatedList

// ListSpacesUser200Response defines model for ListSpacesUser200Response.
type ListSpacesUser200Response = SpaceSimplePaginatedList

// ListUser200Response defines model for ListUser200Response.
type ListUser200Response = UserPaginatedList

// ListUserOrganisations200Response defines model for ListUserOrganisations200Response.
type ListUserOrganisations200Response = OrganisationSimplePaginatedList

// ListVPNConnections200Response Information about one or more VPNConnections.
type ListVPNConnections200Response = VPNConnections

// ListVirtualGateways200Response Information about one or more VirtualGateways.
type ListVirtualGateways200Response = VirtualGateways

// MatchServiceAccount200Response defines model for MatchServiceAccount200Response.
type MatchServiceAccount200Response = ServiceAccountPaginatedList

// NodeProfileList200Response defines model for NodeProfileList200Response.
type NodeProfileList200Response = KubernetesNodeProfiles

// NodepoolCreate201Response defines model for NodepoolCreate201Response.
type NodepoolCreate201Response = OpenShiftNodepoolCreated

// NodepoolDelete202Response defines model for NodepoolDelete202Response.
type NodepoolDelete202Response = OpenShiftClusterDeleted

// Nodepools200Response defines model for Nodepools200Response.
type Nodepools200Response = OpenShiftNodepools

// OpenShiftNodepoolUpdate202Response defines model for OpenShiftNodepoolUpdate202Response.
type OpenShiftNodepoolUpdate202Response = OpenShiftNodepoolUpdated

// OpenShiftOperation200Response defines model for OpenShiftOperation200Response.
type OpenShiftOperation200Response = OpenShiftOperation

// OpenShiftOperations200Response defines model for OpenShiftOperations200Response.
type OpenShiftOperations200Response = OpenShiftOperations

// Operation200Response defines model for Operation200Response.
type Operation200Response = KubernetesOperation

// Operation202Response defines model for Operation202Response.
type Operation202Response = KubernetesOperation

// OperationList200Response defines model for OperationList200Response.
type OperationList200Response = KubernetesListOperations

// PatchUserState200Response defines model for PatchUserState200Response.
type PatchUserState200Response = UserEdited

// PostgresCreateCluster201Response defines model for PostgresCreateCluster201Response.
type PostgresCreateCluster201Response = PostgresClusterWithPassword

// PostgresCreateCluster400Response defines model for PostgresCreateCluster400Response.
type PostgresCreateCluster400Response struct {
	union json.RawMessage
}

// PostgresDeleteBackup202Response defines model for PostgresDeleteBackup202Response.
type PostgresDeleteBackup202Response = PostgresClusterBackup

// PostgresDeleteCluster202Response defines model for PostgresDeleteCluster202Response.
type PostgresDeleteCluster202Response = PostgresCluster

// PostgresGetCluster200Response defines model for PostgresGetCluster200Response.
type PostgresGetCluster200Response = PostgresCluster

// PostgresIncompatibleStatusProblem A problem, compatible with [RFC 9457](https://datatracker.ietf.org/doc/html/rfc9457#name-members-of-a-problem-detail).
type PostgresIncompatibleStatusProblem = PostgresProblem

// PostgresInvalidAuthenticationProblem A problem, compatible with [RFC 9457](https://datatracker.ietf.org/doc/html/rfc9457#name-members-of-a-problem-detail).
type PostgresInvalidAuthenticationProblem = PostgresProblem

// PostgresListBackups200Response defines model for PostgresListBackups200Response.
type PostgresListBackups200Response struct {
	Items []PostgresClusterBackup `json:"items"`

	// NextToken Token to provide in order to get the next page. Absent when the last page has been reached.
	NextToken *string `json:"nextToken,omitempty"`

	// PageNumber The page number.
	PageNumber int32 `json:"pageNumber"`

	// TotalItems The total number of items that match the request.
	TotalItems int32 `json:"totalItems"`
}

// PostgresListClusterBackups200Response defines model for PostgresListClusterBackups200Response.
type PostgresListClusterBackups200Response struct {
	Items []PostgresClusterBackup `json:"items"`
}

// PostgresListClusters200Response defines model for PostgresListClusters200Response.
type PostgresListClusters200Response struct {
	Items []PostgresCluster `json:"items"`
}

// PostgresPatchCluster200Response defines model for PostgresPatchCluster200Response.
type PostgresPatchCluster200Response = PostgresCluster

// PostgresResetPassword202Response defines model for PostgresResetPassword202Response.
type PostgresResetPassword202Response = PostgresClusterWithPassword

// PostgresResourceNotFoundProblem A problem, compatible with [RFC 9457](https://datatracker.ietf.org/doc/html/rfc9457#name-members-of-a-problem-detail).
type PostgresResourceNotFoundProblem = PostgresProblem

// PostgresServiceCatalogClustersAutomaticBackup200Response defines model for PostgresServiceCatalogClustersAutomaticBackup200Response.
type PostgresServiceCatalogClustersAutomaticBackup200Response struct {
	StartTimeSlot PostgresTimeSlot `json:"startTimeSlot"`
}

// PostgresServiceCatalogClustersConfiguration200Response defines model for PostgresServiceCatalogClustersConfiguration200Response.
type PostgresServiceCatalogClustersConfiguration200Response struct {
	Items []PostgresClusterCatalogItem `json:"items"`
}

// PostgresServiceMalfunctionProblem A problem, compatible with [RFC 9457](https://datatracker.ietf.org/doc/html/rfc9457#name-members-of-a-problem-detail).
type PostgresServiceMalfunctionProblem = PostgresProblem

// ReadAdminPassword200Response defines model for ReadAdminPassword200Response.
type ReadAdminPassword200Response = ReadAdminPassword

// ReadClientGateway200Response Information about the client gateway.
type ReadClientGateway200Response = ClientGateway

// ReadComputeBridge200Response The bridge object representation between two compute VPCs.
type ReadComputeBridge200Response = ComputeBridge

// ReadConsoleOutput200Response defines model for ReadConsoleOutput200Response.
type ReadConsoleOutput200Response = ReadConsoleOutput

// ReadDhcpOptions200Response defines model for ReadDhcpOptions200Response.
type ReadDhcpOptions200Response = ReadDhcpOptions

// ReadDhcpOptionsById200Response Information about the DHCP options set.
type ReadDhcpOptionsById200Response = DhcpOptionsSet

// ReadDirectLink200Response Information about the DirectLink.
type ReadDirectLink200Response = DirectLink

// ReadDirectLinkInterface200Response Information about the DirectLink interfaces.
type ReadDirectLinkInterface200Response = DirectLinkInterface

// ReadFlexibleGpus200Response defines model for ReadFlexibleGpus200Response.
type ReadFlexibleGpus200Response = ReadFlexibleGpus

// ReadFlexibleGpusById200Response Information about the flexible GPU (fGPU).
type ReadFlexibleGpusById200Response = FlexibleGpu

// ReadHybridBridge200Response The bridge object representation between a managed service and a standalone compute VPC.
type ReadHybridBridge200Response = HybridBridge

// ReadImages200Response defines model for ReadImages200Response.
type ReadImages200Response = ReadImages

// ReadImagesById200Response Information about the Image.
type ReadImagesById200Response = Image

// ReadInternetGateways200Response defines model for ReadInternetGateways200Response.
type ReadInternetGateways200Response = ReadInternetGateways

// ReadInternetGatewaysById200Response Information about the Internet gateway.
type ReadInternetGatewaysById200Response = InternetGateway

// ReadKeypairs200Response defines model for ReadKeypairs200Response.
type ReadKeypairs200Response = ReadKeypairs

// ReadKeypairsById200Response Information about the keypair.
type ReadKeypairsById200Response = ReadKeypairsById

// ReadListenerRules200Response defines model for ReadListenerRules200Response.
type ReadListenerRules200Response = ReadListenerRules

// ReadListenerRulesById200Response Information about the listener rule.
type ReadListenerRulesById200Response = ListenerRule

// ReadLoadBalancerTags200Response defines model for ReadLoadBalancerTags200Response.
type ReadLoadBalancerTags200Response = ReadLoadBalancerTags

// ReadLoadBalancers200Response defines model for ReadLoadBalancers200Response.
type ReadLoadBalancers200Response = ReadLoadBalancers

// ReadLoadBalancersById200Response Information about the load balancer.
type ReadLoadBalancersById200Response = LoadBalancer

// ReadLocations200Response Locations of your availability zones.
type ReadLocations200Response = Locations

// ReadManagedServicesBridge200Response The bridge object representation between two managed services.
type ReadManagedServicesBridge200Response = ManagedServicesBridge

// ReadNatGateway200Response defines model for ReadNatGateway200Response.
type ReadNatGateway200Response = ReadNatGateway

// ReadNatGatewayById200Response Information about the NAT gateway.
type ReadNatGatewayById200Response = NatGateway

// ReadNics200Response defines model for ReadNics200Response.
type ReadNics200Response = ReadNics

// ReadNicsById200Response Information about the NIC.
type ReadNicsById200Response = Nic

// ReadPublicIps200Response defines model for ReadPublicIps200Response.
type ReadPublicIps200Response = ReadPublicIps

// ReadPublicIpsById200Response Information about the public IP.
type ReadPublicIpsById200Response = PublicIp

// ReadRouteTables200Response defines model for ReadRouteTables200Response.
type ReadRouteTables200Response = ReadRouteTables

// ReadRouteTablesById200Response Information about the route table.
type ReadRouteTablesById200Response = RouteTable

// ReadSecurityGroups200Response defines model for ReadSecurityGroups200Response.
type ReadSecurityGroups200Response = ReadSecurityGroups

// ReadSecurityGroupsById200Response Information about the security group.
type ReadSecurityGroupsById200Response = SecurityGroup

// ReadServerCertificates200Response defines model for ReadServerCertificates200Response.
type ReadServerCertificates200Response = ReadServerCertificates

// ReadSnapshots200Response defines model for ReadSnapshots200Response.
type ReadSnapshots200Response = ReadSnapshots

// ReadSnapshotsById200Response Information about the snapshot.
type ReadSnapshotsById200Response = Snapshot

// ReadSubnets200Response defines model for ReadSubnets200Response.
type ReadSubnets200Response = ReadSubnets

// ReadSubnetsById200Response Information about the Subnet.
type ReadSubnetsById200Response = Subnet

// ReadTags200Response defines model for ReadTags200Response.
type ReadTags200Response = ReadTags

// ReadVPNConnection200Response Information about the vpn connection.
type ReadVPNConnection200Response = VPNConnection

// ReadVirtualGateway200Response Information about the client gateway.
type ReadVirtualGateway200Response = VirtualGateway

// ReadVms200Response defines model for ReadVms200Response.
type ReadVms200Response = ReadVms

// ReadVmsById200Response Information about the VM.
type ReadVmsById200Response = Vm

// ReadVmsHealth200Response defines model for ReadVmsHealth200Response.
type ReadVmsHealth200Response = ReadVmsHealth

// ReadVmsState200Response defines model for ReadVmsState200Response.
type ReadVmsState200Response = ReadVmsState

// ReadVolumes200Response defines model for ReadVolumes200Response.
type ReadVolumes200Response = ReadVolumes

// ReadVolumesById200Response Information about the volume.
type ReadVolumesById200Response = Volume

// ReadVpcs200Response defines model for ReadVpcs200Response.
type ReadVpcs200Response = ReadVpcs

// ReadVpcsById200Response Information about the Vpc.
type ReadVpcsById200Response = Vpc

// RecoverUser200Response defines model for RecoverUser200Response.
type RecoverUser200Response = RecoveryCode

// StartVm200Response Information about the state of the VM.
type StartVm200Response = VmState

// StopVm200Response Information about the state of the VM.
type StopVm200Response = VmState

// Token200Response defines model for Token200Response.
type Token200Response = TokenResp

// UpdateFlexibleGpu200Response Information about the flexible GPU (fGPU).
type UpdateFlexibleGpu200Response = FlexibleGpu

// UpdateImage200Response Information about the Image.
type UpdateImage200Response = Image

// UpdateListenerRule200Response Information about the listener rule.
type UpdateListenerRule200Response = ListenerRule

// UpdateLoadBalancer200Response Information about the load balancer.
type UpdateLoadBalancer200Response = LoadBalancer

// UpdateNic200Response Information about the NIC.
type UpdateNic200Response = Nic

// UpdateRoute200Response Information about the route table.
type UpdateRoute200Response = RouteTable

// UpdateRouteTableRoutePropagation200Response Information about the route table.
type UpdateRouteTableRoutePropagation200Response = RouteTable

// UpdateServerCertificate204Response Information about the Server Certificates.
type UpdateServerCertificate204Response = ServerCertificate

// UpdateServiceAccount200Response defines model for UpdateServiceAccount200Response.
type UpdateServiceAccount200Response = ServiceAccountEdited

// UpdateSubnet200Response Information about the Subnet.
type UpdateSubnet200Response = Subnet

// UpdateUser200Response defines model for UpdateUser200Response.
type UpdateUser200Response = UserModified

// UpdateVm200Response Information about the VM.
type UpdateVm200Response = Vm

// UpdateVolume200Response Information about the volume.
type UpdateVolume200Response = Volume

// UpdateVpc200Response Information about the Vpc.
type UpdateVpc200Response = Vpc

// VersionList200Response defines model for VersionList200Response.
type VersionList200Response = KubernetesVersions

// Versions202Response defines model for Versions202Response.
type Versions202Response = OpenShiftVersions

// ClusterConfigurationRequest defines model for ClusterConfigurationRequest.
type ClusterConfigurationRequest = KubernetesClusterConfiguration

// ConvertTokenRequest defines model for ConvertTokenRequest.
type ConvertTokenRequest = Token

// CreateClientGatewayRequest Create a Client Gateway.
type CreateClientGatewayRequest = CreateClientGateway

// CreateClusterRequest defines model for CreateClusterRequest.
type CreateClusterRequest = OpenShiftClusterCreate

// CreateComputeBridgeRequest Schema request to bridge two compute VPCs.
type CreateComputeBridgeRequest = CreateComputeBridge

// CreateDhcpOptionsRequest defines model for CreateDhcpOptionsRequest.
type CreateDhcpOptionsRequest = CreateDhcpOptions

// CreateDirectLinkInterfaceRequest Create a Direct Link Interface.
type CreateDirectLinkInterfaceRequest = CreateDirectLinkInterface

// CreateDirectLinkRequest Create a Direct Link.
type CreateDirectLinkRequest = CreateDirectLink

// CreateFlexibleGpuRequest defines model for CreateFlexibleGpuRequest.
type CreateFlexibleGpuRequest = CreateFlexibleGpu

// CreateHybridBridgeRequest Schema request to bridge a managed service and a compute VPC.
type CreateHybridBridgeRequest = CreateHybridBridge

// CreateImageRequest defines model for CreateImageRequest.
type CreateImageRequest = CreateImage

// CreateKeypairRequest defines model for CreateKeypairRequest.
type CreateKeypairRequest = CreateKeypairRequestSchema

// CreateListenerRuleRequest defines model for CreateListenerRuleRequest.
type CreateListenerRuleRequest = CreateListenerRule

// CreateLoadBalancerListenersRequest defines model for CreateLoadBalancerListenersRequest.
type CreateLoadBalancerListenersRequest = CreateLoadBalancerListeners

// CreateLoadBalancerPolicyRequest defines model for CreateLoadBalancerPolicyRequest.
type CreateLoadBalancerPolicyRequest = CreateLoadBalancerPolicy

// CreateLoadBalancerRequest defines model for CreateLoadBalancerRequest.
type CreateLoadBalancerRequest = CreateLoadBalancer

// CreateLoadBalancerTagsRequest defines model for CreateLoadBalancerTagsRequest.
type CreateLoadBalancerTagsRequest = CreateLoadBalancerTags

// CreateManagedServicesBridgeRequest Schema request to bridge two managed services.
type CreateManagedServicesBridgeRequest = CreateManagedServicesBridge

// CreateNatGatewayRequest defines model for CreateNatGatewayRequest.
type CreateNatGatewayRequest = CreateNatGateway

// CreateNicRequest defines model for CreateNicRequest.
type CreateNicRequest = CreateNic

// CreateNodepoolRequest defines model for CreateNodepoolRequest.
type CreateNodepoolRequest = OpenShiftNodepool

// CreateRouteRequest defines model for CreateRouteRequest.
type CreateRouteRequest = CreateRoute

// CreateRouteTableRequest defines model for CreateRouteTableRequest.
type CreateRouteTableRequest = CreateRouteTable

// CreateSecurityGroupRequest defines model for CreateSecurityGroupRequest.
type CreateSecurityGroupRequest = CreateSecurityGroup

// CreateSecurityGroupRuleRequest defines model for CreateSecurityGroupRuleRequest.
type CreateSecurityGroupRuleRequest = CreateSecurityGroupRule

// CreateServerCertificateRequest defines model for CreateServerCertificateRequest.
type CreateServerCertificateRequest = CreateServerCertificate

// CreateServiceAccountRequest defines model for CreateServiceAccountRequest.
type CreateServiceAccountRequest = ServiceAccount

// CreateSnapshotRequest defines model for CreateSnapshotRequest.
type CreateSnapshotRequest = CreateSnapshot

// CreateSpaceRequest defines model for CreateSpaceRequest.
type CreateSpaceRequest = CreateSpace

// CreateSubnetRequest defines model for CreateSubnetRequest.
type CreateSubnetRequest = CreateSubnet

// CreateTagsRequest defines model for CreateTagsRequest.
type CreateTagsRequest = CreateTags

// CreateUserRequest defines model for CreateUserRequest.
type CreateUserRequest = User

// CreateVPNConnectionRequest Create a VPN Connection.
type CreateVPNConnectionRequest = CreateVPNConnection

// CreateVPNConnectionRouteRequest Create a VPN Connection Route.
type CreateVPNConnectionRouteRequest = CreateVPNConnectionRoute

// CreateVirtualGatewayRequest Create a Virtual Gateway.
type CreateVirtualGatewayRequest = CreateVirtualGateway

// CreateVmsRequest defines model for CreateVmsRequest.
type CreateVmsRequest = CreateVms

// CreateVolumeRequest defines model for CreateVolumeRequest.
type CreateVolumeRequest = CreateVolume

// CreateVpcRequest defines model for CreateVpcRequest.
type CreateVpcRequest = CreateVpc

// DeleteACLRequest List of ACLs.
type DeleteACLRequest = ACLList

// DeleteLoadBalancerListenersRequest defines model for DeleteLoadBalancerListenersRequest.
type DeleteLoadBalancerListenersRequest = DeleteLoadBalancerListeners

// DeleteLoadBalancerPolicyRequest defines model for DeleteLoadBalancerPolicyRequest.
type DeleteLoadBalancerPolicyRequest = DeleteLoadBalancerPolicy

// DeleteLoadBalancerTagsRequest defines model for DeleteLoadBalancerTagsRequest.
type DeleteLoadBalancerTagsRequest = DeleteLoadBalancerTags

// DeleteRouteRequest defines model for DeleteRouteRequest.
type DeleteRouteRequest = DeleteRoute

// DeleteSecurityGroupRuleRequest defines model for DeleteSecurityGroupRuleRequest.
type DeleteSecurityGroupRuleRequest = DeleteSecurityGroupRule

// DeleteTagsRequest defines model for DeleteTagsRequest.
type DeleteTagsRequest = DeleteTags

// DeleteVPNConnectionRouteRequest Delete a VPN Connection Route.
type DeleteVPNConnectionRouteRequest = DeleteVPNConnectionRoute

// LinkFlexibleGpuRequest defines model for LinkFlexibleGpuRequest.
type LinkFlexibleGpuRequest = LinkFlexibleGpu

// LinkInternetGatewayRequest defines model for LinkInternetGatewayRequest.
type LinkInternetGatewayRequest = LinkInternetGateway

// LinkLoadBalancerBackendMachinesRequest defines model for LinkLoadBalancerBackendMachinesRequest.
type LinkLoadBalancerBackendMachinesRequest = LinkLoadBalancerBackendMachines

// LinkNicRequest defines model for LinkNicRequest.
type LinkNicRequest struct {
	// DeviceNumber The index of the VM device for the NIC attachment (between `1` and `7`, both included).
	DeviceNumber int `json:"deviceNumber"`

	// VmId The ID of the VM to which you want to attach the NIC.
	VmId string `json:"vmId"`
}

// LinkPrivateIpsRequest defines model for LinkPrivateIpsRequest.
type LinkPrivateIpsRequest = LinkPrivateIps

// LinkPublicIpRequest defines model for LinkPublicIpRequest.
type LinkPublicIpRequest struct {
	// AllowRelink If true, allows the public IP to be associated with the VM or NIC that you specify even if it is already associated with another VM or NIC. If false, prevents the public IP from being associated with the VM or NIC that you specify if it is already associated with another VM or NIC. (By default, true in the public Cloud, false in a Vpc.)
	AllowRelink *bool `json:"allowRelink,omitempty"`

	// NicId (Vpc only) The ID of the NIC. This parameter is required if the VM has more than one NIC attached. Otherwise, you need to specify the `VmId` parameter instead. You cannot specify both parameters at the same time.
	NicId *string `json:"nicId,omitempty"`

	// PrivateIp (Vpc only) The primary or secondary private IP of the specified NIC. By default, the primary private IP.
	PrivateIp *string `json:"privateIp,omitempty"`

	// VmId The ID of the VM.<br />
	// - In the public Cloud, this parameter is required.<br />
	// - In a Vpc, this parameter is required if the VM has only one NIC. Otherwise, you need to specify the `NicId` parameter instead. You cannot specify both parameters at the same time.
	VmId *string `json:"vmId,omitempty"`
}

// LinkRouteTableRequest defines model for LinkRouteTableRequest.
type LinkRouteTableRequest struct {
	// SubnetId The ID of the Subnet.
	SubnetId string `json:"subnetId"`
}

// LinkUnlinkVirtualGatewayRequest Link or Unlink a Virtual Gateway.
type LinkUnlinkVirtualGatewayRequest = LinkUnlinkVirtualGateway

// LinkVolumeRequest defines model for LinkVolumeRequest.
type LinkVolumeRequest = LinkVolume

// MasterUpgradeRequest defines model for MasterUpgradeRequest.
type MasterUpgradeRequest = KubernetesMasterUpgrade

// PatchUserStateRequest defines model for PatchUserStateRequest.
type PatchUserStateRequest = UserState

// PostgresClusterCreationRequest defines model for PostgresClusterCreationRequest.
type PostgresClusterCreationRequest struct {
	AllowedIpRanges PostgresAllowedIpRanges `json:"allowedIpRanges"`

	// AutomaticBackup Whether automatic backup is enabled for this cluster.
	AutomaticBackup *bool           `json:"automaticBackup"`
	Name            StrictSlugMax63 `json:"name"`

	// NodeConfiguration The configuration used to provision the cluster nodes.
	NodeConfiguration PostgresNodeConfiguration `json:"nodeConfiguration"`

	// SourceBackupId A backup unique identifier.
	SourceBackupId *PostgresBackupId `json:"sourceBackupId,omitempty"`

	// Tags Tags to identify resources
	Tags *PostgresTags `json:"tags,omitempty"`

	// User The name of the user with administration privileges on the cluster.
	User PostgresUser `json:"user"`

	// Volume The configuration for a data storage volume.
	Volume PostgresVolume `json:"volume"`
}

// PostgresClusterDeleteRequest defines model for PostgresClusterDeleteRequest.
type PostgresClusterDeleteRequest struct {
	// Backups What to do with existing backups, if any, of the cluster upon deleting it.
	Backups *PostgresBackupDeleteOption `json:"backups,omitempty"`
}

// PostgresClusterModificationRequest defines model for PostgresClusterModificationRequest.
type PostgresClusterModificationRequest struct {
	AllowedIpRanges *PostgresAllowedIpRanges `json:"allowedIpRanges,omitempty"`

	// AutomaticBackup Whether automatic backups are enabled for this cluster
	AutomaticBackup *PostgresClusterAutomaticBackup `json:"automaticBackup,omitempty"`

	// NodeConfiguration The configuration used to provision the cluster nodes.
	NodeConfiguration *PostgresNodeConfiguration `json:"nodeConfiguration,omitempty"`
}

// ReadLoadBalancerTagsRequest defines model for ReadLoadBalancerTagsRequest.
type ReadLoadBalancerTagsRequest struct {
	// Names One or more load balancer names.
	Names []string `json:"names"`
}

// ReadVmsHealthRequest defines model for ReadVmsHealthRequest.
type ReadVmsHealthRequest struct {
	// BackendVmIds One or more IDs of back-end VMs.
	BackendVmIds *[]string `json:"backendVmIds,omitempty"`
}

// SetACLRequest List of ACLs.
type SetACLRequest = ACLList

// SetIAMPolicyRequest Defines the structure for modification instructions for roles and permissions
type SetIAMPolicyRequest struct {
	Add    *IAMPolicy `json:"add,omitempty"`
	Delete *IAMPolicy `json:"delete,omitempty"`
}

// StopVmRequest defines model for StopVmRequest.
type StopVmRequest = StopVm

// UnlinkInternetGatewayRequest defines model for UnlinkInternetGatewayRequest.
type UnlinkInternetGatewayRequest = UnlinkInternetGateway

// UnlinkLoadBalancerBackendMachinesRequest defines model for UnlinkLoadBalancerBackendMachinesRequest.
type UnlinkLoadBalancerBackendMachinesRequest = UnlinkLoadBalancerBackendMachines

// UnlinkNicRequest defines model for UnlinkNicRequest.
type UnlinkNicRequest = UnlinkNic

// UnlinkPrivateIpsRequest defines model for UnlinkPrivateIpsRequest.
type UnlinkPrivateIpsRequest = UnlinkPrivateIps

// UnlinkPublicIpRequest defines model for UnlinkPublicIpRequest.
type UnlinkPublicIpRequest = UnlinkPublicIp

// UnlinkRouteTableRequest defines model for UnlinkRouteTableRequest.
type UnlinkRouteTableRequest = UnlinkRouteTable

// UnlinkVolumeRequest defines model for UnlinkVolumeRequest.
type UnlinkVolumeRequest = UnlinkVolume

// UpdateClusterRequest defines model for UpdateClusterRequest.
type UpdateClusterRequest = OpenShiftClusterUpdate

// UpdateFlexibleGpuRequest defines model for UpdateFlexibleGpuRequest.
type UpdateFlexibleGpuRequest = UpdateFlexibleGpu

// UpdateImageRequest defines model for UpdateImageRequest.
type UpdateImageRequest = UpdateImage

// UpdateListenerRuleRequest defines model for UpdateListenerRuleRequest.
type UpdateListenerRuleRequest = UpdateListenerRule

// UpdateLoadBalancerRequest defines model for UpdateLoadBalancerRequest.
type UpdateLoadBalancerRequest = UpdateLoadBalancer

// UpdateNicRequest defines model for UpdateNicRequest.
type UpdateNicRequest = UpdateNic

// UpdateNodepoolRequest defines model for UpdateNodepoolRequest.
type UpdateNodepoolRequest = OpenShiftNodepoolUpdate

// UpdateRouteRequest defines model for UpdateRouteRequest.
type UpdateRouteRequest = UpdateRoute

// UpdateRouteTableRoutePropagationRequest defines model for UpdateRouteTableRoutePropagationRequest.
type UpdateRouteTableRoutePropagationRequest = UpdateRouteTableRoutePropagation

// UpdateServerCertificateRequest defines model for UpdateServerCertificateRequest.
type UpdateServerCertificateRequest = UpdateServerCertificate

// UpdateServiceAccountRequest defines model for UpdateServiceAccountRequest.
type UpdateServiceAccountRequest = ServiceAccount

// UpdateSpaceRequest defines model for UpdateSpaceRequest.
type UpdateSpaceRequest = MutableSpace

// UpdateSubnetRequest defines model for UpdateSubnetRequest.
type UpdateSubnetRequest = UpdateSubnet

// UpdateUserRequest defines model for UpdateUserRequest.
type UpdateUserRequest = UserUpdate

// UpdateVmRequest defines model for UpdateVmRequest.
type UpdateVmRequest = UpdateVm

// UpdateVolumeRequest defines model for UpdateVolumeRequest.
type UpdateVolumeRequest = UpdateVolume

// UpdateVpcRequest defines model for UpdateVpcRequest.
type UpdateVpcRequest = UpdateVpc

// WorkerRemoveRequest defines model for WorkerRemoveRequest.
type WorkerRemoveRequest = KubernetesWorkerRemoval

// WorkerUpgradeRequest defines model for WorkerUpgradeRequest.
type WorkerUpgradeRequest = KubernetesWorkerUpgrade

// WorkersAdditionRequest defines model for WorkersAdditionRequest.
type WorkersAdditionRequest = KubernetesWorkersAddition

// ReadDhcpOptionsParams defines parameters for ReadDhcpOptions.
type ReadDhcpOptionsParams struct {
	// Default If true, lists all default DHCP options set. If false, lists all non-default DHCP options set.
	Default *bool `form:"default,omitempty" json:"default,omitempty"`

	// DomainNameServers The IPs of the domain name servers used for the DHCP options sets.
	DomainNameServers *[]string `form:"domainNameServers,omitempty" json:"domainNameServers,omitempty"`

	// DomainNames The domain names used for the DHCP options sets.
	DomainNames *[]string `form:"domainNames,omitempty" json:"domainNames,omitempty"`

	// LogServers The IPs of the log servers used for the DHCP options sets.
	LogServers *[]string `form:"logServers,omitempty" json:"logServers,omitempty"`

	// NtpServers The IPs of the Network Time Protocol (NTP) servers used for the DHCP options sets.
	NtpServers *[]string `form:"ntpServers,omitempty" json:"ntpServers,omitempty"`

	// TagKeys The keys of the tags associated with the DHCP options sets.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the DHCP options sets.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the DHCP options sets, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// Ids The IDs of the DHCP options sets.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`
}

// ReadFlexibleGpusParams defines parameters for ReadFlexibleGpus.
type ReadFlexibleGpusParams struct {
	// DeleteOnVmDeletion Indicates whether the fGPU is deleted when terminating the VM.
	DeleteOnVmDeletion *bool `form:"deleteOnVmDeletion,omitempty" json:"deleteOnVmDeletion,omitempty"`

	// Generations The processor generations that the fGPUs are compatible with.
	Generations *[]string `form:"generations,omitempty" json:"generations,omitempty"`

	// ModelNames One or more models of fGPUs.
	ModelNames *[]string `form:"modelNames,omitempty" json:"modelNames,omitempty"`

	// States The states of the fGPUs (`allocated` \| `attaching` \| `attached` \| `detaching`).
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// VmIds One or more IDs of VMs.
	VmIds *[]string `form:"vmIds,omitempty" json:"vmIds,omitempty"`

	// AvailabilityZoneNames The Subregions where the fGPUs are located.
	AvailabilityZoneNames *[]string `form:"availabilityZoneNames,omitempty" json:"availabilityZoneNames,omitempty"`

	// Ids One or more IDs of fGPUs.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`
}

// ReadImagesParams defines parameters for ReadImages.
type ReadImagesParams struct {
	// AccountAliases The account aliases of the owners of the OMIs.
	AccountAliases *[]string `form:"accountAliases,omitempty" json:"accountAliases,omitempty"`

	// Architectures The architectures of the OMIs (`i386` \| `x86_64`).
	Architectures *[]string `form:"architectures,omitempty" json:"architectures,omitempty"`

	// BlockDeviceMappingDeleteOnVmDeletion Whether the volumes are deleted or not when terminating the VM.
	BlockDeviceMappingDeleteOnVmDeletion *bool `form:"blockDeviceMappingDeleteOnVmDeletion,omitempty" json:"blockDeviceMappingDeleteOnVmDeletion,omitempty"`

	// BlockDeviceMappingDeviceNames The device names for the volumes.
	BlockDeviceMappingDeviceNames *[]string `form:"blockDeviceMappingDeviceNames,omitempty" json:"blockDeviceMappingDeviceNames,omitempty"`

	// BlockDeviceMappingSnapshotIds The IDs of the snapshots used to create the volumes.
	BlockDeviceMappingSnapshotIds *[]string `form:"blockDeviceMappingSnapshotIds,omitempty" json:"blockDeviceMappingSnapshotIds,omitempty"`

	// BlockDeviceMappingVolumeSizes The sizes of the volumes, in gibibytes (GiB).
	BlockDeviceMappingVolumeSizes *[]int `form:"blockDeviceMappingVolumeSizes,omitempty" json:"blockDeviceMappingVolumeSizes,omitempty"`

	// BlockDeviceMappingVolumeTypes The types of volumes (`standard` \| `gp2` \| `io1`).
	BlockDeviceMappingVolumeTypes *[]string `form:"blockDeviceMappingVolumeTypes,omitempty" json:"blockDeviceMappingVolumeTypes,omitempty"`

	// Descriptions The descriptions of the OMIs, provided when they were created.
	Descriptions *[]string `form:"descriptions,omitempty" json:"descriptions,omitempty"`

	// FileLocations The locations of the buckets where the Image files are stored.
	FileLocations *[]string `form:"fileLocations,omitempty" json:"fileLocations,omitempty"`

	// Hypervisors The hypervisor type of the Image (always `xen`).
	Hypervisors *[]string `form:"hypervisors,omitempty" json:"hypervisors,omitempty"`

	// ImageNames The names of the OMIs, provided when they were created.
	ImageNames *[]string `form:"imageNames,omitempty" json:"imageNames,omitempty"`

	// ProductCodeNames The names of the product codes associated with the Image.
	ProductCodeNames *[]string `form:"productCodeNames,omitempty" json:"productCodeNames,omitempty"`

	// ProductCodes The product codes associated with the Image.
	ProductCodes *[]string `form:"productCodes,omitempty" json:"productCodes,omitempty"`

	// RootDeviceNames The name of the root device. This value must be /dev/sda1.
	RootDeviceNames *[]string `form:"rootDeviceNames,omitempty" json:"rootDeviceNames,omitempty"`

	// RootDeviceTypes The types of root device used by the OMIs (`bsu` or `ebs`).
	RootDeviceTypes *[]string `form:"rootDeviceTypes,omitempty" json:"rootDeviceTypes,omitempty"`

	// States The states of the OMIs (`pending` \| `available` \| `failed`).
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// TagKeys The keys of the tags associated with the OMIs.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the OMIs.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the OMIs, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// VirtualizationTypes The virtualization types (always `hvm`).
	VirtualizationTypes *[]string `form:"virtualizationTypes,omitempty" json:"virtualizationTypes,omitempty"`

	// Ids The IDs of the OMIs.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`

	// IsPublic If true, lists all public OMIs. If false, lists all private OMIs.
	IsPublic *bool `form:"isPublic,omitempty" json:"isPublic,omitempty"`
}

// ReadInternetGatewaysParams defines parameters for ReadInternetGateways.
type ReadInternetGatewaysParams struct {
	// LinkStates The current states of the attachments between the Internet gateways and the Vpcs (only `available`, if the Internet gateway is attached to a Vpc).
	LinkStates *[]string `form:"linkStates,omitempty" json:"linkStates,omitempty"`

	// TagKeys The keys of the tags associated with the Internet gateways.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the Internet gateways.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the Internet gateways, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// LinkVpcIds The IDs of the Vpcs the Internet gateways are attached to.
	LinkVpcIds *[]string `form:"linkVpcIds,omitempty" json:"linkVpcIds,omitempty"`

	// Ids The IDs of the Internet gateways.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`
}

// ReadKeypairsParams defines parameters for ReadKeypairs.
type ReadKeypairsParams struct {
	// KeypairFingerprints The fingerprints of the keypairs.
	KeypairFingerprints *[]string `form:"keypairFingerprints,omitempty" json:"keypairFingerprints,omitempty"`

	// KeypairNames The names of the keypairs.
	KeypairNames *[]string `form:"keypairNames,omitempty" json:"keypairNames,omitempty"`

	// KeypairTypes The types of the keypairs (`ssh-rsa`, `ssh-ed25519`, `ecdsa-sha2-nistp256`, `ecdsa-sha2-nistp384`, or `ecdsa-sha2-nistp521`).
	KeypairTypes *[]string `form:"keypairTypes,omitempty" json:"keypairTypes,omitempty"`
}

// ReadListenerRulesParams defines parameters for ReadListenerRules.
type ReadListenerRulesParams struct {
	// ListenerRuleNames The names of the listener rules.
	ListenerRuleNames *[]string `form:"listenerRuleNames,omitempty" json:"listenerRuleNames,omitempty"`
}

// ReadLoadBalancersParams defines parameters for ReadLoadBalancers.
type ReadLoadBalancersParams struct {
	// LoadBalancerNames The names of the load balancers.
	LoadBalancerNames *[]string `form:"loadBalancerNames,omitempty" json:"loadBalancerNames,omitempty"`
}

// ReadVmsHealthJSONBody defines parameters for ReadVmsHealth.
type ReadVmsHealthJSONBody struct {
	// BackendVmIds One or more IDs of back-end VMs.
	BackendVmIds *[]string `json:"backendVmIds,omitempty"`
}

// ReadLoadBalancerTagsJSONBody defines parameters for ReadLoadBalancerTags.
type ReadLoadBalancerTagsJSONBody struct {
	// Names One or more load balancer names.
	Names []string `json:"names"`
}

// ReadNatGatewayParams defines parameters for ReadNatGateway.
type ReadNatGatewayParams struct {
	// States The states of the NAT gateways (`pending` \| `available` \| `deleting` \| `deleted`).
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// SubnetIds The IDs of the Subnets in which the NAT gateways are.
	SubnetIds *[]string `form:"subnetIds,omitempty" json:"subnetIds,omitempty"`

	// TagKeys The keys of the tags associated with the NAT gateways.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the NAT gateways.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the NAT gateways, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// Ids The IDs of the NAT gateways.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`

	// VpcIds The IDs of the Vpcs in which the NAT gateways are.
	VpcIds *[]string `form:"vpcIds,omitempty" json:"vpcIds,omitempty"`
}

// ReadNicsParams defines parameters for ReadNics.
type ReadNicsParams struct {
	// Descriptions The descriptions of the NICs.
	Descriptions *[]string `form:"descriptions,omitempty" json:"descriptions,omitempty"`

	// IsSourceDestCheck Whether the source/destination checking is enabled (true) or disabled (false).
	IsSourceDestCheck *bool `form:"isSourceDestCheck,omitempty" json:"isSourceDestCheck,omitempty"`

	// LinkNicDeleteOnVmDeletion Whether the NICs are deleted when the VMs they are attached to are terminated.
	LinkNicDeleteOnVmDeletion *bool `form:"linkNicDeleteOnVmDeletion,omitempty" json:"linkNicDeleteOnVmDeletion,omitempty"`

	// LinkNicDeviceNumbers The device numbers the NICs are attached to.
	LinkNicDeviceNumbers *[]int `form:"linkNicDeviceNumbers,omitempty" json:"linkNicDeviceNumbers,omitempty"`

	// LinkNicLinkNicIds The attachment IDs of the NICs.
	LinkNicLinkNicIds *[]string `form:"linkNicLinkNicIds,omitempty" json:"linkNicLinkNicIds,omitempty"`

	// LinkNicStates The states of the attachments.
	LinkNicStates *[]string `form:"linkNicStates,omitempty" json:"linkNicStates,omitempty"`

	// LinkNicVmIds The IDs of the VMs the NICs are attached to.
	LinkNicVmIds *[]string `form:"linkNicVmIds,omitempty" json:"linkNicVmIds,omitempty"`

	// LinkPublicIpLinkPublicIpIds The association IDs returned when the public IPs were associated with the NICs.
	LinkPublicIpLinkPublicIpIds *[]string `form:"linkPublicIpLinkPublicIpIds,omitempty" json:"linkPublicIpLinkPublicIpIds,omitempty"`

	// LinkPublicIpPublicIpIds The allocation IDs returned when the public IPs were allocated to their accounts.
	LinkPublicIpPublicIpIds *[]string `form:"linkPublicIpPublicIpIds,omitempty" json:"linkPublicIpPublicIpIds,omitempty"`

	// LinkPublicIpPublicIps The public IPs associated with the NICs.
	LinkPublicIpPublicIps *[]string `form:"linkPublicIpPublicIps,omitempty" json:"linkPublicIpPublicIps,omitempty"`

	// MacAddresses The Media Access Control (MAC) addresses of the NICs.
	MacAddresses *[]string `form:"macAddresses,omitempty" json:"macAddresses,omitempty"`

	// PrivateDnsNames The private DNS names associated with the primary private IPs.
	PrivateDnsNames *[]string `form:"privateDnsNames,omitempty" json:"privateDnsNames,omitempty"`

	// PrivateIpsLinkPublicIpPublicIps The public IPs associated with the private IPs.
	PrivateIpsLinkPublicIpPublicIps *[]string `form:"privateIpsLinkPublicIpPublicIps,omitempty" json:"privateIpsLinkPublicIpPublicIps,omitempty"`

	// PrivateIpsPrimaryIp Whether the private IP is the primary IP associated with the NIC.
	PrivateIpsPrimaryIp *bool `form:"privateIpsPrimaryIp,omitempty" json:"privateIpsPrimaryIp,omitempty"`

	// PrivateIpsPrivateIps The private IPs of the NICs.
	PrivateIpsPrivateIps *[]string `form:"privateIpsPrivateIps,omitempty" json:"privateIpsPrivateIps,omitempty"`

	// SecurityGroupIds The IDs of the security groups associated with the NICs.
	SecurityGroupIds *[]string `form:"securityGroupIds,omitempty" json:"securityGroupIds,omitempty"`

	// SecurityGroupNames The names of the security groups associated with the NICs.
	SecurityGroupNames *[]string `form:"securityGroupNames,omitempty" json:"securityGroupNames,omitempty"`

	// States The states of the NICs.
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// SubnetIds The IDs of the Subnets for the NICs.
	SubnetIds *[]string `form:"subnetIds,omitempty" json:"subnetIds,omitempty"`

	// TagKeys The keys of the tags associated with the NICs.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the NICs.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the NICs, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// VpcIds The IDs of the Vpcs where the NICs are located.
	VpcIds *[]string `form:"vpcIds,omitempty" json:"vpcIds,omitempty"`

	// Ids The IDs of the NICs.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`

	// AvailabilityZoneNames The Subregions where the NICs are located.
	AvailabilityZoneNames *[]string `form:"availabilityZoneNames,omitempty" json:"availabilityZoneNames,omitempty"`
}

// LinkNicJSONBody defines parameters for LinkNic.
type LinkNicJSONBody struct {
	// DeviceNumber The index of the VM device for the NIC attachment (between `1` and `7`, both included).
	DeviceNumber int `json:"deviceNumber"`

	// VmId The ID of the VM to which you want to attach the NIC.
	VmId string `json:"vmId"`
}

// ReadPublicIpsParams defines parameters for ReadPublicIps.
type ReadPublicIpsParams struct {
	// LinkPublicIpIds The IDs representing the associations of public IPs with VMs or NICs.
	LinkPublicIpIds *[]string `form:"linkPublicIpIds,omitempty" json:"linkPublicIpIds,omitempty"`

	// NicIds The IDs of the NICs.
	NicIds *[]string `form:"nicIds,omitempty" json:"nicIds,omitempty"`

	// PrivateIps The private IPs associated with the public IPs.
	PrivateIps *[]string `form:"privateIps,omitempty" json:"privateIps,omitempty"`

	// TagKeys The keys of the tags associated with the public IPs.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the public IPs.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the public IPs, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// VmIds The IDs of the VMs.
	VmIds *[]string `form:"vmIds,omitempty" json:"vmIds,omitempty"`

	// Ids The IDs of the public IPs.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`
}

// LinkPublicIpJSONBody defines parameters for LinkPublicIp.
type LinkPublicIpJSONBody struct {
	// AllowRelink If true, allows the public IP to be associated with the VM or NIC that you specify even if it is already associated with another VM or NIC. If false, prevents the public IP from being associated with the VM or NIC that you specify if it is already associated with another VM or NIC. (By default, true in the public Cloud, false in a Vpc.)
	AllowRelink *bool `json:"allowRelink,omitempty"`

	// NicId (Vpc only) The ID of the NIC. This parameter is required if the VM has more than one NIC attached. Otherwise, you need to specify the `VmId` parameter instead. You cannot specify both parameters at the same time.
	NicId *string `json:"nicId,omitempty"`

	// PrivateIp (Vpc only) The primary or secondary private IP of the specified NIC. By default, the primary private IP.
	PrivateIp *string `json:"privateIp,omitempty"`

	// VmId The ID of the VM.<br />
	// - In the public Cloud, this parameter is required.<br />
	// - In a Vpc, this parameter is required if the VM has only one NIC. Otherwise, you need to specify the `NicId` parameter instead. You cannot specify both parameters at the same time.
	VmId *string `json:"vmId,omitempty"`
}

// ReadRouteTablesParams defines parameters for ReadRouteTables.
type ReadRouteTablesParams struct {
	// LinkRouteTableIds The IDs of the route tables involved in the associations.
	LinkRouteTableIds *[]string `form:"linkRouteTableIds,omitempty" json:"linkRouteTableIds,omitempty"`

	// LinkRouteTableLinkRouteTableIds The IDs of the associations between the route tables and the Subnets.
	LinkRouteTableLinkRouteTableIds *[]string `form:"linkRouteTableLinkRouteTableIds,omitempty" json:"linkRouteTableLinkRouteTableIds,omitempty"`

	// LinkRouteTableMain If true, the route tables are the main ones for their Vpcs.
	LinkRouteTableMain *bool `form:"linkRouteTableMain,omitempty" json:"linkRouteTableMain,omitempty"`

	// LinkSubnetIds The IDs of the Subnets involved in the associations.
	LinkSubnetIds *[]string `form:"linkSubnetIds,omitempty" json:"linkSubnetIds,omitempty"`

	// RouteCreationMethods The methods used to create a route.
	RouteCreationMethods *[]string `form:"routeCreationMethods,omitempty" json:"routeCreationMethods,omitempty"`

	// RouteDestinationIpRanges The IP ranges specified in routes in the tables.
	RouteDestinationIpRanges *[]string `form:"routeDestinationIpRanges,omitempty" json:"routeDestinationIpRanges,omitempty"`

	// RouteDestinationServiceIds The service IDs specified in routes in the tables.
	RouteDestinationServiceIds *[]string `form:"routeDestinationServiceIds,omitempty" json:"routeDestinationServiceIds,omitempty"`

	// RouteGatewayIds The IDs of the gateways specified in routes in the tables.
	RouteGatewayIds *[]string `form:"routeGatewayIds,omitempty" json:"routeGatewayIds,omitempty"`

	// RouteStates The states of routes in the route tables (always `active`).
	RouteStates *[]string `form:"routeStates,omitempty" json:"routeStates,omitempty"`

	// RouteVmIds The IDs of the VMs specified in routes in the tables.
	RouteVmIds *[]string `form:"routeVmIds,omitempty" json:"routeVmIds,omitempty"`

	// TagKeys The keys of the tags associated with the route tables.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the route tables.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the route tables, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// VpcIds The IDs of the Vpcs for the route tables.
	VpcIds *[]string `form:"vpcIds,omitempty" json:"vpcIds,omitempty"`

	// RouteNatGatewayIds The IDs of the NAT gateways specified in routes in the tables.
	RouteNatGatewayIds *[]string `form:"routeNatGatewayIds,omitempty" json:"routeNatGatewayIds,omitempty"`

	// RouteVpcPeeringIds The IDs of the Vpc peerings specified in routes in the tables.
	RouteVpcPeeringIds *[]string `form:"routeVpcPeeringIds,omitempty" json:"routeVpcPeeringIds,omitempty"`

	// Ids The IDs of the route tables.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`
}

// LinkRouteTableJSONBody defines parameters for LinkRouteTable.
type LinkRouteTableJSONBody struct {
	// SubnetId The ID of the Subnet.
	SubnetId string `json:"subnetId"`
}

// ReadSecurityGroupsParams defines parameters for ReadSecurityGroups.
type ReadSecurityGroupsParams struct {
	// Descriptions The descriptions of the security groups.
	Descriptions *[]string `form:"descriptions,omitempty" json:"descriptions,omitempty"`

	// InboundRuleFromPortRanges The beginnings of the port ranges for the TCP and UDP protocols, or the ICMP type numbers.
	InboundRuleFromPortRanges *[]int `form:"inboundRuleFromPortRanges,omitempty" json:"inboundRuleFromPortRanges,omitempty"`

	// InboundRuleIpRanges The IP ranges that have been granted permissions, in CIDR notation (for example, `10.0.0.0/24`).
	InboundRuleIpRanges *[]string `form:"inboundRuleIpRanges,omitempty" json:"inboundRuleIpRanges,omitempty"`

	// InboundRuleProtocols The IP protocols for the permissions (`tcp` \| `udp` \| `icmp`, or a protocol number, or `-1` for all protocols).
	InboundRuleProtocols *[]string `form:"inboundRuleProtocols,omitempty" json:"inboundRuleProtocols,omitempty"`

	// InboundRuleSecurityGroupIds The IDs of the security groups that have been granted permissions.
	InboundRuleSecurityGroupIds *[]string `form:"inboundRuleSecurityGroupIds,omitempty" json:"inboundRuleSecurityGroupIds,omitempty"`

	// InboundRuleSecurityGroupNames The names of the security groups that have been granted permissions.
	InboundRuleSecurityGroupNames *[]string `form:"inboundRuleSecurityGroupNames,omitempty" json:"inboundRuleSecurityGroupNames,omitempty"`

	// InboundRuleToPortRanges The ends of the port ranges for the TCP and UDP protocols, or the ICMP code numbers.
	InboundRuleToPortRanges *[]int `form:"inboundRuleToPortRanges,omitempty" json:"inboundRuleToPortRanges,omitempty"`

	// OutboundRuleFromPortRanges The beginnings of the port ranges for the TCP and UDP protocols, or the ICMP type numbers.
	OutboundRuleFromPortRanges *[]int `form:"outboundRuleFromPortRanges,omitempty" json:"outboundRuleFromPortRanges,omitempty"`

	// OutboundRuleIpRanges The IP ranges that have been granted permissions, in CIDR notation (for example, `10.0.0.0/24`).
	OutboundRuleIpRanges *[]string `form:"outboundRuleIpRanges,omitempty" json:"outboundRuleIpRanges,omitempty"`

	// OutboundRuleProtocols The IP protocols for the permissions (`tcp` \| `udp` \| `icmp`, or a protocol number, or `-1` for all protocols).
	OutboundRuleProtocols *[]string `form:"outboundRuleProtocols,omitempty" json:"outboundRuleProtocols,omitempty"`

	// OutboundRuleSecurityGroupIds The IDs of the security groups that have been granted permissions.
	OutboundRuleSecurityGroupIds *[]string `form:"outboundRuleSecurityGroupIds,omitempty" json:"outboundRuleSecurityGroupIds,omitempty"`

	// OutboundRuleSecurityGroupNames The names of the security groups that have been granted permissions.
	OutboundRuleSecurityGroupNames *[]string `form:"outboundRuleSecurityGroupNames,omitempty" json:"outboundRuleSecurityGroupNames,omitempty"`

	// OutboundRuleToPortRanges The ends of the port ranges for the TCP and UDP protocols, or the ICMP code numbers.
	OutboundRuleToPortRanges *[]int `form:"outboundRuleToPortRanges,omitempty" json:"outboundRuleToPortRanges,omitempty"`

	// SecurityGroupIds The IDs of the security groups.
	SecurityGroupIds *[]string `form:"securityGroupIds,omitempty" json:"securityGroupIds,omitempty"`

	// SecurityGroupNames The names of the security groups.
	SecurityGroupNames *[]string `form:"securityGroupNames,omitempty" json:"securityGroupNames,omitempty"`

	// TagKeys The keys of the tags associated with the security groups.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the security groups.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the security groups, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// VpcIds The IDs of the Vpcs specified when the security groups were created.
	VpcIds *[]string `form:"vpcIds,omitempty" json:"vpcIds,omitempty"`
}

// ReadServerCertificatesParams defines parameters for ReadServerCertificates.
type ReadServerCertificatesParams struct {
	// Paths The paths to the server certificates.
	Paths *[]string `form:"paths,omitempty" json:"paths,omitempty"`
}

// ReadSnapshotsParams defines parameters for ReadSnapshots.
type ReadSnapshotsParams struct {
	// Descriptions The descriptions of the snapshots.
	Descriptions *[]string `form:"descriptions,omitempty" json:"descriptions,omitempty"`

	// FromCreationDate The beginning of the time period, in ISO 8601 date-time format (for example, `2020-06-14T00:00:00.000Z`).
	FromCreationDate *string `form:"fromCreationDate,omitempty" json:"fromCreationDate,omitempty"`

	// Progresses The progresses of the snapshots, as a percentage.
	Progresses *[]int `form:"progresses,omitempty" json:"progresses,omitempty"`

	// States The states of the snapshots (`in-queue` \| `completed` \| `error`).
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// TagKeys The keys of the tags associated with the snapshots.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the snapshots.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the snapshots, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// ToCreationDate The end of the time period, in ISO 8601 date-time format (for example, `2020-06-30T00:00:00.000Z`).
	ToCreationDate *string `form:"toCreationDate,omitempty" json:"toCreationDate,omitempty"`

	// VolumeIds The IDs of the volumes used to create the snapshots.
	VolumeIds *[]string `form:"volumeIds,omitempty" json:"volumeIds,omitempty"`

	// VolumeSizes The sizes of the volumes used to create the snapshots, in gibibytes (GiB).
	VolumeSizes *[]int `form:"volumeSizes,omitempty" json:"volumeSizes,omitempty"`

	// IsPublic If true, lists all public volumes. If false, lists all private volumes.
	IsPublic *bool `form:"isPublic,omitempty" json:"isPublic,omitempty"`

	// Ids The IDs of the snapshots.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`
}

// ReadSubnetsParams defines parameters for ReadSubnets.
type ReadSubnetsParams struct {
	// AvailableIpsCounts The number of available IPs.
	AvailableIpsCounts *[]int `form:"availableIpsCounts,omitempty" json:"availableIpsCounts,omitempty"`

	// IpRanges The IP ranges in the Subnets, in CIDR notation (for example, `10.0.0.0/16`).
	IpRanges *[]string `form:"ipRanges,omitempty" json:"ipRanges,omitempty"`

	// States The states of the Subnets (`pending` \| `available` \| `deleted`).
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// TagKeys The keys of the tags associated with the Subnets.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the Subnets.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the Subnets, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// VpcIds The IDs of the Vpcs in which the Subnets are.
	VpcIds *[]string `form:"vpcIds,omitempty" json:"vpcIds,omitempty"`

	// Ids The IDs of the Subnets.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`

	// AvailabilityZoneNames The names of the Subregions in which the Subnets are located.
	AvailabilityZoneNames *[]string `form:"availabilityZoneNames,omitempty" json:"availabilityZoneNames,omitempty"`
}

// ReadTagsParams defines parameters for ReadTags.
type ReadTagsParams struct {
	// Keys The keys of the tags that are assigned to the resources. You can use this filter alongside the `Values` filter. In that case, you filter the resources corresponding to each tag, regardless of the other filter.
	Keys *[]string `form:"keys,omitempty" json:"keys,omitempty"`

	// ResourceIds The IDs of the resources with which the tags are associated.
	ResourceIds *[]string `form:"resourceIds,omitempty" json:"resourceIds,omitempty"`

	// ResourceTypes The resource type (`vm` \| `image` \| `volume` \| `snapshot` \| `public-ip` \| `security-group` \| `route-table` \| `nic` \| `vpc` \| `subnet` \| `vpc-peering` \| `vpc-access-point` \| `nat-gateway` \| `internet-gateway` \| `client-gateway` \| `virtual-gateway` \| `vpn-connection` \| `dhcp-options` \| `task`).
	ResourceTypes *[]string `form:"resourceTypes,omitempty" json:"resourceTypes,omitempty"`

	// Values The values of the tags that are assigned to the resources. You can use this filter alongside the `TagKeys` filter. In that case, you filter the resources corresponding to each tag, regardless of the other filter.
	Values *[]string `form:"values,omitempty" json:"values,omitempty"`
}

// ReadVmsParams defines parameters for ReadVms.
type ReadVmsParams struct {
	// Architectures The architectures of the VMs (`i386` \| `x86_64`).
	Architectures *[]string `form:"architectures,omitempty" json:"architectures,omitempty"`

	// BlockDeviceMappingDeleteOnVmDeletion Whether the BSU volumes are deleted when terminating the VMs.
	BlockDeviceMappingDeleteOnVmDeletion *bool `form:"blockDeviceMappingDeleteOnVmDeletion,omitempty" json:"blockDeviceMappingDeleteOnVmDeletion,omitempty"`

	// BlockDeviceMappingDeviceNames The device names for the BSU volumes (in the format `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX`).
	BlockDeviceMappingDeviceNames *[]string `form:"blockDeviceMappingDeviceNames,omitempty" json:"blockDeviceMappingDeviceNames,omitempty"`

	// BlockDeviceMappingLinkDates The link dates for the BSU volumes mapped to the VMs (for example, `2016-01-23T18:45:30.000Z`).
	BlockDeviceMappingLinkDates *[]ReadVmsParams_BlockDeviceMappingLinkDates_Item `form:"blockDeviceMappingLinkDates,omitempty" json:"blockDeviceMappingLinkDates,omitempty"`

	// BlockDeviceMappingStates The states for the BSU volumes (`attaching` \| `attached` \| `detaching` \| `detached`).
	BlockDeviceMappingStates *[]string `form:"blockDeviceMappingStates,omitempty" json:"blockDeviceMappingStates,omitempty"`

	// BlockDeviceMappingVolumeIds The volume IDs of the BSU volumes.
	BlockDeviceMappingVolumeIds *[]string `form:"blockDeviceMappingVolumeIds,omitempty" json:"blockDeviceMappingVolumeIds,omitempty"`

	// ClientTokens The idempotency tokens provided when launching the VMs.
	ClientTokens *[]string `form:"clientTokens,omitempty" json:"clientTokens,omitempty"`

	// CreationDates The dates when the VMs were launched.
	CreationDates *[]ReadVmsParams_CreationDates_Item `form:"creationDates,omitempty" json:"creationDates,omitempty"`

	// ImageIds The IDs of the OMIs used to launch the VMs.
	ImageIds *[]string `form:"imageIds,omitempty" json:"imageIds,omitempty"`

	// IsSourceDestChecked Whether the source/destination checking is enabled (true) or disabled (false).
	IsSourceDestChecked *bool `form:"isSourceDestChecked,omitempty" json:"isSourceDestChecked,omitempty"`

	// KeypairNames The names of the keypairs used when launching the VMs.
	KeypairNames *[]string `form:"keypairNames,omitempty" json:"keypairNames,omitempty"`

	// LaunchNumbers The numbers for the VMs when launching a group of several VMs (for example, `0`, `1`, `2`, and so on).
	LaunchNumbers *[]int `form:"launchNumbers,omitempty" json:"launchNumbers,omitempty"`

	// Lifecycles Whether the VMs are Spot Instances (spot).
	Lifecycles *[]string `form:"lifecycles,omitempty" json:"lifecycles,omitempty"`

	// NicDescriptions The descriptions of the NICs.
	NicDescriptions *[]string `form:"nicDescriptions,omitempty" json:"nicDescriptions,omitempty"`

	// NicIsSourceDestChecked Whether the source/destination checking is enabled (true) or disabled (false).
	NicIsSourceDestChecked *bool `form:"nicIsSourceDestChecked,omitempty" json:"nicIsSourceDestChecked,omitempty"`

	// NicLinkNicDeleteOnVmDeletion Whether the NICs are deleted when the VMs they are attached to are deleted.
	NicLinkNicDeleteOnVmDeletion *bool `form:"nicLinkNicDeleteOnVmDeletion,omitempty" json:"nicLinkNicDeleteOnVmDeletion,omitempty"`

	// NicLinkNicDeviceNumbers The device numbers the NICs are attached to.
	NicLinkNicDeviceNumbers *[]int `form:"nicLinkNicDeviceNumbers,omitempty" json:"nicLinkNicDeviceNumbers,omitempty"`

	// NicLinkNicLinkNicDates The dates and time when the NICs were attached to the VMs.
	NicLinkNicLinkNicDates *[]ReadVmsParams_NicLinkNicLinkNicDates_Item `form:"nicLinkNicLinkNicDates,omitempty" json:"nicLinkNicLinkNicDates,omitempty"`

	// NicLinkNicLinkNicIds The IDs of the NIC attachments.
	NicLinkNicLinkNicIds *[]string `form:"nicLinkNicLinkNicIds,omitempty" json:"nicLinkNicLinkNicIds,omitempty"`

	// NicLinkNicStates The states of the attachments.
	NicLinkNicStates *[]string `form:"nicLinkNicStates,omitempty" json:"nicLinkNicStates,omitempty"`

	// NicLinkNicVmIds The IDs of the VMs the NICs are attached to.
	NicLinkNicVmIds *[]string `form:"nicLinkNicVmIds,omitempty" json:"nicLinkNicVmIds,omitempty"`

	// NicLinkPublicIpLinkPublicIpIds The association IDs returned when the public IPs were associated with the NICs.
	NicLinkPublicIpLinkPublicIpIds *[]string `form:"nicLinkPublicIpLinkPublicIpIds,omitempty" json:"nicLinkPublicIpLinkPublicIpIds,omitempty"`

	// NicLinkPublicIpPublicIpIds The allocation IDs returned when the public IPs were allocated to their accounts.
	NicLinkPublicIpPublicIpIds *[]string `form:"nicLinkPublicIpPublicIpIds,omitempty" json:"nicLinkPublicIpPublicIpIds,omitempty"`

	// NicLinkPublicIpPublicIps The public IPs associated with the NICs.
	NicLinkPublicIpPublicIps *[]string `form:"nicLinkPublicIpPublicIps,omitempty" json:"nicLinkPublicIpPublicIps,omitempty"`

	// NicMacAddresses The Media Access Control (MAC) addresses of the NICs.
	NicMacAddresses *[]string `form:"nicMacAddresses,omitempty" json:"nicMacAddresses,omitempty"`

	// NicNicIds The IDs of the NICs.
	NicNicIds *[]string `form:"nicNicIds,omitempty" json:"nicNicIds,omitempty"`

	// NicPrivateIpsLinkPublicIpIds The public IPs associated with the private IPs.
	NicPrivateIpsLinkPublicIpIds *[]string `form:"nicPrivateIpsLinkPublicIpIds,omitempty" json:"nicPrivateIpsLinkPublicIpIds,omitempty"`

	// NicPrivateIpsPrimaryIp Whether the private IPs are the primary IPs associated with the NICs.
	NicPrivateIpsPrimaryIp *bool `form:"nicPrivateIpsPrimaryIp,omitempty" json:"nicPrivateIpsPrimaryIp,omitempty"`

	// NicPrivateIpsPrivateIps The private IPs of the NICs.
	NicPrivateIpsPrivateIps *[]string `form:"nicPrivateIpsPrivateIps,omitempty" json:"nicPrivateIpsPrivateIps,omitempty"`

	// NicSecurityGroupIds The IDs of the security groups associated with the NICs.
	NicSecurityGroupIds *[]string `form:"nicSecurityGroupIds,omitempty" json:"nicSecurityGroupIds,omitempty"`

	// NicSecurityGroupNames The names of the security groups associated with the NICs.
	NicSecurityGroupNames *[]string `form:"nicSecurityGroupNames,omitempty" json:"nicSecurityGroupNames,omitempty"`

	// NicStates The states of the NICs (`available` \| `in-use`).
	NicStates *[]string `form:"nicStates,omitempty" json:"nicStates,omitempty"`

	// NicSubnetIds The IDs of the Subnets for the NICs.
	NicSubnetIds *[]string `form:"nicSubnetIds,omitempty" json:"nicSubnetIds,omitempty"`

	// Platforms The platforms. Use windows if you have Windows VMs. Otherwise, leave this filter blank.
	Platforms *[]string `form:"platforms,omitempty" json:"platforms,omitempty"`

	// PrivateIps The private IPs of the VMs.
	PrivateIps *[]string `form:"privateIps,omitempty" json:"privateIps,omitempty"`

	// ProductCodes The product codes associated with the Image used to create the VMs.
	ProductCodes *[]string `form:"productCodes,omitempty" json:"productCodes,omitempty"`

	// PublicIps The public IPs of the VMs.
	PublicIps *[]string `form:"publicIps,omitempty" json:"publicIps,omitempty"`

	// ReservationIds The IDs of the reservation of the VMs, created every time you launch VMs. These reservation IDs can be associated with several VMs when you lauch a group of VMs using the same launch request.
	ReservationIds *[]string `form:"reservationIds,omitempty" json:"reservationIds,omitempty"`

	// RootDeviceNames The names of the root devices for the VMs (for example, `/dev/sda1`)
	RootDeviceNames *[]string `form:"rootDeviceNames,omitempty" json:"rootDeviceNames,omitempty"`

	// RootDeviceTypes The root devices types used by the VMs (always `ebs`)
	RootDeviceTypes *[]string `form:"rootDeviceTypes,omitempty" json:"rootDeviceTypes,omitempty"`

	// SecurityGroupIds The IDs of the security groups for the VMs (only in the public Cloud).
	SecurityGroupIds *[]string `form:"securityGroupIds,omitempty" json:"securityGroupIds,omitempty"`

	// SecurityGroupNames The names of the security groups for the VMs (only in the public Cloud).
	SecurityGroupNames *[]string `form:"securityGroupNames,omitempty" json:"securityGroupNames,omitempty"`

	// StateReasonCodes The reason codes for the state changes.
	StateReasonCodes *[]int `form:"stateReasonCodes,omitempty" json:"stateReasonCodes,omitempty"`

	// StateReasonMessages The messages describing the state changes.
	StateReasonMessages *[]string `form:"stateReasonMessages,omitempty" json:"stateReasonMessages,omitempty"`

	// StateReasons The reasons explaining the current states of the VMs. This filter is like the `StateReasonCodes` one.
	StateReasons *[]string `form:"stateReasons,omitempty" json:"stateReasons,omitempty"`

	// SubnetIds The IDs of the Subnets for the VMs.
	SubnetIds *[]string `form:"subnetIds,omitempty" json:"subnetIds,omitempty"`

	// TagKeys The keys of the tags associated with the VMs.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the VMs.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the VMs, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// Tenancies The tenancies of the VMs (`dedicated` \| `default` \| `host`).
	Tenancies *[]string `form:"tenancies,omitempty" json:"tenancies,omitempty"`

	// VmSecurityGroupIds The IDs of the security groups for the VMs.
	VmSecurityGroupIds *[]string `form:"vmSecurityGroupIds,omitempty" json:"vmSecurityGroupIds,omitempty"`

	// VmSecurityGroupNames The names of the security group for the VMs.
	VmSecurityGroupNames *[]string `form:"vmSecurityGroupNames,omitempty" json:"vmSecurityGroupNames,omitempty"`

	// VmStateCodes The state codes of the VMs: `-1` (quarantine), `0` (pending), `16` (running), `32` (shutting-down), `48` (terminated), `64` (stopping), and `80` (stopped).
	VmStateCodes *[]int `form:"vmStateCodes,omitempty" json:"vmStateCodes,omitempty"`

	// VmStateNames The state names of the VMs (`pending` \| `running` \| `stopping` \| `stopped` \| `shutting-down` \| `terminated` \| `quarantine`).
	VmStateNames *[]string `form:"vmStateNames,omitempty" json:"vmStateNames,omitempty"`

	// Types The NumSpot VM types.
	Types *[]string `form:"types,omitempty" json:"types,omitempty"`

	// VpcIds The IDs of the Vpcs in which the VMs are running.
	VpcIds *[]string `form:"vpcIds,omitempty" json:"vpcIds,omitempty"`

	// NicVpcIds The IDs of the Vpcs where the NICs are located.
	NicVpcIds *[]string `form:"nicVpcIds,omitempty" json:"nicVpcIds,omitempty"`

	// NicAvailabilityZoneNames The Subregions where the NICs are located.
	NicAvailabilityZoneNames *[]string `form:"nicAvailabilityZoneNames,omitempty" json:"nicAvailabilityZoneNames,omitempty"`

	// AvailabilityZoneNames The names of the Subregions of the VMs.
	AvailabilityZoneNames *[]string `form:"availabilityZoneNames,omitempty" json:"availabilityZoneNames,omitempty"`

	// Ids One or more IDs of VMs.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`
}

// ReadVmsParamsBlockDeviceMappingLinkDates0 defines parameters for ReadVms.
type ReadVmsParamsBlockDeviceMappingLinkDates0 = openapi_types.Date

// ReadVmsParamsBlockDeviceMappingLinkDates1 defines parameters for ReadVms.
type ReadVmsParamsBlockDeviceMappingLinkDates1 = time.Time

// ReadVmsParams_BlockDeviceMappingLinkDates_Item defines parameters for ReadVms.
type ReadVmsParams_BlockDeviceMappingLinkDates_Item struct {
	union json.RawMessage
}

// ReadVmsParamsCreationDates0 defines parameters for ReadVms.
type ReadVmsParamsCreationDates0 = openapi_types.Date

// ReadVmsParamsCreationDates1 defines parameters for ReadVms.
type ReadVmsParamsCreationDates1 = time.Time

// ReadVmsParams_CreationDates_Item defines parameters for ReadVms.
type ReadVmsParams_CreationDates_Item struct {
	union json.RawMessage
}

// ReadVmsParamsNicLinkNicLinkNicDates0 defines parameters for ReadVms.
type ReadVmsParamsNicLinkNicLinkNicDates0 = openapi_types.Date

// ReadVmsParamsNicLinkNicLinkNicDates1 defines parameters for ReadVms.
type ReadVmsParamsNicLinkNicLinkNicDates1 = time.Time

// ReadVmsParams_NicLinkNicLinkNicDates_Item defines parameters for ReadVms.
type ReadVmsParams_NicLinkNicLinkNicDates_Item struct {
	union json.RawMessage
}

// ReadVmsStateParams defines parameters for ReadVmsState.
type ReadVmsStateParams struct {
	// MaintenanceEventCodes The code for the scheduled event (`system-reboot` \| `system-maintenance`).
	MaintenanceEventCodes *[]string `form:"maintenanceEventCodes,omitempty" json:"maintenanceEventCodes,omitempty"`

	// MaintenanceEventDescriptions The description of the scheduled event.
	MaintenanceEventDescriptions *[]string `form:"maintenanceEventDescriptions,omitempty" json:"maintenanceEventDescriptions,omitempty"`

	// MaintenanceEventsNotAfter The latest time the event can end.
	MaintenanceEventsNotAfter *[]openapi_types.Date `form:"maintenanceEventsNotAfter,omitempty" json:"maintenanceEventsNotAfter,omitempty"`

	// MaintenanceEventsNotBefore The earliest time the event can start.
	MaintenanceEventsNotBefore *[]openapi_types.Date `form:"maintenanceEventsNotBefore,omitempty" json:"maintenanceEventsNotBefore,omitempty"`

	// VmStates The states of the VMs (`pending` \| `running` \| `stopping` \| `stopped` \| `shutting-down` \| `terminated` \| `quarantine`).
	VmStates *[]string `form:"vmStates,omitempty" json:"vmStates,omitempty"`

	// AvailabilityZoneNames The names of the Subregions of the VMs.
	AvailabilityZoneNames *[]string `form:"availabilityZoneNames,omitempty" json:"availabilityZoneNames,omitempty"`

	// Ids One or more IDs of VMs.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`
}

// ReadVolumesParams defines parameters for ReadVolumes.
type ReadVolumesParams struct {
	// CreationDates The dates and times of creation of the volumes, in ISO 8601 date-time format (for example, `2020-06-30T00:00:00.000Z`).
	CreationDates *[]time.Time `form:"creationDates,omitempty" json:"creationDates,omitempty"`

	// LinkVolumeDeleteOnVmDeletion Whether the volumes are deleted or not when terminating the VMs.
	LinkVolumeDeleteOnVmDeletion *bool `form:"linkVolumeDeleteOnVmDeletion,omitempty" json:"linkVolumeDeleteOnVmDeletion,omitempty"`

	// LinkVolumeDeviceNames The VM device names.
	LinkVolumeDeviceNames *[]string `form:"linkVolumeDeviceNames,omitempty" json:"linkVolumeDeviceNames,omitempty"`

	// LinkVolumeLinkDates The dates and times of creation of the volumes, in ISO 8601 date-time format (for example, `2020-06-30T00:00:00.000Z`).
	LinkVolumeLinkDates *[]time.Time `form:"linkVolumeLinkDates,omitempty" json:"linkVolumeLinkDates,omitempty"`

	// LinkVolumeLinkStates The attachment states of the volumes (`attaching` \| `detaching` \| `attached` \| `detached`).
	LinkVolumeLinkStates *[]string `form:"linkVolumeLinkStates,omitempty" json:"linkVolumeLinkStates,omitempty"`

	// LinkVolumeVmIds One or more IDs of VMs.
	LinkVolumeVmIds *[]string `form:"linkVolumeVmIds,omitempty" json:"linkVolumeVmIds,omitempty"`

	// SnapshotIds The snapshots from which the volumes were created.
	SnapshotIds *[]string `form:"snapshotIds,omitempty" json:"snapshotIds,omitempty"`

	// TagKeys The keys of the tags associated with the volumes.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the volumes.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the volumes, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// VolumeSizes The sizes of the volumes, in gibibytes (GiB).
	VolumeSizes *[]int `form:"volumeSizes,omitempty" json:"volumeSizes,omitempty"`

	// VolumeStates The states of the volumes (`creating` \| `available` \| `in-use` \| `updating` \| `deleting` \| `error`).
	VolumeStates *[]string `form:"volumeStates,omitempty" json:"volumeStates,omitempty"`

	// VolumeTypes The types of the volumes (`standard` \| `gp2` \| `io1`).
	VolumeTypes *[]string `form:"volumeTypes,omitempty" json:"volumeTypes,omitempty"`

	// AvailabilityZoneNames The names of the Subregions in which the volumes were created.
	AvailabilityZoneNames *[]string `form:"availabilityZoneNames,omitempty" json:"availabilityZoneNames,omitempty"`

	// Ids The IDs of the volumes.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`
}

// ReadVpcsParams defines parameters for ReadVpcs.
type ReadVpcsParams struct {
	// DhcpOptionsSetIds The IDs of the DHCP options sets.
	DhcpOptionsSetIds *[]string `form:"dhcpOptionsSetIds,omitempty" json:"dhcpOptionsSetIds,omitempty"`

	// IpRanges The IP ranges for the Vpcs, in CIDR notation (for example, `10.0.0.0/16`).
	IpRanges *[]string `form:"ipRanges,omitempty" json:"ipRanges,omitempty"`

	// IsDefault If true, the Vpc used is the default one.
	IsDefault *bool `form:"isDefault,omitempty" json:"isDefault,omitempty"`

	// States The states of the Vpcs (`pending` \| `available` \| `deleting`).
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// TagKeys The keys of the tags associated with the Vpcs.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the Vpcs.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the Vpcs, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// Ids The IDs of the Vpcs.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`
}

// ConsentParams defines parameters for Consent.
type ConsentParams struct {
	// ConsentChallenge token consent challenge
	ConsentChallenge ConsentChallenge `form:"consent_challenge" json:"consent_challenge"`
}

// GetFlowErrorParams defines parameters for GetFlowError.
type GetFlowErrorParams struct {
	// Id Error is the error's ID
	Id string `form:"id" json:"id"`
}

// UpdateLoginFlowParams defines parameters for UpdateLoginFlow.
type UpdateLoginFlowParams struct {
	// Flow The Login Flow ID
	// The value for this parameter comes from `flow` URL Query parameter sent to your application (`/login?flow=abcde`).
	Flow string `form:"flow" json:"flow"`

	// XSessionToken The Session Token of the Identity performing the settings flow.
	XSessionToken *string `json:"X-Session-Token,omitempty"`

	// Cookie HTTP Cookies
	// When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header
	// sent by the client to your server here. This ensures that CSRF and session cookies are respected.
	Cookie *string `json:"Cookie,omitempty"`
}

// CreateBrowserLoginFlowParams defines parameters for CreateBrowserLoginFlow.
type CreateBrowserLoginFlowParams struct {
	// Refresh Refresh a login session
	//
	// If set to true, this will refresh an existing login session by
	// asking the user to sign in again. This will reset the
	// authenticated_at time of the session.
	Refresh *bool `form:"refresh,omitempty" json:"refresh,omitempty"`

	// Aal Request a Specific AuthenticationMethod Assurance Level
	//
	// Use this parameter to upgrade an existing session's authenticator assurance level (AAL). This
	// allows you to ask for multi-factor authentication. When an identity sign in using e.g. username+password,
	// the AAL is 1. If you wish to "upgrade" the session's security by asking the user to perform TOTP / WebAuth/ ...
	// you would set this to "aal2".
	Aal *string `form:"aal,omitempty" json:"aal,omitempty"`

	// ReturnTo The URL to return the browser to after the flow was completed.
	ReturnTo *string `form:"return_to,omitempty" json:"return_to,omitempty"`

	// LoginChallenge The value for this parameter comes from `login_challenge` URL Query parameter sent to your application.
	LoginChallenge *string `form:"login_challenge,omitempty" json:"login_challenge,omitempty"`

	// Organization An optional organization ID that should be used for logging this user in.
	// This parameter is only effective in the  Network.
	Organization *string `form:"organization,omitempty" json:"organization,omitempty"`

	// Cookie HTTP Cookies
	//
	// When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header
	// sent by the client to your server here. This ensures that CSRF and session cookies are respected.
	Cookie *string `json:"Cookie,omitempty"`
}

// GetLoginFlowParams defines parameters for GetLoginFlow.
type GetLoginFlowParams struct {
	// Id The Login Flow ID
	//
	// The value for this parameter comes from `flow` URL Query parameter sent to your
	// application (e.g. `/login?flow=abcde`).
	Id string `form:"id" json:"id"`

	// Cookie HTTP Cookies
	// When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header
	// sent by the client to your server here. This ensures that CSRF and session cookies are respected.
	Cookie *string `json:"Cookie,omitempty"`
}

// UpdateLogoutFlowParams defines parameters for UpdateLogoutFlow.
type UpdateLogoutFlowParams struct {
	// Token A Valid Logout Token
	// If you do not have a logout token because you only have a session cookie,
	// call `/self-service/logout/browser` to generate a URL for this endpoint.
	Token *string `form:"token,omitempty" json:"token,omitempty"`

	// ReturnTo The URL to return to after the logout was completed.
	ReturnTo *string `form:"return_to,omitempty" json:"return_to,omitempty"`

	// Cookie HTTP Cookies
	//
	// When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header
	// sent by the client to your server here. This ensures that CSRF and session cookies are respected.
	Cookie *string `json:"Cookie,omitempty"`
}

// CreateBrowserLogoutFlowParams defines parameters for CreateBrowserLogoutFlow.
type CreateBrowserLogoutFlowParams struct {
	// ReturnTo Return to URL
	//
	// The URL to which the browser should be redirected to after the logout
	// has been performed.
	ReturnTo *string `form:"return_to,omitempty" json:"return_to,omitempty"`

	// Cookie HTTP Cookies
	//
	// If you call this endpoint from a backend, please include the
	// original Cookie header in the request.
	Cookie *string `json:"cookie,omitempty"`
}

// InitRecoveryFlowParams defines parameters for InitRecoveryFlow.
type InitRecoveryFlowParams struct {
	// Flow recovery flowId
	Flow string `form:"flow" json:"flow"`

	// Token Recovery Token
	// The recovery token which completes the recovery request. If the token
	// is invalid (e.g. expired) an error will be shown to the end-user.
	// This parameter is usually set in a link and not used by any direct API call.
	Token *string `form:"token,omitempty" json:"token,omitempty"`

	// Cookie HTTP Cookies
	// When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header
	// sent by the client to your server here. This ensures that CSRF and session cookies are respected.
	Cookie *string `json:"Cookie,omitempty"`
}

// UpdateRecoveryFlowParams defines parameters for UpdateRecoveryFlow.
type UpdateRecoveryFlowParams struct {
	// Flow The Recovery Flow ID
	//
	// The value for this parameter comes from `flow` URL Query parameter sent to your
	// application (e.g. `/recovery?flow=abcde`).
	Flow string `form:"flow" json:"flow"`

	// Token Recovery Token
	// The recovery token which completes the recovery request. If the token
	// is invalid (e.g. expired) an error will be shown to the end-user.
	// This parameter is usually set in a link and not used by any direct API call.
	Token *string `form:"token,omitempty" json:"token,omitempty"`

	// Cookie HTTP Cookies
	// When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header
	// sent by the client to your server here. This ensures that CSRF and session cookies are respected.
	Cookie *string `json:"Cookie,omitempty"`
}

// CreateBrowserRecoveryFlowParams defines parameters for CreateBrowserRecoveryFlow.
type CreateBrowserRecoveryFlowParams struct {
	// ReturnTo The URL to return the browser to after the flow was completed.
	ReturnTo *string `form:"return_to,omitempty" json:"return_to,omitempty"`
}

// GetRecoveryFlowParams defines parameters for GetRecoveryFlow.
type GetRecoveryFlowParams struct {
	// Id The Flow ID
	// The value for this parameter comes from `request` URL Query parameter sent to your application (`/recovery?flow=abcde`).
	Id string `form:"id" json:"id"`

	// Cookie HTTP Cookies
	//
	// When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header
	// sent by the client to your server here. This ensures that CSRF and session cookies are respected.
	Cookie *string `json:"Cookie,omitempty"`
}

// UpdateSettingsFloParams defines parameters for UpdateSettingsFlo.
type UpdateSettingsFloParams struct {
	// Flow The Settings Flow ID
	// The value for this parameter comes from `flow` URL Query parameter sent to your application (e.g. `/settings?flow=abcde`).
	Flow string `form:"flow" json:"flow"`

	// XSessionToken The Session Token of the Identity performing the settings flow.
	XSessionToken *string `json:"X-Session-Token,omitempty"`

	// Cookie HTTP Cookies
	//
	// When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header
	// sent by the client to your server here. This ensures that CSRF and session cookies are respected.
	Cookie *string `json:"Cookie,omitempty"`
}

// CreateBrowserSettingsFlowParams defines parameters for CreateBrowserSettingsFlow.
type CreateBrowserSettingsFlowParams struct {
	// ReturnTo The URL to return the browser to after the flow was completed.
	ReturnTo *string `form:"return_to,omitempty" json:"return_to,omitempty"`

	// Cookie HTTP Cookies
	// When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header
	// sent by the client to your server here. This ensures that CSRF and session cookies are respected.
	Cookie *string `json:"Cookie,omitempty"`
}

// GetSettingsFlowParams defines parameters for GetSettingsFlow.
type GetSettingsFlowParams struct {
	// Id ID is the Settings Flow ID
	//
	// The value for this parameter comes from `flow` URL Query parameter sent to your
	// application (e.g. `/settings?flow=abcde`).
	Id string `form:"id" json:"id"`

	// XSessionToken The Session Token
	//
	// When using the SDK in an app without a browser, please include the
	// session token here.
	XSessionToken *string `json:"X-Session-Token,omitempty"`

	// Cookie HTTP Cookies
	//
	// When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header
	// sent by the client to your server here. This ensures that CSRF and session cookies are respected.
	Cookie *string `json:"Cookie,omitempty"`
}

// ToSessionParams defines parameters for ToSession.
type ToSessionParams struct {
	// TokenizeAs Returns the session additionally as a token (such as a JWT). The value of this parameter has to be a valid, configured Session token template.
	TokenizeAs *string `form:"tokenize_as,omitempty" json:"tokenize_as,omitempty"`

	// XSessionToken Set the Session Token when calling from non-browser clients.
	XSessionToken *string `json:"X-Session-Token,omitempty"`

	// Cookie Set the Cookie Header. This is especially useful when calling this endpoint from a server-side application. In that
	// scenario you must include the HTTP Cookie Header which originally was included in the request to your server.
	// It is ok if more than one cookie are included here as all other cookies will be ignored.
	Cookie *string `json:"Cookie,omitempty"`
}

// ListOrganisationsIdentityParams defines parameters for ListOrganisationsIdentity.
type ListOrganisationsIdentityParams struct {
	// Page Paginated request
	Page *ListUserOrganisations `json:"page,omitempty"`
}

// SetIAMPolicyOrganisationJSONBody defines parameters for SetIAMPolicyOrganisation.
type SetIAMPolicyOrganisationJSONBody struct {
	Add    *IAMPolicy `json:"add,omitempty"`
	Delete *IAMPolicy `json:"delete,omitempty"`
}

// MatchServiceAccountOrganisationParams defines parameters for MatchServiceAccountOrganisation.
type MatchServiceAccountOrganisationParams struct {
	// ServiceAccountName Service account name
	ServiceAccountName ServiceAccountName `form:"serviceAccountName" json:"serviceAccountName"`

	// Authorization required authorization token
	Authorization RequiredAuthorization `json:"Authorization"`
}

// GetUserOrganisationByEmailParams defines parameters for GetUserOrganisationByEmail.
type GetUserOrganisationByEmailParams struct {
	// Email User email
	Email UserEmail `form:"email" json:"email"`

	// Authorization required authorization token
	Authorization RequiredAuthorization `json:"Authorization"`
}

// ListPermissionsOrganisationParams defines parameters for ListPermissionsOrganisation.
type ListPermissionsOrganisationParams struct {
	// Service service the permission is related to
	Service *Service `form:"service,omitempty" json:"service,omitempty"`

	// Resource resource the permission is related to
	Resource *Resource `form:"resource,omitempty" json:"resource,omitempty"`

	// Subresource subresource the permission is related to
	Subresource *SubResource `form:"subresource,omitempty" json:"subresource,omitempty"`

	// Action action the permission allows to perform
	Action *Action `form:"action,omitempty" json:"action,omitempty"`

	// Page Paginated request
	Page *ListPermissionsPage `json:"page,omitempty"`
}

// ListRolesOrganisationParams defines parameters for ListRolesOrganisation.
type ListRolesOrganisationParams struct {
	// Name Role name
	Name *RoleName `form:"name,omitempty" json:"name,omitempty"`

	// Page Paginated request
	Page *ListRolesPage `json:"page,omitempty"`
}

// GetRolePermissionsOrganisationParams defines parameters for GetRolePermissionsOrganisation.
type GetRolePermissionsOrganisationParams struct {
	// Page Paginated request
	Page *ListRolePermissionsPage `json:"page,omitempty"`
}

// ListServiceAccountOrganisationParams defines parameters for ListServiceAccountOrganisation.
type ListServiceAccountOrganisationParams struct {
	// Page Paginated request
	Page *ListServiceAccounts `json:"page,omitempty"`
}

// GetACLServiceAccountOrganisationParams defines parameters for GetACLServiceAccountOrganisation.
type GetACLServiceAccountOrganisationParams struct {
	// Page Paginated request
	Page        *ListPolicyPage `json:"page,omitempty"`
	Service     string          `form:"service" json:"service"`
	Resource    string          `form:"resource" json:"resource"`
	Subresource *string         `form:"subresource,omitempty" json:"subresource,omitempty"`
}

// ListSpacesOfServiceAccountParams defines parameters for ListSpacesOfServiceAccount.
type ListSpacesOfServiceAccountParams struct {
	// Page Paginated request
	Page *ListSpacesOfServiceAccount `json:"page,omitempty"`
}

// ListSpacesIdentityParams defines parameters for ListSpacesIdentity.
type ListSpacesIdentityParams struct {
	// Page Paginated request
	Page *ListSpacesIdentity `json:"page,omitempty"`
}

// ListUserOrganisationParams defines parameters for ListUserOrganisation.
type ListUserOrganisationParams struct {
	// Page Paginated request
	Page *ListUser `json:"page,omitempty"`
}

// GetACLUserOrganisationParams defines parameters for GetACLUserOrganisation.
type GetACLUserOrganisationParams struct {
	// Page Paginated request
	Page        *ListPolicyPage `json:"page,omitempty"`
	Service     string          `form:"service" json:"service"`
	Resource    string          `form:"resource" json:"resource"`
	Subresource *string         `form:"subresource,omitempty" json:"subresource,omitempty"`
}

// ListSpacesOfUserParams defines parameters for ListSpacesOfUser.
type ListSpacesOfUserParams struct {
	// Page Paginated request
	Page *ListSpacesOfUser `json:"page,omitempty"`
}

// RevokeParams defines parameters for Revoke.
type RevokeParams struct {
	// Authorization The client identifier.
	Authorization *Authorization `json:"Authorization,omitempty"`
}

// SetIAMPolicySpaceJSONBody defines parameters for SetIAMPolicySpace.
type SetIAMPolicySpaceJSONBody struct {
	Add    *IAMPolicy `json:"add,omitempty"`
	Delete *IAMPolicy `json:"delete,omitempty"`
}

// MatchServiceAccountSpaceParams defines parameters for MatchServiceAccountSpace.
type MatchServiceAccountSpaceParams struct {
	// ServiceAccountName Service account name
	ServiceAccountName ServiceAccountName `form:"serviceAccountName" json:"serviceAccountName"`

	// Authorization required authorization token
	Authorization RequiredAuthorization `json:"Authorization"`
}

// GetUserSpaceByEmailParams defines parameters for GetUserSpaceByEmail.
type GetUserSpaceByEmailParams struct {
	// Email User email
	Email UserEmail `form:"email" json:"email"`

	// Authorization required authorization token
	Authorization RequiredAuthorization `json:"Authorization"`
}

// ListPermissionsSpaceParams defines parameters for ListPermissionsSpace.
type ListPermissionsSpaceParams struct {
	// Service service the permission is related to
	Service *Service `form:"service,omitempty" json:"service,omitempty"`

	// Resource resource the permission is related to
	Resource *Resource `form:"resource,omitempty" json:"resource,omitempty"`

	// Subresource subresource the permission is related to
	Subresource *SubResource `form:"subresource,omitempty" json:"subresource,omitempty"`

	// Action action the permission allows to perform
	Action *Action `form:"action,omitempty" json:"action,omitempty"`

	// Page Paginated request
	Page *ListPermissionsPage `json:"page,omitempty"`
}

// ListRolesSpaceParams defines parameters for ListRolesSpace.
type ListRolesSpaceParams struct {
	// Name Role name
	Name *RoleName `form:"name,omitempty" json:"name,omitempty"`

	// Page Paginated request
	Page *ListRolesPage `json:"page,omitempty"`
}

// GetRolePermissionsSpaceParams defines parameters for GetRolePermissionsSpace.
type GetRolePermissionsSpaceParams struct {
	// Page Paginated request
	Page *ListRolePermissionsPage `json:"page,omitempty"`
}

// ListServiceAccountSpaceParams defines parameters for ListServiceAccountSpace.
type ListServiceAccountSpaceParams struct {
	// Page Paginated request
	Page *ListServiceAccounts `json:"page,omitempty"`
}

// GetACLServiceAccountSpaceParams defines parameters for GetACLServiceAccountSpace.
type GetACLServiceAccountSpaceParams struct {
	// Page Paginated request
	Page        *ListPolicyPage `json:"page,omitempty"`
	Service     string          `form:"service" json:"service"`
	Resource    string          `form:"resource" json:"resource"`
	Subresource *string         `form:"subresource,omitempty" json:"subresource,omitempty"`
}

// ListUserSpaceParams defines parameters for ListUserSpace.
type ListUserSpaceParams struct {
	// Page Paginated request
	Page *ListUser `json:"page,omitempty"`
}

// GetACLUserSpaceParams defines parameters for GetACLUserSpace.
type GetACLUserSpaceParams struct {
	// Page Paginated request
	Page        *ListPolicyPage `json:"page,omitempty"`
	Service     string          `form:"service" json:"service"`
	Resource    string          `form:"resource" json:"resource"`
	Subresource *string         `form:"subresource,omitempty" json:"subresource,omitempty"`
}

// TokenParams defines parameters for Token.
type TokenParams struct {
	// Authorization The client identifier.
	Authorization *Authorization `json:"Authorization,omitempty"`
}

// GetUserInfoParams defines parameters for GetUserInfo.
type GetUserInfoParams struct {
	// Authorization The client identifier.
	Authorization *Authorization `json:"Authorization,omitempty"`
}

// GetKubernetesOperationParams defines parameters for GetKubernetesOperation.
type GetKubernetesOperationParams struct {
	// Authorization required authorization token
	Authorization RequiredAuthorization `json:"Authorization"`
}

// ListClustersParams defines parameters for ListClusters.
type ListClustersParams struct {
	// Page Paginated request
	Page *OpenShiftPage `json:"page,omitempty"`
}

// ListOperationsParams defines parameters for ListOperations.
type ListOperationsParams struct {
	// Page Paginated request
	Page      *OpenShiftPage              `json:"page,omitempty"`
	Status    *OpenShiftOperationStatuses `form:"status,omitempty" json:"status,omitempty"`
	ClusterId *QueryClusterId             `form:"clusterId,omitempty" json:"clusterId,omitempty"`
}

// ListSpacesParams defines parameters for ListSpaces.
type ListSpacesParams struct {
	// Page list spaces paginated request
	Page *ListSpacesPage `json:"page,omitempty"`
}

// PostgreSQLListBackupsParams defines parameters for PostgreSQLListBackups.
type PostgreSQLListBackupsParams struct {
	// Tag Tag to filter on. Repeat to combine filters on several tags.
	Tag *PostgresTagsParameter `json:"tag,omitempty"`

	// Page A page configuration.
	Page *PostgresPageParameter `json:"page,omitempty"`
}

// PostgreSQLCreateClusterJSONBody defines parameters for PostgreSQLCreateCluster.
type PostgreSQLCreateClusterJSONBody struct {
	AllowedIpRanges PostgresAllowedIpRanges `json:"allowedIpRanges"`

	// AutomaticBackup Whether automatic backup is enabled for this cluster.
	AutomaticBackup *bool           `json:"automaticBackup"`
	Name            StrictSlugMax63 `json:"name"`

	// NodeConfiguration The configuration used to provision the cluster nodes.
	NodeConfiguration PostgresNodeConfiguration `json:"nodeConfiguration"`

	// SourceBackupId A backup unique identifier.
	SourceBackupId *PostgresBackupId `json:"sourceBackupId,omitempty"`

	// Tags Tags to identify resources
	Tags *PostgresTags `json:"tags,omitempty"`

	// User The name of the user with administration privileges on the cluster.
	User PostgresUser `json:"user"`

	// Volume The configuration for a data storage volume.
	Volume PostgresVolume `json:"volume"`
}

// PostgreSQLDeleteClusterJSONBody defines parameters for PostgreSQLDeleteCluster.
type PostgreSQLDeleteClusterJSONBody struct {
	// Backups What to do with existing backups, if any, of the cluster upon deleting it.
	Backups *PostgresBackupDeleteOption `json:"backups,omitempty"`
}

// PostgreSQLModifyClusterJSONBody defines parameters for PostgreSQLModifyCluster.
type PostgreSQLModifyClusterJSONBody struct {
	AllowedIpRanges *PostgresAllowedIpRanges `json:"allowedIpRanges,omitempty"`

	// AutomaticBackup Whether automatic backups are enabled for this cluster
	AutomaticBackup *PostgresClusterAutomaticBackup `json:"automaticBackup,omitempty"`

	// NodeConfiguration The configuration used to provision the cluster nodes.
	NodeConfiguration *PostgresNodeConfiguration `json:"nodeConfiguration,omitempty"`
}

// DeleteLoadBalancerTagsJSONRequestBody defines body for DeleteLoadBalancerTags for application/json ContentType.
type DeleteLoadBalancerTagsJSONRequestBody = DeleteLoadBalancerTags

// CreateLoadBalancerTagsJSONRequestBody defines body for CreateLoadBalancerTags for application/json ContentType.
type CreateLoadBalancerTagsJSONRequestBody = CreateLoadBalancerTags

// DeleteTagsJSONRequestBody defines body for DeleteTags for application/json ContentType.
type DeleteTagsJSONRequestBody = DeleteTags

// CreateTagsJSONRequestBody defines body for CreateTags for application/json ContentType.
type CreateTagsJSONRequestBody = CreateTags

// CreateDhcpOptionsJSONRequestBody defines body for CreateDhcpOptions for application/json ContentType.
type CreateDhcpOptionsJSONRequestBody = CreateDhcpOptions

// CreateFlexibleGpuJSONRequestBody defines body for CreateFlexibleGpu for application/json ContentType.
type CreateFlexibleGpuJSONRequestBody = CreateFlexibleGpu

// UpdateFlexibleGpuJSONRequestBody defines body for UpdateFlexibleGpu for application/json ContentType.
type UpdateFlexibleGpuJSONRequestBody = UpdateFlexibleGpu

// LinkFlexibleGpuJSONRequestBody defines body for LinkFlexibleGpu for application/json ContentType.
type LinkFlexibleGpuJSONRequestBody = LinkFlexibleGpu

// CreateImageJSONRequestBody defines body for CreateImage for application/json ContentType.
type CreateImageJSONRequestBody = CreateImage

// UpdateImageJSONRequestBody defines body for UpdateImage for application/json ContentType.
type UpdateImageJSONRequestBody = UpdateImage

// LinkInternetGatewayJSONRequestBody defines body for LinkInternetGateway for application/json ContentType.
type LinkInternetGatewayJSONRequestBody = LinkInternetGateway

// UnlinkInternetGatewayJSONRequestBody defines body for UnlinkInternetGateway for application/json ContentType.
type UnlinkInternetGatewayJSONRequestBody = UnlinkInternetGateway

// CreateKeypairJSONRequestBody defines body for CreateKeypair for application/json ContentType.
type CreateKeypairJSONRequestBody = CreateKeypairRequestSchema

// CreateListenerRuleJSONRequestBody defines body for CreateListenerRule for application/json ContentType.
type CreateListenerRuleJSONRequestBody = CreateListenerRule

// UpdateListenerRuleJSONRequestBody defines body for UpdateListenerRule for application/json ContentType.
type UpdateListenerRuleJSONRequestBody = UpdateListenerRule

// CreateLoadBalancerJSONRequestBody defines body for CreateLoadBalancer for application/json ContentType.
type CreateLoadBalancerJSONRequestBody = CreateLoadBalancer

// UpdateLoadBalancerJSONRequestBody defines body for UpdateLoadBalancer for application/json ContentType.
type UpdateLoadBalancerJSONRequestBody = UpdateLoadBalancer

// LinkLoadBalancerBackendMachinesJSONRequestBody defines body for LinkLoadBalancerBackendMachines for application/json ContentType.
type LinkLoadBalancerBackendMachinesJSONRequestBody = LinkLoadBalancerBackendMachines

// UnlinkLoadBalancerBackendMachinesJSONRequestBody defines body for UnlinkLoadBalancerBackendMachines for application/json ContentType.
type UnlinkLoadBalancerBackendMachinesJSONRequestBody = UnlinkLoadBalancerBackendMachines

// DeleteLoadBalancerListenersJSONRequestBody defines body for DeleteLoadBalancerListeners for application/json ContentType.
type DeleteLoadBalancerListenersJSONRequestBody = DeleteLoadBalancerListeners

// CreateLoadBalancerListenersJSONRequestBody defines body for CreateLoadBalancerListeners for application/json ContentType.
type CreateLoadBalancerListenersJSONRequestBody = CreateLoadBalancerListeners

// DeleteLoadBalancerPolicyJSONRequestBody defines body for DeleteLoadBalancerPolicy for application/json ContentType.
type DeleteLoadBalancerPolicyJSONRequestBody = DeleteLoadBalancerPolicy

// CreateLoadBalancerPolicyJSONRequestBody defines body for CreateLoadBalancerPolicy for application/json ContentType.
type CreateLoadBalancerPolicyJSONRequestBody = CreateLoadBalancerPolicy

// ReadVmsHealthJSONRequestBody defines body for ReadVmsHealth for application/json ContentType.
type ReadVmsHealthJSONRequestBody ReadVmsHealthJSONBody

// ReadLoadBalancerTagsJSONRequestBody defines body for ReadLoadBalancerTags for application/json ContentType.
type ReadLoadBalancerTagsJSONRequestBody ReadLoadBalancerTagsJSONBody

// CreateNatGatewayJSONRequestBody defines body for CreateNatGateway for application/json ContentType.
type CreateNatGatewayJSONRequestBody = CreateNatGateway

// CreateNicJSONRequestBody defines body for CreateNic for application/json ContentType.
type CreateNicJSONRequestBody = CreateNic

// UpdateNicJSONRequestBody defines body for UpdateNic for application/json ContentType.
type UpdateNicJSONRequestBody = UpdateNic

// LinkPrivateIpsJSONRequestBody defines body for LinkPrivateIps for application/json ContentType.
type LinkPrivateIpsJSONRequestBody = LinkPrivateIps

// UnlinkPrivateIpsJSONRequestBody defines body for UnlinkPrivateIps for application/json ContentType.
type UnlinkPrivateIpsJSONRequestBody = UnlinkPrivateIps

// LinkNicJSONRequestBody defines body for LinkNic for application/json ContentType.
type LinkNicJSONRequestBody LinkNicJSONBody

// UnlinkNicJSONRequestBody defines body for UnlinkNic for application/json ContentType.
type UnlinkNicJSONRequestBody = UnlinkNic

// LinkPublicIpJSONRequestBody defines body for LinkPublicIp for application/json ContentType.
type LinkPublicIpJSONRequestBody LinkPublicIpJSONBody

// UnlinkPublicIpJSONRequestBody defines body for UnlinkPublicIp for application/json ContentType.
type UnlinkPublicIpJSONRequestBody = UnlinkPublicIp

// CreateRouteTableJSONRequestBody defines body for CreateRouteTable for application/json ContentType.
type CreateRouteTableJSONRequestBody = CreateRouteTable

// UpdateRouteTableRoutePropagationJSONRequestBody defines body for UpdateRouteTableRoutePropagation for application/json ContentType.
type UpdateRouteTableRoutePropagationJSONRequestBody = UpdateRouteTableRoutePropagation

// DeleteRouteJSONRequestBody defines body for DeleteRoute for application/json ContentType.
type DeleteRouteJSONRequestBody = DeleteRoute

// CreateRouteJSONRequestBody defines body for CreateRoute for application/json ContentType.
type CreateRouteJSONRequestBody = CreateRoute

// UpdateRouteJSONRequestBody defines body for UpdateRoute for application/json ContentType.
type UpdateRouteJSONRequestBody = UpdateRoute

// LinkRouteTableJSONRequestBody defines body for LinkRouteTable for application/json ContentType.
type LinkRouteTableJSONRequestBody LinkRouteTableJSONBody

// UnlinkRouteTableJSONRequestBody defines body for UnlinkRouteTable for application/json ContentType.
type UnlinkRouteTableJSONRequestBody = UnlinkRouteTable

// CreateSecurityGroupJSONRequestBody defines body for CreateSecurityGroup for application/json ContentType.
type CreateSecurityGroupJSONRequestBody = CreateSecurityGroup

// DeleteSecurityGroupRuleJSONRequestBody defines body for DeleteSecurityGroupRule for application/json ContentType.
type DeleteSecurityGroupRuleJSONRequestBody = DeleteSecurityGroupRule

// CreateSecurityGroupRuleJSONRequestBody defines body for CreateSecurityGroupRule for application/json ContentType.
type CreateSecurityGroupRuleJSONRequestBody = CreateSecurityGroupRule

// CreateServerCertificateJSONRequestBody defines body for CreateServerCertificate for application/json ContentType.
type CreateServerCertificateJSONRequestBody = CreateServerCertificate

// UpdateServerCertificateJSONRequestBody defines body for UpdateServerCertificate for application/json ContentType.
type UpdateServerCertificateJSONRequestBody = UpdateServerCertificate

// CreateSnapshotJSONRequestBody defines body for CreateSnapshot for application/json ContentType.
type CreateSnapshotJSONRequestBody = CreateSnapshot

// CreateSubnetJSONRequestBody defines body for CreateSubnet for application/json ContentType.
type CreateSubnetJSONRequestBody = CreateSubnet

// UpdateSubnetJSONRequestBody defines body for UpdateSubnet for application/json ContentType.
type UpdateSubnetJSONRequestBody = UpdateSubnet

// CreateVmsJSONRequestBody defines body for CreateVms for application/json ContentType.
type CreateVmsJSONRequestBody = CreateVms

// UpdateVmJSONRequestBody defines body for UpdateVm for application/json ContentType.
type UpdateVmJSONRequestBody = UpdateVm

// StopVmJSONRequestBody defines body for StopVm for application/json ContentType.
type StopVmJSONRequestBody = StopVm

// CreateVolumeJSONRequestBody defines body for CreateVolume for application/json ContentType.
type CreateVolumeJSONRequestBody = CreateVolume

// UpdateVolumeJSONRequestBody defines body for UpdateVolume for application/json ContentType.
type UpdateVolumeJSONRequestBody = UpdateVolume

// LinkVolumeJSONRequestBody defines body for LinkVolume for application/json ContentType.
type LinkVolumeJSONRequestBody = LinkVolume

// UnlinkVolumeJSONRequestBody defines body for UnlinkVolume for application/json ContentType.
type UnlinkVolumeJSONRequestBody = UnlinkVolume

// CreateVpcJSONRequestBody defines body for CreateVpc for application/json ContentType.
type CreateVpcJSONRequestBody = CreateVpc

// UpdateVpcJSONRequestBody defines body for UpdateVpc for application/json ContentType.
type UpdateVpcJSONRequestBody = UpdateVpc

// CreateClientGatewayJSONRequestBody defines body for CreateClientGateway for application/json ContentType.
type CreateClientGatewayJSONRequestBody = CreateClientGateway

// CreateComputeBridgeJSONRequestBody defines body for CreateComputeBridge for application/json ContentType.
type CreateComputeBridgeJSONRequestBody = CreateComputeBridge

// CreateDirectLinkInterfaceJSONRequestBody defines body for CreateDirectLinkInterface for application/json ContentType.
type CreateDirectLinkInterfaceJSONRequestBody = CreateDirectLinkInterface

// CreateDirectLinkJSONRequestBody defines body for CreateDirectLink for application/json ContentType.
type CreateDirectLinkJSONRequestBody = CreateDirectLink

// CreateHybridBridgeJSONRequestBody defines body for CreateHybridBridge for application/json ContentType.
type CreateHybridBridgeJSONRequestBody = CreateHybridBridge

// CreateManagedServicesBridgeJSONRequestBody defines body for CreateManagedServicesBridge for application/json ContentType.
type CreateManagedServicesBridgeJSONRequestBody = CreateManagedServicesBridge

// UnlinkVirtualGatewayJSONRequestBody defines body for UnlinkVirtualGateway for application/json ContentType.
type UnlinkVirtualGatewayJSONRequestBody = LinkUnlinkVirtualGateway

// LinkVirtualGatewayJSONRequestBody defines body for LinkVirtualGateway for application/json ContentType.
type LinkVirtualGatewayJSONRequestBody = LinkUnlinkVirtualGateway

// CreateVirtualGatewayJSONRequestBody defines body for CreateVirtualGateway for application/json ContentType.
type CreateVirtualGatewayJSONRequestBody = CreateVirtualGateway

// DeleteVPNConnectionRouteJSONRequestBody defines body for DeleteVPNConnectionRoute for application/json ContentType.
type DeleteVPNConnectionRouteJSONRequestBody = DeleteVPNConnectionRoute

// CreateVPNConnectionRouteJSONRequestBody defines body for CreateVPNConnectionRoute for application/json ContentType.
type CreateVPNConnectionRouteJSONRequestBody = CreateVPNConnectionRoute

// CreateVPNConnectionJSONRequestBody defines body for CreateVPNConnection for application/json ContentType.
type CreateVPNConnectionJSONRequestBody = CreateVPNConnection

// CreateAdminServiceAccountSpaceJSONRequestBody defines body for CreateAdminServiceAccountSpace for application/json ContentType.
type CreateAdminServiceAccountSpaceJSONRequestBody = ServiceAccount

// UpdateLoginFlowJSONRequestBody defines body for UpdateLoginFlow for application/json ContentType.
type UpdateLoginFlowJSONRequestBody = UpdateLoginFlowBody

// UpdateLoginFlowFormdataRequestBody defines body for UpdateLoginFlow for application/x-www-form-urlencoded ContentType.
type UpdateLoginFlowFormdataRequestBody = UpdateLoginFlowBody

// UpdateRecoveryFlowJSONRequestBody defines body for UpdateRecoveryFlow for application/json ContentType.
type UpdateRecoveryFlowJSONRequestBody = UpdateRecoveryFlowBody

// UpdateRecoveryFlowFormdataRequestBody defines body for UpdateRecoveryFlow for application/x-www-form-urlencoded ContentType.
type UpdateRecoveryFlowFormdataRequestBody = UpdateRecoveryFlowBody

// UpdateSettingsFloJSONRequestBody defines body for UpdateSettingsFlo for application/json ContentType.
type UpdateSettingsFloJSONRequestBody = UpdateSettingsFlowBody

// UpdateSettingsFloFormdataRequestBody defines body for UpdateSettingsFlo for application/x-www-form-urlencoded ContentType.
type UpdateSettingsFloFormdataRequestBody = UpdateSettingsFlowBody

// IntrospectFormdataRequestBody defines body for Introspect for application/x-www-form-urlencoded ContentType.
type IntrospectFormdataRequestBody = TokenBody

// SetIAMPolicyOrganisationJSONRequestBody defines body for SetIAMPolicyOrganisation for application/json ContentType.
type SetIAMPolicyOrganisationJSONRequestBody SetIAMPolicyOrganisationJSONBody

// CreateServiceAccountOrganisationJSONRequestBody defines body for CreateServiceAccountOrganisation for application/json ContentType.
type CreateServiceAccountOrganisationJSONRequestBody = ServiceAccount

// UpdateServiceAccountOrganisationJSONRequestBody defines body for UpdateServiceAccountOrganisation for application/json ContentType.
type UpdateServiceAccountOrganisationJSONRequestBody = ServiceAccount

// DeleteACLServiceAccountOrganisationBulkJSONRequestBody defines body for DeleteACLServiceAccountOrganisationBulk for application/json ContentType.
type DeleteACLServiceAccountOrganisationBulkJSONRequestBody = ACLList

// CreateACLServiceAccountOrganisationBulkJSONRequestBody defines body for CreateACLServiceAccountOrganisationBulk for application/json ContentType.
type CreateACLServiceAccountOrganisationBulkJSONRequestBody = ACLList

// CreateUserOrganisationJSONRequestBody defines body for CreateUserOrganisation for application/json ContentType.
type CreateUserOrganisationJSONRequestBody = User

// PatchUserStateOrganisationJSONRequestBody defines body for PatchUserStateOrganisation for application/json ContentType.
type PatchUserStateOrganisationJSONRequestBody = UserState

// UpdateUserOrganisationJSONRequestBody defines body for UpdateUserOrganisation for application/json ContentType.
type UpdateUserOrganisationJSONRequestBody = UserUpdate

// DeleteACLUserOrganisationBulkJSONRequestBody defines body for DeleteACLUserOrganisationBulk for application/json ContentType.
type DeleteACLUserOrganisationBulkJSONRequestBody = ACLList

// CreateACLUserOrganisationBulkJSONRequestBody defines body for CreateACLUserOrganisationBulk for application/json ContentType.
type CreateACLUserOrganisationBulkJSONRequestBody = ACLList

// RevokeFormdataRequestBody defines body for Revoke for application/x-www-form-urlencoded ContentType.
type RevokeFormdataRequestBody = TokenBody

// SetIAMPolicySpaceJSONRequestBody defines body for SetIAMPolicySpace for application/json ContentType.
type SetIAMPolicySpaceJSONRequestBody SetIAMPolicySpaceJSONBody

// CreateServiceAccountSpaceJSONRequestBody defines body for CreateServiceAccountSpace for application/json ContentType.
type CreateServiceAccountSpaceJSONRequestBody = ServiceAccount

// UpdateServiceAccountSpaceJSONRequestBody defines body for UpdateServiceAccountSpace for application/json ContentType.
type UpdateServiceAccountSpaceJSONRequestBody = ServiceAccount

// DeleteACLServiceAccountSpaceBulkJSONRequestBody defines body for DeleteACLServiceAccountSpaceBulk for application/json ContentType.
type DeleteACLServiceAccountSpaceBulkJSONRequestBody = ACLList

// CreateACLServiceAccountSpaceBulkJSONRequestBody defines body for CreateACLServiceAccountSpaceBulk for application/json ContentType.
type CreateACLServiceAccountSpaceBulkJSONRequestBody = ACLList

// CreateUserSpaceJSONRequestBody defines body for CreateUserSpace for application/json ContentType.
type CreateUserSpaceJSONRequestBody = User

// PatchUserStateSpaceJSONRequestBody defines body for PatchUserStateSpace for application/json ContentType.
type PatchUserStateSpaceJSONRequestBody = UserState

// UpdateUserSpaceJSONRequestBody defines body for UpdateUserSpace for application/json ContentType.
type UpdateUserSpaceJSONRequestBody = UserUpdate

// DeleteACLUserSpaceBulkJSONRequestBody defines body for DeleteACLUserSpaceBulk for application/json ContentType.
type DeleteACLUserSpaceBulkJSONRequestBody = ACLList

// CreateACLUserSpaceBulkJSONRequestBody defines body for CreateACLUserSpaceBulk for application/json ContentType.
type CreateACLUserSpaceBulkJSONRequestBody = ACLList

// TokenFormdataRequestBody defines body for Token for application/x-www-form-urlencoded ContentType.
type TokenFormdataRequestBody = TokenReq

// ConvertTokenJSONRequestBody defines body for ConvertToken for application/json ContentType.
type ConvertTokenJSONRequestBody = Token

// CreateKubernetesClusterJSONRequestBody defines body for CreateKubernetesCluster for application/json ContentType.
type CreateKubernetesClusterJSONRequestBody = KubernetesClusterConfiguration

// UpgradeKubernetesMastersJSONRequestBody defines body for UpgradeKubernetesMasters for application/json ContentType.
type UpgradeKubernetesMastersJSONRequestBody = KubernetesMasterUpgrade

// AddKubernetesWorkersJSONRequestBody defines body for AddKubernetesWorkers for application/json ContentType.
type AddKubernetesWorkersJSONRequestBody = KubernetesWorkersAddition

// RemoveKubernetesWorkerJSONRequestBody defines body for RemoveKubernetesWorker for application/json ContentType.
type RemoveKubernetesWorkerJSONRequestBody = KubernetesWorkerRemoval

// UpgradeKubernetesWorkersJSONRequestBody defines body for UpgradeKubernetesWorkers for application/json ContentType.
type UpgradeKubernetesWorkersJSONRequestBody = KubernetesWorkerUpgrade

// CreateClusterJSONRequestBody defines body for CreateCluster for application/json ContentType.
type CreateClusterJSONRequestBody = OpenShiftClusterCreate

// UpdateClusterJSONRequestBody defines body for UpdateCluster for application/json ContentType.
type UpdateClusterJSONRequestBody = OpenShiftClusterUpdate

// CreateNodePoolJSONRequestBody defines body for CreateNodePool for application/json ContentType.
type CreateNodePoolJSONRequestBody = OpenShiftNodepool

// UpdateNodepoolJSONRequestBody defines body for UpdateNodepool for application/json ContentType.
type UpdateNodepoolJSONRequestBody = OpenShiftNodepoolUpdate

// CreateSpaceJSONRequestBody defines body for CreateSpace for application/json ContentType.
type CreateSpaceJSONRequestBody = CreateSpace

// UpdateSpaceJSONRequestBody defines body for UpdateSpace for application/json ContentType.
type UpdateSpaceJSONRequestBody = MutableSpace

// PostgreSQLCreateClusterJSONRequestBody defines body for PostgreSQLCreateCluster for application/json ContentType.
type PostgreSQLCreateClusterJSONRequestBody PostgreSQLCreateClusterJSONBody

// PostgreSQLDeleteClusterJSONRequestBody defines body for PostgreSQLDeleteCluster for application/json ContentType.
type PostgreSQLDeleteClusterJSONRequestBody PostgreSQLDeleteClusterJSONBody

// PostgreSQLModifyClusterJSONRequestBody defines body for PostgreSQLModifyCluster for application/json ContentType.
type PostgreSQLModifyClusterJSONRequestBody PostgreSQLModifyClusterJSONBody

// AsContinueWithVerificationUi returns the union data inside the ContinueWith as a ContinueWithVerificationUi
func (t ContinueWith) AsContinueWithVerificationUi() (ContinueWithVerificationUi, error) {
	var body ContinueWithVerificationUi
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContinueWithVerificationUi overwrites any union data inside the ContinueWith as the provided ContinueWithVerificationUi
func (t *ContinueWith) FromContinueWithVerificationUi(v ContinueWithVerificationUi) error {
	v.Action = "show_verification_ui"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContinueWithVerificationUi performs a merge with any union data inside the ContinueWith, using the provided ContinueWithVerificationUi
func (t *ContinueWith) MergeContinueWithVerificationUi(v ContinueWithVerificationUi) error {
	v.Action = "show_verification_ui"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContinueWithSetSessionToken returns the union data inside the ContinueWith as a ContinueWithSetSessionToken
func (t ContinueWith) AsContinueWithSetSessionToken() (ContinueWithSetSessionToken, error) {
	var body ContinueWithSetSessionToken
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContinueWithSetSessionToken overwrites any union data inside the ContinueWith as the provided ContinueWithSetSessionToken
func (t *ContinueWith) FromContinueWithSetSessionToken(v ContinueWithSetSessionToken) error {
	v.Action = "set_session_token"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContinueWithSetSessionToken performs a merge with any union data inside the ContinueWith, using the provided ContinueWithSetSessionToken
func (t *ContinueWith) MergeContinueWithSetSessionToken(v ContinueWithSetSessionToken) error {
	v.Action = "set_session_token"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContinueWithSettingsUi returns the union data inside the ContinueWith as a ContinueWithSettingsUi
func (t ContinueWith) AsContinueWithSettingsUi() (ContinueWithSettingsUi, error) {
	var body ContinueWithSettingsUi
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContinueWithSettingsUi overwrites any union data inside the ContinueWith as the provided ContinueWithSettingsUi
func (t *ContinueWith) FromContinueWithSettingsUi(v ContinueWithSettingsUi) error {
	v.Action = "show_settings_ui"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContinueWithSettingsUi performs a merge with any union data inside the ContinueWith, using the provided ContinueWithSettingsUi
func (t *ContinueWith) MergeContinueWithSettingsUi(v ContinueWithSettingsUi) error {
	v.Action = "show_settings_ui"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContinueWithRecoveryUi returns the union data inside the ContinueWith as a ContinueWithRecoveryUi
func (t ContinueWith) AsContinueWithRecoveryUi() (ContinueWithRecoveryUi, error) {
	var body ContinueWithRecoveryUi
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContinueWithRecoveryUi overwrites any union data inside the ContinueWith as the provided ContinueWithRecoveryUi
func (t *ContinueWith) FromContinueWithRecoveryUi(v ContinueWithRecoveryUi) error {
	v.Action = "show_recovery_ui"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContinueWithRecoveryUi performs a merge with any union data inside the ContinueWith, using the provided ContinueWithRecoveryUi
func (t *ContinueWith) MergeContinueWithRecoveryUi(v ContinueWithRecoveryUi) error {
	v.Action = "show_recovery_ui"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ContinueWith) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"action"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ContinueWith) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "set_session_token":
		return t.AsContinueWithSetSessionToken()
	case "show_recovery_ui":
		return t.AsContinueWithRecoveryUi()
	case "show_settings_ui":
		return t.AsContinueWithSettingsUi()
	case "show_verification_ui":
		return t.AsContinueWithVerificationUi()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ContinueWith) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ContinueWith) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPostgresVolumeIo1 returns the union data inside the PostgresVolume as a PostgresVolumeIo1
func (t PostgresVolume) AsPostgresVolumeIo1() (PostgresVolumeIo1, error) {
	var body PostgresVolumeIo1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPostgresVolumeIo1 overwrites any union data inside the PostgresVolume as the provided PostgresVolumeIo1
func (t *PostgresVolume) FromPostgresVolumeIo1(v PostgresVolumeIo1) error {
	v.Type = "IO1"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePostgresVolumeIo1 performs a merge with any union data inside the PostgresVolume, using the provided PostgresVolumeIo1
func (t *PostgresVolume) MergePostgresVolumeIo1(v PostgresVolumeIo1) error {
	v.Type = "IO1"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPostgresVolumeGp2 returns the union data inside the PostgresVolume as a PostgresVolumeGp2
func (t PostgresVolume) AsPostgresVolumeGp2() (PostgresVolumeGp2, error) {
	var body PostgresVolumeGp2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPostgresVolumeGp2 overwrites any union data inside the PostgresVolume as the provided PostgresVolumeGp2
func (t *PostgresVolume) FromPostgresVolumeGp2(v PostgresVolumeGp2) error {
	v.Type = "GP2"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePostgresVolumeGp2 performs a merge with any union data inside the PostgresVolume, using the provided PostgresVolumeGp2
func (t *PostgresVolume) MergePostgresVolumeGp2(v PostgresVolumeGp2) error {
	v.Type = "GP2"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PostgresVolume) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PostgresVolume) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "GP2":
		return t.AsPostgresVolumeGp2()
	case "IO1":
		return t.AsPostgresVolumeIo1()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PostgresVolume) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PostgresVolume) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStringOrObject0 returns the union data inside the StringOrObject as a StringOrObject0
func (t StringOrObject) AsStringOrObject0() (StringOrObject0, error) {
	var body StringOrObject0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStringOrObject0 overwrites any union data inside the StringOrObject as the provided StringOrObject0
func (t *StringOrObject) FromStringOrObject0(v StringOrObject0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStringOrObject0 performs a merge with any union data inside the StringOrObject, using the provided StringOrObject0
func (t *StringOrObject) MergeStringOrObject0(v StringOrObject0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStringOrObject1 returns the union data inside the StringOrObject as a StringOrObject1
func (t StringOrObject) AsStringOrObject1() (StringOrObject1, error) {
	var body StringOrObject1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStringOrObject1 overwrites any union data inside the StringOrObject as the provided StringOrObject1
func (t *StringOrObject) FromStringOrObject1(v StringOrObject1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStringOrObject1 performs a merge with any union data inside the StringOrObject, using the provided StringOrObject1
func (t *StringOrObject) MergeStringOrObject1(v StringOrObject1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StringOrObject) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StringOrObject) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUiNodeInputAttributes returns the union data inside the UiNodeAttributes as a UiNodeInputAttributes
func (t UiNodeAttributes) AsUiNodeInputAttributes() (UiNodeInputAttributes, error) {
	var body UiNodeInputAttributes
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUiNodeInputAttributes overwrites any union data inside the UiNodeAttributes as the provided UiNodeInputAttributes
func (t *UiNodeAttributes) FromUiNodeInputAttributes(v UiNodeInputAttributes) error {
	v.NodeType = "input"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUiNodeInputAttributes performs a merge with any union data inside the UiNodeAttributes, using the provided UiNodeInputAttributes
func (t *UiNodeAttributes) MergeUiNodeInputAttributes(v UiNodeInputAttributes) error {
	v.NodeType = "input"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUiNodeTextAttributes returns the union data inside the UiNodeAttributes as a UiNodeTextAttributes
func (t UiNodeAttributes) AsUiNodeTextAttributes() (UiNodeTextAttributes, error) {
	var body UiNodeTextAttributes
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUiNodeTextAttributes overwrites any union data inside the UiNodeAttributes as the provided UiNodeTextAttributes
func (t *UiNodeAttributes) FromUiNodeTextAttributes(v UiNodeTextAttributes) error {
	v.NodeType = "text"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUiNodeTextAttributes performs a merge with any union data inside the UiNodeAttributes, using the provided UiNodeTextAttributes
func (t *UiNodeAttributes) MergeUiNodeTextAttributes(v UiNodeTextAttributes) error {
	v.NodeType = "text"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUiNodeImageAttributes returns the union data inside the UiNodeAttributes as a UiNodeImageAttributes
func (t UiNodeAttributes) AsUiNodeImageAttributes() (UiNodeImageAttributes, error) {
	var body UiNodeImageAttributes
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUiNodeImageAttributes overwrites any union data inside the UiNodeAttributes as the provided UiNodeImageAttributes
func (t *UiNodeAttributes) FromUiNodeImageAttributes(v UiNodeImageAttributes) error {
	v.NodeType = "img"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUiNodeImageAttributes performs a merge with any union data inside the UiNodeAttributes, using the provided UiNodeImageAttributes
func (t *UiNodeAttributes) MergeUiNodeImageAttributes(v UiNodeImageAttributes) error {
	v.NodeType = "img"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUiNodeAnchorAttributes returns the union data inside the UiNodeAttributes as a UiNodeAnchorAttributes
func (t UiNodeAttributes) AsUiNodeAnchorAttributes() (UiNodeAnchorAttributes, error) {
	var body UiNodeAnchorAttributes
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUiNodeAnchorAttributes overwrites any union data inside the UiNodeAttributes as the provided UiNodeAnchorAttributes
func (t *UiNodeAttributes) FromUiNodeAnchorAttributes(v UiNodeAnchorAttributes) error {
	v.NodeType = "a"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUiNodeAnchorAttributes performs a merge with any union data inside the UiNodeAttributes, using the provided UiNodeAnchorAttributes
func (t *UiNodeAttributes) MergeUiNodeAnchorAttributes(v UiNodeAnchorAttributes) error {
	v.NodeType = "a"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUiNodeScriptAttributes returns the union data inside the UiNodeAttributes as a UiNodeScriptAttributes
func (t UiNodeAttributes) AsUiNodeScriptAttributes() (UiNodeScriptAttributes, error) {
	var body UiNodeScriptAttributes
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUiNodeScriptAttributes overwrites any union data inside the UiNodeAttributes as the provided UiNodeScriptAttributes
func (t *UiNodeAttributes) FromUiNodeScriptAttributes(v UiNodeScriptAttributes) error {
	v.NodeType = "script"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUiNodeScriptAttributes performs a merge with any union data inside the UiNodeAttributes, using the provided UiNodeScriptAttributes
func (t *UiNodeAttributes) MergeUiNodeScriptAttributes(v UiNodeScriptAttributes) error {
	v.NodeType = "script"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UiNodeAttributes) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"node_type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t UiNodeAttributes) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "a":
		return t.AsUiNodeAnchorAttributes()
	case "img":
		return t.AsUiNodeImageAttributes()
	case "input":
		return t.AsUiNodeInputAttributes()
	case "script":
		return t.AsUiNodeScriptAttributes()
	case "text":
		return t.AsUiNodeTextAttributes()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t UiNodeAttributes) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UiNodeAttributes) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUpdateLoginFlowWithPasswordMethod returns the union data inside the UpdateLoginFlowBody as a UpdateLoginFlowWithPasswordMethod
func (t UpdateLoginFlowBody) AsUpdateLoginFlowWithPasswordMethod() (UpdateLoginFlowWithPasswordMethod, error) {
	var body UpdateLoginFlowWithPasswordMethod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateLoginFlowWithPasswordMethod overwrites any union data inside the UpdateLoginFlowBody as the provided UpdateLoginFlowWithPasswordMethod
func (t *UpdateLoginFlowBody) FromUpdateLoginFlowWithPasswordMethod(v UpdateLoginFlowWithPasswordMethod) error {
	v.Method = "password"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateLoginFlowWithPasswordMethod performs a merge with any union data inside the UpdateLoginFlowBody, using the provided UpdateLoginFlowWithPasswordMethod
func (t *UpdateLoginFlowBody) MergeUpdateLoginFlowWithPasswordMethod(v UpdateLoginFlowWithPasswordMethod) error {
	v.Method = "password"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateLoginFlowWithOidcMethod returns the union data inside the UpdateLoginFlowBody as a UpdateLoginFlowWithOidcMethod
func (t UpdateLoginFlowBody) AsUpdateLoginFlowWithOidcMethod() (UpdateLoginFlowWithOidcMethod, error) {
	var body UpdateLoginFlowWithOidcMethod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateLoginFlowWithOidcMethod overwrites any union data inside the UpdateLoginFlowBody as the provided UpdateLoginFlowWithOidcMethod
func (t *UpdateLoginFlowBody) FromUpdateLoginFlowWithOidcMethod(v UpdateLoginFlowWithOidcMethod) error {
	v.Method = "oidc"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateLoginFlowWithOidcMethod performs a merge with any union data inside the UpdateLoginFlowBody, using the provided UpdateLoginFlowWithOidcMethod
func (t *UpdateLoginFlowBody) MergeUpdateLoginFlowWithOidcMethod(v UpdateLoginFlowWithOidcMethod) error {
	v.Method = "oidc"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateLoginFlowWithTotpMethod returns the union data inside the UpdateLoginFlowBody as a UpdateLoginFlowWithTotpMethod
func (t UpdateLoginFlowBody) AsUpdateLoginFlowWithTotpMethod() (UpdateLoginFlowWithTotpMethod, error) {
	var body UpdateLoginFlowWithTotpMethod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateLoginFlowWithTotpMethod overwrites any union data inside the UpdateLoginFlowBody as the provided UpdateLoginFlowWithTotpMethod
func (t *UpdateLoginFlowBody) FromUpdateLoginFlowWithTotpMethod(v UpdateLoginFlowWithTotpMethod) error {
	v.Method = "totp"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateLoginFlowWithTotpMethod performs a merge with any union data inside the UpdateLoginFlowBody, using the provided UpdateLoginFlowWithTotpMethod
func (t *UpdateLoginFlowBody) MergeUpdateLoginFlowWithTotpMethod(v UpdateLoginFlowWithTotpMethod) error {
	v.Method = "totp"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateLoginFlowWithWebAuthnMethod returns the union data inside the UpdateLoginFlowBody as a UpdateLoginFlowWithWebAuthnMethod
func (t UpdateLoginFlowBody) AsUpdateLoginFlowWithWebAuthnMethod() (UpdateLoginFlowWithWebAuthnMethod, error) {
	var body UpdateLoginFlowWithWebAuthnMethod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateLoginFlowWithWebAuthnMethod overwrites any union data inside the UpdateLoginFlowBody as the provided UpdateLoginFlowWithWebAuthnMethod
func (t *UpdateLoginFlowBody) FromUpdateLoginFlowWithWebAuthnMethod(v UpdateLoginFlowWithWebAuthnMethod) error {
	v.Method = "webauthn"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateLoginFlowWithWebAuthnMethod performs a merge with any union data inside the UpdateLoginFlowBody, using the provided UpdateLoginFlowWithWebAuthnMethod
func (t *UpdateLoginFlowBody) MergeUpdateLoginFlowWithWebAuthnMethod(v UpdateLoginFlowWithWebAuthnMethod) error {
	v.Method = "webauthn"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateLoginFlowWithLookupSecretMethod returns the union data inside the UpdateLoginFlowBody as a UpdateLoginFlowWithLookupSecretMethod
func (t UpdateLoginFlowBody) AsUpdateLoginFlowWithLookupSecretMethod() (UpdateLoginFlowWithLookupSecretMethod, error) {
	var body UpdateLoginFlowWithLookupSecretMethod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateLoginFlowWithLookupSecretMethod overwrites any union data inside the UpdateLoginFlowBody as the provided UpdateLoginFlowWithLookupSecretMethod
func (t *UpdateLoginFlowBody) FromUpdateLoginFlowWithLookupSecretMethod(v UpdateLoginFlowWithLookupSecretMethod) error {
	v.Method = "lookup_secret"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateLoginFlowWithLookupSecretMethod performs a merge with any union data inside the UpdateLoginFlowBody, using the provided UpdateLoginFlowWithLookupSecretMethod
func (t *UpdateLoginFlowBody) MergeUpdateLoginFlowWithLookupSecretMethod(v UpdateLoginFlowWithLookupSecretMethod) error {
	v.Method = "lookup_secret"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateLoginFlowWithCodeMethod returns the union data inside the UpdateLoginFlowBody as a UpdateLoginFlowWithCodeMethod
func (t UpdateLoginFlowBody) AsUpdateLoginFlowWithCodeMethod() (UpdateLoginFlowWithCodeMethod, error) {
	var body UpdateLoginFlowWithCodeMethod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateLoginFlowWithCodeMethod overwrites any union data inside the UpdateLoginFlowBody as the provided UpdateLoginFlowWithCodeMethod
func (t *UpdateLoginFlowBody) FromUpdateLoginFlowWithCodeMethod(v UpdateLoginFlowWithCodeMethod) error {
	v.Method = "code"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateLoginFlowWithCodeMethod performs a merge with any union data inside the UpdateLoginFlowBody, using the provided UpdateLoginFlowWithCodeMethod
func (t *UpdateLoginFlowBody) MergeUpdateLoginFlowWithCodeMethod(v UpdateLoginFlowWithCodeMethod) error {
	v.Method = "code"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateLoginFlowBody) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"method"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t UpdateLoginFlowBody) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "code":
		return t.AsUpdateLoginFlowWithCodeMethod()
	case "lookup_secret":
		return t.AsUpdateLoginFlowWithLookupSecretMethod()
	case "oidc":
		return t.AsUpdateLoginFlowWithOidcMethod()
	case "password":
		return t.AsUpdateLoginFlowWithPasswordMethod()
	case "totp":
		return t.AsUpdateLoginFlowWithTotpMethod()
	case "webauthn":
		return t.AsUpdateLoginFlowWithWebAuthnMethod()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t UpdateLoginFlowBody) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateLoginFlowBody) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUpdateRecoveryFlowWithLinkMethod returns the union data inside the UpdateRecoveryFlowBody as a UpdateRecoveryFlowWithLinkMethod
func (t UpdateRecoveryFlowBody) AsUpdateRecoveryFlowWithLinkMethod() (UpdateRecoveryFlowWithLinkMethod, error) {
	var body UpdateRecoveryFlowWithLinkMethod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateRecoveryFlowWithLinkMethod overwrites any union data inside the UpdateRecoveryFlowBody as the provided UpdateRecoveryFlowWithLinkMethod
func (t *UpdateRecoveryFlowBody) FromUpdateRecoveryFlowWithLinkMethod(v UpdateRecoveryFlowWithLinkMethod) error {
	v.Method = "link"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateRecoveryFlowWithLinkMethod performs a merge with any union data inside the UpdateRecoveryFlowBody, using the provided UpdateRecoveryFlowWithLinkMethod
func (t *UpdateRecoveryFlowBody) MergeUpdateRecoveryFlowWithLinkMethod(v UpdateRecoveryFlowWithLinkMethod) error {
	v.Method = "link"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateRecoveryFlowWithCodeMethod returns the union data inside the UpdateRecoveryFlowBody as a UpdateRecoveryFlowWithCodeMethod
func (t UpdateRecoveryFlowBody) AsUpdateRecoveryFlowWithCodeMethod() (UpdateRecoveryFlowWithCodeMethod, error) {
	var body UpdateRecoveryFlowWithCodeMethod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateRecoveryFlowWithCodeMethod overwrites any union data inside the UpdateRecoveryFlowBody as the provided UpdateRecoveryFlowWithCodeMethod
func (t *UpdateRecoveryFlowBody) FromUpdateRecoveryFlowWithCodeMethod(v UpdateRecoveryFlowWithCodeMethod) error {
	v.Method = "code"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateRecoveryFlowWithCodeMethod performs a merge with any union data inside the UpdateRecoveryFlowBody, using the provided UpdateRecoveryFlowWithCodeMethod
func (t *UpdateRecoveryFlowBody) MergeUpdateRecoveryFlowWithCodeMethod(v UpdateRecoveryFlowWithCodeMethod) error {
	v.Method = "code"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateRecoveryFlowBody) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"method"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t UpdateRecoveryFlowBody) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "code":
		return t.AsUpdateRecoveryFlowWithCodeMethod()
	case "link":
		return t.AsUpdateRecoveryFlowWithLinkMethod()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t UpdateRecoveryFlowBody) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateRecoveryFlowBody) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUpdateSettingsFlowWithPasswordMethod returns the union data inside the UpdateSettingsFlowBody as a UpdateSettingsFlowWithPasswordMethod
func (t UpdateSettingsFlowBody) AsUpdateSettingsFlowWithPasswordMethod() (UpdateSettingsFlowWithPasswordMethod, error) {
	var body UpdateSettingsFlowWithPasswordMethod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateSettingsFlowWithPasswordMethod overwrites any union data inside the UpdateSettingsFlowBody as the provided UpdateSettingsFlowWithPasswordMethod
func (t *UpdateSettingsFlowBody) FromUpdateSettingsFlowWithPasswordMethod(v UpdateSettingsFlowWithPasswordMethod) error {
	v.Method = "password"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateSettingsFlowWithPasswordMethod performs a merge with any union data inside the UpdateSettingsFlowBody, using the provided UpdateSettingsFlowWithPasswordMethod
func (t *UpdateSettingsFlowBody) MergeUpdateSettingsFlowWithPasswordMethod(v UpdateSettingsFlowWithPasswordMethod) error {
	v.Method = "password"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateSettingsFlowWithTotpMethod returns the union data inside the UpdateSettingsFlowBody as a UpdateSettingsFlowWithTotpMethod
func (t UpdateSettingsFlowBody) AsUpdateSettingsFlowWithTotpMethod() (UpdateSettingsFlowWithTotpMethod, error) {
	var body UpdateSettingsFlowWithTotpMethod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateSettingsFlowWithTotpMethod overwrites any union data inside the UpdateSettingsFlowBody as the provided UpdateSettingsFlowWithTotpMethod
func (t *UpdateSettingsFlowBody) FromUpdateSettingsFlowWithTotpMethod(v UpdateSettingsFlowWithTotpMethod) error {
	v.Method = "totp"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateSettingsFlowWithTotpMethod performs a merge with any union data inside the UpdateSettingsFlowBody, using the provided UpdateSettingsFlowWithTotpMethod
func (t *UpdateSettingsFlowBody) MergeUpdateSettingsFlowWithTotpMethod(v UpdateSettingsFlowWithTotpMethod) error {
	v.Method = "totp"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateSettingsFlowBody) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"method"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t UpdateSettingsFlowBody) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "password":
		return t.AsUpdateSettingsFlowWithPasswordMethod()
	case "totp":
		return t.AsUpdateSettingsFlowWithTotpMethod()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t UpdateSettingsFlowBody) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateSettingsFlowBody) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPostgresInvalidParameterProblem returns the union data inside the PostgresCreateCluster400Response as a PostgresInvalidParameterProblem
func (t PostgresCreateCluster400Response) AsPostgresInvalidParameterProblem() (PostgresInvalidParameterProblem, error) {
	var body PostgresInvalidParameterProblem
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPostgresInvalidParameterProblem overwrites any union data inside the PostgresCreateCluster400Response as the provided PostgresInvalidParameterProblem
func (t *PostgresCreateCluster400Response) FromPostgresInvalidParameterProblem(v PostgresInvalidParameterProblem) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePostgresInvalidParameterProblem performs a merge with any union data inside the PostgresCreateCluster400Response, using the provided PostgresInvalidParameterProblem
func (t *PostgresCreateCluster400Response) MergePostgresInvalidParameterProblem(v PostgresInvalidParameterProblem) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPostgresDuplicatedResourceProblem returns the union data inside the PostgresCreateCluster400Response as a PostgresDuplicatedResourceProblem
func (t PostgresCreateCluster400Response) AsPostgresDuplicatedResourceProblem() (PostgresDuplicatedResourceProblem, error) {
	var body PostgresDuplicatedResourceProblem
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPostgresDuplicatedResourceProblem overwrites any union data inside the PostgresCreateCluster400Response as the provided PostgresDuplicatedResourceProblem
func (t *PostgresCreateCluster400Response) FromPostgresDuplicatedResourceProblem(v PostgresDuplicatedResourceProblem) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePostgresDuplicatedResourceProblem performs a merge with any union data inside the PostgresCreateCluster400Response, using the provided PostgresDuplicatedResourceProblem
func (t *PostgresCreateCluster400Response) MergePostgresDuplicatedResourceProblem(v PostgresDuplicatedResourceProblem) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PostgresCreateCluster400Response) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PostgresCreateCluster400Response) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// DeleteLoadBalancerTagsWithBody request with any body
	DeleteLoadBalancerTagsWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteLoadBalancerTags(ctx context.Context, spaceId SpaceId, body DeleteLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLoadBalancerTagsWithBody request with any body
	CreateLoadBalancerTagsWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLoadBalancerTags(ctx context.Context, spaceId SpaceId, body CreateLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTagsWithBody request with any body
	DeleteTagsWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteTags(ctx context.Context, spaceId SpaceId, body DeleteTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTagsWithBody request with any body
	CreateTagsWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTags(ctx context.Context, spaceId SpaceId, body CreateTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadDhcpOptions request
	ReadDhcpOptions(ctx context.Context, spaceId SpaceId, params *ReadDhcpOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDhcpOptionsWithBody request with any body
	CreateDhcpOptionsWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDhcpOptions(ctx context.Context, spaceId SpaceId, body CreateDhcpOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDhcpOptions request
	DeleteDhcpOptions(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadDhcpOptionsById request
	ReadDhcpOptionsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadFlexibleGpus request
	ReadFlexibleGpus(ctx context.Context, spaceId SpaceId, params *ReadFlexibleGpusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFlexibleGpuWithBody request with any body
	CreateFlexibleGpuWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFlexibleGpu(ctx context.Context, spaceId SpaceId, body CreateFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFlexibleGpu request
	DeleteFlexibleGpu(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadFlexibleGpusById request
	ReadFlexibleGpusById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateFlexibleGpuWithBody request with any body
	UpdateFlexibleGpuWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateFlexibleGpu(ctx context.Context, spaceId SpaceId, id string, body UpdateFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkFlexibleGpuWithBody request with any body
	LinkFlexibleGpuWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkFlexibleGpu(ctx context.Context, spaceId SpaceId, id string, body LinkFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkFlexibleGpu request
	UnlinkFlexibleGpu(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadImages request
	ReadImages(ctx context.Context, spaceId SpaceId, params *ReadImagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateImageWithBody request with any body
	CreateImageWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateImage(ctx context.Context, spaceId SpaceId, body CreateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteImage request
	DeleteImage(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadImagesById request
	ReadImagesById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateImageWithBody request with any body
	UpdateImageWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateImage(ctx context.Context, spaceId SpaceId, id string, body UpdateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadInternetGateways request
	ReadInternetGateways(ctx context.Context, spaceId SpaceId, params *ReadInternetGatewaysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateInternetGateway request
	CreateInternetGateway(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteInternetGateway request
	DeleteInternetGateway(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadInternetGatewaysById request
	ReadInternetGatewaysById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkInternetGatewayWithBody request with any body
	LinkInternetGatewayWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkInternetGateway(ctx context.Context, spaceId SpaceId, id string, body LinkInternetGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkInternetGatewayWithBody request with any body
	UnlinkInternetGatewayWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnlinkInternetGateway(ctx context.Context, spaceId SpaceId, id string, body UnlinkInternetGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadKeypairs request
	ReadKeypairs(ctx context.Context, spaceId SpaceId, params *ReadKeypairsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateKeypairWithBody request with any body
	CreateKeypairWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateKeypair(ctx context.Context, spaceId SpaceId, body CreateKeypairJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteKeypair request
	DeleteKeypair(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadKeypairsById request
	ReadKeypairsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadListenerRules request
	ReadListenerRules(ctx context.Context, spaceId SpaceId, params *ReadListenerRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateListenerRuleWithBody request with any body
	CreateListenerRuleWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateListenerRule(ctx context.Context, spaceId SpaceId, body CreateListenerRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteListenerRule request
	DeleteListenerRule(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadListenerRulesById request
	ReadListenerRulesById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateListenerRuleWithBody request with any body
	UpdateListenerRuleWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateListenerRule(ctx context.Context, spaceId SpaceId, id string, body UpdateListenerRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadLoadBalancers request
	ReadLoadBalancers(ctx context.Context, spaceId SpaceId, params *ReadLoadBalancersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLoadBalancerWithBody request with any body
	CreateLoadBalancerWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLoadBalancer(ctx context.Context, spaceId SpaceId, body CreateLoadBalancerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLoadBalancer request
	DeleteLoadBalancer(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadLoadBalancersById request
	ReadLoadBalancersById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateLoadBalancerWithBody request with any body
	UpdateLoadBalancerWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateLoadBalancer(ctx context.Context, spaceId SpaceId, id string, body UpdateLoadBalancerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkLoadBalancerBackendMachinesWithBody request with any body
	LinkLoadBalancerBackendMachinesWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkLoadBalancerBackendMachines(ctx context.Context, spaceId SpaceId, id string, body LinkLoadBalancerBackendMachinesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkLoadBalancerBackendMachinesWithBody request with any body
	UnlinkLoadBalancerBackendMachinesWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnlinkLoadBalancerBackendMachines(ctx context.Context, spaceId SpaceId, id string, body UnlinkLoadBalancerBackendMachinesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLoadBalancerListenersWithBody request with any body
	DeleteLoadBalancerListenersWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteLoadBalancerListeners(ctx context.Context, spaceId SpaceId, id string, body DeleteLoadBalancerListenersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLoadBalancerListenersWithBody request with any body
	CreateLoadBalancerListenersWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLoadBalancerListeners(ctx context.Context, spaceId SpaceId, id string, body CreateLoadBalancerListenersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLoadBalancerPolicyWithBody request with any body
	DeleteLoadBalancerPolicyWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteLoadBalancerPolicy(ctx context.Context, spaceId SpaceId, id string, body DeleteLoadBalancerPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLoadBalancerPolicyWithBody request with any body
	CreateLoadBalancerPolicyWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLoadBalancerPolicy(ctx context.Context, spaceId SpaceId, id string, body CreateLoadBalancerPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVmsHealthWithBody request with any body
	ReadVmsHealthWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReadVmsHealth(ctx context.Context, spaceId SpaceId, id string, body ReadVmsHealthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadLoadBalancerTagsWithBody request with any body
	ReadLoadBalancerTagsWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReadLoadBalancerTags(ctx context.Context, spaceId SpaceId, body ReadLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadNatGateway request
	ReadNatGateway(ctx context.Context, spaceId SpaceId, params *ReadNatGatewayParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNatGatewayWithBody request with any body
	CreateNatGatewayWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNatGateway(ctx context.Context, spaceId SpaceId, body CreateNatGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNatGateway request
	DeleteNatGateway(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadNatGatewayById request
	ReadNatGatewayById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadNics request
	ReadNics(ctx context.Context, spaceId SpaceId, params *ReadNicsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNicWithBody request with any body
	CreateNicWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNic(ctx context.Context, spaceId SpaceId, body CreateNicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNic request
	DeleteNic(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadNicsById request
	ReadNicsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateNicWithBody request with any body
	UpdateNicWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateNic(ctx context.Context, spaceId SpaceId, id string, body UpdateNicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkPrivateIpsWithBody request with any body
	LinkPrivateIpsWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkPrivateIps(ctx context.Context, spaceId SpaceId, id string, body LinkPrivateIpsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkPrivateIpsWithBody request with any body
	UnlinkPrivateIpsWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnlinkPrivateIps(ctx context.Context, spaceId SpaceId, id string, body UnlinkPrivateIpsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkNicWithBody request with any body
	LinkNicWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkNic(ctx context.Context, spaceId SpaceId, id string, body LinkNicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkNicWithBody request with any body
	UnlinkNicWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnlinkNic(ctx context.Context, spaceId SpaceId, id string, body UnlinkNicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadPublicIps request
	ReadPublicIps(ctx context.Context, spaceId SpaceId, params *ReadPublicIpsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePublicIp request
	CreatePublicIp(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePublicIp request
	DeletePublicIp(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadPublicIpsById request
	ReadPublicIpsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkPublicIpWithBody request with any body
	LinkPublicIpWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkPublicIp(ctx context.Context, spaceId SpaceId, id string, body LinkPublicIpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkPublicIpWithBody request with any body
	UnlinkPublicIpWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnlinkPublicIp(ctx context.Context, spaceId SpaceId, id string, body UnlinkPublicIpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadRouteTables request
	ReadRouteTables(ctx context.Context, spaceId SpaceId, params *ReadRouteTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRouteTableWithBody request with any body
	CreateRouteTableWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRouteTable(ctx context.Context, spaceId SpaceId, body CreateRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRouteTable request
	DeleteRouteTable(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadRouteTablesById request
	ReadRouteTablesById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRouteTableRoutePropagationWithBody request with any body
	UpdateRouteTableRoutePropagationWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRouteTableRoutePropagation(ctx context.Context, spaceId SpaceId, id string, body UpdateRouteTableRoutePropagationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRouteWithBody request with any body
	DeleteRouteWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteRoute(ctx context.Context, spaceId SpaceId, id string, body DeleteRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRouteWithBody request with any body
	CreateRouteWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRoute(ctx context.Context, spaceId SpaceId, id string, body CreateRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRouteWithBody request with any body
	UpdateRouteWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRoute(ctx context.Context, spaceId SpaceId, id string, body UpdateRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkRouteTableWithBody request with any body
	LinkRouteTableWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkRouteTable(ctx context.Context, spaceId SpaceId, id string, body LinkRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkRouteTableWithBody request with any body
	UnlinkRouteTableWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnlinkRouteTable(ctx context.Context, spaceId SpaceId, id string, body UnlinkRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadSecurityGroups request
	ReadSecurityGroups(ctx context.Context, spaceId SpaceId, params *ReadSecurityGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSecurityGroupWithBody request with any body
	CreateSecurityGroupWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSecurityGroup(ctx context.Context, spaceId SpaceId, body CreateSecurityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSecurityGroup request
	DeleteSecurityGroup(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadSecurityGroupsById request
	ReadSecurityGroupsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSecurityGroupRuleWithBody request with any body
	DeleteSecurityGroupRuleWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteSecurityGroupRule(ctx context.Context, spaceId SpaceId, id string, body DeleteSecurityGroupRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSecurityGroupRuleWithBody request with any body
	CreateSecurityGroupRuleWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSecurityGroupRule(ctx context.Context, spaceId SpaceId, id string, body CreateSecurityGroupRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadServerCertificates request
	ReadServerCertificates(ctx context.Context, spaceId SpaceId, params *ReadServerCertificatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateServerCertificateWithBody request with any body
	CreateServerCertificateWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateServerCertificate(ctx context.Context, spaceId SpaceId, body CreateServerCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServerCertificate request
	DeleteServerCertificate(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateServerCertificateWithBody request with any body
	UpdateServerCertificateWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateServerCertificate(ctx context.Context, spaceId SpaceId, id string, body UpdateServerCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadSnapshots request
	ReadSnapshots(ctx context.Context, spaceId SpaceId, params *ReadSnapshotsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSnapshotWithBody request with any body
	CreateSnapshotWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSnapshot(ctx context.Context, spaceId SpaceId, body CreateSnapshotJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSnapshot request
	DeleteSnapshot(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadSnapshotsById request
	ReadSnapshotsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadSubnets request
	ReadSubnets(ctx context.Context, spaceId SpaceId, params *ReadSubnetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSubnetWithBody request with any body
	CreateSubnetWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSubnet(ctx context.Context, spaceId SpaceId, body CreateSubnetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSubnet request
	DeleteSubnet(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadSubnetsById request
	ReadSubnetsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSubnetWithBody request with any body
	UpdateSubnetWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSubnet(ctx context.Context, spaceId SpaceId, id string, body UpdateSubnetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadTags request
	ReadTags(ctx context.Context, spaceId SpaceId, params *ReadTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVms request
	ReadVms(ctx context.Context, spaceId SpaceId, params *ReadVmsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVmsWithBody request with any body
	CreateVmsWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVms(ctx context.Context, spaceId SpaceId, body CreateVmsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVmsState request
	ReadVmsState(ctx context.Context, spaceId SpaceId, params *ReadVmsStateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVms request
	DeleteVms(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVmsById request
	ReadVmsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVmWithBody request with any body
	UpdateVmWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVm(ctx context.Context, spaceId SpaceId, id string, body UpdateVmJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadAdminPassword request
	ReadAdminPassword(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadConsoleOutput request
	ReadConsoleOutput(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RebootVm request
	RebootVm(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartVm request
	StartVm(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StopVmWithBody request with any body
	StopVmWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StopVm(ctx context.Context, spaceId SpaceId, id string, body StopVmJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVolumes request
	ReadVolumes(ctx context.Context, spaceId SpaceId, params *ReadVolumesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVolumeWithBody request with any body
	CreateVolumeWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVolume(ctx context.Context, spaceId SpaceId, body CreateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVolume request
	DeleteVolume(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVolumesById request
	ReadVolumesById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVolumeWithBody request with any body
	UpdateVolumeWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVolume(ctx context.Context, spaceId SpaceId, id string, body UpdateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkVolumeWithBody request with any body
	LinkVolumeWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkVolume(ctx context.Context, spaceId SpaceId, id string, body LinkVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkVolumeWithBody request with any body
	UnlinkVolumeWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnlinkVolume(ctx context.Context, spaceId SpaceId, id string, body UnlinkVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVpcs request
	ReadVpcs(ctx context.Context, spaceId SpaceId, params *ReadVpcsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVpcWithBody request with any body
	CreateVpcWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVpc(ctx context.Context, spaceId SpaceId, body CreateVpcJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVpc request
	DeleteVpc(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVpcsById request
	ReadVpcsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVpcWithBody request with any body
	UpdateVpcWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVpc(ctx context.Context, spaceId SpaceId, id string, body UpdateVpcJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteClientGateway request
	DeleteClientGateway(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadClientGateway request
	ReadClientGateway(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListClientGateways request
	ListClientGateways(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateClientGatewayWithBody request with any body
	CreateClientGatewayWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateClientGateway(ctx context.Context, spaceId SpaceId, body CreateClientGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListComputeBridges request
	ListComputeBridges(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateComputeBridgeWithBody request with any body
	CreateComputeBridgeWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateComputeBridge(ctx context.Context, spaceId SpaceId, body CreateComputeBridgeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteComputeBridge request
	DeleteComputeBridge(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadComputeBridge request
	ReadComputeBridge(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDirectLinkInterfaces request
	ListDirectLinkInterfaces(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDirectLinkInterfaceWithBody request with any body
	CreateDirectLinkInterfaceWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDirectLinkInterface(ctx context.Context, spaceId SpaceId, body CreateDirectLinkInterfaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDirectLinkInterface request
	DeleteDirectLinkInterface(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadDirectLinkInterface request
	ReadDirectLinkInterface(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDirectLinks request
	ListDirectLinks(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDirectLinkWithBody request with any body
	CreateDirectLinkWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDirectLink(ctx context.Context, spaceId SpaceId, body CreateDirectLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDirectLink request
	DeleteDirectLink(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadDirectLink request
	ReadDirectLink(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListHybridBridges request
	ListHybridBridges(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHybridBridgeWithBody request with any body
	CreateHybridBridgeWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHybridBridge(ctx context.Context, spaceId SpaceId, body CreateHybridBridgeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHybridBridge request
	DeleteHybridBridge(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadHybridBridge request
	ReadHybridBridge(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListManagedServicesBridges request
	ListManagedServicesBridges(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateManagedServicesBridgeWithBody request with any body
	CreateManagedServicesBridgeWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateManagedServicesBridge(ctx context.Context, spaceId SpaceId, body CreateManagedServicesBridgeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteManagedServicesBridge request
	DeleteManagedServicesBridge(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadManagedServicesBridge request
	ReadManagedServicesBridge(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadLocations request
	ReadLocations(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVirtualGateway request
	DeleteVirtualGateway(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVirtualGateway request
	ReadVirtualGateway(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkVirtualGatewayWithBody request with any body
	UnlinkVirtualGatewayWithBody(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnlinkVirtualGateway(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, body UnlinkVirtualGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkVirtualGatewayWithBody request with any body
	LinkVirtualGatewayWithBody(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkVirtualGateway(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, body LinkVirtualGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListVirtualGateways request
	ListVirtualGateways(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVirtualGatewayWithBody request with any body
	CreateVirtualGatewayWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVirtualGateway(ctx context.Context, spaceId SpaceId, body CreateVirtualGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVPNConnection request
	DeleteVPNConnection(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVPNConnection request
	ReadVPNConnection(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVPNConnectionRouteWithBody request with any body
	DeleteVPNConnectionRouteWithBody(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteVPNConnectionRoute(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, body DeleteVPNConnectionRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVPNConnectionRouteWithBody request with any body
	CreateVPNConnectionRouteWithBody(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVPNConnectionRoute(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, body CreateVPNConnectionRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListVPNConnections request
	ListVPNConnections(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVPNConnectionWithBody request with any body
	CreateVPNConnectionWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVPNConnection(ctx context.Context, spaceId SpaceId, body CreateVPNConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JsonWebKeys request
	JsonWebKeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DiscoverOidcConfiguration request
	DiscoverOidcConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWebAuthnJavaScript request
	GetWebAuthnJavaScript(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAdminServiceAccountSpaceWithBody request with any body
	CreateAdminServiceAccountSpaceWithBody(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAdminServiceAccountSpace(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, body CreateAdminServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Consent request
	Consent(ctx context.Context, params *ConsentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFlowError request
	GetFlowError(ctx context.Context, params *GetFlowErrorParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateLoginFlowWithBody request with any body
	UpdateLoginFlowWithBody(ctx context.Context, params *UpdateLoginFlowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateLoginFlow(ctx context.Context, params *UpdateLoginFlowParams, body UpdateLoginFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateLoginFlowWithFormdataBody(ctx context.Context, params *UpdateLoginFlowParams, body UpdateLoginFlowFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBrowserLoginFlow request
	CreateBrowserLoginFlow(ctx context.Context, params *CreateBrowserLoginFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLoginFlow request
	GetLoginFlow(ctx context.Context, params *GetLoginFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateLogoutFlow request
	UpdateLogoutFlow(ctx context.Context, params *UpdateLogoutFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBrowserLogoutFlow request
	CreateBrowserLogoutFlow(ctx context.Context, params *CreateBrowserLogoutFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InitRecoveryFlow request
	InitRecoveryFlow(ctx context.Context, params *InitRecoveryFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRecoveryFlowWithBody request with any body
	UpdateRecoveryFlowWithBody(ctx context.Context, params *UpdateRecoveryFlowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRecoveryFlow(ctx context.Context, params *UpdateRecoveryFlowParams, body UpdateRecoveryFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRecoveryFlowWithFormdataBody(ctx context.Context, params *UpdateRecoveryFlowParams, body UpdateRecoveryFlowFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBrowserRecoveryFlow request
	CreateBrowserRecoveryFlow(ctx context.Context, params *CreateBrowserRecoveryFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRecoveryFlow request
	GetRecoveryFlow(ctx context.Context, params *GetRecoveryFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSettingsFloWithBody request with any body
	UpdateSettingsFloWithBody(ctx context.Context, params *UpdateSettingsFloParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSettingsFlo(ctx context.Context, params *UpdateSettingsFloParams, body UpdateSettingsFloJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSettingsFloWithFormdataBody(ctx context.Context, params *UpdateSettingsFloParams, body UpdateSettingsFloFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBrowserSettingsFlow request
	CreateBrowserSettingsFlow(ctx context.Context, params *CreateBrowserSettingsFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSettingsFlow request
	GetSettingsFlow(ctx context.Context, params *GetSettingsFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ToSession request
	ToSession(ctx context.Context, params *ToSessionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IntrospectWithBody request with any body
	IntrospectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IntrospectWithFormdataBody(ctx context.Context, body IntrospectFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListOrganisationsIdentity request
	ListOrganisationsIdentity(ctx context.Context, params *ListOrganisationsIdentityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIAMPolicyOrganisation request
	GetIAMPolicyOrganisation(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetIAMPolicyOrganisationWithBody request with any body
	SetIAMPolicyOrganisationWithBody(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetIAMPolicyOrganisation(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, body SetIAMPolicyOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MatchServiceAccountOrganisation request
	MatchServiceAccountOrganisation(ctx context.Context, organisationId OrganisationId, params *MatchServiceAccountOrganisationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserOrganisationByEmail request
	GetUserOrganisationByEmail(ctx context.Context, organisationId OrganisationId, params *GetUserOrganisationByEmailParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPermissionsOrganisation request
	ListPermissionsOrganisation(ctx context.Context, organisationId OrganisationId, params *ListPermissionsOrganisationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPermissionOrganisation request
	GetPermissionOrganisation(ctx context.Context, organisationId OrganisationId, permissionUuid PermissionUuid, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRolesOrganisation request
	ListRolesOrganisation(ctx context.Context, organisationId OrganisationId, params *ListRolesOrganisationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRoleOrganisation request
	GetRoleOrganisation(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRolePermissionsOrganisation request
	GetRolePermissionsOrganisation(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, params *GetRolePermissionsOrganisationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListServiceAccountOrganisation request
	ListServiceAccountOrganisation(ctx context.Context, organisationId OrganisationId, params *ListServiceAccountOrganisationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateServiceAccountOrganisationWithBody request with any body
	CreateServiceAccountOrganisationWithBody(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateServiceAccountOrganisation(ctx context.Context, organisationId OrganisationId, body CreateServiceAccountOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServiceAccountOrganisation request
	DeleteServiceAccountOrganisation(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServiceAccountOrganisation request
	GetServiceAccountOrganisation(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateServiceAccountOrganisationWithBody request with any body
	UpdateServiceAccountOrganisationWithBody(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateServiceAccountOrganisation(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, body UpdateServiceAccountOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetACLServiceAccountOrganisation request
	GetACLServiceAccountOrganisation(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, params *GetACLServiceAccountOrganisationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteACLServiceAccountOrganisationBulkWithBody request with any body
	DeleteACLServiceAccountOrganisationBulkWithBody(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteACLServiceAccountOrganisationBulk(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, body DeleteACLServiceAccountOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateACLServiceAccountOrganisationBulkWithBody request with any body
	CreateACLServiceAccountOrganisationBulkWithBody(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateACLServiceAccountOrganisationBulk(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, body CreateACLServiceAccountOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSpacesOfServiceAccount request
	ListSpacesOfServiceAccount(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, params *ListSpacesOfServiceAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSpacesIdentity request
	ListSpacesIdentity(ctx context.Context, organisationId OrganisationId, params *ListSpacesIdentityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserOrganisation request
	ListUserOrganisation(ctx context.Context, organisationId OrganisationId, params *ListUserOrganisationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserOrganisationWithBody request with any body
	CreateUserOrganisationWithBody(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUserOrganisation(ctx context.Context, organisationId OrganisationId, body CreateUserOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserOrganisation request
	DeleteUserOrganisation(ctx context.Context, organisationId OrganisationId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserOrganisation request
	GetUserOrganisation(ctx context.Context, organisationId OrganisationId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchUserStateOrganisationWithBody request with any body
	PatchUserStateOrganisationWithBody(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchUserStateOrganisation(ctx context.Context, organisationId OrganisationId, userId UserId, body PatchUserStateOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserOrganisationWithBody request with any body
	UpdateUserOrganisationWithBody(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUserOrganisation(ctx context.Context, organisationId OrganisationId, userId UserId, body UpdateUserOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetACLUserOrganisation request
	GetACLUserOrganisation(ctx context.Context, organisationId OrganisationId, userId UserId, params *GetACLUserOrganisationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteACLUserOrganisationBulkWithBody request with any body
	DeleteACLUserOrganisationBulkWithBody(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteACLUserOrganisationBulk(ctx context.Context, organisationId OrganisationId, userId UserId, body DeleteACLUserOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateACLUserOrganisationBulkWithBody request with any body
	CreateACLUserOrganisationBulkWithBody(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateACLUserOrganisationBulk(ctx context.Context, organisationId OrganisationId, userId UserId, body CreateACLUserOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RecoverUserOrganisation request
	RecoverUserOrganisation(ctx context.Context, organisationId OrganisationId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSpacesOfUser request
	ListSpacesOfUser(ctx context.Context, organisationId OrganisationId, userId UserId, params *ListSpacesOfUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevokeWithBody request with any body
	RevokeWithBody(ctx context.Context, params *RevokeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevokeWithFormdataBody(ctx context.Context, params *RevokeParams, body RevokeFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIAMPolicySpace request
	GetIAMPolicySpace(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetIAMPolicySpaceWithBody request with any body
	SetIAMPolicySpaceWithBody(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetIAMPolicySpace(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, body SetIAMPolicySpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MatchServiceAccountSpace request
	MatchServiceAccountSpace(ctx context.Context, spaceId SpaceId, params *MatchServiceAccountSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserSpaceByEmail request
	GetUserSpaceByEmail(ctx context.Context, spaceId SpaceId, params *GetUserSpaceByEmailParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPermissionsSpace request
	ListPermissionsSpace(ctx context.Context, spaceId SpaceId, params *ListPermissionsSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPermissionSpace request
	GetPermissionSpace(ctx context.Context, spaceId SpaceId, permissionUuid PermissionUuid, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRolesSpace request
	ListRolesSpace(ctx context.Context, spaceId SpaceId, params *ListRolesSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRoleSpace request
	GetRoleSpace(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRolePermissionsSpace request
	GetRolePermissionsSpace(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, params *GetRolePermissionsSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListServiceAccountSpace request
	ListServiceAccountSpace(ctx context.Context, spaceId SpaceId, params *ListServiceAccountSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateServiceAccountSpaceWithBody request with any body
	CreateServiceAccountSpaceWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateServiceAccountSpace(ctx context.Context, spaceId SpaceId, body CreateServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServiceAccountSpace request
	DeleteServiceAccountSpace(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServiceAccountSpace request
	GetServiceAccountSpace(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignServiceAccountToSpace request
	AssignServiceAccountToSpace(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateServiceAccountSpaceWithBody request with any body
	UpdateServiceAccountSpaceWithBody(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateServiceAccountSpace(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, body UpdateServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetACLServiceAccountSpace request
	GetACLServiceAccountSpace(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, params *GetACLServiceAccountSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteACLServiceAccountSpaceBulkWithBody request with any body
	DeleteACLServiceAccountSpaceBulkWithBody(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteACLServiceAccountSpaceBulk(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, body DeleteACLServiceAccountSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateACLServiceAccountSpaceBulkWithBody request with any body
	CreateACLServiceAccountSpaceBulkWithBody(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateACLServiceAccountSpaceBulk(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, body CreateACLServiceAccountSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserSpace request
	ListUserSpace(ctx context.Context, spaceId SpaceId, params *ListUserSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserSpaceWithBody request with any body
	CreateUserSpaceWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUserSpace(ctx context.Context, spaceId SpaceId, body CreateUserSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnassignUserSpace request
	UnassignUserSpace(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserSpace request
	GetUserSpace(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchUserStateSpaceWithBody request with any body
	PatchUserStateSpaceWithBody(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchUserStateSpace(ctx context.Context, spaceId SpaceId, userId UserId, body PatchUserStateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignUserToSpace request
	AssignUserToSpace(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserSpaceWithBody request with any body
	UpdateUserSpaceWithBody(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUserSpace(ctx context.Context, spaceId SpaceId, userId UserId, body UpdateUserSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetACLUserSpace request
	GetACLUserSpace(ctx context.Context, spaceId SpaceId, userId UserId, params *GetACLUserSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteACLUserSpaceBulkWithBody request with any body
	DeleteACLUserSpaceBulkWithBody(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteACLUserSpaceBulk(ctx context.Context, spaceId SpaceId, userId UserId, body DeleteACLUserSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateACLUserSpaceBulkWithBody request with any body
	CreateACLUserSpaceBulkWithBody(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateACLUserSpaceBulk(ctx context.Context, spaceId SpaceId, userId UserId, body CreateACLUserSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RecoverUserSpace request
	RecoverUserSpace(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TokenWithBody request with any body
	TokenWithBody(ctx context.Context, params *TokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TokenWithFormdataBody(ctx context.Context, params *TokenParams, body TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConvertTokenWithBody request with any body
	ConvertTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConvertToken(ctx context.Context, body ConvertTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserInfo request
	GetUserInfo(ctx context.Context, params *GetUserInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Healthcheck request
	Healthcheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListKubernetesSupportedNodeProfiles request
	ListKubernetesSupportedNodeProfiles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListKubernetesClusters request
	ListKubernetesClusters(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateKubernetesClusterWithBody request with any body
	CreateKubernetesClusterWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateKubernetesCluster(ctx context.Context, spaceId SpaceId, body CreateKubernetesClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteKubernetesCluster request
	DeleteKubernetesCluster(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKubernetesClusterInfo request
	GetKubernetesClusterInfo(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKubernetesKubeConfig request
	GetKubernetesKubeConfig(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpgradeKubernetesMastersWithBody request with any body
	UpgradeKubernetesMastersWithBody(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpgradeKubernetesMasters(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, body UpgradeKubernetesMastersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListKubernetesOperations request
	ListKubernetesOperations(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKubernetesPrivateKey request
	GetKubernetesPrivateKey(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKubernetesClusterState request
	GetKubernetesClusterState(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateKubernetesNodes request
	UpdateKubernetesNodes(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddKubernetesWorkersWithBody request with any body
	AddKubernetesWorkersWithBody(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddKubernetesWorkers(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, body AddKubernetesWorkersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveKubernetesWorkerWithBody request with any body
	RemoveKubernetesWorkerWithBody(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveKubernetesWorker(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, body RemoveKubernetesWorkerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpgradeKubernetesWorkersWithBody request with any body
	UpgradeKubernetesWorkersWithBody(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpgradeKubernetesWorkers(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, body UpgradeKubernetesWorkersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKubernetesOperation request
	GetKubernetesOperation(ctx context.Context, spaceId SpaceId, operationId OperationId, params *GetKubernetesOperationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListKubernetesSupportedVersions request
	ListKubernetesSupportedVersions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListClusters request
	ListClusters(ctx context.Context, spaceId SpaceId, params *ListClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateClusterWithBody request with any body
	CreateClusterWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCluster(ctx context.Context, spaceId SpaceId, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCluster request
	DeleteCluster(ctx context.Context, spaceId SpaceId, clusterId OpenShiftClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCluster request
	GetCluster(ctx context.Context, spaceId SpaceId, clusterId OpenShiftClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateClusterWithBody request with any body
	UpdateClusterWithBody(ctx context.Context, spaceId SpaceId, clusterId OpenShiftClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCluster(ctx context.Context, spaceId SpaceId, clusterId OpenShiftClusterId, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListNodepools request
	ListNodepools(ctx context.Context, spaceId SpaceId, clusterId OpenShiftClusterId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNodePoolWithBody request with any body
	CreateNodePoolWithBody(ctx context.Context, spaceId SpaceId, clusterId OpenShiftClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNodePool(ctx context.Context, spaceId SpaceId, clusterId OpenShiftClusterId, body CreateNodePoolJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNodePool request
	DeleteNodePool(ctx context.Context, spaceId SpaceId, clusterId OpenShiftClusterId, nodePoolName OpenShiftNodepoolName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateNodepoolWithBody request with any body
	UpdateNodepoolWithBody(ctx context.Context, spaceId SpaceId, clusterId OpenShiftClusterId, nodePoolName OpenShiftNodepoolName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateNodepool(ctx context.Context, spaceId SpaceId, clusterId OpenShiftClusterId, nodePoolName OpenShiftNodepoolName, body UpdateNodepoolJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListOperations request
	ListOperations(ctx context.Context, spaceId SpaceId, params *ListOperationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOperation request
	GetOperation(ctx context.Context, spaceId SpaceId, operationId OperationId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListVersions request
	ListVersions(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSpaces request
	ListSpaces(ctx context.Context, organisationId OrganisationId, params *ListSpacesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSpaceWithBody request with any body
	CreateSpaceWithBody(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSpace(ctx context.Context, organisationId OrganisationId, body CreateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSpace request
	DeleteSpace(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpaceById request
	GetSpaceById(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSpaceWithBody request with any body
	UpdateSpaceWithBody(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSpace(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, body UpdateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostgreSQLGetAvailableClusterConfigurations request
	PostgreSQLGetAvailableClusterConfigurations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostgreSQLGetClusterAutomaticBackupInformation request
	PostgreSQLGetClusterAutomaticBackupInformation(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostgreSQLListBackups request
	PostgreSQLListBackups(ctx context.Context, spaceId SpaceId, params *PostgreSQLListBackupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostgreSQLDeleteBackup request
	PostgreSQLDeleteBackup(ctx context.Context, spaceId SpaceId, backupId PostgresBackupIdParameter, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostgreSQLListClusters request
	PostgreSQLListClusters(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostgreSQLCreateClusterWithBody request with any body
	PostgreSQLCreateClusterWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostgreSQLCreateCluster(ctx context.Context, spaceId SpaceId, body PostgreSQLCreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostgreSQLDeleteClusterWithBody request with any body
	PostgreSQLDeleteClusterWithBody(ctx context.Context, spaceId SpaceId, clusterId PostgresClusterIdParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostgreSQLDeleteCluster(ctx context.Context, spaceId SpaceId, clusterId PostgresClusterIdParameter, body PostgreSQLDeleteClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostgreSQLGetCluster request
	PostgreSQLGetCluster(ctx context.Context, spaceId SpaceId, clusterId PostgresClusterIdParameter, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostgreSQLModifyClusterWithBody request with any body
	PostgreSQLModifyClusterWithBody(ctx context.Context, spaceId SpaceId, clusterId PostgresClusterIdParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostgreSQLModifyCluster(ctx context.Context, spaceId SpaceId, clusterId PostgresClusterIdParameter, body PostgreSQLModifyClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostgreSQLListClusterBackups request
	PostgreSQLListClusterBackups(ctx context.Context, spaceId SpaceId, clusterId PostgresClusterIdParameter, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OldPostgreSQLResetClusterAdministrationPassword request
	OldPostgreSQLResetClusterAdministrationPassword(ctx context.Context, spaceId SpaceId, clusterId PostgresClusterIdParameter, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostgreSQLResetClusterAdministrationPassword request
	PostgreSQLResetClusterAdministrationPassword(ctx context.Context, spaceId SpaceId, clusterId PostgresClusterIdParameter, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) DeleteLoadBalancerTagsWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLoadBalancerTagsRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLoadBalancerTags(ctx context.Context, spaceId SpaceId, body DeleteLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLoadBalancerTagsRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLoadBalancerTagsWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLoadBalancerTagsRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLoadBalancerTags(ctx context.Context, spaceId SpaceId, body CreateLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLoadBalancerTagsRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTagsWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTagsRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTags(ctx context.Context, spaceId SpaceId, body DeleteTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTagsRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTagsWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTagsRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTags(ctx context.Context, spaceId SpaceId, body CreateTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTagsRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadDhcpOptions(ctx context.Context, spaceId SpaceId, params *ReadDhcpOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadDhcpOptionsRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDhcpOptionsWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDhcpOptionsRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDhcpOptions(ctx context.Context, spaceId SpaceId, body CreateDhcpOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDhcpOptionsRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDhcpOptions(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDhcpOptionsRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadDhcpOptionsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadDhcpOptionsByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadFlexibleGpus(ctx context.Context, spaceId SpaceId, params *ReadFlexibleGpusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadFlexibleGpusRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFlexibleGpuWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFlexibleGpuRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFlexibleGpu(ctx context.Context, spaceId SpaceId, body CreateFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFlexibleGpuRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFlexibleGpu(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFlexibleGpuRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadFlexibleGpusById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadFlexibleGpusByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFlexibleGpuWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFlexibleGpuRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFlexibleGpu(ctx context.Context, spaceId SpaceId, id string, body UpdateFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFlexibleGpuRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkFlexibleGpuWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkFlexibleGpuRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkFlexibleGpu(ctx context.Context, spaceId SpaceId, id string, body LinkFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkFlexibleGpuRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkFlexibleGpu(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkFlexibleGpuRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadImages(ctx context.Context, spaceId SpaceId, params *ReadImagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadImagesRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateImageWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateImageRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateImage(ctx context.Context, spaceId SpaceId, body CreateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateImageRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteImage(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteImageRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadImagesById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadImagesByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateImageWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateImageRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateImage(ctx context.Context, spaceId SpaceId, id string, body UpdateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateImageRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadInternetGateways(ctx context.Context, spaceId SpaceId, params *ReadInternetGatewaysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadInternetGatewaysRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateInternetGateway(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateInternetGatewayRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteInternetGateway(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteInternetGatewayRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadInternetGatewaysById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadInternetGatewaysByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkInternetGatewayWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkInternetGatewayRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkInternetGateway(ctx context.Context, spaceId SpaceId, id string, body LinkInternetGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkInternetGatewayRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkInternetGatewayWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkInternetGatewayRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkInternetGateway(ctx context.Context, spaceId SpaceId, id string, body UnlinkInternetGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkInternetGatewayRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadKeypairs(ctx context.Context, spaceId SpaceId, params *ReadKeypairsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadKeypairsRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKeypairWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeypairRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKeypair(ctx context.Context, spaceId SpaceId, body CreateKeypairJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeypairRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteKeypair(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteKeypairRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadKeypairsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadKeypairsByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadListenerRules(ctx context.Context, spaceId SpaceId, params *ReadListenerRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadListenerRulesRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateListenerRuleWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateListenerRuleRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateListenerRule(ctx context.Context, spaceId SpaceId, body CreateListenerRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateListenerRuleRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteListenerRule(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteListenerRuleRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadListenerRulesById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadListenerRulesByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateListenerRuleWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateListenerRuleRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateListenerRule(ctx context.Context, spaceId SpaceId, id string, body UpdateListenerRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateListenerRuleRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadLoadBalancers(ctx context.Context, spaceId SpaceId, params *ReadLoadBalancersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadLoadBalancersRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLoadBalancerWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLoadBalancerRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLoadBalancer(ctx context.Context, spaceId SpaceId, body CreateLoadBalancerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLoadBalancerRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLoadBalancer(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLoadBalancerRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadLoadBalancersById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadLoadBalancersByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLoadBalancerWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLoadBalancerRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLoadBalancer(ctx context.Context, spaceId SpaceId, id string, body UpdateLoadBalancerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLoadBalancerRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkLoadBalancerBackendMachinesWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkLoadBalancerBackendMachinesRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkLoadBalancerBackendMachines(ctx context.Context, spaceId SpaceId, id string, body LinkLoadBalancerBackendMachinesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkLoadBalancerBackendMachinesRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkLoadBalancerBackendMachinesWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkLoadBalancerBackendMachinesRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkLoadBalancerBackendMachines(ctx context.Context, spaceId SpaceId, id string, body UnlinkLoadBalancerBackendMachinesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkLoadBalancerBackendMachinesRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLoadBalancerListenersWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLoadBalancerListenersRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLoadBalancerListeners(ctx context.Context, spaceId SpaceId, id string, body DeleteLoadBalancerListenersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLoadBalancerListenersRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLoadBalancerListenersWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLoadBalancerListenersRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLoadBalancerListeners(ctx context.Context, spaceId SpaceId, id string, body CreateLoadBalancerListenersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLoadBalancerListenersRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLoadBalancerPolicyWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLoadBalancerPolicyRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLoadBalancerPolicy(ctx context.Context, spaceId SpaceId, id string, body DeleteLoadBalancerPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLoadBalancerPolicyRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLoadBalancerPolicyWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLoadBalancerPolicyRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLoadBalancerPolicy(ctx context.Context, spaceId SpaceId, id string, body CreateLoadBalancerPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLoadBalancerPolicyRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVmsHealthWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVmsHealthRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVmsHealth(ctx context.Context, spaceId SpaceId, id string, body ReadVmsHealthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVmsHealthRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadLoadBalancerTagsWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadLoadBalancerTagsRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadLoadBalancerTags(ctx context.Context, spaceId SpaceId, body ReadLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadLoadBalancerTagsRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadNatGateway(ctx context.Context, spaceId SpaceId, params *ReadNatGatewayParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadNatGatewayRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNatGatewayWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNatGatewayRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNatGateway(ctx context.Context, spaceId SpaceId, body CreateNatGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNatGatewayRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNatGateway(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNatGatewayRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadNatGatewayById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadNatGatewayByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadNics(ctx context.Context, spaceId SpaceId, params *ReadNicsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadNicsRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNicWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNicRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNic(ctx context.Context, spaceId SpaceId, body CreateNicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNicRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNic(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNicRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadNicsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadNicsByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNicWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNicRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNic(ctx context.Context, spaceId SpaceId, id string, body UpdateNicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNicRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkPrivateIpsWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkPrivateIpsRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkPrivateIps(ctx context.Context, spaceId SpaceId, id string, body LinkPrivateIpsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkPrivateIpsRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkPrivateIpsWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkPrivateIpsRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkPrivateIps(ctx context.Context, spaceId SpaceId, id string, body UnlinkPrivateIpsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkPrivateIpsRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkNicWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkNicRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkNic(ctx context.Context, spaceId SpaceId, id string, body LinkNicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkNicRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkNicWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkNicRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkNic(ctx context.Context, spaceId SpaceId, id string, body UnlinkNicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkNicRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadPublicIps(ctx context.Context, spaceId SpaceId, params *ReadPublicIpsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadPublicIpsRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePublicIp(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePublicIpRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePublicIp(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePublicIpRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadPublicIpsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadPublicIpsByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkPublicIpWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkPublicIpRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkPublicIp(ctx context.Context, spaceId SpaceId, id string, body LinkPublicIpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkPublicIpRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkPublicIpWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkPublicIpRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkPublicIp(ctx context.Context, spaceId SpaceId, id string, body UnlinkPublicIpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkPublicIpRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadRouteTables(ctx context.Context, spaceId SpaceId, params *ReadRouteTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadRouteTablesRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRouteTableWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRouteTableRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRouteTable(ctx context.Context, spaceId SpaceId, body CreateRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRouteTableRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRouteTable(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRouteTableRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadRouteTablesById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadRouteTablesByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRouteTableRoutePropagationWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRouteTableRoutePropagationRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRouteTableRoutePropagation(ctx context.Context, spaceId SpaceId, id string, body UpdateRouteTableRoutePropagationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRouteTableRoutePropagationRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRouteWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRouteRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRoute(ctx context.Context, spaceId SpaceId, id string, body DeleteRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRouteRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRouteWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRouteRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRoute(ctx context.Context, spaceId SpaceId, id string, body CreateRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRouteRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRouteWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRouteRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRoute(ctx context.Context, spaceId SpaceId, id string, body UpdateRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRouteRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkRouteTableWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkRouteTableRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkRouteTable(ctx context.Context, spaceId SpaceId, id string, body LinkRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkRouteTableRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkRouteTableWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkRouteTableRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkRouteTable(ctx context.Context, spaceId SpaceId, id string, body UnlinkRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkRouteTableRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadSecurityGroups(ctx context.Context, spaceId SpaceId, params *ReadSecurityGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadSecurityGroupsRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSecurityGroupWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSecurityGroupRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSecurityGroup(ctx context.Context, spaceId SpaceId, body CreateSecurityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSecurityGroupRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSecurityGroup(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSecurityGroupRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadSecurityGroupsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadSecurityGroupsByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSecurityGroupRuleWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSecurityGroupRuleRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSecurityGroupRule(ctx context.Context, spaceId SpaceId, id string, body DeleteSecurityGroupRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSecurityGroupRuleRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSecurityGroupRuleWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSecurityGroupRuleRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSecurityGroupRule(ctx context.Context, spaceId SpaceId, id string, body CreateSecurityGroupRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSecurityGroupRuleRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadServerCertificates(ctx context.Context, spaceId SpaceId, params *ReadServerCertificatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadServerCertificatesRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServerCertificateWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerCertificateRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServerCertificate(ctx context.Context, spaceId SpaceId, body CreateServerCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerCertificateRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServerCertificate(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServerCertificateRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServerCertificateWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServerCertificateRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServerCertificate(ctx context.Context, spaceId SpaceId, id string, body UpdateServerCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServerCertificateRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadSnapshots(ctx context.Context, spaceId SpaceId, params *ReadSnapshotsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadSnapshotsRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSnapshotWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSnapshotRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSnapshot(ctx context.Context, spaceId SpaceId, body CreateSnapshotJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSnapshotRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSnapshot(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSnapshotRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadSnapshotsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadSnapshotsByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadSubnets(ctx context.Context, spaceId SpaceId, params *ReadSubnetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadSubnetsRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSubnetWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSubnetRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSubnet(ctx context.Context, spaceId SpaceId, body CreateSubnetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSubnetRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSubnet(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSubnetRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadSubnetsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadSubnetsByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSubnetWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSubnetRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSubnet(ctx context.Context, spaceId SpaceId, id string, body UpdateSubnetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSubnetRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadTags(ctx context.Context, spaceId SpaceId, params *ReadTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadTagsRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVms(ctx context.Context, spaceId SpaceId, params *ReadVmsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVmsRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVmsWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVmsRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVms(ctx context.Context, spaceId SpaceId, body CreateVmsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVmsRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVmsState(ctx context.Context, spaceId SpaceId, params *ReadVmsStateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVmsStateRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVms(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVmsRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVmsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVmsByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVmWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVmRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVm(ctx context.Context, spaceId SpaceId, id string, body UpdateVmJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVmRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadAdminPassword(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadAdminPasswordRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadConsoleOutput(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadConsoleOutputRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RebootVm(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRebootVmRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartVm(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartVmRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopVmWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopVmRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopVm(ctx context.Context, spaceId SpaceId, id string, body StopVmJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopVmRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVolumes(ctx context.Context, spaceId SpaceId, params *ReadVolumesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVolumesRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVolumeWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVolumeRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVolume(ctx context.Context, spaceId SpaceId, body CreateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVolumeRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVolume(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVolumeRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVolumesById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVolumesByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVolumeWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVolumeRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVolume(ctx context.Context, spaceId SpaceId, id string, body UpdateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVolumeRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkVolumeWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkVolumeRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkVolume(ctx context.Context, spaceId SpaceId, id string, body LinkVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkVolumeRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkVolumeWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkVolumeRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkVolume(ctx context.Context, spaceId SpaceId, id string, body UnlinkVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkVolumeRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVpcs(ctx context.Context, spaceId SpaceId, params *ReadVpcsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVpcsRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVpcWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVpcRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVpc(ctx context.Context, spaceId SpaceId, body CreateVpcJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVpcRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVpc(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVpcRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVpcsById(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVpcsByIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVpcWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVpcRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVpc(ctx context.Context, spaceId SpaceId, id string, body UpdateVpcJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVpcRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteClientGateway(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClientGatewayRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadClientGateway(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadClientGatewayRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListClientGateways(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListClientGatewaysRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClientGatewayWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientGatewayRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClientGateway(ctx context.Context, spaceId SpaceId, body CreateClientGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientGatewayRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListComputeBridges(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListComputeBridgesRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateComputeBridgeWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateComputeBridgeRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateComputeBridge(ctx context.Context, spaceId SpaceId, body CreateComputeBridgeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateComputeBridgeRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteComputeBridge(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteComputeBridgeRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadComputeBridge(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadComputeBridgeRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDirectLinkInterfaces(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDirectLinkInterfacesRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDirectLinkInterfaceWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDirectLinkInterfaceRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDirectLinkInterface(ctx context.Context, spaceId SpaceId, body CreateDirectLinkInterfaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDirectLinkInterfaceRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDirectLinkInterface(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDirectLinkInterfaceRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadDirectLinkInterface(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadDirectLinkInterfaceRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDirectLinks(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDirectLinksRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDirectLinkWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDirectLinkRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDirectLink(ctx context.Context, spaceId SpaceId, body CreateDirectLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDirectLinkRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDirectLink(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDirectLinkRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadDirectLink(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadDirectLinkRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListHybridBridges(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListHybridBridgesRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHybridBridgeWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHybridBridgeRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHybridBridge(ctx context.Context, spaceId SpaceId, body CreateHybridBridgeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHybridBridgeRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHybridBridge(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHybridBridgeRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadHybridBridge(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadHybridBridgeRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListManagedServicesBridges(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListManagedServicesBridgesRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManagedServicesBridgeWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManagedServicesBridgeRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManagedServicesBridge(ctx context.Context, spaceId SpaceId, body CreateManagedServicesBridgeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManagedServicesBridgeRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteManagedServicesBridge(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteManagedServicesBridgeRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadManagedServicesBridge(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadManagedServicesBridgeRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadLocations(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadLocationsRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVirtualGateway(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVirtualGatewayRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVirtualGateway(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVirtualGatewayRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkVirtualGatewayWithBody(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkVirtualGatewayRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkVirtualGateway(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, body UnlinkVirtualGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkVirtualGatewayRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkVirtualGatewayWithBody(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkVirtualGatewayRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkVirtualGateway(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, body LinkVirtualGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkVirtualGatewayRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListVirtualGateways(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVirtualGatewaysRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVirtualGatewayWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVirtualGatewayRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVirtualGateway(ctx context.Context, spaceId SpaceId, body CreateVirtualGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVirtualGatewayRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVPNConnection(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVPNConnectionRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVPNConnection(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVPNConnectionRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVPNConnectionRouteWithBody(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVPNConnectionRouteRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVPNConnectionRoute(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, body DeleteVPNConnectionRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVPNConnectionRouteRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVPNConnectionRouteWithBody(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVPNConnectionRouteRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVPNConnectionRoute(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, body CreateVPNConnectionRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVPNConnectionRouteRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListVPNConnections(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVPNConnectionsRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVPNConnectionWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVPNConnectionRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVPNConnection(ctx context.Context, spaceId SpaceId, body CreateVPNConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVPNConnectionRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JsonWebKeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJsonWebKeysRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DiscoverOidcConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDiscoverOidcConfigurationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWebAuthnJavaScript(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebAuthnJavaScriptRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAdminServiceAccountSpaceWithBody(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAdminServiceAccountSpaceRequestWithBody(c.Server, organisationId, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAdminServiceAccountSpace(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, body CreateAdminServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAdminServiceAccountSpaceRequest(c.Server, organisationId, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Consent(ctx context.Context, params *ConsentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConsentRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFlowError(ctx context.Context, params *GetFlowErrorParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFlowErrorRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLoginFlowWithBody(ctx context.Context, params *UpdateLoginFlowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLoginFlowRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLoginFlow(ctx context.Context, params *UpdateLoginFlowParams, body UpdateLoginFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLoginFlowRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLoginFlowWithFormdataBody(ctx context.Context, params *UpdateLoginFlowParams, body UpdateLoginFlowFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLoginFlowRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBrowserLoginFlow(ctx context.Context, params *CreateBrowserLoginFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBrowserLoginFlowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLoginFlow(ctx context.Context, params *GetLoginFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLoginFlowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLogoutFlow(ctx context.Context, params *UpdateLogoutFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLogoutFlowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBrowserLogoutFlow(ctx context.Context, params *CreateBrowserLogoutFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBrowserLogoutFlowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InitRecoveryFlow(ctx context.Context, params *InitRecoveryFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInitRecoveryFlowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRecoveryFlowWithBody(ctx context.Context, params *UpdateRecoveryFlowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRecoveryFlowRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRecoveryFlow(ctx context.Context, params *UpdateRecoveryFlowParams, body UpdateRecoveryFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRecoveryFlowRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRecoveryFlowWithFormdataBody(ctx context.Context, params *UpdateRecoveryFlowParams, body UpdateRecoveryFlowFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRecoveryFlowRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBrowserRecoveryFlow(ctx context.Context, params *CreateBrowserRecoveryFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBrowserRecoveryFlowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRecoveryFlow(ctx context.Context, params *GetRecoveryFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRecoveryFlowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSettingsFloWithBody(ctx context.Context, params *UpdateSettingsFloParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSettingsFloRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSettingsFlo(ctx context.Context, params *UpdateSettingsFloParams, body UpdateSettingsFloJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSettingsFloRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSettingsFloWithFormdataBody(ctx context.Context, params *UpdateSettingsFloParams, body UpdateSettingsFloFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSettingsFloRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBrowserSettingsFlow(ctx context.Context, params *CreateBrowserSettingsFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBrowserSettingsFlowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSettingsFlow(ctx context.Context, params *GetSettingsFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSettingsFlowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToSession(ctx context.Context, params *ToSessionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToSessionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IntrospectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIntrospectRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IntrospectWithFormdataBody(ctx context.Context, body IntrospectFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIntrospectRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListOrganisationsIdentity(ctx context.Context, params *ListOrganisationsIdentityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListOrganisationsIdentityRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIAMPolicyOrganisation(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIAMPolicyOrganisationRequest(c.Server, organisationId, subjectType, subjectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetIAMPolicyOrganisationWithBody(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetIAMPolicyOrganisationRequestWithBody(c.Server, organisationId, subjectType, subjectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetIAMPolicyOrganisation(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, body SetIAMPolicyOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetIAMPolicyOrganisationRequest(c.Server, organisationId, subjectType, subjectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MatchServiceAccountOrganisation(ctx context.Context, organisationId OrganisationId, params *MatchServiceAccountOrganisationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMatchServiceAccountOrganisationRequest(c.Server, organisationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserOrganisationByEmail(ctx context.Context, organisationId OrganisationId, params *GetUserOrganisationByEmailParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserOrganisationByEmailRequest(c.Server, organisationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPermissionsOrganisation(ctx context.Context, organisationId OrganisationId, params *ListPermissionsOrganisationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPermissionsOrganisationRequest(c.Server, organisationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPermissionOrganisation(ctx context.Context, organisationId OrganisationId, permissionUuid PermissionUuid, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPermissionOrganisationRequest(c.Server, organisationId, permissionUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRolesOrganisation(ctx context.Context, organisationId OrganisationId, params *ListRolesOrganisationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRolesOrganisationRequest(c.Server, organisationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRoleOrganisation(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRoleOrganisationRequest(c.Server, organisationId, roleUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRolePermissionsOrganisation(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, params *GetRolePermissionsOrganisationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRolePermissionsOrganisationRequest(c.Server, organisationId, roleUuid, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListServiceAccountOrganisation(ctx context.Context, organisationId OrganisationId, params *ListServiceAccountOrganisationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListServiceAccountOrganisationRequest(c.Server, organisationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServiceAccountOrganisationWithBody(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceAccountOrganisationRequestWithBody(c.Server, organisationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServiceAccountOrganisation(ctx context.Context, organisationId OrganisationId, body CreateServiceAccountOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceAccountOrganisationRequest(c.Server, organisationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServiceAccountOrganisation(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServiceAccountOrganisationRequest(c.Server, organisationId, serviceAccountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServiceAccountOrganisation(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServiceAccountOrganisationRequest(c.Server, organisationId, serviceAccountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServiceAccountOrganisationWithBody(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServiceAccountOrganisationRequestWithBody(c.Server, organisationId, serviceAccountId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServiceAccountOrganisation(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, body UpdateServiceAccountOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServiceAccountOrganisationRequest(c.Server, organisationId, serviceAccountId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetACLServiceAccountOrganisation(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, params *GetACLServiceAccountOrganisationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetACLServiceAccountOrganisationRequest(c.Server, organisationId, serviceAccountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteACLServiceAccountOrganisationBulkWithBody(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteACLServiceAccountOrganisationBulkRequestWithBody(c.Server, organisationId, serviceAccountId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteACLServiceAccountOrganisationBulk(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, body DeleteACLServiceAccountOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteACLServiceAccountOrganisationBulkRequest(c.Server, organisationId, serviceAccountId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateACLServiceAccountOrganisationBulkWithBody(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateACLServiceAccountOrganisationBulkRequestWithBody(c.Server, organisationId, serviceAccountId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateACLServiceAccountOrganisationBulk(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, body CreateACLServiceAccountOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateACLServiceAccountOrganisationBulkRequest(c.Server, organisationId, serviceAccountId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSpacesOfServiceAccount(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, params *ListSpacesOfServiceAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSpacesOfServiceAccountRequest(c.Server, organisationId, serviceAccountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSpacesIdentity(ctx context.Context, organisationId OrganisationId, params *ListSpacesIdentityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSpacesIdentityRequest(c.Server, organisationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserOrganisation(ctx context.Context, organisationId OrganisationId, params *ListUserOrganisationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserOrganisationRequest(c.Server, organisationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserOrganisationWithBody(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserOrganisationRequestWithBody(c.Server, organisationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserOrganisation(ctx context.Context, organisationId OrganisationId, body CreateUserOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserOrganisationRequest(c.Server, organisationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserOrganisation(ctx context.Context, organisationId OrganisationId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserOrganisationRequest(c.Server, organisationId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserOrganisation(ctx context.Context, organisationId OrganisationId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserOrganisationRequest(c.Server, organisationId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchUserStateOrganisationWithBody(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchUserStateOrganisationRequestWithBody(c.Server, organisationId, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchUserStateOrganisation(ctx context.Context, organisationId OrganisationId, userId UserId, body PatchUserStateOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchUserStateOrganisationRequest(c.Server, organisationId, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserOrganisationWithBody(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserOrganisationRequestWithBody(c.Server, organisationId, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserOrganisation(ctx context.Context, organisationId OrganisationId, userId UserId, body UpdateUserOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserOrganisationRequest(c.Server, organisationId, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetACLUserOrganisation(ctx context.Context, organisationId OrganisationId, userId UserId, params *GetACLUserOrganisationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetACLUserOrganisationRequest(c.Server, organisationId, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteACLUserOrganisationBulkWithBody(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteACLUserOrganisationBulkRequestWithBody(c.Server, organisationId, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteACLUserOrganisationBulk(ctx context.Context, organisationId OrganisationId, userId UserId, body DeleteACLUserOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteACLUserOrganisationBulkRequest(c.Server, organisationId, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateACLUserOrganisationBulkWithBody(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateACLUserOrganisationBulkRequestWithBody(c.Server, organisationId, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateACLUserOrganisationBulk(ctx context.Context, organisationId OrganisationId, userId UserId, body CreateACLUserOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateACLUserOrganisationBulkRequest(c.Server, organisationId, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RecoverUserOrganisation(ctx context.Context, organisationId OrganisationId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRecoverUserOrganisationRequest(c.Server, organisationId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSpacesOfUser(ctx context.Context, organisationId OrganisationId, userId UserId, params *ListSpacesOfUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSpacesOfUserRequest(c.Server, organisationId, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokeWithBody(ctx context.Context, params *RevokeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokeRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokeWithFormdataBody(ctx context.Context, params *RevokeParams, body RevokeFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokeRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIAMPolicySpace(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIAMPolicySpaceRequest(c.Server, spaceId, subjectType, subjectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetIAMPolicySpaceWithBody(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetIAMPolicySpaceRequestWithBody(c.Server, spaceId, subjectType, subjectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetIAMPolicySpace(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, body SetIAMPolicySpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetIAMPolicySpaceRequest(c.Server, spaceId, subjectType, subjectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MatchServiceAccountSpace(ctx context.Context, spaceId SpaceId, params *MatchServiceAccountSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMatchServiceAccountSpaceRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserSpaceByEmail(ctx context.Context, spaceId SpaceId, params *GetUserSpaceByEmailParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserSpaceByEmailRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPermissionsSpace(ctx context.Context, spaceId SpaceId, params *ListPermissionsSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPermissionsSpaceRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPermissionSpace(ctx context.Context, spaceId SpaceId, permissionUuid PermissionUuid, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPermissionSpaceRequest(c.Server, spaceId, permissionUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRolesSpace(ctx context.Context, spaceId SpaceId, params *ListRolesSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRolesSpaceRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRoleSpace(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRoleSpaceRequest(c.Server, spaceId, roleUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRolePermissionsSpace(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, params *GetRolePermissionsSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRolePermissionsSpaceRequest(c.Server, spaceId, roleUuid, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListServiceAccountSpace(ctx context.Context, spaceId SpaceId, params *ListServiceAccountSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListServiceAccountSpaceRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServiceAccountSpaceWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceAccountSpaceRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServiceAccountSpace(ctx context.Context, spaceId SpaceId, body CreateServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceAccountSpaceRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServiceAccountSpace(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServiceAccountSpaceRequest(c.Server, spaceId, serviceAccountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServiceAccountSpace(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServiceAccountSpaceRequest(c.Server, spaceId, serviceAccountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignServiceAccountToSpace(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignServiceAccountToSpaceRequest(c.Server, spaceId, serviceAccountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServiceAccountSpaceWithBody(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServiceAccountSpaceRequestWithBody(c.Server, spaceId, serviceAccountId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServiceAccountSpace(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, body UpdateServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServiceAccountSpaceRequest(c.Server, spaceId, serviceAccountId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetACLServiceAccountSpace(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, params *GetACLServiceAccountSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetACLServiceAccountSpaceRequest(c.Server, spaceId, serviceAccountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteACLServiceAccountSpaceBulkWithBody(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteACLServiceAccountSpaceBulkRequestWithBody(c.Server, spaceId, serviceAccountId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteACLServiceAccountSpaceBulk(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, body DeleteACLServiceAccountSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteACLServiceAccountSpaceBulkRequest(c.Server, spaceId, serviceAccountId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateACLServiceAccountSpaceBulkWithBody(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateACLServiceAccountSpaceBulkRequestWithBody(c.Server, spaceId, serviceAccountId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateACLServiceAccountSpaceBulk(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, body CreateACLServiceAccountSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateACLServiceAccountSpaceBulkRequest(c.Server, spaceId, serviceAccountId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserSpace(ctx context.Context, spaceId SpaceId, params *ListUserSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserSpaceRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserSpaceWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserSpaceRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserSpace(ctx context.Context, spaceId SpaceId, body CreateUserSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserSpaceRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnassignUserSpace(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnassignUserSpaceRequest(c.Server, spaceId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserSpace(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserSpaceRequest(c.Server, spaceId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchUserStateSpaceWithBody(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchUserStateSpaceRequestWithBody(c.Server, spaceId, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchUserStateSpace(ctx context.Context, spaceId SpaceId, userId UserId, body PatchUserStateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchUserStateSpaceRequest(c.Server, spaceId, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignUserToSpace(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignUserToSpaceRequest(c.Server, spaceId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserSpaceWithBody(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserSpaceRequestWithBody(c.Server, spaceId, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserSpace(ctx context.Context, spaceId SpaceId, userId UserId, body UpdateUserSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserSpaceRequest(c.Server, spaceId, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetACLUserSpace(ctx context.Context, spaceId SpaceId, userId UserId, params *GetACLUserSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetACLUserSpaceRequest(c.Server, spaceId, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteACLUserSpaceBulkWithBody(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteACLUserSpaceBulkRequestWithBody(c.Server, spaceId, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteACLUserSpaceBulk(ctx context.Context, spaceId SpaceId, userId UserId, body DeleteACLUserSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteACLUserSpaceBulkRequest(c.Server, spaceId, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateACLUserSpaceBulkWithBody(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateACLUserSpaceBulkRequestWithBody(c.Server, spaceId, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateACLUserSpaceBulk(ctx context.Context, spaceId SpaceId, userId UserId, body CreateACLUserSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateACLUserSpaceBulkRequest(c.Server, spaceId, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RecoverUserSpace(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRecoverUserSpaceRequest(c.Server, spaceId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TokenWithBody(ctx context.Context, params *TokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTokenRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TokenWithFormdataBody(ctx context.Context, params *TokenParams, body TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTokenRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConvertTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConvertTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConvertToken(ctx context.Context, body ConvertTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConvertTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserInfo(ctx context.Context, params *GetUserInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserInfoRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Healthcheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHealthcheckRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListKubernetesSupportedNodeProfiles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListKubernetesSupportedNodeProfilesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListKubernetesClusters(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListKubernetesClustersRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKubernetesClusterWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKubernetesClusterRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKubernetesCluster(ctx context.Context, spaceId SpaceId, body CreateKubernetesClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKubernetesClusterRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteKubernetesCluster(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteKubernetesClusterRequest(c.Server, spaceId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKubernetesClusterInfo(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKubernetesClusterInfoRequest(c.Server, spaceId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKubernetesKubeConfig(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKubernetesKubeConfigRequest(c.Server, spaceId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpgradeKubernetesMastersWithBody(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpgradeKubernetesMastersRequestWithBody(c.Server, spaceId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpgradeKubernetesMasters(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, body UpgradeKubernetesMastersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpgradeKubernetesMastersRequest(c.Server, spaceId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListKubernetesOperations(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListKubernetesOperationsRequest(c.Server, spaceId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKubernetesPrivateKey(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKubernetesPrivateKeyRequest(c.Server, spaceId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKubernetesClusterState(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKubernetesClusterStateRequest(c.Server, spaceId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateKubernetesNodes(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateKubernetesNodesRequest(c.Server, spaceId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddKubernetesWorkersWithBody(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddKubernetesWorkersRequestWithBody(c.Server, spaceId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddKubernetesWorkers(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, body AddKubernetesWorkersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddKubernetesWorkersRequest(c.Server, spaceId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveKubernetesWorkerWithBody(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveKubernetesWorkerRequestWithBody(c.Server, spaceId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveKubernetesWorker(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, body RemoveKubernetesWorkerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveKubernetesWorkerRequest(c.Server, spaceId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpgradeKubernetesWorkersWithBody(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpgradeKubernetesWorkersRequestWithBody(c.Server, spaceId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpgradeKubernetesWorkers(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, body UpgradeKubernetesWorkersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpgradeKubernetesWorkersRequest(c.Server, spaceId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKubernetesOperation(ctx context.Context, spaceId SpaceId, operationId OperationId, params *GetKubernetesOperationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKubernetesOperationRequest(c.Server, spaceId, operationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListKubernetesSupportedVersions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListKubernetesSupportedVersionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListClusters(ctx context.Context, spaceId SpaceId, params *ListClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListClustersRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClusterWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClusterRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCluster(ctx context.Context, spaceId SpaceId, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClusterRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCluster(ctx context.Context, spaceId SpaceId, clusterId OpenShiftClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClusterRequest(c.Server, spaceId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCluster(ctx context.Context, spaceId SpaceId, clusterId OpenShiftClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterRequest(c.Server, spaceId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClusterWithBody(ctx context.Context, spaceId SpaceId, clusterId OpenShiftClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClusterRequestWithBody(c.Server, spaceId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCluster(ctx context.Context, spaceId SpaceId, clusterId OpenShiftClusterId, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClusterRequest(c.Server, spaceId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListNodepools(ctx context.Context, spaceId SpaceId, clusterId OpenShiftClusterId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListNodepoolsRequest(c.Server, spaceId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNodePoolWithBody(ctx context.Context, spaceId SpaceId, clusterId OpenShiftClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNodePoolRequestWithBody(c.Server, spaceId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNodePool(ctx context.Context, spaceId SpaceId, clusterId OpenShiftClusterId, body CreateNodePoolJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNodePoolRequest(c.Server, spaceId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNodePool(ctx context.Context, spaceId SpaceId, clusterId OpenShiftClusterId, nodePoolName OpenShiftNodepoolName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNodePoolRequest(c.Server, spaceId, clusterId, nodePoolName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNodepoolWithBody(ctx context.Context, spaceId SpaceId, clusterId OpenShiftClusterId, nodePoolName OpenShiftNodepoolName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNodepoolRequestWithBody(c.Server, spaceId, clusterId, nodePoolName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNodepool(ctx context.Context, spaceId SpaceId, clusterId OpenShiftClusterId, nodePoolName OpenShiftNodepoolName, body UpdateNodepoolJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNodepoolRequest(c.Server, spaceId, clusterId, nodePoolName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListOperations(ctx context.Context, spaceId SpaceId, params *ListOperationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListOperationsRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOperation(ctx context.Context, spaceId SpaceId, operationId OperationId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOperationRequest(c.Server, spaceId, operationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListVersions(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVersionsRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSpaces(ctx context.Context, organisationId OrganisationId, params *ListSpacesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSpacesRequest(c.Server, organisationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpaceWithBody(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpaceRequestWithBody(c.Server, organisationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpace(ctx context.Context, organisationId OrganisationId, body CreateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpaceRequest(c.Server, organisationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSpace(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSpaceRequest(c.Server, organisationId, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpaceById(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpaceByIdRequest(c.Server, organisationId, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSpaceWithBody(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSpaceRequestWithBody(c.Server, organisationId, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSpace(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, body UpdateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSpaceRequest(c.Server, organisationId, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostgreSQLGetAvailableClusterConfigurations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostgreSQLGetAvailableClusterConfigurationsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostgreSQLGetClusterAutomaticBackupInformation(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostgreSQLGetClusterAutomaticBackupInformationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostgreSQLListBackups(ctx context.Context, spaceId SpaceId, params *PostgreSQLListBackupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostgreSQLListBackupsRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostgreSQLDeleteBackup(ctx context.Context, spaceId SpaceId, backupId PostgresBackupIdParameter, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostgreSQLDeleteBackupRequest(c.Server, spaceId, backupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostgreSQLListClusters(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostgreSQLListClustersRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostgreSQLCreateClusterWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostgreSQLCreateClusterRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostgreSQLCreateCluster(ctx context.Context, spaceId SpaceId, body PostgreSQLCreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostgreSQLCreateClusterRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostgreSQLDeleteClusterWithBody(ctx context.Context, spaceId SpaceId, clusterId PostgresClusterIdParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostgreSQLDeleteClusterRequestWithBody(c.Server, spaceId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostgreSQLDeleteCluster(ctx context.Context, spaceId SpaceId, clusterId PostgresClusterIdParameter, body PostgreSQLDeleteClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostgreSQLDeleteClusterRequest(c.Server, spaceId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostgreSQLGetCluster(ctx context.Context, spaceId SpaceId, clusterId PostgresClusterIdParameter, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostgreSQLGetClusterRequest(c.Server, spaceId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostgreSQLModifyClusterWithBody(ctx context.Context, spaceId SpaceId, clusterId PostgresClusterIdParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostgreSQLModifyClusterRequestWithBody(c.Server, spaceId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostgreSQLModifyCluster(ctx context.Context, spaceId SpaceId, clusterId PostgresClusterIdParameter, body PostgreSQLModifyClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostgreSQLModifyClusterRequest(c.Server, spaceId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostgreSQLListClusterBackups(ctx context.Context, spaceId SpaceId, clusterId PostgresClusterIdParameter, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostgreSQLListClusterBackupsRequest(c.Server, spaceId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OldPostgreSQLResetClusterAdministrationPassword(ctx context.Context, spaceId SpaceId, clusterId PostgresClusterIdParameter, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOldPostgreSQLResetClusterAdministrationPasswordRequest(c.Server, spaceId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostgreSQLResetClusterAdministrationPassword(ctx context.Context, spaceId SpaceId, clusterId PostgresClusterIdParameter, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostgreSQLResetClusterAdministrationPasswordRequest(c.Server, spaceId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewDeleteLoadBalancerTagsRequest calls the generic DeleteLoadBalancerTags builder with application/json body
func NewDeleteLoadBalancerTagsRequest(server string, spaceId SpaceId, body DeleteLoadBalancerTagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteLoadBalancerTagsRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewDeleteLoadBalancerTagsRequestWithBody generates requests for DeleteLoadBalancerTags with any type of body
func NewDeleteLoadBalancerTagsRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/bulk/loadBalancersTags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateLoadBalancerTagsRequest calls the generic CreateLoadBalancerTags builder with application/json body
func NewCreateLoadBalancerTagsRequest(server string, spaceId SpaceId, body CreateLoadBalancerTagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLoadBalancerTagsRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateLoadBalancerTagsRequestWithBody generates requests for CreateLoadBalancerTags with any type of body
func NewCreateLoadBalancerTagsRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/bulk/loadBalancersTags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTagsRequest calls the generic DeleteTags builder with application/json body
func NewDeleteTagsRequest(server string, spaceId SpaceId, body DeleteTagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteTagsRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewDeleteTagsRequestWithBody generates requests for DeleteTags with any type of body
func NewDeleteTagsRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/bulk/tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateTagsRequest calls the generic CreateTags builder with application/json body
func NewCreateTagsRequest(server string, spaceId SpaceId, body CreateTagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTagsRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateTagsRequestWithBody generates requests for CreateTags with any type of body
func NewCreateTagsRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/bulk/tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadDhcpOptionsRequest generates requests for ReadDhcpOptions
func NewReadDhcpOptionsRequest(server string, spaceId SpaceId, params *ReadDhcpOptionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/dhcpOptions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Default != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "default", runtime.ParamLocationQuery, *params.Default); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DomainNameServers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domainNameServers", runtime.ParamLocationQuery, *params.DomainNameServers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DomainNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domainNames", runtime.ParamLocationQuery, *params.DomainNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LogServers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "logServers", runtime.ParamLocationQuery, *params.LogServers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NtpServers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ntpServers", runtime.ParamLocationQuery, *params.NtpServers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDhcpOptionsRequest calls the generic CreateDhcpOptions builder with application/json body
func NewCreateDhcpOptionsRequest(server string, spaceId SpaceId, body CreateDhcpOptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDhcpOptionsRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateDhcpOptionsRequestWithBody generates requests for CreateDhcpOptions with any type of body
func NewCreateDhcpOptionsRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/dhcpOptions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDhcpOptionsRequest generates requests for DeleteDhcpOptions
func NewDeleteDhcpOptionsRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/dhcpOptions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadDhcpOptionsByIdRequest generates requests for ReadDhcpOptionsById
func NewReadDhcpOptionsByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/dhcpOptions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadFlexibleGpusRequest generates requests for ReadFlexibleGpus
func NewReadFlexibleGpusRequest(server string, spaceId SpaceId, params *ReadFlexibleGpusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/flexibleGpus", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DeleteOnVmDeletion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleteOnVmDeletion", runtime.ParamLocationQuery, *params.DeleteOnVmDeletion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Generations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "generations", runtime.ParamLocationQuery, *params.Generations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModelNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modelNames", runtime.ParamLocationQuery, *params.ModelNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VmIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vmIds", runtime.ParamLocationQuery, *params.VmIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AvailabilityZoneNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "availabilityZoneNames", runtime.ParamLocationQuery, *params.AvailabilityZoneNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFlexibleGpuRequest calls the generic CreateFlexibleGpu builder with application/json body
func NewCreateFlexibleGpuRequest(server string, spaceId SpaceId, body CreateFlexibleGpuJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFlexibleGpuRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateFlexibleGpuRequestWithBody generates requests for CreateFlexibleGpu with any type of body
func NewCreateFlexibleGpuRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/flexibleGpus", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFlexibleGpuRequest generates requests for DeleteFlexibleGpu
func NewDeleteFlexibleGpuRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/flexibleGpus/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadFlexibleGpusByIdRequest generates requests for ReadFlexibleGpusById
func NewReadFlexibleGpusByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/flexibleGpus/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateFlexibleGpuRequest calls the generic UpdateFlexibleGpu builder with application/json body
func NewUpdateFlexibleGpuRequest(server string, spaceId SpaceId, id string, body UpdateFlexibleGpuJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateFlexibleGpuRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateFlexibleGpuRequestWithBody generates requests for UpdateFlexibleGpu with any type of body
func NewUpdateFlexibleGpuRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/flexibleGpus/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLinkFlexibleGpuRequest calls the generic LinkFlexibleGpu builder with application/json body
func NewLinkFlexibleGpuRequest(server string, spaceId SpaceId, id string, body LinkFlexibleGpuJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkFlexibleGpuRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewLinkFlexibleGpuRequestWithBody generates requests for LinkFlexibleGpu with any type of body
func NewLinkFlexibleGpuRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/flexibleGpus/%s/vms/link", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnlinkFlexibleGpuRequest generates requests for UnlinkFlexibleGpu
func NewUnlinkFlexibleGpuRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/flexibleGpus/%s/vms/unlink", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadImagesRequest generates requests for ReadImages
func NewReadImagesRequest(server string, spaceId SpaceId, params *ReadImagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/images", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AccountAliases != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accountAliases", runtime.ParamLocationQuery, *params.AccountAliases); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Architectures != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "architectures", runtime.ParamLocationQuery, *params.Architectures); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BlockDeviceMappingDeleteOnVmDeletion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blockDeviceMappingDeleteOnVmDeletion", runtime.ParamLocationQuery, *params.BlockDeviceMappingDeleteOnVmDeletion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BlockDeviceMappingDeviceNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blockDeviceMappingDeviceNames", runtime.ParamLocationQuery, *params.BlockDeviceMappingDeviceNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BlockDeviceMappingSnapshotIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blockDeviceMappingSnapshotIds", runtime.ParamLocationQuery, *params.BlockDeviceMappingSnapshotIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BlockDeviceMappingVolumeSizes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blockDeviceMappingVolumeSizes", runtime.ParamLocationQuery, *params.BlockDeviceMappingVolumeSizes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BlockDeviceMappingVolumeTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blockDeviceMappingVolumeTypes", runtime.ParamLocationQuery, *params.BlockDeviceMappingVolumeTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Descriptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "descriptions", runtime.ParamLocationQuery, *params.Descriptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FileLocations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fileLocations", runtime.ParamLocationQuery, *params.FileLocations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Hypervisors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hypervisors", runtime.ParamLocationQuery, *params.Hypervisors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageNames", runtime.ParamLocationQuery, *params.ImageNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductCodeNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "productCodeNames", runtime.ParamLocationQuery, *params.ProductCodeNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductCodes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "productCodes", runtime.ParamLocationQuery, *params.ProductCodes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RootDeviceNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rootDeviceNames", runtime.ParamLocationQuery, *params.RootDeviceNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RootDeviceTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rootDeviceTypes", runtime.ParamLocationQuery, *params.RootDeviceTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VirtualizationTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "virtualizationTypes", runtime.ParamLocationQuery, *params.VirtualizationTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsPublic != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isPublic", runtime.ParamLocationQuery, *params.IsPublic); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateImageRequest calls the generic CreateImage builder with application/json body
func NewCreateImageRequest(server string, spaceId SpaceId, body CreateImageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateImageRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateImageRequestWithBody generates requests for CreateImage with any type of body
func NewCreateImageRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/images", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteImageRequest generates requests for DeleteImage
func NewDeleteImageRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/images/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadImagesByIdRequest generates requests for ReadImagesById
func NewReadImagesByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/images/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateImageRequest calls the generic UpdateImage builder with application/json body
func NewUpdateImageRequest(server string, spaceId SpaceId, id string, body UpdateImageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateImageRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateImageRequestWithBody generates requests for UpdateImage with any type of body
func NewUpdateImageRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/images/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadInternetGatewaysRequest generates requests for ReadInternetGateways
func NewReadInternetGatewaysRequest(server string, spaceId SpaceId, params *ReadInternetGatewaysParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/internetGateways", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LinkStates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkStates", runtime.ParamLocationQuery, *params.LinkStates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkVpcIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkVpcIds", runtime.ParamLocationQuery, *params.LinkVpcIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateInternetGatewayRequest generates requests for CreateInternetGateway
func NewCreateInternetGatewayRequest(server string, spaceId SpaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/internetGateways", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteInternetGatewayRequest generates requests for DeleteInternetGateway
func NewDeleteInternetGatewayRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/internetGateways/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadInternetGatewaysByIdRequest generates requests for ReadInternetGatewaysById
func NewReadInternetGatewaysByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/internetGateways/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLinkInternetGatewayRequest calls the generic LinkInternetGateway builder with application/json body
func NewLinkInternetGatewayRequest(server string, spaceId SpaceId, id string, body LinkInternetGatewayJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkInternetGatewayRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewLinkInternetGatewayRequestWithBody generates requests for LinkInternetGateway with any type of body
func NewLinkInternetGatewayRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/internetGateways/%s/vpcs/link", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnlinkInternetGatewayRequest calls the generic UnlinkInternetGateway builder with application/json body
func NewUnlinkInternetGatewayRequest(server string, spaceId SpaceId, id string, body UnlinkInternetGatewayJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnlinkInternetGatewayRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUnlinkInternetGatewayRequestWithBody generates requests for UnlinkInternetGateway with any type of body
func NewUnlinkInternetGatewayRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/internetGateways/%s/vpcs/unlink", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadKeypairsRequest generates requests for ReadKeypairs
func NewReadKeypairsRequest(server string, spaceId SpaceId, params *ReadKeypairsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/keypairs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.KeypairFingerprints != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keypairFingerprints", runtime.ParamLocationQuery, *params.KeypairFingerprints); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.KeypairNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keypairNames", runtime.ParamLocationQuery, *params.KeypairNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.KeypairTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keypairTypes", runtime.ParamLocationQuery, *params.KeypairTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateKeypairRequest calls the generic CreateKeypair builder with application/json body
func NewCreateKeypairRequest(server string, spaceId SpaceId, body CreateKeypairJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateKeypairRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateKeypairRequestWithBody generates requests for CreateKeypair with any type of body
func NewCreateKeypairRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/keypairs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteKeypairRequest generates requests for DeleteKeypair
func NewDeleteKeypairRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/keypairs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadKeypairsByIdRequest generates requests for ReadKeypairsById
func NewReadKeypairsByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/keypairs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadListenerRulesRequest generates requests for ReadListenerRules
func NewReadListenerRulesRequest(server string, spaceId SpaceId, params *ReadListenerRulesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/listenerRules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ListenerRuleNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "listenerRuleNames", runtime.ParamLocationQuery, *params.ListenerRuleNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateListenerRuleRequest calls the generic CreateListenerRule builder with application/json body
func NewCreateListenerRuleRequest(server string, spaceId SpaceId, body CreateListenerRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateListenerRuleRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateListenerRuleRequestWithBody generates requests for CreateListenerRule with any type of body
func NewCreateListenerRuleRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/listenerRules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteListenerRuleRequest generates requests for DeleteListenerRule
func NewDeleteListenerRuleRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/listenerRules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadListenerRulesByIdRequest generates requests for ReadListenerRulesById
func NewReadListenerRulesByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/listenerRules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateListenerRuleRequest calls the generic UpdateListenerRule builder with application/json body
func NewUpdateListenerRuleRequest(server string, spaceId SpaceId, id string, body UpdateListenerRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateListenerRuleRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateListenerRuleRequestWithBody generates requests for UpdateListenerRule with any type of body
func NewUpdateListenerRuleRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/listenerRules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadLoadBalancersRequest generates requests for ReadLoadBalancers
func NewReadLoadBalancersRequest(server string, spaceId SpaceId, params *ReadLoadBalancersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/loadBalancers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LoadBalancerNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "loadBalancerNames", runtime.ParamLocationQuery, *params.LoadBalancerNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateLoadBalancerRequest calls the generic CreateLoadBalancer builder with application/json body
func NewCreateLoadBalancerRequest(server string, spaceId SpaceId, body CreateLoadBalancerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLoadBalancerRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateLoadBalancerRequestWithBody generates requests for CreateLoadBalancer with any type of body
func NewCreateLoadBalancerRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/loadBalancers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLoadBalancerRequest generates requests for DeleteLoadBalancer
func NewDeleteLoadBalancerRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/loadBalancers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadLoadBalancersByIdRequest generates requests for ReadLoadBalancersById
func NewReadLoadBalancersByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/loadBalancers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateLoadBalancerRequest calls the generic UpdateLoadBalancer builder with application/json body
func NewUpdateLoadBalancerRequest(server string, spaceId SpaceId, id string, body UpdateLoadBalancerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateLoadBalancerRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateLoadBalancerRequestWithBody generates requests for UpdateLoadBalancer with any type of body
func NewUpdateLoadBalancerRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/loadBalancers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLinkLoadBalancerBackendMachinesRequest calls the generic LinkLoadBalancerBackendMachines builder with application/json body
func NewLinkLoadBalancerBackendMachinesRequest(server string, spaceId SpaceId, id string, body LinkLoadBalancerBackendMachinesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkLoadBalancerBackendMachinesRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewLinkLoadBalancerBackendMachinesRequestWithBody generates requests for LinkLoadBalancerBackendMachines with any type of body
func NewLinkLoadBalancerBackendMachinesRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/loadBalancers/%s/backendMachines/link", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnlinkLoadBalancerBackendMachinesRequest calls the generic UnlinkLoadBalancerBackendMachines builder with application/json body
func NewUnlinkLoadBalancerBackendMachinesRequest(server string, spaceId SpaceId, id string, body UnlinkLoadBalancerBackendMachinesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnlinkLoadBalancerBackendMachinesRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUnlinkLoadBalancerBackendMachinesRequestWithBody generates requests for UnlinkLoadBalancerBackendMachines with any type of body
func NewUnlinkLoadBalancerBackendMachinesRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/loadBalancers/%s/backendMachines/unlink", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLoadBalancerListenersRequest calls the generic DeleteLoadBalancerListeners builder with application/json body
func NewDeleteLoadBalancerListenersRequest(server string, spaceId SpaceId, id string, body DeleteLoadBalancerListenersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteLoadBalancerListenersRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewDeleteLoadBalancerListenersRequestWithBody generates requests for DeleteLoadBalancerListeners with any type of body
func NewDeleteLoadBalancerListenersRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/loadBalancers/%s/listeners", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateLoadBalancerListenersRequest calls the generic CreateLoadBalancerListeners builder with application/json body
func NewCreateLoadBalancerListenersRequest(server string, spaceId SpaceId, id string, body CreateLoadBalancerListenersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLoadBalancerListenersRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewCreateLoadBalancerListenersRequestWithBody generates requests for CreateLoadBalancerListeners with any type of body
func NewCreateLoadBalancerListenersRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/loadBalancers/%s/listeners", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLoadBalancerPolicyRequest calls the generic DeleteLoadBalancerPolicy builder with application/json body
func NewDeleteLoadBalancerPolicyRequest(server string, spaceId SpaceId, id string, body DeleteLoadBalancerPolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteLoadBalancerPolicyRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewDeleteLoadBalancerPolicyRequestWithBody generates requests for DeleteLoadBalancerPolicy with any type of body
func NewDeleteLoadBalancerPolicyRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/loadBalancers/%s/policies", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateLoadBalancerPolicyRequest calls the generic CreateLoadBalancerPolicy builder with application/json body
func NewCreateLoadBalancerPolicyRequest(server string, spaceId SpaceId, id string, body CreateLoadBalancerPolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLoadBalancerPolicyRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewCreateLoadBalancerPolicyRequestWithBody generates requests for CreateLoadBalancerPolicy with any type of body
func NewCreateLoadBalancerPolicyRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/loadBalancers/%s/policies", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadVmsHealthRequest calls the generic ReadVmsHealth builder with application/json body
func NewReadVmsHealthRequest(server string, spaceId SpaceId, id string, body ReadVmsHealthJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReadVmsHealthRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewReadVmsHealthRequestWithBody generates requests for ReadVmsHealth with any type of body
func NewReadVmsHealthRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/loadBalancers/%s/vmsHealth", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadLoadBalancerTagsRequest calls the generic ReadLoadBalancerTags builder with application/json body
func NewReadLoadBalancerTagsRequest(server string, spaceId SpaceId, body ReadLoadBalancerTagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReadLoadBalancerTagsRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewReadLoadBalancerTagsRequestWithBody generates requests for ReadLoadBalancerTags with any type of body
func NewReadLoadBalancerTagsRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/loadBalancersTags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadNatGatewayRequest generates requests for ReadNatGateway
func NewReadNatGatewayRequest(server string, spaceId SpaceId, params *ReadNatGatewayParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/natGateways", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubnetIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subnetIds", runtime.ParamLocationQuery, *params.SubnetIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VpcIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vpcIds", runtime.ParamLocationQuery, *params.VpcIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNatGatewayRequest calls the generic CreateNatGateway builder with application/json body
func NewCreateNatGatewayRequest(server string, spaceId SpaceId, body CreateNatGatewayJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNatGatewayRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateNatGatewayRequestWithBody generates requests for CreateNatGateway with any type of body
func NewCreateNatGatewayRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/natGateways", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteNatGatewayRequest generates requests for DeleteNatGateway
func NewDeleteNatGatewayRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/natGateways/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadNatGatewayByIdRequest generates requests for ReadNatGatewayById
func NewReadNatGatewayByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/natGateways/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadNicsRequest generates requests for ReadNics
func NewReadNicsRequest(server string, spaceId SpaceId, params *ReadNicsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/nics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Descriptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "descriptions", runtime.ParamLocationQuery, *params.Descriptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsSourceDestCheck != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isSourceDestCheck", runtime.ParamLocationQuery, *params.IsSourceDestCheck); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkNicDeleteOnVmDeletion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkNicDeleteOnVmDeletion", runtime.ParamLocationQuery, *params.LinkNicDeleteOnVmDeletion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkNicDeviceNumbers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkNicDeviceNumbers", runtime.ParamLocationQuery, *params.LinkNicDeviceNumbers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkNicLinkNicIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkNicLinkNicIds", runtime.ParamLocationQuery, *params.LinkNicLinkNicIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkNicStates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkNicStates", runtime.ParamLocationQuery, *params.LinkNicStates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkNicVmIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkNicVmIds", runtime.ParamLocationQuery, *params.LinkNicVmIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkPublicIpLinkPublicIpIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkPublicIpLinkPublicIpIds", runtime.ParamLocationQuery, *params.LinkPublicIpLinkPublicIpIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkPublicIpPublicIpIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkPublicIpPublicIpIds", runtime.ParamLocationQuery, *params.LinkPublicIpPublicIpIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkPublicIpPublicIps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkPublicIpPublicIps", runtime.ParamLocationQuery, *params.LinkPublicIpPublicIps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MacAddresses != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "macAddresses", runtime.ParamLocationQuery, *params.MacAddresses); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrivateDnsNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "privateDnsNames", runtime.ParamLocationQuery, *params.PrivateDnsNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrivateIpsLinkPublicIpPublicIps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "privateIpsLinkPublicIpPublicIps", runtime.ParamLocationQuery, *params.PrivateIpsLinkPublicIpPublicIps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrivateIpsPrimaryIp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "privateIpsPrimaryIp", runtime.ParamLocationQuery, *params.PrivateIpsPrimaryIp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrivateIpsPrivateIps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "privateIpsPrivateIps", runtime.ParamLocationQuery, *params.PrivateIpsPrivateIps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SecurityGroupIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "securityGroupIds", runtime.ParamLocationQuery, *params.SecurityGroupIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SecurityGroupNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "securityGroupNames", runtime.ParamLocationQuery, *params.SecurityGroupNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubnetIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subnetIds", runtime.ParamLocationQuery, *params.SubnetIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VpcIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vpcIds", runtime.ParamLocationQuery, *params.VpcIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AvailabilityZoneNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "availabilityZoneNames", runtime.ParamLocationQuery, *params.AvailabilityZoneNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNicRequest calls the generic CreateNic builder with application/json body
func NewCreateNicRequest(server string, spaceId SpaceId, body CreateNicJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNicRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateNicRequestWithBody generates requests for CreateNic with any type of body
func NewCreateNicRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/nics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteNicRequest generates requests for DeleteNic
func NewDeleteNicRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/nics/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadNicsByIdRequest generates requests for ReadNicsById
func NewReadNicsByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/nics/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateNicRequest calls the generic UpdateNic builder with application/json body
func NewUpdateNicRequest(server string, spaceId SpaceId, id string, body UpdateNicJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateNicRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateNicRequestWithBody generates requests for UpdateNic with any type of body
func NewUpdateNicRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/nics/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLinkPrivateIpsRequest calls the generic LinkPrivateIps builder with application/json body
func NewLinkPrivateIpsRequest(server string, spaceId SpaceId, id string, body LinkPrivateIpsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkPrivateIpsRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewLinkPrivateIpsRequestWithBody generates requests for LinkPrivateIps with any type of body
func NewLinkPrivateIpsRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/nics/%s/privateIps/link", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnlinkPrivateIpsRequest calls the generic UnlinkPrivateIps builder with application/json body
func NewUnlinkPrivateIpsRequest(server string, spaceId SpaceId, id string, body UnlinkPrivateIpsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnlinkPrivateIpsRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUnlinkPrivateIpsRequestWithBody generates requests for UnlinkPrivateIps with any type of body
func NewUnlinkPrivateIpsRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/nics/%s/privateIps/unlink", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLinkNicRequest calls the generic LinkNic builder with application/json body
func NewLinkNicRequest(server string, spaceId SpaceId, id string, body LinkNicJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkNicRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewLinkNicRequestWithBody generates requests for LinkNic with any type of body
func NewLinkNicRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/nics/%s/vms/link", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnlinkNicRequest calls the generic UnlinkNic builder with application/json body
func NewUnlinkNicRequest(server string, spaceId SpaceId, id string, body UnlinkNicJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnlinkNicRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUnlinkNicRequestWithBody generates requests for UnlinkNic with any type of body
func NewUnlinkNicRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/nics/%s/vms/unlink", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadPublicIpsRequest generates requests for ReadPublicIps
func NewReadPublicIpsRequest(server string, spaceId SpaceId, params *ReadPublicIpsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/publicIps", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LinkPublicIpIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkPublicIpIds", runtime.ParamLocationQuery, *params.LinkPublicIpIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicIds", runtime.ParamLocationQuery, *params.NicIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrivateIps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "privateIps", runtime.ParamLocationQuery, *params.PrivateIps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VmIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vmIds", runtime.ParamLocationQuery, *params.VmIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePublicIpRequest generates requests for CreatePublicIp
func NewCreatePublicIpRequest(server string, spaceId SpaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/publicIps", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeletePublicIpRequest generates requests for DeletePublicIp
func NewDeletePublicIpRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/publicIps/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadPublicIpsByIdRequest generates requests for ReadPublicIpsById
func NewReadPublicIpsByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/publicIps/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLinkPublicIpRequest calls the generic LinkPublicIp builder with application/json body
func NewLinkPublicIpRequest(server string, spaceId SpaceId, id string, body LinkPublicIpJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkPublicIpRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewLinkPublicIpRequestWithBody generates requests for LinkPublicIp with any type of body
func NewLinkPublicIpRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/publicIps/%s/link", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnlinkPublicIpRequest calls the generic UnlinkPublicIp builder with application/json body
func NewUnlinkPublicIpRequest(server string, spaceId SpaceId, id string, body UnlinkPublicIpJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnlinkPublicIpRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUnlinkPublicIpRequestWithBody generates requests for UnlinkPublicIp with any type of body
func NewUnlinkPublicIpRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/publicIps/%s/unlink", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadRouteTablesRequest generates requests for ReadRouteTables
func NewReadRouteTablesRequest(server string, spaceId SpaceId, params *ReadRouteTablesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/routeTables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LinkRouteTableIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkRouteTableIds", runtime.ParamLocationQuery, *params.LinkRouteTableIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkRouteTableLinkRouteTableIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkRouteTableLinkRouteTableIds", runtime.ParamLocationQuery, *params.LinkRouteTableLinkRouteTableIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkRouteTableMain != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkRouteTableMain", runtime.ParamLocationQuery, *params.LinkRouteTableMain); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkSubnetIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkSubnetIds", runtime.ParamLocationQuery, *params.LinkSubnetIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RouteCreationMethods != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "routeCreationMethods", runtime.ParamLocationQuery, *params.RouteCreationMethods); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RouteDestinationIpRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "routeDestinationIpRanges", runtime.ParamLocationQuery, *params.RouteDestinationIpRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RouteDestinationServiceIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "routeDestinationServiceIds", runtime.ParamLocationQuery, *params.RouteDestinationServiceIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RouteGatewayIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "routeGatewayIds", runtime.ParamLocationQuery, *params.RouteGatewayIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RouteStates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "routeStates", runtime.ParamLocationQuery, *params.RouteStates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RouteVmIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "routeVmIds", runtime.ParamLocationQuery, *params.RouteVmIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VpcIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vpcIds", runtime.ParamLocationQuery, *params.VpcIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RouteNatGatewayIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "routeNatGatewayIds", runtime.ParamLocationQuery, *params.RouteNatGatewayIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RouteVpcPeeringIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "routeVpcPeeringIds", runtime.ParamLocationQuery, *params.RouteVpcPeeringIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRouteTableRequest calls the generic CreateRouteTable builder with application/json body
func NewCreateRouteTableRequest(server string, spaceId SpaceId, body CreateRouteTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRouteTableRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateRouteTableRequestWithBody generates requests for CreateRouteTable with any type of body
func NewCreateRouteTableRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/routeTables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRouteTableRequest generates requests for DeleteRouteTable
func NewDeleteRouteTableRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/routeTables/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadRouteTablesByIdRequest generates requests for ReadRouteTablesById
func NewReadRouteTablesByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/routeTables/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRouteTableRoutePropagationRequest calls the generic UpdateRouteTableRoutePropagation builder with application/json body
func NewUpdateRouteTableRoutePropagationRequest(server string, spaceId SpaceId, id string, body UpdateRouteTableRoutePropagationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRouteTableRoutePropagationRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateRouteTableRoutePropagationRequestWithBody generates requests for UpdateRouteTableRoutePropagation with any type of body
func NewUpdateRouteTableRoutePropagationRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/routeTables/%s/routePropagation", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRouteRequest calls the generic DeleteRoute builder with application/json body
func NewDeleteRouteRequest(server string, spaceId SpaceId, id string, body DeleteRouteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteRouteRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewDeleteRouteRequestWithBody generates requests for DeleteRoute with any type of body
func NewDeleteRouteRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/routeTables/%s/routes", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateRouteRequest calls the generic CreateRoute builder with application/json body
func NewCreateRouteRequest(server string, spaceId SpaceId, id string, body CreateRouteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRouteRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewCreateRouteRequestWithBody generates requests for CreateRoute with any type of body
func NewCreateRouteRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/routeTables/%s/routes", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateRouteRequest calls the generic UpdateRoute builder with application/json body
func NewUpdateRouteRequest(server string, spaceId SpaceId, id string, body UpdateRouteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRouteRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateRouteRequestWithBody generates requests for UpdateRoute with any type of body
func NewUpdateRouteRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/routeTables/%s/routes", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLinkRouteTableRequest calls the generic LinkRouteTable builder with application/json body
func NewLinkRouteTableRequest(server string, spaceId SpaceId, id string, body LinkRouteTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkRouteTableRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewLinkRouteTableRequestWithBody generates requests for LinkRouteTable with any type of body
func NewLinkRouteTableRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/routeTables/%s/subnets/link", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnlinkRouteTableRequest calls the generic UnlinkRouteTable builder with application/json body
func NewUnlinkRouteTableRequest(server string, spaceId SpaceId, id string, body UnlinkRouteTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnlinkRouteTableRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUnlinkRouteTableRequestWithBody generates requests for UnlinkRouteTable with any type of body
func NewUnlinkRouteTableRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/routeTables/%s/subnets/unlink", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadSecurityGroupsRequest generates requests for ReadSecurityGroups
func NewReadSecurityGroupsRequest(server string, spaceId SpaceId, params *ReadSecurityGroupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/securityGroups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Descriptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "descriptions", runtime.ParamLocationQuery, *params.Descriptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InboundRuleFromPortRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inboundRuleFromPortRanges", runtime.ParamLocationQuery, *params.InboundRuleFromPortRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InboundRuleIpRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inboundRuleIpRanges", runtime.ParamLocationQuery, *params.InboundRuleIpRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InboundRuleProtocols != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inboundRuleProtocols", runtime.ParamLocationQuery, *params.InboundRuleProtocols); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InboundRuleSecurityGroupIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inboundRuleSecurityGroupIds", runtime.ParamLocationQuery, *params.InboundRuleSecurityGroupIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InboundRuleSecurityGroupNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inboundRuleSecurityGroupNames", runtime.ParamLocationQuery, *params.InboundRuleSecurityGroupNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InboundRuleToPortRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inboundRuleToPortRanges", runtime.ParamLocationQuery, *params.InboundRuleToPortRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OutboundRuleFromPortRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outboundRuleFromPortRanges", runtime.ParamLocationQuery, *params.OutboundRuleFromPortRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OutboundRuleIpRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outboundRuleIpRanges", runtime.ParamLocationQuery, *params.OutboundRuleIpRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OutboundRuleProtocols != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outboundRuleProtocols", runtime.ParamLocationQuery, *params.OutboundRuleProtocols); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OutboundRuleSecurityGroupIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outboundRuleSecurityGroupIds", runtime.ParamLocationQuery, *params.OutboundRuleSecurityGroupIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OutboundRuleSecurityGroupNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outboundRuleSecurityGroupNames", runtime.ParamLocationQuery, *params.OutboundRuleSecurityGroupNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OutboundRuleToPortRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outboundRuleToPortRanges", runtime.ParamLocationQuery, *params.OutboundRuleToPortRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SecurityGroupIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "securityGroupIds", runtime.ParamLocationQuery, *params.SecurityGroupIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SecurityGroupNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "securityGroupNames", runtime.ParamLocationQuery, *params.SecurityGroupNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VpcIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vpcIds", runtime.ParamLocationQuery, *params.VpcIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSecurityGroupRequest calls the generic CreateSecurityGroup builder with application/json body
func NewCreateSecurityGroupRequest(server string, spaceId SpaceId, body CreateSecurityGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSecurityGroupRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateSecurityGroupRequestWithBody generates requests for CreateSecurityGroup with any type of body
func NewCreateSecurityGroupRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/securityGroups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSecurityGroupRequest generates requests for DeleteSecurityGroup
func NewDeleteSecurityGroupRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/securityGroups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadSecurityGroupsByIdRequest generates requests for ReadSecurityGroupsById
func NewReadSecurityGroupsByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/securityGroups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteSecurityGroupRuleRequest calls the generic DeleteSecurityGroupRule builder with application/json body
func NewDeleteSecurityGroupRuleRequest(server string, spaceId SpaceId, id string, body DeleteSecurityGroupRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteSecurityGroupRuleRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewDeleteSecurityGroupRuleRequestWithBody generates requests for DeleteSecurityGroupRule with any type of body
func NewDeleteSecurityGroupRuleRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/securityGroups/%s/rules", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateSecurityGroupRuleRequest calls the generic CreateSecurityGroupRule builder with application/json body
func NewCreateSecurityGroupRuleRequest(server string, spaceId SpaceId, id string, body CreateSecurityGroupRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSecurityGroupRuleRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewCreateSecurityGroupRuleRequestWithBody generates requests for CreateSecurityGroupRule with any type of body
func NewCreateSecurityGroupRuleRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/securityGroups/%s/rules", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadServerCertificatesRequest generates requests for ReadServerCertificates
func NewReadServerCertificatesRequest(server string, spaceId SpaceId, params *ReadServerCertificatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/serverCertificates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Paths != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paths", runtime.ParamLocationQuery, *params.Paths); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateServerCertificateRequest calls the generic CreateServerCertificate builder with application/json body
func NewCreateServerCertificateRequest(server string, spaceId SpaceId, body CreateServerCertificateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServerCertificateRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateServerCertificateRequestWithBody generates requests for CreateServerCertificate with any type of body
func NewCreateServerCertificateRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/serverCertificates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServerCertificateRequest generates requests for DeleteServerCertificate
func NewDeleteServerCertificateRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/serverCertificates/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateServerCertificateRequest calls the generic UpdateServerCertificate builder with application/json body
func NewUpdateServerCertificateRequest(server string, spaceId SpaceId, id string, body UpdateServerCertificateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateServerCertificateRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateServerCertificateRequestWithBody generates requests for UpdateServerCertificate with any type of body
func NewUpdateServerCertificateRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/serverCertificates/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadSnapshotsRequest generates requests for ReadSnapshots
func NewReadSnapshotsRequest(server string, spaceId SpaceId, params *ReadSnapshotsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/snapshots", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Descriptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "descriptions", runtime.ParamLocationQuery, *params.Descriptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FromCreationDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromCreationDate", runtime.ParamLocationQuery, *params.FromCreationDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Progresses != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "progresses", runtime.ParamLocationQuery, *params.Progresses); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToCreationDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toCreationDate", runtime.ParamLocationQuery, *params.ToCreationDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VolumeIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "volumeIds", runtime.ParamLocationQuery, *params.VolumeIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VolumeSizes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "volumeSizes", runtime.ParamLocationQuery, *params.VolumeSizes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsPublic != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isPublic", runtime.ParamLocationQuery, *params.IsPublic); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSnapshotRequest calls the generic CreateSnapshot builder with application/json body
func NewCreateSnapshotRequest(server string, spaceId SpaceId, body CreateSnapshotJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSnapshotRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateSnapshotRequestWithBody generates requests for CreateSnapshot with any type of body
func NewCreateSnapshotRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/snapshots", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSnapshotRequest generates requests for DeleteSnapshot
func NewDeleteSnapshotRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/snapshots/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadSnapshotsByIdRequest generates requests for ReadSnapshotsById
func NewReadSnapshotsByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/snapshots/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadSubnetsRequest generates requests for ReadSubnets
func NewReadSubnetsRequest(server string, spaceId SpaceId, params *ReadSubnetsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/subnets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AvailableIpsCounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "availableIpsCounts", runtime.ParamLocationQuery, *params.AvailableIpsCounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IpRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ipRanges", runtime.ParamLocationQuery, *params.IpRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VpcIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vpcIds", runtime.ParamLocationQuery, *params.VpcIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AvailabilityZoneNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "availabilityZoneNames", runtime.ParamLocationQuery, *params.AvailabilityZoneNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSubnetRequest calls the generic CreateSubnet builder with application/json body
func NewCreateSubnetRequest(server string, spaceId SpaceId, body CreateSubnetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSubnetRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateSubnetRequestWithBody generates requests for CreateSubnet with any type of body
func NewCreateSubnetRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/subnets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSubnetRequest generates requests for DeleteSubnet
func NewDeleteSubnetRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/subnets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadSubnetsByIdRequest generates requests for ReadSubnetsById
func NewReadSubnetsByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/subnets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSubnetRequest calls the generic UpdateSubnet builder with application/json body
func NewUpdateSubnetRequest(server string, spaceId SpaceId, id string, body UpdateSubnetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSubnetRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateSubnetRequestWithBody generates requests for UpdateSubnet with any type of body
func NewUpdateSubnetRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/subnets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadTagsRequest generates requests for ReadTags
func NewReadTagsRequest(server string, spaceId SpaceId, params *ReadTagsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Keys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keys", runtime.ParamLocationQuery, *params.Keys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResourceIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resourceIds", runtime.ParamLocationQuery, *params.ResourceIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResourceTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resourceTypes", runtime.ParamLocationQuery, *params.ResourceTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Values != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "values", runtime.ParamLocationQuery, *params.Values); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadVmsRequest generates requests for ReadVms
func NewReadVmsRequest(server string, spaceId SpaceId, params *ReadVmsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vms", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Architectures != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "architectures", runtime.ParamLocationQuery, *params.Architectures); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BlockDeviceMappingDeleteOnVmDeletion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blockDeviceMappingDeleteOnVmDeletion", runtime.ParamLocationQuery, *params.BlockDeviceMappingDeleteOnVmDeletion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BlockDeviceMappingDeviceNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blockDeviceMappingDeviceNames", runtime.ParamLocationQuery, *params.BlockDeviceMappingDeviceNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BlockDeviceMappingLinkDates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blockDeviceMappingLinkDates", runtime.ParamLocationQuery, *params.BlockDeviceMappingLinkDates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BlockDeviceMappingStates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blockDeviceMappingStates", runtime.ParamLocationQuery, *params.BlockDeviceMappingStates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BlockDeviceMappingVolumeIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blockDeviceMappingVolumeIds", runtime.ParamLocationQuery, *params.BlockDeviceMappingVolumeIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClientTokens != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "clientTokens", runtime.ParamLocationQuery, *params.ClientTokens); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreationDates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "creationDates", runtime.ParamLocationQuery, *params.CreationDates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageIds", runtime.ParamLocationQuery, *params.ImageIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsSourceDestChecked != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isSourceDestChecked", runtime.ParamLocationQuery, *params.IsSourceDestChecked); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.KeypairNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keypairNames", runtime.ParamLocationQuery, *params.KeypairNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LaunchNumbers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "launchNumbers", runtime.ParamLocationQuery, *params.LaunchNumbers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Lifecycles != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lifecycles", runtime.ParamLocationQuery, *params.Lifecycles); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicDescriptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicDescriptions", runtime.ParamLocationQuery, *params.NicDescriptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicIsSourceDestChecked != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicIsSourceDestChecked", runtime.ParamLocationQuery, *params.NicIsSourceDestChecked); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicLinkNicDeleteOnVmDeletion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicLinkNicDeleteOnVmDeletion", runtime.ParamLocationQuery, *params.NicLinkNicDeleteOnVmDeletion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicLinkNicDeviceNumbers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicLinkNicDeviceNumbers", runtime.ParamLocationQuery, *params.NicLinkNicDeviceNumbers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicLinkNicLinkNicDates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicLinkNicLinkNicDates", runtime.ParamLocationQuery, *params.NicLinkNicLinkNicDates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicLinkNicLinkNicIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicLinkNicLinkNicIds", runtime.ParamLocationQuery, *params.NicLinkNicLinkNicIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicLinkNicStates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicLinkNicStates", runtime.ParamLocationQuery, *params.NicLinkNicStates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicLinkNicVmIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicLinkNicVmIds", runtime.ParamLocationQuery, *params.NicLinkNicVmIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicLinkPublicIpLinkPublicIpIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicLinkPublicIpLinkPublicIpIds", runtime.ParamLocationQuery, *params.NicLinkPublicIpLinkPublicIpIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicLinkPublicIpPublicIpIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicLinkPublicIpPublicIpIds", runtime.ParamLocationQuery, *params.NicLinkPublicIpPublicIpIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicLinkPublicIpPublicIps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicLinkPublicIpPublicIps", runtime.ParamLocationQuery, *params.NicLinkPublicIpPublicIps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicMacAddresses != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicMacAddresses", runtime.ParamLocationQuery, *params.NicMacAddresses); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicNicIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicNicIds", runtime.ParamLocationQuery, *params.NicNicIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicPrivateIpsLinkPublicIpIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicPrivateIpsLinkPublicIpIds", runtime.ParamLocationQuery, *params.NicPrivateIpsLinkPublicIpIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicPrivateIpsPrimaryIp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicPrivateIpsPrimaryIp", runtime.ParamLocationQuery, *params.NicPrivateIpsPrimaryIp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicPrivateIpsPrivateIps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicPrivateIpsPrivateIps", runtime.ParamLocationQuery, *params.NicPrivateIpsPrivateIps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicSecurityGroupIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicSecurityGroupIds", runtime.ParamLocationQuery, *params.NicSecurityGroupIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicSecurityGroupNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicSecurityGroupNames", runtime.ParamLocationQuery, *params.NicSecurityGroupNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicStates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicStates", runtime.ParamLocationQuery, *params.NicStates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicSubnetIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicSubnetIds", runtime.ParamLocationQuery, *params.NicSubnetIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Platforms != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "platforms", runtime.ParamLocationQuery, *params.Platforms); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrivateIps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "privateIps", runtime.ParamLocationQuery, *params.PrivateIps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductCodes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "productCodes", runtime.ParamLocationQuery, *params.ProductCodes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PublicIps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "publicIps", runtime.ParamLocationQuery, *params.PublicIps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReservationIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reservationIds", runtime.ParamLocationQuery, *params.ReservationIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RootDeviceNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rootDeviceNames", runtime.ParamLocationQuery, *params.RootDeviceNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RootDeviceTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rootDeviceTypes", runtime.ParamLocationQuery, *params.RootDeviceTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SecurityGroupIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "securityGroupIds", runtime.ParamLocationQuery, *params.SecurityGroupIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SecurityGroupNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "securityGroupNames", runtime.ParamLocationQuery, *params.SecurityGroupNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StateReasonCodes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stateReasonCodes", runtime.ParamLocationQuery, *params.StateReasonCodes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StateReasonMessages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stateReasonMessages", runtime.ParamLocationQuery, *params.StateReasonMessages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StateReasons != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stateReasons", runtime.ParamLocationQuery, *params.StateReasons); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubnetIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subnetIds", runtime.ParamLocationQuery, *params.SubnetIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tenancies != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tenancies", runtime.ParamLocationQuery, *params.Tenancies); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VmSecurityGroupIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vmSecurityGroupIds", runtime.ParamLocationQuery, *params.VmSecurityGroupIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VmSecurityGroupNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vmSecurityGroupNames", runtime.ParamLocationQuery, *params.VmSecurityGroupNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VmStateCodes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vmStateCodes", runtime.ParamLocationQuery, *params.VmStateCodes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VmStateNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vmStateNames", runtime.ParamLocationQuery, *params.VmStateNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Types != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "types", runtime.ParamLocationQuery, *params.Types); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VpcIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vpcIds", runtime.ParamLocationQuery, *params.VpcIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicVpcIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicVpcIds", runtime.ParamLocationQuery, *params.NicVpcIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicAvailabilityZoneNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicAvailabilityZoneNames", runtime.ParamLocationQuery, *params.NicAvailabilityZoneNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AvailabilityZoneNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "availabilityZoneNames", runtime.ParamLocationQuery, *params.AvailabilityZoneNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVmsRequest calls the generic CreateVms builder with application/json body
func NewCreateVmsRequest(server string, spaceId SpaceId, body CreateVmsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVmsRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateVmsRequestWithBody generates requests for CreateVms with any type of body
func NewCreateVmsRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vms", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadVmsStateRequest generates requests for ReadVmsState
func NewReadVmsStateRequest(server string, spaceId SpaceId, params *ReadVmsStateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vms/states", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MaintenanceEventCodes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maintenanceEventCodes", runtime.ParamLocationQuery, *params.MaintenanceEventCodes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaintenanceEventDescriptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maintenanceEventDescriptions", runtime.ParamLocationQuery, *params.MaintenanceEventDescriptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaintenanceEventsNotAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maintenanceEventsNotAfter", runtime.ParamLocationQuery, *params.MaintenanceEventsNotAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaintenanceEventsNotBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maintenanceEventsNotBefore", runtime.ParamLocationQuery, *params.MaintenanceEventsNotBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VmStates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vmStates", runtime.ParamLocationQuery, *params.VmStates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AvailabilityZoneNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "availabilityZoneNames", runtime.ParamLocationQuery, *params.AvailabilityZoneNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteVmsRequest generates requests for DeleteVms
func NewDeleteVmsRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vms/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadVmsByIdRequest generates requests for ReadVmsById
func NewReadVmsByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vms/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVmRequest calls the generic UpdateVm builder with application/json body
func NewUpdateVmRequest(server string, spaceId SpaceId, id string, body UpdateVmJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVmRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateVmRequestWithBody generates requests for UpdateVm with any type of body
func NewUpdateVmRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vms/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadAdminPasswordRequest generates requests for ReadAdminPassword
func NewReadAdminPasswordRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vms/%s/adminPasswords", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadConsoleOutputRequest generates requests for ReadConsoleOutput
func NewReadConsoleOutputRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vms/%s/consoleOutputs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRebootVmRequest generates requests for RebootVm
func NewRebootVmRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vms/%s/reboot", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartVmRequest generates requests for StartVm
func NewStartVmRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vms/%s/start", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStopVmRequest calls the generic StopVm builder with application/json body
func NewStopVmRequest(server string, spaceId SpaceId, id string, body StopVmJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStopVmRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewStopVmRequestWithBody generates requests for StopVm with any type of body
func NewStopVmRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vms/%s/stop", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadVolumesRequest generates requests for ReadVolumes
func NewReadVolumesRequest(server string, spaceId SpaceId, params *ReadVolumesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/volumes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreationDates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "creationDates", runtime.ParamLocationQuery, *params.CreationDates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkVolumeDeleteOnVmDeletion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkVolumeDeleteOnVmDeletion", runtime.ParamLocationQuery, *params.LinkVolumeDeleteOnVmDeletion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkVolumeDeviceNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkVolumeDeviceNames", runtime.ParamLocationQuery, *params.LinkVolumeDeviceNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkVolumeLinkDates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkVolumeLinkDates", runtime.ParamLocationQuery, *params.LinkVolumeLinkDates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkVolumeLinkStates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkVolumeLinkStates", runtime.ParamLocationQuery, *params.LinkVolumeLinkStates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkVolumeVmIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkVolumeVmIds", runtime.ParamLocationQuery, *params.LinkVolumeVmIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SnapshotIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "snapshotIds", runtime.ParamLocationQuery, *params.SnapshotIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VolumeSizes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "volumeSizes", runtime.ParamLocationQuery, *params.VolumeSizes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VolumeStates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "volumeStates", runtime.ParamLocationQuery, *params.VolumeStates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VolumeTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "volumeTypes", runtime.ParamLocationQuery, *params.VolumeTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AvailabilityZoneNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "availabilityZoneNames", runtime.ParamLocationQuery, *params.AvailabilityZoneNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVolumeRequest calls the generic CreateVolume builder with application/json body
func NewCreateVolumeRequest(server string, spaceId SpaceId, body CreateVolumeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVolumeRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateVolumeRequestWithBody generates requests for CreateVolume with any type of body
func NewCreateVolumeRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/volumes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVolumeRequest generates requests for DeleteVolume
func NewDeleteVolumeRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/volumes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadVolumesByIdRequest generates requests for ReadVolumesById
func NewReadVolumesByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/volumes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVolumeRequest calls the generic UpdateVolume builder with application/json body
func NewUpdateVolumeRequest(server string, spaceId SpaceId, id string, body UpdateVolumeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVolumeRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateVolumeRequestWithBody generates requests for UpdateVolume with any type of body
func NewUpdateVolumeRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/volumes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLinkVolumeRequest calls the generic LinkVolume builder with application/json body
func NewLinkVolumeRequest(server string, spaceId SpaceId, id string, body LinkVolumeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkVolumeRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewLinkVolumeRequestWithBody generates requests for LinkVolume with any type of body
func NewLinkVolumeRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/volumes/%s/vms/link", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnlinkVolumeRequest calls the generic UnlinkVolume builder with application/json body
func NewUnlinkVolumeRequest(server string, spaceId SpaceId, id string, body UnlinkVolumeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnlinkVolumeRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUnlinkVolumeRequestWithBody generates requests for UnlinkVolume with any type of body
func NewUnlinkVolumeRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/volumes/%s/vms/unlink", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadVpcsRequest generates requests for ReadVpcs
func NewReadVpcsRequest(server string, spaceId SpaceId, params *ReadVpcsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpcs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DhcpOptionsSetIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dhcpOptionsSetIds", runtime.ParamLocationQuery, *params.DhcpOptionsSetIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IpRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ipRanges", runtime.ParamLocationQuery, *params.IpRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsDefault != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isDefault", runtime.ParamLocationQuery, *params.IsDefault); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVpcRequest calls the generic CreateVpc builder with application/json body
func NewCreateVpcRequest(server string, spaceId SpaceId, body CreateVpcJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVpcRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateVpcRequestWithBody generates requests for CreateVpc with any type of body
func NewCreateVpcRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpcs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVpcRequest generates requests for DeleteVpc
func NewDeleteVpcRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpcs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadVpcsByIdRequest generates requests for ReadVpcsById
func NewReadVpcsByIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpcs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVpcRequest calls the generic UpdateVpc builder with application/json body
func NewUpdateVpcRequest(server string, spaceId SpaceId, id string, body UpdateVpcJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVpcRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateVpcRequestWithBody generates requests for UpdateVpc with any type of body
func NewUpdateVpcRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compute/spaces/%s/vpcs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteClientGatewayRequest generates requests for DeleteClientGateway
func NewDeleteClientGatewayRequest(server string, spaceId SpaceId, id ResourceIdentifier) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectivity/spaces/%s/clientGateway/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadClientGatewayRequest generates requests for ReadClientGateway
func NewReadClientGatewayRequest(server string, spaceId SpaceId, id ResourceIdentifier) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectivity/spaces/%s/clientGateway/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListClientGatewaysRequest generates requests for ListClientGateways
func NewListClientGatewaysRequest(server string, spaceId SpaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectivity/spaces/%s/clientGateways", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateClientGatewayRequest calls the generic CreateClientGateway builder with application/json body
func NewCreateClientGatewayRequest(server string, spaceId SpaceId, body CreateClientGatewayJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateClientGatewayRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateClientGatewayRequestWithBody generates requests for CreateClientGateway with any type of body
func NewCreateClientGatewayRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectivity/spaces/%s/clientGateways", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListComputeBridgesRequest generates requests for ListComputeBridges
func NewListComputeBridgesRequest(server string, spaceId SpaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectivity/spaces/%s/computeBridges", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateComputeBridgeRequest calls the generic CreateComputeBridge builder with application/json body
func NewCreateComputeBridgeRequest(server string, spaceId SpaceId, body CreateComputeBridgeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateComputeBridgeRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateComputeBridgeRequestWithBody generates requests for CreateComputeBridge with any type of body
func NewCreateComputeBridgeRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectivity/spaces/%s/computeBridges", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteComputeBridgeRequest generates requests for DeleteComputeBridge
func NewDeleteComputeBridgeRequest(server string, spaceId SpaceId, id ResourceIdentifier) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectivity/spaces/%s/computeBridges/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadComputeBridgeRequest generates requests for ReadComputeBridge
func NewReadComputeBridgeRequest(server string, spaceId SpaceId, id ResourceIdentifier) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectivity/spaces/%s/computeBridges/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListDirectLinkInterfacesRequest generates requests for ListDirectLinkInterfaces
func NewListDirectLinkInterfacesRequest(server string, spaceId SpaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectivity/spaces/%s/directLinkInterfaces", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDirectLinkInterfaceRequest calls the generic CreateDirectLinkInterface builder with application/json body
func NewCreateDirectLinkInterfaceRequest(server string, spaceId SpaceId, body CreateDirectLinkInterfaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDirectLinkInterfaceRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateDirectLinkInterfaceRequestWithBody generates requests for CreateDirectLinkInterface with any type of body
func NewCreateDirectLinkInterfaceRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectivity/spaces/%s/directLinkInterfaces", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDirectLinkInterfaceRequest generates requests for DeleteDirectLinkInterface
func NewDeleteDirectLinkInterfaceRequest(server string, spaceId SpaceId, id ResourceIdentifier) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectivity/spaces/%s/directLinkInterfaces/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadDirectLinkInterfaceRequest generates requests for ReadDirectLinkInterface
func NewReadDirectLinkInterfaceRequest(server string, spaceId SpaceId, id ResourceIdentifier) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectivity/spaces/%s/directLinkInterfaces/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListDirectLinksRequest generates requests for ListDirectLinks
func NewListDirectLinksRequest(server string, spaceId SpaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectivity/spaces/%s/directLinks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDirectLinkRequest calls the generic CreateDirectLink builder with application/json body
func NewCreateDirectLinkRequest(server string, spaceId SpaceId, body CreateDirectLinkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDirectLinkRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateDirectLinkRequestWithBody generates requests for CreateDirectLink with any type of body
func NewCreateDirectLinkRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectivity/spaces/%s/directLinks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDirectLinkRequest generates requests for DeleteDirectLink
func NewDeleteDirectLinkRequest(server string, spaceId SpaceId, id ResourceIdentifier) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectivity/spaces/%s/directLinks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadDirectLinkRequest generates requests for ReadDirectLink
func NewReadDirectLinkRequest(server string, spaceId SpaceId, id ResourceIdentifier) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectivity/spaces/%s/directLinks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListHybridBridgesRequest generates requests for ListHybridBridges
func NewListHybridBridgesRequest(server string, spaceId SpaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectivity/spaces/%s/hybridBridges", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHybridBridgeRequest calls the generic CreateHybridBridge builder with application/json body
func NewCreateHybridBridgeRequest(server string, spaceId SpaceId, body CreateHybridBridgeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHybridBridgeRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateHybridBridgeRequestWithBody generates requests for CreateHybridBridge with any type of body
func NewCreateHybridBridgeRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectivity/spaces/%s/hybridBridges", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHybridBridgeRequest generates requests for DeleteHybridBridge
func NewDeleteHybridBridgeRequest(server string, spaceId SpaceId, id ResourceIdentifier) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectivity/spaces/%s/hybridBridges/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadHybridBridgeRequest generates requests for ReadHybridBridge
func NewReadHybridBridgeRequest(server string, spaceId SpaceId, id ResourceIdentifier) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectivity/spaces/%s/hybridBridges/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListManagedServicesBridgesRequest generates requests for ListManagedServicesBridges
func NewListManagedServicesBridgesRequest(server string, spaceId SpaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectivity/spaces/%s/managedServiceBridges", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateManagedServicesBridgeRequest calls the generic CreateManagedServicesBridge builder with application/json body
func NewCreateManagedServicesBridgeRequest(server string, spaceId SpaceId, body CreateManagedServicesBridgeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateManagedServicesBridgeRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateManagedServicesBridgeRequestWithBody generates requests for CreateManagedServicesBridge with any type of body
func NewCreateManagedServicesBridgeRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectivity/spaces/%s/managedServiceBridges", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteManagedServicesBridgeRequest generates requests for DeleteManagedServicesBridge
func NewDeleteManagedServicesBridgeRequest(server string, spaceId SpaceId, id ResourceIdentifier) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectivity/spaces/%s/managedServiceBridges/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadManagedServicesBridgeRequest generates requests for ReadManagedServicesBridge
func NewReadManagedServicesBridgeRequest(server string, spaceId SpaceId, id ResourceIdentifier) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectivity/spaces/%s/managedServiceBridges/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadLocationsRequest generates requests for ReadLocations
func NewReadLocationsRequest(server string, spaceId SpaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectivity/spaces/%s/readLocations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteVirtualGatewayRequest generates requests for DeleteVirtualGateway
func NewDeleteVirtualGatewayRequest(server string, spaceId SpaceId, id ResourceIdentifier) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectivity/spaces/%s/virtualGateway/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadVirtualGatewayRequest generates requests for ReadVirtualGateway
func NewReadVirtualGatewayRequest(server string, spaceId SpaceId, id ResourceIdentifier) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectivity/spaces/%s/virtualGateway/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnlinkVirtualGatewayRequest calls the generic UnlinkVirtualGateway builder with application/json body
func NewUnlinkVirtualGatewayRequest(server string, spaceId SpaceId, id ResourceIdentifier, body UnlinkVirtualGatewayJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnlinkVirtualGatewayRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUnlinkVirtualGatewayRequestWithBody generates requests for UnlinkVirtualGateway with any type of body
func NewUnlinkVirtualGatewayRequestWithBody(server string, spaceId SpaceId, id ResourceIdentifier, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectivity/spaces/%s/virtualGateway/%s/link", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLinkVirtualGatewayRequest calls the generic LinkVirtualGateway builder with application/json body
func NewLinkVirtualGatewayRequest(server string, spaceId SpaceId, id ResourceIdentifier, body LinkVirtualGatewayJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkVirtualGatewayRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewLinkVirtualGatewayRequestWithBody generates requests for LinkVirtualGateway with any type of body
func NewLinkVirtualGatewayRequestWithBody(server string, spaceId SpaceId, id ResourceIdentifier, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectivity/spaces/%s/virtualGateway/%s/link", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListVirtualGatewaysRequest generates requests for ListVirtualGateways
func NewListVirtualGatewaysRequest(server string, spaceId SpaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectivity/spaces/%s/virtualGateways", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVirtualGatewayRequest calls the generic CreateVirtualGateway builder with application/json body
func NewCreateVirtualGatewayRequest(server string, spaceId SpaceId, body CreateVirtualGatewayJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVirtualGatewayRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateVirtualGatewayRequestWithBody generates requests for CreateVirtualGateway with any type of body
func NewCreateVirtualGatewayRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectivity/spaces/%s/virtualGateways", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVPNConnectionRequest generates requests for DeleteVPNConnection
func NewDeleteVPNConnectionRequest(server string, spaceId SpaceId, id ResourceIdentifier) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectivity/spaces/%s/vpnConnection/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadVPNConnectionRequest generates requests for ReadVPNConnection
func NewReadVPNConnectionRequest(server string, spaceId SpaceId, id ResourceIdentifier) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectivity/spaces/%s/vpnConnection/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteVPNConnectionRouteRequest calls the generic DeleteVPNConnectionRoute builder with application/json body
func NewDeleteVPNConnectionRouteRequest(server string, spaceId SpaceId, id ResourceIdentifier, body DeleteVPNConnectionRouteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteVPNConnectionRouteRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewDeleteVPNConnectionRouteRequestWithBody generates requests for DeleteVPNConnectionRoute with any type of body
func NewDeleteVPNConnectionRouteRequestWithBody(server string, spaceId SpaceId, id ResourceIdentifier, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectivity/spaces/%s/vpnConnection/%s/routes", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateVPNConnectionRouteRequest calls the generic CreateVPNConnectionRoute builder with application/json body
func NewCreateVPNConnectionRouteRequest(server string, spaceId SpaceId, id ResourceIdentifier, body CreateVPNConnectionRouteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVPNConnectionRouteRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewCreateVPNConnectionRouteRequestWithBody generates requests for CreateVPNConnectionRoute with any type of body
func NewCreateVPNConnectionRouteRequestWithBody(server string, spaceId SpaceId, id ResourceIdentifier, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectivity/spaces/%s/vpnConnection/%s/routes", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListVPNConnectionsRequest generates requests for ListVPNConnections
func NewListVPNConnectionsRequest(server string, spaceId SpaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectivity/spaces/%s/vpnConnections", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVPNConnectionRequest calls the generic CreateVPNConnection builder with application/json body
func NewCreateVPNConnectionRequest(server string, spaceId SpaceId, body CreateVPNConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVPNConnectionRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateVPNConnectionRequestWithBody generates requests for CreateVPNConnection with any type of body
func NewCreateVPNConnectionRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectivity/spaces/%s/vpnConnections", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewJsonWebKeysRequest generates requests for JsonWebKeys
func NewJsonWebKeysRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/.well-known/jwks.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDiscoverOidcConfigurationRequest generates requests for DiscoverOidcConfiguration
func NewDiscoverOidcConfigurationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/.well-known/openid-configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWebAuthnJavaScriptRequest generates requests for GetWebAuthnJavaScript
func NewGetWebAuthnJavaScriptRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/.well-known/webauthn.js")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAdminServiceAccountSpaceRequest calls the generic CreateAdminServiceAccountSpace builder with application/json body
func NewCreateAdminServiceAccountSpaceRequest(server string, organisationId OrganisationId, spaceId SpaceId, body CreateAdminServiceAccountSpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAdminServiceAccountSpaceRequestWithBody(server, organisationId, spaceId, "application/json", bodyReader)
}

// NewCreateAdminServiceAccountSpaceRequestWithBody generates requests for CreateAdminServiceAccountSpace with any type of body
func NewCreateAdminServiceAccountSpaceRequestWithBody(server string, organisationId OrganisationId, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/admin/organisations/%s/spaces/%s/serviceAccounts", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewConsentRequest generates requests for Consent
func NewConsentRequest(server string, params *ConsentParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/consent")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "consent_challenge", runtime.ParamLocationQuery, params.ConsentChallenge); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFlowErrorRequest generates requests for GetFlowError
func NewGetFlowErrorRequest(server string, params *GetFlowErrorParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/errors")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateLoginFlowRequest calls the generic UpdateLoginFlow builder with application/json body
func NewUpdateLoginFlowRequest(server string, params *UpdateLoginFlowParams, body UpdateLoginFlowJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateLoginFlowRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateLoginFlowRequestWithFormdataBody calls the generic UpdateLoginFlow builder with application/x-www-form-urlencoded body
func NewUpdateLoginFlowRequestWithFormdataBody(server string, params *UpdateLoginFlowParams, body UpdateLoginFlowFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewUpdateLoginFlowRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewUpdateLoginFlowRequestWithBody generates requests for UpdateLoginFlow with any type of body
func NewUpdateLoginFlowRequestWithBody(server string, params *UpdateLoginFlowParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "flow", runtime.ParamLocationQuery, params.Flow); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XSessionToken != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Session-Token", runtime.ParamLocationHeader, *params.XSessionToken)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Session-Token", headerParam0)
		}

		if params.Cookie != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam1)
		}

	}

	return req, nil
}

// NewCreateBrowserLoginFlowRequest generates requests for CreateBrowserLoginFlow
func NewCreateBrowserLoginFlowRequest(server string, params *CreateBrowserLoginFlowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/login/browser")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Refresh != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "refresh", runtime.ParamLocationQuery, *params.Refresh); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Aal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "aal", runtime.ParamLocationQuery, *params.Aal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReturnTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return_to", runtime.ParamLocationQuery, *params.ReturnTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LoginChallenge != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "login_challenge", runtime.ParamLocationQuery, *params.LoginChallenge); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Organization != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organization", runtime.ParamLocationQuery, *params.Organization); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Cookie != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam0)
		}

	}

	return req, nil
}

// NewGetLoginFlowRequest generates requests for GetLoginFlow
func NewGetLoginFlowRequest(server string, params *GetLoginFlowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/login/flows")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Cookie != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateLogoutFlowRequest generates requests for UpdateLogoutFlow
func NewUpdateLogoutFlowRequest(server string, params *UpdateLogoutFlowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Token != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token", runtime.ParamLocationQuery, *params.Token); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReturnTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return_to", runtime.ParamLocationQuery, *params.ReturnTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Cookie != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam0)
		}

	}

	return req, nil
}

// NewCreateBrowserLogoutFlowRequest generates requests for CreateBrowserLogoutFlow
func NewCreateBrowserLogoutFlowRequest(server string, params *CreateBrowserLogoutFlowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/logout/browser")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ReturnTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return_to", runtime.ParamLocationQuery, *params.ReturnTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Cookie != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("cookie", headerParam0)
		}

	}

	return req, nil
}

// NewInitRecoveryFlowRequest generates requests for InitRecoveryFlow
func NewInitRecoveryFlowRequest(server string, params *InitRecoveryFlowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/recovery")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "flow", runtime.ParamLocationQuery, params.Flow); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Token != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token", runtime.ParamLocationQuery, *params.Token); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Cookie != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateRecoveryFlowRequest calls the generic UpdateRecoveryFlow builder with application/json body
func NewUpdateRecoveryFlowRequest(server string, params *UpdateRecoveryFlowParams, body UpdateRecoveryFlowJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRecoveryFlowRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateRecoveryFlowRequestWithFormdataBody calls the generic UpdateRecoveryFlow builder with application/x-www-form-urlencoded body
func NewUpdateRecoveryFlowRequestWithFormdataBody(server string, params *UpdateRecoveryFlowParams, body UpdateRecoveryFlowFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewUpdateRecoveryFlowRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewUpdateRecoveryFlowRequestWithBody generates requests for UpdateRecoveryFlow with any type of body
func NewUpdateRecoveryFlowRequestWithBody(server string, params *UpdateRecoveryFlowParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/recovery")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "flow", runtime.ParamLocationQuery, params.Flow); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Token != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token", runtime.ParamLocationQuery, *params.Token); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Cookie != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam0)
		}

	}

	return req, nil
}

// NewCreateBrowserRecoveryFlowRequest generates requests for CreateBrowserRecoveryFlow
func NewCreateBrowserRecoveryFlowRequest(server string, params *CreateBrowserRecoveryFlowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/recovery/browser")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ReturnTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return_to", runtime.ParamLocationQuery, *params.ReturnTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRecoveryFlowRequest generates requests for GetRecoveryFlow
func NewGetRecoveryFlowRequest(server string, params *GetRecoveryFlowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/recovery/flows")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Cookie != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateSettingsFloRequest calls the generic UpdateSettingsFlo builder with application/json body
func NewUpdateSettingsFloRequest(server string, params *UpdateSettingsFloParams, body UpdateSettingsFloJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSettingsFloRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateSettingsFloRequestWithFormdataBody calls the generic UpdateSettingsFlo builder with application/x-www-form-urlencoded body
func NewUpdateSettingsFloRequestWithFormdataBody(server string, params *UpdateSettingsFloParams, body UpdateSettingsFloFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewUpdateSettingsFloRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewUpdateSettingsFloRequestWithBody generates requests for UpdateSettingsFlo with any type of body
func NewUpdateSettingsFloRequestWithBody(server string, params *UpdateSettingsFloParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "flow", runtime.ParamLocationQuery, params.Flow); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XSessionToken != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Session-Token", runtime.ParamLocationHeader, *params.XSessionToken)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Session-Token", headerParam0)
		}

		if params.Cookie != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam1)
		}

	}

	return req, nil
}

// NewCreateBrowserSettingsFlowRequest generates requests for CreateBrowserSettingsFlow
func NewCreateBrowserSettingsFlowRequest(server string, params *CreateBrowserSettingsFlowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/settings/browser")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ReturnTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "return_to", runtime.ParamLocationQuery, *params.ReturnTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Cookie != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam0)
		}

	}

	return req, nil
}

// NewGetSettingsFlowRequest generates requests for GetSettingsFlow
func NewGetSettingsFlowRequest(server string, params *GetSettingsFlowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/self-service/settings/flows")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XSessionToken != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Session-Token", runtime.ParamLocationHeader, *params.XSessionToken)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Session-Token", headerParam0)
		}

		if params.Cookie != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam1)
		}

	}

	return req, nil
}

// NewToSessionRequest generates requests for ToSession
func NewToSessionRequest(server string, params *ToSessionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/frontend/sessions/whoami")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TokenizeAs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tokenize_as", runtime.ParamLocationQuery, *params.TokenizeAs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XSessionToken != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Session-Token", runtime.ParamLocationHeader, *params.XSessionToken)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Session-Token", headerParam0)
		}

		if params.Cookie != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Cookie", runtime.ParamLocationHeader, *params.Cookie)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Cookie", headerParam1)
		}

	}

	return req, nil
}

// NewIntrospectRequestWithFormdataBody calls the generic Introspect builder with application/x-www-form-urlencoded body
func NewIntrospectRequestWithFormdataBody(server string, body IntrospectFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewIntrospectRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewIntrospectRequestWithBody generates requests for Introspect with any type of body
func NewIntrospectRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/introspect")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListOrganisationsIdentityRequest generates requests for ListOrganisationsIdentity
func NewListOrganisationsIdentityRequest(server string, params *ListOrganisationsIdentityParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIAMPolicyOrganisationRequest generates requests for GetIAMPolicyOrganisation
func NewGetIAMPolicyOrganisationRequest(server string, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "subjectType", runtime.ParamLocationPath, subjectType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "subjectId", runtime.ParamLocationPath, subjectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/iampolicy/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetIAMPolicyOrganisationRequest calls the generic SetIAMPolicyOrganisation builder with application/json body
func NewSetIAMPolicyOrganisationRequest(server string, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, body SetIAMPolicyOrganisationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetIAMPolicyOrganisationRequestWithBody(server, organisationId, subjectType, subjectId, "application/json", bodyReader)
}

// NewSetIAMPolicyOrganisationRequestWithBody generates requests for SetIAMPolicyOrganisation with any type of body
func NewSetIAMPolicyOrganisationRequestWithBody(server string, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "subjectType", runtime.ParamLocationPath, subjectType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "subjectId", runtime.ParamLocationPath, subjectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/iampolicy/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMatchServiceAccountOrganisationRequest generates requests for MatchServiceAccountOrganisation
func NewMatchServiceAccountOrganisationRequest(server string, organisationId OrganisationId, params *MatchServiceAccountOrganisationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/match/serviceAccounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "serviceAccountName", runtime.ParamLocationQuery, params.ServiceAccountName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

	}

	return req, nil
}

// NewGetUserOrganisationByEmailRequest generates requests for GetUserOrganisationByEmail
func NewGetUserOrganisationByEmailRequest(server string, organisationId OrganisationId, params *GetUserOrganisationByEmailParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/match/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "email", runtime.ParamLocationQuery, params.Email); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

	}

	return req, nil
}

// NewListPermissionsOrganisationRequest generates requests for ListPermissionsOrganisation
func NewListPermissionsOrganisationRequest(server string, organisationId OrganisationId, params *ListPermissionsOrganisationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/permissions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Service != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "service", runtime.ParamLocationQuery, *params.Service); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Resource != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resource", runtime.ParamLocationQuery, *params.Resource); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Subresource != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subresource", runtime.ParamLocationQuery, *params.Subresource); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Action != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "action", runtime.ParamLocationQuery, *params.Action); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPermissionOrganisationRequest generates requests for GetPermissionOrganisation
func NewGetPermissionOrganisationRequest(server string, organisationId OrganisationId, permissionUuid PermissionUuid) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "permissionUuid", runtime.ParamLocationPath, permissionUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/permissions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRolesOrganisationRequest generates requests for ListRolesOrganisation
func NewListRolesOrganisationRequest(server string, organisationId OrganisationId, params *ListRolesOrganisationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/roles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRoleOrganisationRequest generates requests for GetRoleOrganisation
func NewGetRoleOrganisationRequest(server string, organisationId OrganisationId, roleUuid RoleUuid) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUuid", runtime.ParamLocationPath, roleUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/roles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRolePermissionsOrganisationRequest generates requests for GetRolePermissionsOrganisation
func NewGetRolePermissionsOrganisationRequest(server string, organisationId OrganisationId, roleUuid RoleUuid, params *GetRolePermissionsOrganisationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUuid", runtime.ParamLocationPath, roleUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/roles/%s/permissions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListServiceAccountOrganisationRequest generates requests for ListServiceAccountOrganisation
func NewListServiceAccountOrganisationRequest(server string, organisationId OrganisationId, params *ListServiceAccountOrganisationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/serviceAccounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateServiceAccountOrganisationRequest calls the generic CreateServiceAccountOrganisation builder with application/json body
func NewCreateServiceAccountOrganisationRequest(server string, organisationId OrganisationId, body CreateServiceAccountOrganisationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServiceAccountOrganisationRequestWithBody(server, organisationId, "application/json", bodyReader)
}

// NewCreateServiceAccountOrganisationRequestWithBody generates requests for CreateServiceAccountOrganisation with any type of body
func NewCreateServiceAccountOrganisationRequestWithBody(server string, organisationId OrganisationId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/serviceAccounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServiceAccountOrganisationRequest generates requests for DeleteServiceAccountOrganisation
func NewDeleteServiceAccountOrganisationRequest(server string, organisationId OrganisationId, serviceAccountId ServiceAccountId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/serviceAccounts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServiceAccountOrganisationRequest generates requests for GetServiceAccountOrganisation
func NewGetServiceAccountOrganisationRequest(server string, organisationId OrganisationId, serviceAccountId ServiceAccountId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/serviceAccounts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateServiceAccountOrganisationRequest calls the generic UpdateServiceAccountOrganisation builder with application/json body
func NewUpdateServiceAccountOrganisationRequest(server string, organisationId OrganisationId, serviceAccountId ServiceAccountId, body UpdateServiceAccountOrganisationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateServiceAccountOrganisationRequestWithBody(server, organisationId, serviceAccountId, "application/json", bodyReader)
}

// NewUpdateServiceAccountOrganisationRequestWithBody generates requests for UpdateServiceAccountOrganisation with any type of body
func NewUpdateServiceAccountOrganisationRequestWithBody(server string, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/serviceAccounts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetACLServiceAccountOrganisationRequest generates requests for GetACLServiceAccountOrganisation
func NewGetACLServiceAccountOrganisationRequest(server string, organisationId OrganisationId, serviceAccountId ServiceAccountId, params *GetACLServiceAccountOrganisationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/serviceAccounts/%s/acl", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "service", runtime.ParamLocationQuery, params.Service); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resource", runtime.ParamLocationQuery, params.Resource); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Subresource != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subresource", runtime.ParamLocationQuery, *params.Subresource); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteACLServiceAccountOrganisationBulkRequest calls the generic DeleteACLServiceAccountOrganisationBulk builder with application/json body
func NewDeleteACLServiceAccountOrganisationBulkRequest(server string, organisationId OrganisationId, serviceAccountId ServiceAccountId, body DeleteACLServiceAccountOrganisationBulkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteACLServiceAccountOrganisationBulkRequestWithBody(server, organisationId, serviceAccountId, "application/json", bodyReader)
}

// NewDeleteACLServiceAccountOrganisationBulkRequestWithBody generates requests for DeleteACLServiceAccountOrganisationBulk with any type of body
func NewDeleteACLServiceAccountOrganisationBulkRequestWithBody(server string, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/serviceAccounts/%s/bulk/acl", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateACLServiceAccountOrganisationBulkRequest calls the generic CreateACLServiceAccountOrganisationBulk builder with application/json body
func NewCreateACLServiceAccountOrganisationBulkRequest(server string, organisationId OrganisationId, serviceAccountId ServiceAccountId, body CreateACLServiceAccountOrganisationBulkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateACLServiceAccountOrganisationBulkRequestWithBody(server, organisationId, serviceAccountId, "application/json", bodyReader)
}

// NewCreateACLServiceAccountOrganisationBulkRequestWithBody generates requests for CreateACLServiceAccountOrganisationBulk with any type of body
func NewCreateACLServiceAccountOrganisationBulkRequestWithBody(server string, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/serviceAccounts/%s/bulk/acl", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListSpacesOfServiceAccountRequest generates requests for ListSpacesOfServiceAccount
func NewListSpacesOfServiceAccountRequest(server string, organisationId OrganisationId, serviceAccountId ServiceAccountId, params *ListSpacesOfServiceAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/serviceAccounts/%s/spaces", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSpacesIdentityRequest generates requests for ListSpacesIdentity
func NewListSpacesIdentityRequest(server string, organisationId OrganisationId, params *ListSpacesIdentityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/spaces", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUserOrganisationRequest generates requests for ListUserOrganisation
func NewListUserOrganisationRequest(server string, organisationId OrganisationId, params *ListUserOrganisationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserOrganisationRequest calls the generic CreateUserOrganisation builder with application/json body
func NewCreateUserOrganisationRequest(server string, organisationId OrganisationId, body CreateUserOrganisationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserOrganisationRequestWithBody(server, organisationId, "application/json", bodyReader)
}

// NewCreateUserOrganisationRequestWithBody generates requests for CreateUserOrganisation with any type of body
func NewCreateUserOrganisationRequestWithBody(server string, organisationId OrganisationId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserOrganisationRequest generates requests for DeleteUserOrganisation
func NewDeleteUserOrganisationRequest(server string, organisationId OrganisationId, userId UserId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserOrganisationRequest generates requests for GetUserOrganisation
func NewGetUserOrganisationRequest(server string, organisationId OrganisationId, userId UserId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchUserStateOrganisationRequest calls the generic PatchUserStateOrganisation builder with application/json body
func NewPatchUserStateOrganisationRequest(server string, organisationId OrganisationId, userId UserId, body PatchUserStateOrganisationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchUserStateOrganisationRequestWithBody(server, organisationId, userId, "application/json", bodyReader)
}

// NewPatchUserStateOrganisationRequestWithBody generates requests for PatchUserStateOrganisation with any type of body
func NewPatchUserStateOrganisationRequestWithBody(server string, organisationId OrganisationId, userId UserId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateUserOrganisationRequest calls the generic UpdateUserOrganisation builder with application/json body
func NewUpdateUserOrganisationRequest(server string, organisationId OrganisationId, userId UserId, body UpdateUserOrganisationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserOrganisationRequestWithBody(server, organisationId, userId, "application/json", bodyReader)
}

// NewUpdateUserOrganisationRequestWithBody generates requests for UpdateUserOrganisation with any type of body
func NewUpdateUserOrganisationRequestWithBody(server string, organisationId OrganisationId, userId UserId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetACLUserOrganisationRequest generates requests for GetACLUserOrganisation
func NewGetACLUserOrganisationRequest(server string, organisationId OrganisationId, userId UserId, params *GetACLUserOrganisationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/users/%s/acl", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "service", runtime.ParamLocationQuery, params.Service); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resource", runtime.ParamLocationQuery, params.Resource); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Subresource != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subresource", runtime.ParamLocationQuery, *params.Subresource); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteACLUserOrganisationBulkRequest calls the generic DeleteACLUserOrganisationBulk builder with application/json body
func NewDeleteACLUserOrganisationBulkRequest(server string, organisationId OrganisationId, userId UserId, body DeleteACLUserOrganisationBulkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteACLUserOrganisationBulkRequestWithBody(server, organisationId, userId, "application/json", bodyReader)
}

// NewDeleteACLUserOrganisationBulkRequestWithBody generates requests for DeleteACLUserOrganisationBulk with any type of body
func NewDeleteACLUserOrganisationBulkRequestWithBody(server string, organisationId OrganisationId, userId UserId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/users/%s/bulk/acl", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateACLUserOrganisationBulkRequest calls the generic CreateACLUserOrganisationBulk builder with application/json body
func NewCreateACLUserOrganisationBulkRequest(server string, organisationId OrganisationId, userId UserId, body CreateACLUserOrganisationBulkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateACLUserOrganisationBulkRequestWithBody(server, organisationId, userId, "application/json", bodyReader)
}

// NewCreateACLUserOrganisationBulkRequestWithBody generates requests for CreateACLUserOrganisationBulk with any type of body
func NewCreateACLUserOrganisationBulkRequestWithBody(server string, organisationId OrganisationId, userId UserId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/users/%s/bulk/acl", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRecoverUserOrganisationRequest generates requests for RecoverUserOrganisation
func NewRecoverUserOrganisationRequest(server string, organisationId OrganisationId, userId UserId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/users/%s/recover", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSpacesOfUserRequest generates requests for ListSpacesOfUser
func NewListSpacesOfUserRequest(server string, organisationId OrganisationId, userId UserId, params *ListSpacesOfUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/organisations/%s/users/%s/spaces", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRevokeRequestWithFormdataBody calls the generic Revoke builder with application/x-www-form-urlencoded body
func NewRevokeRequestWithFormdataBody(server string, params *RevokeParams, body RevokeFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewRevokeRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewRevokeRequestWithBody generates requests for Revoke with any type of body
func NewRevokeRequestWithBody(server string, params *RevokeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/revoke")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Authorization != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, *params.Authorization)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Authorization", headerParam0)
		}

	}

	return req, nil
}

// NewGetIAMPolicySpaceRequest generates requests for GetIAMPolicySpace
func NewGetIAMPolicySpaceRequest(server string, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "subjectType", runtime.ParamLocationPath, subjectType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "subjectId", runtime.ParamLocationPath, subjectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/iampolicy/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetIAMPolicySpaceRequest calls the generic SetIAMPolicySpace builder with application/json body
func NewSetIAMPolicySpaceRequest(server string, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, body SetIAMPolicySpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetIAMPolicySpaceRequestWithBody(server, spaceId, subjectType, subjectId, "application/json", bodyReader)
}

// NewSetIAMPolicySpaceRequestWithBody generates requests for SetIAMPolicySpace with any type of body
func NewSetIAMPolicySpaceRequestWithBody(server string, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "subjectType", runtime.ParamLocationPath, subjectType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "subjectId", runtime.ParamLocationPath, subjectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/iampolicy/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMatchServiceAccountSpaceRequest generates requests for MatchServiceAccountSpace
func NewMatchServiceAccountSpaceRequest(server string, spaceId SpaceId, params *MatchServiceAccountSpaceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/match/serviceAccounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "serviceAccountName", runtime.ParamLocationQuery, params.ServiceAccountName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

	}

	return req, nil
}

// NewGetUserSpaceByEmailRequest generates requests for GetUserSpaceByEmail
func NewGetUserSpaceByEmailRequest(server string, spaceId SpaceId, params *GetUserSpaceByEmailParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/match/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "email", runtime.ParamLocationQuery, params.Email); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

	}

	return req, nil
}

// NewListPermissionsSpaceRequest generates requests for ListPermissionsSpace
func NewListPermissionsSpaceRequest(server string, spaceId SpaceId, params *ListPermissionsSpaceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/permissions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Service != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "service", runtime.ParamLocationQuery, *params.Service); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Resource != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resource", runtime.ParamLocationQuery, *params.Resource); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Subresource != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subresource", runtime.ParamLocationQuery, *params.Subresource); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Action != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "action", runtime.ParamLocationQuery, *params.Action); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPermissionSpaceRequest generates requests for GetPermissionSpace
func NewGetPermissionSpaceRequest(server string, spaceId SpaceId, permissionUuid PermissionUuid) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "permissionUuid", runtime.ParamLocationPath, permissionUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/permissions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRolesSpaceRequest generates requests for ListRolesSpace
func NewListRolesSpaceRequest(server string, spaceId SpaceId, params *ListRolesSpaceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/roles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRoleSpaceRequest generates requests for GetRoleSpace
func NewGetRoleSpaceRequest(server string, spaceId SpaceId, roleUuid RoleUuid) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUuid", runtime.ParamLocationPath, roleUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/roles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRolePermissionsSpaceRequest generates requests for GetRolePermissionsSpace
func NewGetRolePermissionsSpaceRequest(server string, spaceId SpaceId, roleUuid RoleUuid, params *GetRolePermissionsSpaceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUuid", runtime.ParamLocationPath, roleUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/roles/%s/permissions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListServiceAccountSpaceRequest generates requests for ListServiceAccountSpace
func NewListServiceAccountSpaceRequest(server string, spaceId SpaceId, params *ListServiceAccountSpaceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/serviceAccounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateServiceAccountSpaceRequest calls the generic CreateServiceAccountSpace builder with application/json body
func NewCreateServiceAccountSpaceRequest(server string, spaceId SpaceId, body CreateServiceAccountSpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServiceAccountSpaceRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateServiceAccountSpaceRequestWithBody generates requests for CreateServiceAccountSpace with any type of body
func NewCreateServiceAccountSpaceRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/serviceAccounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServiceAccountSpaceRequest generates requests for DeleteServiceAccountSpace
func NewDeleteServiceAccountSpaceRequest(server string, spaceId SpaceId, serviceAccountId ServiceAccountId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/serviceAccounts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServiceAccountSpaceRequest generates requests for GetServiceAccountSpace
func NewGetServiceAccountSpaceRequest(server string, spaceId SpaceId, serviceAccountId ServiceAccountId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/serviceAccounts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignServiceAccountToSpaceRequest generates requests for AssignServiceAccountToSpace
func NewAssignServiceAccountToSpaceRequest(server string, spaceId SpaceId, serviceAccountId ServiceAccountId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/serviceAccounts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateServiceAccountSpaceRequest calls the generic UpdateServiceAccountSpace builder with application/json body
func NewUpdateServiceAccountSpaceRequest(server string, spaceId SpaceId, serviceAccountId ServiceAccountId, body UpdateServiceAccountSpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateServiceAccountSpaceRequestWithBody(server, spaceId, serviceAccountId, "application/json", bodyReader)
}

// NewUpdateServiceAccountSpaceRequestWithBody generates requests for UpdateServiceAccountSpace with any type of body
func NewUpdateServiceAccountSpaceRequestWithBody(server string, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/serviceAccounts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetACLServiceAccountSpaceRequest generates requests for GetACLServiceAccountSpace
func NewGetACLServiceAccountSpaceRequest(server string, spaceId SpaceId, serviceAccountId ServiceAccountId, params *GetACLServiceAccountSpaceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/serviceAccounts/%s/acl", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "service", runtime.ParamLocationQuery, params.Service); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resource", runtime.ParamLocationQuery, params.Resource); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Subresource != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subresource", runtime.ParamLocationQuery, *params.Subresource); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteACLServiceAccountSpaceBulkRequest calls the generic DeleteACLServiceAccountSpaceBulk builder with application/json body
func NewDeleteACLServiceAccountSpaceBulkRequest(server string, spaceId SpaceId, serviceAccountId ServiceAccountId, body DeleteACLServiceAccountSpaceBulkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteACLServiceAccountSpaceBulkRequestWithBody(server, spaceId, serviceAccountId, "application/json", bodyReader)
}

// NewDeleteACLServiceAccountSpaceBulkRequestWithBody generates requests for DeleteACLServiceAccountSpaceBulk with any type of body
func NewDeleteACLServiceAccountSpaceBulkRequestWithBody(server string, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/serviceAccounts/%s/bulk/acl", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateACLServiceAccountSpaceBulkRequest calls the generic CreateACLServiceAccountSpaceBulk builder with application/json body
func NewCreateACLServiceAccountSpaceBulkRequest(server string, spaceId SpaceId, serviceAccountId ServiceAccountId, body CreateACLServiceAccountSpaceBulkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateACLServiceAccountSpaceBulkRequestWithBody(server, spaceId, serviceAccountId, "application/json", bodyReader)
}

// NewCreateACLServiceAccountSpaceBulkRequestWithBody generates requests for CreateACLServiceAccountSpaceBulk with any type of body
func NewCreateACLServiceAccountSpaceBulkRequestWithBody(server string, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/serviceAccounts/%s/bulk/acl", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListUserSpaceRequest generates requests for ListUserSpace
func NewListUserSpaceRequest(server string, spaceId SpaceId, params *ListUserSpaceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserSpaceRequest calls the generic CreateUserSpace builder with application/json body
func NewCreateUserSpaceRequest(server string, spaceId SpaceId, body CreateUserSpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserSpaceRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateUserSpaceRequestWithBody generates requests for CreateUserSpace with any type of body
func NewCreateUserSpaceRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnassignUserSpaceRequest generates requests for UnassignUserSpace
func NewUnassignUserSpaceRequest(server string, spaceId SpaceId, userId UserId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserSpaceRequest generates requests for GetUserSpace
func NewGetUserSpaceRequest(server string, spaceId SpaceId, userId UserId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchUserStateSpaceRequest calls the generic PatchUserStateSpace builder with application/json body
func NewPatchUserStateSpaceRequest(server string, spaceId SpaceId, userId UserId, body PatchUserStateSpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchUserStateSpaceRequestWithBody(server, spaceId, userId, "application/json", bodyReader)
}

// NewPatchUserStateSpaceRequestWithBody generates requests for PatchUserStateSpace with any type of body
func NewPatchUserStateSpaceRequestWithBody(server string, spaceId SpaceId, userId UserId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAssignUserToSpaceRequest generates requests for AssignUserToSpace
func NewAssignUserToSpaceRequest(server string, spaceId SpaceId, userId UserId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserSpaceRequest calls the generic UpdateUserSpace builder with application/json body
func NewUpdateUserSpaceRequest(server string, spaceId SpaceId, userId UserId, body UpdateUserSpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserSpaceRequestWithBody(server, spaceId, userId, "application/json", bodyReader)
}

// NewUpdateUserSpaceRequestWithBody generates requests for UpdateUserSpace with any type of body
func NewUpdateUserSpaceRequestWithBody(server string, spaceId SpaceId, userId UserId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetACLUserSpaceRequest generates requests for GetACLUserSpace
func NewGetACLUserSpaceRequest(server string, spaceId SpaceId, userId UserId, params *GetACLUserSpaceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/users/%s/acl", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "service", runtime.ParamLocationQuery, params.Service); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resource", runtime.ParamLocationQuery, params.Resource); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Subresource != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subresource", runtime.ParamLocationQuery, *params.Subresource); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteACLUserSpaceBulkRequest calls the generic DeleteACLUserSpaceBulk builder with application/json body
func NewDeleteACLUserSpaceBulkRequest(server string, spaceId SpaceId, userId UserId, body DeleteACLUserSpaceBulkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteACLUserSpaceBulkRequestWithBody(server, spaceId, userId, "application/json", bodyReader)
}

// NewDeleteACLUserSpaceBulkRequestWithBody generates requests for DeleteACLUserSpaceBulk with any type of body
func NewDeleteACLUserSpaceBulkRequestWithBody(server string, spaceId SpaceId, userId UserId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/users/%s/bulk/acl", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateACLUserSpaceBulkRequest calls the generic CreateACLUserSpaceBulk builder with application/json body
func NewCreateACLUserSpaceBulkRequest(server string, spaceId SpaceId, userId UserId, body CreateACLUserSpaceBulkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateACLUserSpaceBulkRequestWithBody(server, spaceId, userId, "application/json", bodyReader)
}

// NewCreateACLUserSpaceBulkRequestWithBody generates requests for CreateACLUserSpaceBulk with any type of body
func NewCreateACLUserSpaceBulkRequestWithBody(server string, spaceId SpaceId, userId UserId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/users/%s/bulk/acl", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRecoverUserSpaceRequest generates requests for RecoverUserSpace
func NewRecoverUserSpaceRequest(server string, spaceId SpaceId, userId UserId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/spaces/%s/users/%s/recover", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTokenRequestWithFormdataBody calls the generic Token builder with application/x-www-form-urlencoded body
func NewTokenRequestWithFormdataBody(server string, params *TokenParams, body TokenFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTokenRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewTokenRequestWithBody generates requests for Token with any type of body
func NewTokenRequestWithBody(server string, params *TokenParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Authorization != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, *params.Authorization)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Authorization", headerParam0)
		}

	}

	return req, nil
}

// NewConvertTokenRequest calls the generic ConvertToken builder with application/json body
func NewConvertTokenRequest(server string, body ConvertTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConvertTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewConvertTokenRequestWithBody generates requests for ConvertToken with any type of body
func NewConvertTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/token/convert")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserInfoRequest generates requests for GetUserInfo
func NewGetUserInfoRequest(server string, params *GetUserInfoParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/userinfo")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Authorization != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, *params.Authorization)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Authorization", headerParam0)
		}

	}

	return req, nil
}

// NewHealthcheckRequest generates requests for Healthcheck
func NewHealthcheckRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/kubernetes/healthcheck")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListKubernetesSupportedNodeProfilesRequest generates requests for ListKubernetesSupportedNodeProfiles
func NewListKubernetesSupportedNodeProfilesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/kubernetes/nodeprofiles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListKubernetesClustersRequest generates requests for ListKubernetesClusters
func NewListKubernetesClustersRequest(server string, spaceId SpaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/kubernetes/spaces/%s/clusters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateKubernetesClusterRequest calls the generic CreateKubernetesCluster builder with application/json body
func NewCreateKubernetesClusterRequest(server string, spaceId SpaceId, body CreateKubernetesClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateKubernetesClusterRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateKubernetesClusterRequestWithBody generates requests for CreateKubernetesCluster with any type of body
func NewCreateKubernetesClusterRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/kubernetes/spaces/%s/clusters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteKubernetesClusterRequest generates requests for DeleteKubernetesCluster
func NewDeleteKubernetesClusterRequest(server string, spaceId SpaceId, clusterId KubernetesClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/kubernetes/spaces/%s/clusters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKubernetesClusterInfoRequest generates requests for GetKubernetesClusterInfo
func NewGetKubernetesClusterInfoRequest(server string, spaceId SpaceId, clusterId KubernetesClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/kubernetes/spaces/%s/clusters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKubernetesKubeConfigRequest generates requests for GetKubernetesKubeConfig
func NewGetKubernetesKubeConfigRequest(server string, spaceId SpaceId, clusterId KubernetesClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/kubernetes/spaces/%s/clusters/%s/kubeconfig", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpgradeKubernetesMastersRequest calls the generic UpgradeKubernetesMasters builder with application/json body
func NewUpgradeKubernetesMastersRequest(server string, spaceId SpaceId, clusterId KubernetesClusterId, body UpgradeKubernetesMastersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpgradeKubernetesMastersRequestWithBody(server, spaceId, clusterId, "application/json", bodyReader)
}

// NewUpgradeKubernetesMastersRequestWithBody generates requests for UpgradeKubernetesMasters with any type of body
func NewUpgradeKubernetesMastersRequestWithBody(server string, spaceId SpaceId, clusterId KubernetesClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/kubernetes/spaces/%s/clusters/%s/masters/upgrade", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListKubernetesOperationsRequest generates requests for ListKubernetesOperations
func NewListKubernetesOperationsRequest(server string, spaceId SpaceId, clusterId KubernetesClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/kubernetes/spaces/%s/clusters/%s/operations", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKubernetesPrivateKeyRequest generates requests for GetKubernetesPrivateKey
func NewGetKubernetesPrivateKeyRequest(server string, spaceId SpaceId, clusterId KubernetesClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/kubernetes/spaces/%s/clusters/%s/privatekey", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKubernetesClusterStateRequest generates requests for GetKubernetesClusterState
func NewGetKubernetesClusterStateRequest(server string, spaceId SpaceId, clusterId KubernetesClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/kubernetes/spaces/%s/clusters/%s/state", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateKubernetesNodesRequest generates requests for UpdateKubernetesNodes
func NewUpdateKubernetesNodesRequest(server string, spaceId SpaceId, clusterId KubernetesClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/kubernetes/spaces/%s/clusters/%s/update", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddKubernetesWorkersRequest calls the generic AddKubernetesWorkers builder with application/json body
func NewAddKubernetesWorkersRequest(server string, spaceId SpaceId, clusterId KubernetesClusterId, body AddKubernetesWorkersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddKubernetesWorkersRequestWithBody(server, spaceId, clusterId, "application/json", bodyReader)
}

// NewAddKubernetesWorkersRequestWithBody generates requests for AddKubernetesWorkers with any type of body
func NewAddKubernetesWorkersRequestWithBody(server string, spaceId SpaceId, clusterId KubernetesClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/kubernetes/spaces/%s/clusters/%s/workers/add", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveKubernetesWorkerRequest calls the generic RemoveKubernetesWorker builder with application/json body
func NewRemoveKubernetesWorkerRequest(server string, spaceId SpaceId, clusterId KubernetesClusterId, body RemoveKubernetesWorkerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveKubernetesWorkerRequestWithBody(server, spaceId, clusterId, "application/json", bodyReader)
}

// NewRemoveKubernetesWorkerRequestWithBody generates requests for RemoveKubernetesWorker with any type of body
func NewRemoveKubernetesWorkerRequestWithBody(server string, spaceId SpaceId, clusterId KubernetesClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/kubernetes/spaces/%s/clusters/%s/workers/remove", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpgradeKubernetesWorkersRequest calls the generic UpgradeKubernetesWorkers builder with application/json body
func NewUpgradeKubernetesWorkersRequest(server string, spaceId SpaceId, clusterId KubernetesClusterId, body UpgradeKubernetesWorkersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpgradeKubernetesWorkersRequestWithBody(server, spaceId, clusterId, "application/json", bodyReader)
}

// NewUpgradeKubernetesWorkersRequestWithBody generates requests for UpgradeKubernetesWorkers with any type of body
func NewUpgradeKubernetesWorkersRequestWithBody(server string, spaceId SpaceId, clusterId KubernetesClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/kubernetes/spaces/%s/clusters/%s/workers/upgrade", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetKubernetesOperationRequest generates requests for GetKubernetesOperation
func NewGetKubernetesOperationRequest(server string, spaceId SpaceId, operationId OperationId, params *GetKubernetesOperationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "operationId", runtime.ParamLocationPath, operationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/kubernetes/spaces/%s/operations/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

	}

	return req, nil
}

// NewListKubernetesSupportedVersionsRequest generates requests for ListKubernetesSupportedVersions
func NewListKubernetesSupportedVersionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/kubernetes/versions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListClustersRequest generates requests for ListClusters
func NewListClustersRequest(server string, spaceId SpaceId, params *ListClustersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openshift/spaces/%s/clusters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateClusterRequest calls the generic CreateCluster builder with application/json body
func NewCreateClusterRequest(server string, spaceId SpaceId, body CreateClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateClusterRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateClusterRequestWithBody generates requests for CreateCluster with any type of body
func NewCreateClusterRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openshift/spaces/%s/clusters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteClusterRequest generates requests for DeleteCluster
func NewDeleteClusterRequest(server string, spaceId SpaceId, clusterId OpenShiftClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openshift/spaces/%s/clusters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClusterRequest generates requests for GetCluster
func NewGetClusterRequest(server string, spaceId SpaceId, clusterId OpenShiftClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openshift/spaces/%s/clusters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateClusterRequest calls the generic UpdateCluster builder with application/json body
func NewUpdateClusterRequest(server string, spaceId SpaceId, clusterId OpenShiftClusterId, body UpdateClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateClusterRequestWithBody(server, spaceId, clusterId, "application/json", bodyReader)
}

// NewUpdateClusterRequestWithBody generates requests for UpdateCluster with any type of body
func NewUpdateClusterRequestWithBody(server string, spaceId SpaceId, clusterId OpenShiftClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openshift/spaces/%s/clusters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListNodepoolsRequest generates requests for ListNodepools
func NewListNodepoolsRequest(server string, spaceId SpaceId, clusterId OpenShiftClusterId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openshift/spaces/%s/clusters/%s/nodepools", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNodePoolRequest calls the generic CreateNodePool builder with application/json body
func NewCreateNodePoolRequest(server string, spaceId SpaceId, clusterId OpenShiftClusterId, body CreateNodePoolJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNodePoolRequestWithBody(server, spaceId, clusterId, "application/json", bodyReader)
}

// NewCreateNodePoolRequestWithBody generates requests for CreateNodePool with any type of body
func NewCreateNodePoolRequestWithBody(server string, spaceId SpaceId, clusterId OpenShiftClusterId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openshift/spaces/%s/clusters/%s/nodepools", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteNodePoolRequest generates requests for DeleteNodePool
func NewDeleteNodePoolRequest(server string, spaceId SpaceId, clusterId OpenShiftClusterId, nodePoolName OpenShiftNodepoolName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "nodePoolName", runtime.ParamLocationPath, nodePoolName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openshift/spaces/%s/clusters/%s/nodepools/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateNodepoolRequest calls the generic UpdateNodepool builder with application/json body
func NewUpdateNodepoolRequest(server string, spaceId SpaceId, clusterId OpenShiftClusterId, nodePoolName OpenShiftNodepoolName, body UpdateNodepoolJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateNodepoolRequestWithBody(server, spaceId, clusterId, nodePoolName, "application/json", bodyReader)
}

// NewUpdateNodepoolRequestWithBody generates requests for UpdateNodepool with any type of body
func NewUpdateNodepoolRequestWithBody(server string, spaceId SpaceId, clusterId OpenShiftClusterId, nodePoolName OpenShiftNodepoolName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "nodePoolName", runtime.ParamLocationPath, nodePoolName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openshift/spaces/%s/clusters/%s/nodepools/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListOperationsRequest generates requests for ListOperations
func NewListOperationsRequest(server string, spaceId SpaceId, params *ListOperationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openshift/spaces/%s/operations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClusterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "clusterId", runtime.ParamLocationQuery, *params.ClusterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOperationRequest generates requests for GetOperation
func NewGetOperationRequest(server string, spaceId SpaceId, operationId OperationId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "operationId", runtime.ParamLocationPath, operationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openshift/spaces/%s/operations/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListVersionsRequest generates requests for ListVersions
func NewListVersionsRequest(server string, spaceId SpaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openshift/spaces/%s/versions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSpacesRequest generates requests for ListSpaces
func NewListSpacesRequest(server string, organisationId OrganisationId, params *ListSpacesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organisations/%s/spaces", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSpaceRequest calls the generic CreateSpace builder with application/json body
func NewCreateSpaceRequest(server string, organisationId OrganisationId, body CreateSpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSpaceRequestWithBody(server, organisationId, "application/json", bodyReader)
}

// NewCreateSpaceRequestWithBody generates requests for CreateSpace with any type of body
func NewCreateSpaceRequestWithBody(server string, organisationId OrganisationId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organisations/%s/spaces", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSpaceRequest generates requests for DeleteSpace
func NewDeleteSpaceRequest(server string, organisationId OrganisationId, spaceId SpaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organisations/%s/spaces/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSpaceByIdRequest generates requests for GetSpaceById
func NewGetSpaceByIdRequest(server string, organisationId OrganisationId, spaceId SpaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organisations/%s/spaces/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSpaceRequest calls the generic UpdateSpace builder with application/json body
func NewUpdateSpaceRequest(server string, organisationId OrganisationId, spaceId SpaceId, body UpdateSpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSpaceRequestWithBody(server, organisationId, spaceId, "application/json", bodyReader)
}

// NewUpdateSpaceRequestWithBody generates requests for UpdateSpace with any type of body
func NewUpdateSpaceRequestWithBody(server string, organisationId OrganisationId, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organisationId", runtime.ParamLocationPath, organisationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organisations/%s/spaces/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostgreSQLGetAvailableClusterConfigurationsRequest generates requests for PostgreSQLGetAvailableClusterConfigurations
func NewPostgreSQLGetAvailableClusterConfigurationsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/postgresql/serviceCatalog/clusters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostgreSQLGetClusterAutomaticBackupInformationRequest generates requests for PostgreSQLGetClusterAutomaticBackupInformation
func NewPostgreSQLGetClusterAutomaticBackupInformationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/postgresql/serviceCatalog/clusters/automaticBackup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostgreSQLListBackupsRequest generates requests for PostgreSQLListBackups
func NewPostgreSQLListBackupsRequest(server string, spaceId SpaceId, params *PostgreSQLListBackupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/postgresql/spaces/%s/backups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostgreSQLDeleteBackupRequest generates requests for PostgreSQLDeleteBackup
func NewPostgreSQLDeleteBackupRequest(server string, spaceId SpaceId, backupId PostgresBackupIdParameter) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "backupId", runtime.ParamLocationPath, backupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/postgresql/spaces/%s/backups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostgreSQLListClustersRequest generates requests for PostgreSQLListClusters
func NewPostgreSQLListClustersRequest(server string, spaceId SpaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/postgresql/spaces/%s/clusters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostgreSQLCreateClusterRequest calls the generic PostgreSQLCreateCluster builder with application/json body
func NewPostgreSQLCreateClusterRequest(server string, spaceId SpaceId, body PostgreSQLCreateClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostgreSQLCreateClusterRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewPostgreSQLCreateClusterRequestWithBody generates requests for PostgreSQLCreateCluster with any type of body
func NewPostgreSQLCreateClusterRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/postgresql/spaces/%s/clusters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostgreSQLDeleteClusterRequest calls the generic PostgreSQLDeleteCluster builder with application/json body
func NewPostgreSQLDeleteClusterRequest(server string, spaceId SpaceId, clusterId PostgresClusterIdParameter, body PostgreSQLDeleteClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostgreSQLDeleteClusterRequestWithBody(server, spaceId, clusterId, "application/json", bodyReader)
}

// NewPostgreSQLDeleteClusterRequestWithBody generates requests for PostgreSQLDeleteCluster with any type of body
func NewPostgreSQLDeleteClusterRequestWithBody(server string, spaceId SpaceId, clusterId PostgresClusterIdParameter, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/postgresql/spaces/%s/clusters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostgreSQLGetClusterRequest generates requests for PostgreSQLGetCluster
func NewPostgreSQLGetClusterRequest(server string, spaceId SpaceId, clusterId PostgresClusterIdParameter) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/postgresql/spaces/%s/clusters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostgreSQLModifyClusterRequest calls the generic PostgreSQLModifyCluster builder with application/json body
func NewPostgreSQLModifyClusterRequest(server string, spaceId SpaceId, clusterId PostgresClusterIdParameter, body PostgreSQLModifyClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostgreSQLModifyClusterRequestWithBody(server, spaceId, clusterId, "application/json", bodyReader)
}

// NewPostgreSQLModifyClusterRequestWithBody generates requests for PostgreSQLModifyCluster with any type of body
func NewPostgreSQLModifyClusterRequestWithBody(server string, spaceId SpaceId, clusterId PostgresClusterIdParameter, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/postgresql/spaces/%s/clusters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostgreSQLListClusterBackupsRequest generates requests for PostgreSQLListClusterBackups
func NewPostgreSQLListClusterBackupsRequest(server string, spaceId SpaceId, clusterId PostgresClusterIdParameter) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/postgresql/spaces/%s/clusters/%s/backups", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOldPostgreSQLResetClusterAdministrationPasswordRequest generates requests for OldPostgreSQLResetClusterAdministrationPassword
func NewOldPostgreSQLResetClusterAdministrationPasswordRequest(server string, spaceId SpaceId, clusterId PostgresClusterIdParameter) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/postgresql/spaces/%s/clusters/%s/password/reset", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostgreSQLResetClusterAdministrationPasswordRequest generates requests for PostgreSQLResetClusterAdministrationPassword
func NewPostgreSQLResetClusterAdministrationPasswordRequest(server string, spaceId SpaceId, clusterId PostgresClusterIdParameter) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/postgresql/spaces/%s/clusters/%s/password/reset", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// DeleteLoadBalancerTagsWithBodyWithResponse request with any body
	DeleteLoadBalancerTagsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerTagsResponse, error)

	DeleteLoadBalancerTagsWithResponse(ctx context.Context, spaceId SpaceId, body DeleteLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerTagsResponse, error)

	// CreateLoadBalancerTagsWithBodyWithResponse request with any body
	CreateLoadBalancerTagsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLoadBalancerTagsResponse, error)

	CreateLoadBalancerTagsWithResponse(ctx context.Context, spaceId SpaceId, body CreateLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLoadBalancerTagsResponse, error)

	// DeleteTagsWithBodyWithResponse request with any body
	DeleteTagsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteTagsResponse, error)

	DeleteTagsWithResponse(ctx context.Context, spaceId SpaceId, body DeleteTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteTagsResponse, error)

	// CreateTagsWithBodyWithResponse request with any body
	CreateTagsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTagsResponse, error)

	CreateTagsWithResponse(ctx context.Context, spaceId SpaceId, body CreateTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTagsResponse, error)

	// ReadDhcpOptionsWithResponse request
	ReadDhcpOptionsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadDhcpOptionsParams, reqEditors ...RequestEditorFn) (*ReadDhcpOptionsResponse, error)

	// CreateDhcpOptionsWithBodyWithResponse request with any body
	CreateDhcpOptionsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDhcpOptionsResponse, error)

	CreateDhcpOptionsWithResponse(ctx context.Context, spaceId SpaceId, body CreateDhcpOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDhcpOptionsResponse, error)

	// DeleteDhcpOptionsWithResponse request
	DeleteDhcpOptionsWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteDhcpOptionsResponse, error)

	// ReadDhcpOptionsByIdWithResponse request
	ReadDhcpOptionsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadDhcpOptionsByIdResponse, error)

	// ReadFlexibleGpusWithResponse request
	ReadFlexibleGpusWithResponse(ctx context.Context, spaceId SpaceId, params *ReadFlexibleGpusParams, reqEditors ...RequestEditorFn) (*ReadFlexibleGpusResponse, error)

	// CreateFlexibleGpuWithBodyWithResponse request with any body
	CreateFlexibleGpuWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFlexibleGpuResponse, error)

	CreateFlexibleGpuWithResponse(ctx context.Context, spaceId SpaceId, body CreateFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFlexibleGpuResponse, error)

	// DeleteFlexibleGpuWithResponse request
	DeleteFlexibleGpuWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteFlexibleGpuResponse, error)

	// ReadFlexibleGpusByIdWithResponse request
	ReadFlexibleGpusByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadFlexibleGpusByIdResponse, error)

	// UpdateFlexibleGpuWithBodyWithResponse request with any body
	UpdateFlexibleGpuWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFlexibleGpuResponse, error)

	UpdateFlexibleGpuWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFlexibleGpuResponse, error)

	// LinkFlexibleGpuWithBodyWithResponse request with any body
	LinkFlexibleGpuWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkFlexibleGpuResponse, error)

	LinkFlexibleGpuWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkFlexibleGpuResponse, error)

	// UnlinkFlexibleGpuWithResponse request
	UnlinkFlexibleGpuWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*UnlinkFlexibleGpuResponse, error)

	// ReadImagesWithResponse request
	ReadImagesWithResponse(ctx context.Context, spaceId SpaceId, params *ReadImagesParams, reqEditors ...RequestEditorFn) (*ReadImagesResponse, error)

	// CreateImageWithBodyWithResponse request with any body
	CreateImageWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateImageResponse, error)

	CreateImageWithResponse(ctx context.Context, spaceId SpaceId, body CreateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateImageResponse, error)

	// DeleteImageWithResponse request
	DeleteImageWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteImageResponse, error)

	// ReadImagesByIdWithResponse request
	ReadImagesByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadImagesByIdResponse, error)

	// UpdateImageWithBodyWithResponse request with any body
	UpdateImageWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateImageResponse, error)

	UpdateImageWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateImageResponse, error)

	// ReadInternetGatewaysWithResponse request
	ReadInternetGatewaysWithResponse(ctx context.Context, spaceId SpaceId, params *ReadInternetGatewaysParams, reqEditors ...RequestEditorFn) (*ReadInternetGatewaysResponse, error)

	// CreateInternetGatewayWithResponse request
	CreateInternetGatewayWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*CreateInternetGatewayResponse, error)

	// DeleteInternetGatewayWithResponse request
	DeleteInternetGatewayWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteInternetGatewayResponse, error)

	// ReadInternetGatewaysByIdWithResponse request
	ReadInternetGatewaysByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadInternetGatewaysByIdResponse, error)

	// LinkInternetGatewayWithBodyWithResponse request with any body
	LinkInternetGatewayWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkInternetGatewayResponse, error)

	LinkInternetGatewayWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkInternetGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkInternetGatewayResponse, error)

	// UnlinkInternetGatewayWithBodyWithResponse request with any body
	UnlinkInternetGatewayWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkInternetGatewayResponse, error)

	UnlinkInternetGatewayWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkInternetGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkInternetGatewayResponse, error)

	// ReadKeypairsWithResponse request
	ReadKeypairsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadKeypairsParams, reqEditors ...RequestEditorFn) (*ReadKeypairsResponse, error)

	// CreateKeypairWithBodyWithResponse request with any body
	CreateKeypairWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeypairResponse, error)

	CreateKeypairWithResponse(ctx context.Context, spaceId SpaceId, body CreateKeypairJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeypairResponse, error)

	// DeleteKeypairWithResponse request
	DeleteKeypairWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteKeypairResponse, error)

	// ReadKeypairsByIdWithResponse request
	ReadKeypairsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadKeypairsByIdResponse, error)

	// ReadListenerRulesWithResponse request
	ReadListenerRulesWithResponse(ctx context.Context, spaceId SpaceId, params *ReadListenerRulesParams, reqEditors ...RequestEditorFn) (*ReadListenerRulesResponse, error)

	// CreateListenerRuleWithBodyWithResponse request with any body
	CreateListenerRuleWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateListenerRuleResponse, error)

	CreateListenerRuleWithResponse(ctx context.Context, spaceId SpaceId, body CreateListenerRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateListenerRuleResponse, error)

	// DeleteListenerRuleWithResponse request
	DeleteListenerRuleWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteListenerRuleResponse, error)

	// ReadListenerRulesByIdWithResponse request
	ReadListenerRulesByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadListenerRulesByIdResponse, error)

	// UpdateListenerRuleWithBodyWithResponse request with any body
	UpdateListenerRuleWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateListenerRuleResponse, error)

	UpdateListenerRuleWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateListenerRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateListenerRuleResponse, error)

	// ReadLoadBalancersWithResponse request
	ReadLoadBalancersWithResponse(ctx context.Context, spaceId SpaceId, params *ReadLoadBalancersParams, reqEditors ...RequestEditorFn) (*ReadLoadBalancersResponse, error)

	// CreateLoadBalancerWithBodyWithResponse request with any body
	CreateLoadBalancerWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLoadBalancerResponse, error)

	CreateLoadBalancerWithResponse(ctx context.Context, spaceId SpaceId, body CreateLoadBalancerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLoadBalancerResponse, error)

	// DeleteLoadBalancerWithResponse request
	DeleteLoadBalancerWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerResponse, error)

	// ReadLoadBalancersByIdWithResponse request
	ReadLoadBalancersByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadLoadBalancersByIdResponse, error)

	// UpdateLoadBalancerWithBodyWithResponse request with any body
	UpdateLoadBalancerWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLoadBalancerResponse, error)

	UpdateLoadBalancerWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateLoadBalancerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLoadBalancerResponse, error)

	// LinkLoadBalancerBackendMachinesWithBodyWithResponse request with any body
	LinkLoadBalancerBackendMachinesWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkLoadBalancerBackendMachinesResponse, error)

	LinkLoadBalancerBackendMachinesWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkLoadBalancerBackendMachinesJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkLoadBalancerBackendMachinesResponse, error)

	// UnlinkLoadBalancerBackendMachinesWithBodyWithResponse request with any body
	UnlinkLoadBalancerBackendMachinesWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkLoadBalancerBackendMachinesResponse, error)

	UnlinkLoadBalancerBackendMachinesWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkLoadBalancerBackendMachinesJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkLoadBalancerBackendMachinesResponse, error)

	// DeleteLoadBalancerListenersWithBodyWithResponse request with any body
	DeleteLoadBalancerListenersWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerListenersResponse, error)

	DeleteLoadBalancerListenersWithResponse(ctx context.Context, spaceId SpaceId, id string, body DeleteLoadBalancerListenersJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerListenersResponse, error)

	// CreateLoadBalancerListenersWithBodyWithResponse request with any body
	CreateLoadBalancerListenersWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLoadBalancerListenersResponse, error)

	CreateLoadBalancerListenersWithResponse(ctx context.Context, spaceId SpaceId, id string, body CreateLoadBalancerListenersJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLoadBalancerListenersResponse, error)

	// DeleteLoadBalancerPolicyWithBodyWithResponse request with any body
	DeleteLoadBalancerPolicyWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerPolicyResponse, error)

	DeleteLoadBalancerPolicyWithResponse(ctx context.Context, spaceId SpaceId, id string, body DeleteLoadBalancerPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerPolicyResponse, error)

	// CreateLoadBalancerPolicyWithBodyWithResponse request with any body
	CreateLoadBalancerPolicyWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLoadBalancerPolicyResponse, error)

	CreateLoadBalancerPolicyWithResponse(ctx context.Context, spaceId SpaceId, id string, body CreateLoadBalancerPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLoadBalancerPolicyResponse, error)

	// ReadVmsHealthWithBodyWithResponse request with any body
	ReadVmsHealthWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReadVmsHealthResponse, error)

	ReadVmsHealthWithResponse(ctx context.Context, spaceId SpaceId, id string, body ReadVmsHealthJSONRequestBody, reqEditors ...RequestEditorFn) (*ReadVmsHealthResponse, error)

	// ReadLoadBalancerTagsWithBodyWithResponse request with any body
	ReadLoadBalancerTagsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReadLoadBalancerTagsResponse, error)

	ReadLoadBalancerTagsWithResponse(ctx context.Context, spaceId SpaceId, body ReadLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReadLoadBalancerTagsResponse, error)

	// ReadNatGatewayWithResponse request
	ReadNatGatewayWithResponse(ctx context.Context, spaceId SpaceId, params *ReadNatGatewayParams, reqEditors ...RequestEditorFn) (*ReadNatGatewayResponse, error)

	// CreateNatGatewayWithBodyWithResponse request with any body
	CreateNatGatewayWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNatGatewayResponse, error)

	CreateNatGatewayWithResponse(ctx context.Context, spaceId SpaceId, body CreateNatGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNatGatewayResponse, error)

	// DeleteNatGatewayWithResponse request
	DeleteNatGatewayWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteNatGatewayResponse, error)

	// ReadNatGatewayByIdWithResponse request
	ReadNatGatewayByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadNatGatewayByIdResponse, error)

	// ReadNicsWithResponse request
	ReadNicsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadNicsParams, reqEditors ...RequestEditorFn) (*ReadNicsResponse, error)

	// CreateNicWithBodyWithResponse request with any body
	CreateNicWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNicResponse, error)

	CreateNicWithResponse(ctx context.Context, spaceId SpaceId, body CreateNicJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNicResponse, error)

	// DeleteNicWithResponse request
	DeleteNicWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteNicResponse, error)

	// ReadNicsByIdWithResponse request
	ReadNicsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadNicsByIdResponse, error)

	// UpdateNicWithBodyWithResponse request with any body
	UpdateNicWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNicResponse, error)

	UpdateNicWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateNicJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNicResponse, error)

	// LinkPrivateIpsWithBodyWithResponse request with any body
	LinkPrivateIpsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkPrivateIpsResponse, error)

	LinkPrivateIpsWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkPrivateIpsJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkPrivateIpsResponse, error)

	// UnlinkPrivateIpsWithBodyWithResponse request with any body
	UnlinkPrivateIpsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkPrivateIpsResponse, error)

	UnlinkPrivateIpsWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkPrivateIpsJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkPrivateIpsResponse, error)

	// LinkNicWithBodyWithResponse request with any body
	LinkNicWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkNicResponse, error)

	LinkNicWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkNicJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkNicResponse, error)

	// UnlinkNicWithBodyWithResponse request with any body
	UnlinkNicWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkNicResponse, error)

	UnlinkNicWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkNicJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkNicResponse, error)

	// ReadPublicIpsWithResponse request
	ReadPublicIpsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadPublicIpsParams, reqEditors ...RequestEditorFn) (*ReadPublicIpsResponse, error)

	// CreatePublicIpWithResponse request
	CreatePublicIpWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*CreatePublicIpResponse, error)

	// DeletePublicIpWithResponse request
	DeletePublicIpWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeletePublicIpResponse, error)

	// ReadPublicIpsByIdWithResponse request
	ReadPublicIpsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadPublicIpsByIdResponse, error)

	// LinkPublicIpWithBodyWithResponse request with any body
	LinkPublicIpWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkPublicIpResponse, error)

	LinkPublicIpWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkPublicIpJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkPublicIpResponse, error)

	// UnlinkPublicIpWithBodyWithResponse request with any body
	UnlinkPublicIpWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkPublicIpResponse, error)

	UnlinkPublicIpWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkPublicIpJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkPublicIpResponse, error)

	// ReadRouteTablesWithResponse request
	ReadRouteTablesWithResponse(ctx context.Context, spaceId SpaceId, params *ReadRouteTablesParams, reqEditors ...RequestEditorFn) (*ReadRouteTablesResponse, error)

	// CreateRouteTableWithBodyWithResponse request with any body
	CreateRouteTableWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRouteTableResponse, error)

	CreateRouteTableWithResponse(ctx context.Context, spaceId SpaceId, body CreateRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRouteTableResponse, error)

	// DeleteRouteTableWithResponse request
	DeleteRouteTableWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteRouteTableResponse, error)

	// ReadRouteTablesByIdWithResponse request
	ReadRouteTablesByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadRouteTablesByIdResponse, error)

	// UpdateRouteTableRoutePropagationWithBodyWithResponse request with any body
	UpdateRouteTableRoutePropagationWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRouteTableRoutePropagationResponse, error)

	UpdateRouteTableRoutePropagationWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateRouteTableRoutePropagationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRouteTableRoutePropagationResponse, error)

	// DeleteRouteWithBodyWithResponse request with any body
	DeleteRouteWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteRouteResponse, error)

	DeleteRouteWithResponse(ctx context.Context, spaceId SpaceId, id string, body DeleteRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteRouteResponse, error)

	// CreateRouteWithBodyWithResponse request with any body
	CreateRouteWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRouteResponse, error)

	CreateRouteWithResponse(ctx context.Context, spaceId SpaceId, id string, body CreateRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRouteResponse, error)

	// UpdateRouteWithBodyWithResponse request with any body
	UpdateRouteWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRouteResponse, error)

	UpdateRouteWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRouteResponse, error)

	// LinkRouteTableWithBodyWithResponse request with any body
	LinkRouteTableWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkRouteTableResponse, error)

	LinkRouteTableWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkRouteTableResponse, error)

	// UnlinkRouteTableWithBodyWithResponse request with any body
	UnlinkRouteTableWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkRouteTableResponse, error)

	UnlinkRouteTableWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkRouteTableResponse, error)

	// ReadSecurityGroupsWithResponse request
	ReadSecurityGroupsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadSecurityGroupsParams, reqEditors ...RequestEditorFn) (*ReadSecurityGroupsResponse, error)

	// CreateSecurityGroupWithBodyWithResponse request with any body
	CreateSecurityGroupWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSecurityGroupResponse, error)

	CreateSecurityGroupWithResponse(ctx context.Context, spaceId SpaceId, body CreateSecurityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSecurityGroupResponse, error)

	// DeleteSecurityGroupWithResponse request
	DeleteSecurityGroupWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteSecurityGroupResponse, error)

	// ReadSecurityGroupsByIdWithResponse request
	ReadSecurityGroupsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadSecurityGroupsByIdResponse, error)

	// DeleteSecurityGroupRuleWithBodyWithResponse request with any body
	DeleteSecurityGroupRuleWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteSecurityGroupRuleResponse, error)

	DeleteSecurityGroupRuleWithResponse(ctx context.Context, spaceId SpaceId, id string, body DeleteSecurityGroupRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteSecurityGroupRuleResponse, error)

	// CreateSecurityGroupRuleWithBodyWithResponse request with any body
	CreateSecurityGroupRuleWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSecurityGroupRuleResponse, error)

	CreateSecurityGroupRuleWithResponse(ctx context.Context, spaceId SpaceId, id string, body CreateSecurityGroupRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSecurityGroupRuleResponse, error)

	// ReadServerCertificatesWithResponse request
	ReadServerCertificatesWithResponse(ctx context.Context, spaceId SpaceId, params *ReadServerCertificatesParams, reqEditors ...RequestEditorFn) (*ReadServerCertificatesResponse, error)

	// CreateServerCertificateWithBodyWithResponse request with any body
	CreateServerCertificateWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServerCertificateResponse, error)

	CreateServerCertificateWithResponse(ctx context.Context, spaceId SpaceId, body CreateServerCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServerCertificateResponse, error)

	// DeleteServerCertificateWithResponse request
	DeleteServerCertificateWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteServerCertificateResponse, error)

	// UpdateServerCertificateWithBodyWithResponse request with any body
	UpdateServerCertificateWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServerCertificateResponse, error)

	UpdateServerCertificateWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateServerCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServerCertificateResponse, error)

	// ReadSnapshotsWithResponse request
	ReadSnapshotsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadSnapshotsParams, reqEditors ...RequestEditorFn) (*ReadSnapshotsResponse, error)

	// CreateSnapshotWithBodyWithResponse request with any body
	CreateSnapshotWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSnapshotResponse, error)

	CreateSnapshotWithResponse(ctx context.Context, spaceId SpaceId, body CreateSnapshotJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSnapshotResponse, error)

	// DeleteSnapshotWithResponse request
	DeleteSnapshotWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteSnapshotResponse, error)

	// ReadSnapshotsByIdWithResponse request
	ReadSnapshotsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadSnapshotsByIdResponse, error)

	// ReadSubnetsWithResponse request
	ReadSubnetsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadSubnetsParams, reqEditors ...RequestEditorFn) (*ReadSubnetsResponse, error)

	// CreateSubnetWithBodyWithResponse request with any body
	CreateSubnetWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSubnetResponse, error)

	CreateSubnetWithResponse(ctx context.Context, spaceId SpaceId, body CreateSubnetJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSubnetResponse, error)

	// DeleteSubnetWithResponse request
	DeleteSubnetWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteSubnetResponse, error)

	// ReadSubnetsByIdWithResponse request
	ReadSubnetsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadSubnetsByIdResponse, error)

	// UpdateSubnetWithBodyWithResponse request with any body
	UpdateSubnetWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSubnetResponse, error)

	UpdateSubnetWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateSubnetJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSubnetResponse, error)

	// ReadTagsWithResponse request
	ReadTagsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadTagsParams, reqEditors ...RequestEditorFn) (*ReadTagsResponse, error)

	// ReadVmsWithResponse request
	ReadVmsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadVmsParams, reqEditors ...RequestEditorFn) (*ReadVmsResponse, error)

	// CreateVmsWithBodyWithResponse request with any body
	CreateVmsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVmsResponse, error)

	CreateVmsWithResponse(ctx context.Context, spaceId SpaceId, body CreateVmsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVmsResponse, error)

	// ReadVmsStateWithResponse request
	ReadVmsStateWithResponse(ctx context.Context, spaceId SpaceId, params *ReadVmsStateParams, reqEditors ...RequestEditorFn) (*ReadVmsStateResponse, error)

	// DeleteVmsWithResponse request
	DeleteVmsWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteVmsResponse, error)

	// ReadVmsByIdWithResponse request
	ReadVmsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadVmsByIdResponse, error)

	// UpdateVmWithBodyWithResponse request with any body
	UpdateVmWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVmResponse, error)

	UpdateVmWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateVmJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVmResponse, error)

	// ReadAdminPasswordWithResponse request
	ReadAdminPasswordWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadAdminPasswordResponse, error)

	// ReadConsoleOutputWithResponse request
	ReadConsoleOutputWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadConsoleOutputResponse, error)

	// RebootVmWithResponse request
	RebootVmWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*RebootVmResponse, error)

	// StartVmWithResponse request
	StartVmWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*StartVmResponse, error)

	// StopVmWithBodyWithResponse request with any body
	StopVmWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StopVmResponse, error)

	StopVmWithResponse(ctx context.Context, spaceId SpaceId, id string, body StopVmJSONRequestBody, reqEditors ...RequestEditorFn) (*StopVmResponse, error)

	// ReadVolumesWithResponse request
	ReadVolumesWithResponse(ctx context.Context, spaceId SpaceId, params *ReadVolumesParams, reqEditors ...RequestEditorFn) (*ReadVolumesResponse, error)

	// CreateVolumeWithBodyWithResponse request with any body
	CreateVolumeWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVolumeResponse, error)

	CreateVolumeWithResponse(ctx context.Context, spaceId SpaceId, body CreateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVolumeResponse, error)

	// DeleteVolumeWithResponse request
	DeleteVolumeWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteVolumeResponse, error)

	// ReadVolumesByIdWithResponse request
	ReadVolumesByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadVolumesByIdResponse, error)

	// UpdateVolumeWithBodyWithResponse request with any body
	UpdateVolumeWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVolumeResponse, error)

	UpdateVolumeWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVolumeResponse, error)

	// LinkVolumeWithBodyWithResponse request with any body
	LinkVolumeWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkVolumeResponse, error)

	LinkVolumeWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkVolumeResponse, error)

	// UnlinkVolumeWithBodyWithResponse request with any body
	UnlinkVolumeWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkVolumeResponse, error)

	UnlinkVolumeWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkVolumeResponse, error)

	// ReadVpcsWithResponse request
	ReadVpcsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadVpcsParams, reqEditors ...RequestEditorFn) (*ReadVpcsResponse, error)

	// CreateVpcWithBodyWithResponse request with any body
	CreateVpcWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVpcResponse, error)

	CreateVpcWithResponse(ctx context.Context, spaceId SpaceId, body CreateVpcJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVpcResponse, error)

	// DeleteVpcWithResponse request
	DeleteVpcWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteVpcResponse, error)

	// ReadVpcsByIdWithResponse request
	ReadVpcsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadVpcsByIdResponse, error)

	// UpdateVpcWithBodyWithResponse request with any body
	UpdateVpcWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVpcResponse, error)

	UpdateVpcWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateVpcJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVpcResponse, error)

	// DeleteClientGatewayWithResponse request
	DeleteClientGatewayWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*DeleteClientGatewayResponse, error)

	// ReadClientGatewayWithResponse request
	ReadClientGatewayWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*ReadClientGatewayResponse, error)

	// ListClientGatewaysWithResponse request
	ListClientGatewaysWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*ListClientGatewaysResponse, error)

	// CreateClientGatewayWithBodyWithResponse request with any body
	CreateClientGatewayWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientGatewayResponse, error)

	CreateClientGatewayWithResponse(ctx context.Context, spaceId SpaceId, body CreateClientGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientGatewayResponse, error)

	// ListComputeBridgesWithResponse request
	ListComputeBridgesWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*ListComputeBridgesResponse, error)

	// CreateComputeBridgeWithBodyWithResponse request with any body
	CreateComputeBridgeWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateComputeBridgeResponse, error)

	CreateComputeBridgeWithResponse(ctx context.Context, spaceId SpaceId, body CreateComputeBridgeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateComputeBridgeResponse, error)

	// DeleteComputeBridgeWithResponse request
	DeleteComputeBridgeWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*DeleteComputeBridgeResponse, error)

	// ReadComputeBridgeWithResponse request
	ReadComputeBridgeWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*ReadComputeBridgeResponse, error)

	// ListDirectLinkInterfacesWithResponse request
	ListDirectLinkInterfacesWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*ListDirectLinkInterfacesResponse, error)

	// CreateDirectLinkInterfaceWithBodyWithResponse request with any body
	CreateDirectLinkInterfaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDirectLinkInterfaceResponse, error)

	CreateDirectLinkInterfaceWithResponse(ctx context.Context, spaceId SpaceId, body CreateDirectLinkInterfaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDirectLinkInterfaceResponse, error)

	// DeleteDirectLinkInterfaceWithResponse request
	DeleteDirectLinkInterfaceWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*DeleteDirectLinkInterfaceResponse, error)

	// ReadDirectLinkInterfaceWithResponse request
	ReadDirectLinkInterfaceWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*ReadDirectLinkInterfaceResponse, error)

	// ListDirectLinksWithResponse request
	ListDirectLinksWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*ListDirectLinksResponse, error)

	// CreateDirectLinkWithBodyWithResponse request with any body
	CreateDirectLinkWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDirectLinkResponse, error)

	CreateDirectLinkWithResponse(ctx context.Context, spaceId SpaceId, body CreateDirectLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDirectLinkResponse, error)

	// DeleteDirectLinkWithResponse request
	DeleteDirectLinkWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*DeleteDirectLinkResponse, error)

	// ReadDirectLinkWithResponse request
	ReadDirectLinkWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*ReadDirectLinkResponse, error)

	// ListHybridBridgesWithResponse request
	ListHybridBridgesWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*ListHybridBridgesResponse, error)

	// CreateHybridBridgeWithBodyWithResponse request with any body
	CreateHybridBridgeWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHybridBridgeResponse, error)

	CreateHybridBridgeWithResponse(ctx context.Context, spaceId SpaceId, body CreateHybridBridgeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHybridBridgeResponse, error)

	// DeleteHybridBridgeWithResponse request
	DeleteHybridBridgeWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*DeleteHybridBridgeResponse, error)

	// ReadHybridBridgeWithResponse request
	ReadHybridBridgeWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*ReadHybridBridgeResponse, error)

	// ListManagedServicesBridgesWithResponse request
	ListManagedServicesBridgesWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*ListManagedServicesBridgesResponse, error)

	// CreateManagedServicesBridgeWithBodyWithResponse request with any body
	CreateManagedServicesBridgeWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManagedServicesBridgeResponse, error)

	CreateManagedServicesBridgeWithResponse(ctx context.Context, spaceId SpaceId, body CreateManagedServicesBridgeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManagedServicesBridgeResponse, error)

	// DeleteManagedServicesBridgeWithResponse request
	DeleteManagedServicesBridgeWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*DeleteManagedServicesBridgeResponse, error)

	// ReadManagedServicesBridgeWithResponse request
	ReadManagedServicesBridgeWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*ReadManagedServicesBridgeResponse, error)

	// ReadLocationsWithResponse request
	ReadLocationsWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*ReadLocationsResponse, error)

	// DeleteVirtualGatewayWithResponse request
	DeleteVirtualGatewayWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*DeleteVirtualGatewayResponse, error)

	// ReadVirtualGatewayWithResponse request
	ReadVirtualGatewayWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*ReadVirtualGatewayResponse, error)

	// UnlinkVirtualGatewayWithBodyWithResponse request with any body
	UnlinkVirtualGatewayWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkVirtualGatewayResponse, error)

	UnlinkVirtualGatewayWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, body UnlinkVirtualGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkVirtualGatewayResponse, error)

	// LinkVirtualGatewayWithBodyWithResponse request with any body
	LinkVirtualGatewayWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkVirtualGatewayResponse, error)

	LinkVirtualGatewayWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, body LinkVirtualGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkVirtualGatewayResponse, error)

	// ListVirtualGatewaysWithResponse request
	ListVirtualGatewaysWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*ListVirtualGatewaysResponse, error)

	// CreateVirtualGatewayWithBodyWithResponse request with any body
	CreateVirtualGatewayWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVirtualGatewayResponse, error)

	CreateVirtualGatewayWithResponse(ctx context.Context, spaceId SpaceId, body CreateVirtualGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVirtualGatewayResponse, error)

	// DeleteVPNConnectionWithResponse request
	DeleteVPNConnectionWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*DeleteVPNConnectionResponse, error)

	// ReadVPNConnectionWithResponse request
	ReadVPNConnectionWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*ReadVPNConnectionResponse, error)

	// DeleteVPNConnectionRouteWithBodyWithResponse request with any body
	DeleteVPNConnectionRouteWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteVPNConnectionRouteResponse, error)

	DeleteVPNConnectionRouteWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, body DeleteVPNConnectionRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteVPNConnectionRouteResponse, error)

	// CreateVPNConnectionRouteWithBodyWithResponse request with any body
	CreateVPNConnectionRouteWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVPNConnectionRouteResponse, error)

	CreateVPNConnectionRouteWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, body CreateVPNConnectionRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVPNConnectionRouteResponse, error)

	// ListVPNConnectionsWithResponse request
	ListVPNConnectionsWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*ListVPNConnectionsResponse, error)

	// CreateVPNConnectionWithBodyWithResponse request with any body
	CreateVPNConnectionWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVPNConnectionResponse, error)

	CreateVPNConnectionWithResponse(ctx context.Context, spaceId SpaceId, body CreateVPNConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVPNConnectionResponse, error)

	// JsonWebKeysWithResponse request
	JsonWebKeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*JsonWebKeysResponse, error)

	// DiscoverOidcConfigurationWithResponse request
	DiscoverOidcConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DiscoverOidcConfigurationResponse, error)

	// GetWebAuthnJavaScriptWithResponse request
	GetWebAuthnJavaScriptWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWebAuthnJavaScriptResponse, error)

	// CreateAdminServiceAccountSpaceWithBodyWithResponse request with any body
	CreateAdminServiceAccountSpaceWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAdminServiceAccountSpaceResponse, error)

	CreateAdminServiceAccountSpaceWithResponse(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, body CreateAdminServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAdminServiceAccountSpaceResponse, error)

	// ConsentWithResponse request
	ConsentWithResponse(ctx context.Context, params *ConsentParams, reqEditors ...RequestEditorFn) (*ConsentResponse, error)

	// GetFlowErrorWithResponse request
	GetFlowErrorWithResponse(ctx context.Context, params *GetFlowErrorParams, reqEditors ...RequestEditorFn) (*GetFlowErrorResponse, error)

	// UpdateLoginFlowWithBodyWithResponse request with any body
	UpdateLoginFlowWithBodyWithResponse(ctx context.Context, params *UpdateLoginFlowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLoginFlowResponse, error)

	UpdateLoginFlowWithResponse(ctx context.Context, params *UpdateLoginFlowParams, body UpdateLoginFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLoginFlowResponse, error)

	UpdateLoginFlowWithFormdataBodyWithResponse(ctx context.Context, params *UpdateLoginFlowParams, body UpdateLoginFlowFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateLoginFlowResponse, error)

	// CreateBrowserLoginFlowWithResponse request
	CreateBrowserLoginFlowWithResponse(ctx context.Context, params *CreateBrowserLoginFlowParams, reqEditors ...RequestEditorFn) (*CreateBrowserLoginFlowResponse, error)

	// GetLoginFlowWithResponse request
	GetLoginFlowWithResponse(ctx context.Context, params *GetLoginFlowParams, reqEditors ...RequestEditorFn) (*GetLoginFlowResponse, error)

	// UpdateLogoutFlowWithResponse request
	UpdateLogoutFlowWithResponse(ctx context.Context, params *UpdateLogoutFlowParams, reqEditors ...RequestEditorFn) (*UpdateLogoutFlowResponse, error)

	// CreateBrowserLogoutFlowWithResponse request
	CreateBrowserLogoutFlowWithResponse(ctx context.Context, params *CreateBrowserLogoutFlowParams, reqEditors ...RequestEditorFn) (*CreateBrowserLogoutFlowResponse, error)

	// InitRecoveryFlowWithResponse request
	InitRecoveryFlowWithResponse(ctx context.Context, params *InitRecoveryFlowParams, reqEditors ...RequestEditorFn) (*InitRecoveryFlowResponse, error)

	// UpdateRecoveryFlowWithBodyWithResponse request with any body
	UpdateRecoveryFlowWithBodyWithResponse(ctx context.Context, params *UpdateRecoveryFlowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRecoveryFlowResponse, error)

	UpdateRecoveryFlowWithResponse(ctx context.Context, params *UpdateRecoveryFlowParams, body UpdateRecoveryFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRecoveryFlowResponse, error)

	UpdateRecoveryFlowWithFormdataBodyWithResponse(ctx context.Context, params *UpdateRecoveryFlowParams, body UpdateRecoveryFlowFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateRecoveryFlowResponse, error)

	// CreateBrowserRecoveryFlowWithResponse request
	CreateBrowserRecoveryFlowWithResponse(ctx context.Context, params *CreateBrowserRecoveryFlowParams, reqEditors ...RequestEditorFn) (*CreateBrowserRecoveryFlowResponse, error)

	// GetRecoveryFlowWithResponse request
	GetRecoveryFlowWithResponse(ctx context.Context, params *GetRecoveryFlowParams, reqEditors ...RequestEditorFn) (*GetRecoveryFlowResponse, error)

	// UpdateSettingsFloWithBodyWithResponse request with any body
	UpdateSettingsFloWithBodyWithResponse(ctx context.Context, params *UpdateSettingsFloParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSettingsFloResponse, error)

	UpdateSettingsFloWithResponse(ctx context.Context, params *UpdateSettingsFloParams, body UpdateSettingsFloJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSettingsFloResponse, error)

	UpdateSettingsFloWithFormdataBodyWithResponse(ctx context.Context, params *UpdateSettingsFloParams, body UpdateSettingsFloFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateSettingsFloResponse, error)

	// CreateBrowserSettingsFlowWithResponse request
	CreateBrowserSettingsFlowWithResponse(ctx context.Context, params *CreateBrowserSettingsFlowParams, reqEditors ...RequestEditorFn) (*CreateBrowserSettingsFlowResponse, error)

	// GetSettingsFlowWithResponse request
	GetSettingsFlowWithResponse(ctx context.Context, params *GetSettingsFlowParams, reqEditors ...RequestEditorFn) (*GetSettingsFlowResponse, error)

	// ToSessionWithResponse request
	ToSessionWithResponse(ctx context.Context, params *ToSessionParams, reqEditors ...RequestEditorFn) (*ToSessionResponse, error)

	// IntrospectWithBodyWithResponse request with any body
	IntrospectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IntrospectResponse, error)

	IntrospectWithFormdataBodyWithResponse(ctx context.Context, body IntrospectFormdataRequestBody, reqEditors ...RequestEditorFn) (*IntrospectResponse, error)

	// ListOrganisationsIdentityWithResponse request
	ListOrganisationsIdentityWithResponse(ctx context.Context, params *ListOrganisationsIdentityParams, reqEditors ...RequestEditorFn) (*ListOrganisationsIdentityResponse, error)

	// GetIAMPolicyOrganisationWithResponse request
	GetIAMPolicyOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, reqEditors ...RequestEditorFn) (*GetIAMPolicyOrganisationResponse, error)

	// SetIAMPolicyOrganisationWithBodyWithResponse request with any body
	SetIAMPolicyOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetIAMPolicyOrganisationResponse, error)

	SetIAMPolicyOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, body SetIAMPolicyOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*SetIAMPolicyOrganisationResponse, error)

	// MatchServiceAccountOrganisationWithResponse request
	MatchServiceAccountOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, params *MatchServiceAccountOrganisationParams, reqEditors ...RequestEditorFn) (*MatchServiceAccountOrganisationResponse, error)

	// GetUserOrganisationByEmailWithResponse request
	GetUserOrganisationByEmailWithResponse(ctx context.Context, organisationId OrganisationId, params *GetUserOrganisationByEmailParams, reqEditors ...RequestEditorFn) (*GetUserOrganisationByEmailResponse, error)

	// ListPermissionsOrganisationWithResponse request
	ListPermissionsOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, params *ListPermissionsOrganisationParams, reqEditors ...RequestEditorFn) (*ListPermissionsOrganisationResponse, error)

	// GetPermissionOrganisationWithResponse request
	GetPermissionOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, permissionUuid PermissionUuid, reqEditors ...RequestEditorFn) (*GetPermissionOrganisationResponse, error)

	// ListRolesOrganisationWithResponse request
	ListRolesOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, params *ListRolesOrganisationParams, reqEditors ...RequestEditorFn) (*ListRolesOrganisationResponse, error)

	// GetRoleOrganisationWithResponse request
	GetRoleOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*GetRoleOrganisationResponse, error)

	// GetRolePermissionsOrganisationWithResponse request
	GetRolePermissionsOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, params *GetRolePermissionsOrganisationParams, reqEditors ...RequestEditorFn) (*GetRolePermissionsOrganisationResponse, error)

	// ListServiceAccountOrganisationWithResponse request
	ListServiceAccountOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, params *ListServiceAccountOrganisationParams, reqEditors ...RequestEditorFn) (*ListServiceAccountOrganisationResponse, error)

	// CreateServiceAccountOrganisationWithBodyWithResponse request with any body
	CreateServiceAccountOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceAccountOrganisationResponse, error)

	CreateServiceAccountOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, body CreateServiceAccountOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceAccountOrganisationResponse, error)

	// DeleteServiceAccountOrganisationWithResponse request
	DeleteServiceAccountOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*DeleteServiceAccountOrganisationResponse, error)

	// GetServiceAccountOrganisationWithResponse request
	GetServiceAccountOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*GetServiceAccountOrganisationResponse, error)

	// UpdateServiceAccountOrganisationWithBodyWithResponse request with any body
	UpdateServiceAccountOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServiceAccountOrganisationResponse, error)

	UpdateServiceAccountOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, body UpdateServiceAccountOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServiceAccountOrganisationResponse, error)

	// GetACLServiceAccountOrganisationWithResponse request
	GetACLServiceAccountOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, params *GetACLServiceAccountOrganisationParams, reqEditors ...RequestEditorFn) (*GetACLServiceAccountOrganisationResponse, error)

	// DeleteACLServiceAccountOrganisationBulkWithBodyWithResponse request with any body
	DeleteACLServiceAccountOrganisationBulkWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteACLServiceAccountOrganisationBulkResponse, error)

	DeleteACLServiceAccountOrganisationBulkWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, body DeleteACLServiceAccountOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteACLServiceAccountOrganisationBulkResponse, error)

	// CreateACLServiceAccountOrganisationBulkWithBodyWithResponse request with any body
	CreateACLServiceAccountOrganisationBulkWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateACLServiceAccountOrganisationBulkResponse, error)

	CreateACLServiceAccountOrganisationBulkWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, body CreateACLServiceAccountOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateACLServiceAccountOrganisationBulkResponse, error)

	// ListSpacesOfServiceAccountWithResponse request
	ListSpacesOfServiceAccountWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, params *ListSpacesOfServiceAccountParams, reqEditors ...RequestEditorFn) (*ListSpacesOfServiceAccountResponse, error)

	// ListSpacesIdentityWithResponse request
	ListSpacesIdentityWithResponse(ctx context.Context, organisationId OrganisationId, params *ListSpacesIdentityParams, reqEditors ...RequestEditorFn) (*ListSpacesIdentityResponse, error)

	// ListUserOrganisationWithResponse request
	ListUserOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, params *ListUserOrganisationParams, reqEditors ...RequestEditorFn) (*ListUserOrganisationResponse, error)

	// CreateUserOrganisationWithBodyWithResponse request with any body
	CreateUserOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserOrganisationResponse, error)

	CreateUserOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, body CreateUserOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserOrganisationResponse, error)

	// DeleteUserOrganisationWithResponse request
	DeleteUserOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, reqEditors ...RequestEditorFn) (*DeleteUserOrganisationResponse, error)

	// GetUserOrganisationWithResponse request
	GetUserOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, reqEditors ...RequestEditorFn) (*GetUserOrganisationResponse, error)

	// PatchUserStateOrganisationWithBodyWithResponse request with any body
	PatchUserStateOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchUserStateOrganisationResponse, error)

	PatchUserStateOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, body PatchUserStateOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchUserStateOrganisationResponse, error)

	// UpdateUserOrganisationWithBodyWithResponse request with any body
	UpdateUserOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserOrganisationResponse, error)

	UpdateUserOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, body UpdateUserOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserOrganisationResponse, error)

	// GetACLUserOrganisationWithResponse request
	GetACLUserOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, params *GetACLUserOrganisationParams, reqEditors ...RequestEditorFn) (*GetACLUserOrganisationResponse, error)

	// DeleteACLUserOrganisationBulkWithBodyWithResponse request with any body
	DeleteACLUserOrganisationBulkWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteACLUserOrganisationBulkResponse, error)

	DeleteACLUserOrganisationBulkWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, body DeleteACLUserOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteACLUserOrganisationBulkResponse, error)

	// CreateACLUserOrganisationBulkWithBodyWithResponse request with any body
	CreateACLUserOrganisationBulkWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateACLUserOrganisationBulkResponse, error)

	CreateACLUserOrganisationBulkWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, body CreateACLUserOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateACLUserOrganisationBulkResponse, error)

	// RecoverUserOrganisationWithResponse request
	RecoverUserOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, reqEditors ...RequestEditorFn) (*RecoverUserOrganisationResponse, error)

	// ListSpacesOfUserWithResponse request
	ListSpacesOfUserWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, params *ListSpacesOfUserParams, reqEditors ...RequestEditorFn) (*ListSpacesOfUserResponse, error)

	// RevokeWithBodyWithResponse request with any body
	RevokeWithBodyWithResponse(ctx context.Context, params *RevokeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevokeResponse, error)

	RevokeWithFormdataBodyWithResponse(ctx context.Context, params *RevokeParams, body RevokeFormdataRequestBody, reqEditors ...RequestEditorFn) (*RevokeResponse, error)

	// GetIAMPolicySpaceWithResponse request
	GetIAMPolicySpaceWithResponse(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, reqEditors ...RequestEditorFn) (*GetIAMPolicySpaceResponse, error)

	// SetIAMPolicySpaceWithBodyWithResponse request with any body
	SetIAMPolicySpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetIAMPolicySpaceResponse, error)

	SetIAMPolicySpaceWithResponse(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, body SetIAMPolicySpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*SetIAMPolicySpaceResponse, error)

	// MatchServiceAccountSpaceWithResponse request
	MatchServiceAccountSpaceWithResponse(ctx context.Context, spaceId SpaceId, params *MatchServiceAccountSpaceParams, reqEditors ...RequestEditorFn) (*MatchServiceAccountSpaceResponse, error)

	// GetUserSpaceByEmailWithResponse request
	GetUserSpaceByEmailWithResponse(ctx context.Context, spaceId SpaceId, params *GetUserSpaceByEmailParams, reqEditors ...RequestEditorFn) (*GetUserSpaceByEmailResponse, error)

	// ListPermissionsSpaceWithResponse request
	ListPermissionsSpaceWithResponse(ctx context.Context, spaceId SpaceId, params *ListPermissionsSpaceParams, reqEditors ...RequestEditorFn) (*ListPermissionsSpaceResponse, error)

	// GetPermissionSpaceWithResponse request
	GetPermissionSpaceWithResponse(ctx context.Context, spaceId SpaceId, permissionUuid PermissionUuid, reqEditors ...RequestEditorFn) (*GetPermissionSpaceResponse, error)

	// ListRolesSpaceWithResponse request
	ListRolesSpaceWithResponse(ctx context.Context, spaceId SpaceId, params *ListRolesSpaceParams, reqEditors ...RequestEditorFn) (*ListRolesSpaceResponse, error)

	// GetRoleSpaceWithResponse request
	GetRoleSpaceWithResponse(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*GetRoleSpaceResponse, error)

	// GetRolePermissionsSpaceWithResponse request
	GetRolePermissionsSpaceWithResponse(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, params *GetRolePermissionsSpaceParams, reqEditors ...RequestEditorFn) (*GetRolePermissionsSpaceResponse, error)

	// ListServiceAccountSpaceWithResponse request
	ListServiceAccountSpaceWithResponse(ctx context.Context, spaceId SpaceId, params *ListServiceAccountSpaceParams, reqEditors ...RequestEditorFn) (*ListServiceAccountSpaceResponse, error)

	// CreateServiceAccountSpaceWithBodyWithResponse request with any body
	CreateServiceAccountSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceAccountSpaceResponse, error)

	CreateServiceAccountSpaceWithResponse(ctx context.Context, spaceId SpaceId, body CreateServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceAccountSpaceResponse, error)

	// DeleteServiceAccountSpaceWithResponse request
	DeleteServiceAccountSpaceWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*DeleteServiceAccountSpaceResponse, error)

	// GetServiceAccountSpaceWithResponse request
	GetServiceAccountSpaceWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*GetServiceAccountSpaceResponse, error)

	// AssignServiceAccountToSpaceWithResponse request
	AssignServiceAccountToSpaceWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*AssignServiceAccountToSpaceResponse, error)

	// UpdateServiceAccountSpaceWithBodyWithResponse request with any body
	UpdateServiceAccountSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServiceAccountSpaceResponse, error)

	UpdateServiceAccountSpaceWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, body UpdateServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServiceAccountSpaceResponse, error)

	// GetACLServiceAccountSpaceWithResponse request
	GetACLServiceAccountSpaceWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, params *GetACLServiceAccountSpaceParams, reqEditors ...RequestEditorFn) (*GetACLServiceAccountSpaceResponse, error)

	// DeleteACLServiceAccountSpaceBulkWithBodyWithResponse request with any body
	DeleteACLServiceAccountSpaceBulkWithBodyWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteACLServiceAccountSpaceBulkResponse, error)

	DeleteACLServiceAccountSpaceBulkWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, body DeleteACLServiceAccountSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteACLServiceAccountSpaceBulkResponse, error)

	// CreateACLServiceAccountSpaceBulkWithBodyWithResponse request with any body
	CreateACLServiceAccountSpaceBulkWithBodyWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateACLServiceAccountSpaceBulkResponse, error)

	CreateACLServiceAccountSpaceBulkWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, body CreateACLServiceAccountSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateACLServiceAccountSpaceBulkResponse, error)

	// ListUserSpaceWithResponse request
	ListUserSpaceWithResponse(ctx context.Context, spaceId SpaceId, params *ListUserSpaceParams, reqEditors ...RequestEditorFn) (*ListUserSpaceResponse, error)

	// CreateUserSpaceWithBodyWithResponse request with any body
	CreateUserSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserSpaceResponse, error)

	CreateUserSpaceWithResponse(ctx context.Context, spaceId SpaceId, body CreateUserSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserSpaceResponse, error)

	// UnassignUserSpaceWithResponse request
	UnassignUserSpaceWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*UnassignUserSpaceResponse, error)

	// GetUserSpaceWithResponse request
	GetUserSpaceWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*GetUserSpaceResponse, error)

	// PatchUserStateSpaceWithBodyWithResponse request with any body
	PatchUserStateSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchUserStateSpaceResponse, error)

	PatchUserStateSpaceWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, body PatchUserStateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchUserStateSpaceResponse, error)

	// AssignUserToSpaceWithResponse request
	AssignUserToSpaceWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*AssignUserToSpaceResponse, error)

	// UpdateUserSpaceWithBodyWithResponse request with any body
	UpdateUserSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserSpaceResponse, error)

	UpdateUserSpaceWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, body UpdateUserSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserSpaceResponse, error)

	// GetACLUserSpaceWithResponse request
	GetACLUserSpaceWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, params *GetACLUserSpaceParams, reqEditors ...RequestEditorFn) (*GetACLUserSpaceResponse, error)

	// DeleteACLUserSpaceBulkWithBodyWithResponse request with any body
	DeleteACLUserSpaceBulkWithBodyWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteACLUserSpaceBulkResponse, error)

	DeleteACLUserSpaceBulkWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, body DeleteACLUserSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteACLUserSpaceBulkResponse, error)

	// CreateACLUserSpaceBulkWithBodyWithResponse request with any body
	CreateACLUserSpaceBulkWithBodyWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateACLUserSpaceBulkResponse, error)

	CreateACLUserSpaceBulkWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, body CreateACLUserSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateACLUserSpaceBulkResponse, error)

	// RecoverUserSpaceWithResponse request
	RecoverUserSpaceWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*RecoverUserSpaceResponse, error)

	// TokenWithBodyWithResponse request with any body
	TokenWithBodyWithResponse(ctx context.Context, params *TokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TokenResponse, error)

	TokenWithFormdataBodyWithResponse(ctx context.Context, params *TokenParams, body TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*TokenResponse, error)

	// ConvertTokenWithBodyWithResponse request with any body
	ConvertTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConvertTokenResponse, error)

	ConvertTokenWithResponse(ctx context.Context, body ConvertTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*ConvertTokenResponse, error)

	// GetUserInfoWithResponse request
	GetUserInfoWithResponse(ctx context.Context, params *GetUserInfoParams, reqEditors ...RequestEditorFn) (*GetUserInfoResponse, error)

	// HealthcheckWithResponse request
	HealthcheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthcheckResponse, error)

	// ListKubernetesSupportedNodeProfilesWithResponse request
	ListKubernetesSupportedNodeProfilesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListKubernetesSupportedNodeProfilesResponse, error)

	// ListKubernetesClustersWithResponse request
	ListKubernetesClustersWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*ListKubernetesClustersResponse, error)

	// CreateKubernetesClusterWithBodyWithResponse request with any body
	CreateKubernetesClusterWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKubernetesClusterResponse, error)

	CreateKubernetesClusterWithResponse(ctx context.Context, spaceId SpaceId, body CreateKubernetesClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKubernetesClusterResponse, error)

	// DeleteKubernetesClusterWithResponse request
	DeleteKubernetesClusterWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*DeleteKubernetesClusterResponse, error)

	// GetKubernetesClusterInfoWithResponse request
	GetKubernetesClusterInfoWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*GetKubernetesClusterInfoResponse, error)

	// GetKubernetesKubeConfigWithResponse request
	GetKubernetesKubeConfigWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*GetKubernetesKubeConfigResponse, error)

	// UpgradeKubernetesMastersWithBodyWithResponse request with any body
	UpgradeKubernetesMastersWithBodyWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpgradeKubernetesMastersResponse, error)

	UpgradeKubernetesMastersWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, body UpgradeKubernetesMastersJSONRequestBody, reqEditors ...RequestEditorFn) (*UpgradeKubernetesMastersResponse, error)

	// ListKubernetesOperationsWithResponse request
	ListKubernetesOperationsWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*ListKubernetesOperationsResponse, error)

	// GetKubernetesPrivateKeyWithResponse request
	GetKubernetesPrivateKeyWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*GetKubernetesPrivateKeyResponse, error)

	// GetKubernetesClusterStateWithResponse request
	GetKubernetesClusterStateWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*GetKubernetesClusterStateResponse, error)

	// UpdateKubernetesNodesWithResponse request
	UpdateKubernetesNodesWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*UpdateKubernetesNodesResponse, error)

	// AddKubernetesWorkersWithBodyWithResponse request with any body
	AddKubernetesWorkersWithBodyWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddKubernetesWorkersResponse, error)

	AddKubernetesWorkersWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, body AddKubernetesWorkersJSONRequestBody, reqEditors ...RequestEditorFn) (*AddKubernetesWorkersResponse, error)

	// RemoveKubernetesWorkerWithBodyWithResponse request with any body
	RemoveKubernetesWorkerWithBodyWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveKubernetesWorkerResponse, error)

	RemoveKubernetesWorkerWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, body RemoveKubernetesWorkerJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveKubernetesWorkerResponse, error)

	// UpgradeKubernetesWorkersWithBodyWithResponse request with any body
	UpgradeKubernetesWorkersWithBodyWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpgradeKubernetesWorkersResponse, error)

	UpgradeKubernetesWorkersWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, body UpgradeKubernetesWorkersJSONRequestBody, reqEditors ...RequestEditorFn) (*UpgradeKubernetesWorkersResponse, error)

	// GetKubernetesOperationWithResponse request
	GetKubernetesOperationWithResponse(ctx context.Context, spaceId SpaceId, operationId OperationId, params *GetKubernetesOperationParams, reqEditors ...RequestEditorFn) (*GetKubernetesOperationResponse, error)

	// ListKubernetesSupportedVersionsWithResponse request
	ListKubernetesSupportedVersionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListKubernetesSupportedVersionsResponse, error)

	// ListClustersWithResponse request
	ListClustersWithResponse(ctx context.Context, spaceId SpaceId, params *ListClustersParams, reqEditors ...RequestEditorFn) (*ListClustersResponse, error)

	// CreateClusterWithBodyWithResponse request with any body
	CreateClusterWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error)

	CreateClusterWithResponse(ctx context.Context, spaceId SpaceId, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error)

	// DeleteClusterWithResponse request
	DeleteClusterWithResponse(ctx context.Context, spaceId SpaceId, clusterId OpenShiftClusterId, reqEditors ...RequestEditorFn) (*DeleteClusterResponse, error)

	// GetClusterWithResponse request
	GetClusterWithResponse(ctx context.Context, spaceId SpaceId, clusterId OpenShiftClusterId, reqEditors ...RequestEditorFn) (*GetClusterResponse, error)

	// UpdateClusterWithBodyWithResponse request with any body
	UpdateClusterWithBodyWithResponse(ctx context.Context, spaceId SpaceId, clusterId OpenShiftClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error)

	UpdateClusterWithResponse(ctx context.Context, spaceId SpaceId, clusterId OpenShiftClusterId, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error)

	// ListNodepoolsWithResponse request
	ListNodepoolsWithResponse(ctx context.Context, spaceId SpaceId, clusterId OpenShiftClusterId, reqEditors ...RequestEditorFn) (*ListNodepoolsResponse, error)

	// CreateNodePoolWithBodyWithResponse request with any body
	CreateNodePoolWithBodyWithResponse(ctx context.Context, spaceId SpaceId, clusterId OpenShiftClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNodePoolResponse, error)

	CreateNodePoolWithResponse(ctx context.Context, spaceId SpaceId, clusterId OpenShiftClusterId, body CreateNodePoolJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNodePoolResponse, error)

	// DeleteNodePoolWithResponse request
	DeleteNodePoolWithResponse(ctx context.Context, spaceId SpaceId, clusterId OpenShiftClusterId, nodePoolName OpenShiftNodepoolName, reqEditors ...RequestEditorFn) (*DeleteNodePoolResponse, error)

	// UpdateNodepoolWithBodyWithResponse request with any body
	UpdateNodepoolWithBodyWithResponse(ctx context.Context, spaceId SpaceId, clusterId OpenShiftClusterId, nodePoolName OpenShiftNodepoolName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNodepoolResponse, error)

	UpdateNodepoolWithResponse(ctx context.Context, spaceId SpaceId, clusterId OpenShiftClusterId, nodePoolName OpenShiftNodepoolName, body UpdateNodepoolJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNodepoolResponse, error)

	// ListOperationsWithResponse request
	ListOperationsWithResponse(ctx context.Context, spaceId SpaceId, params *ListOperationsParams, reqEditors ...RequestEditorFn) (*ListOperationsResponse, error)

	// GetOperationWithResponse request
	GetOperationWithResponse(ctx context.Context, spaceId SpaceId, operationId OperationId, reqEditors ...RequestEditorFn) (*GetOperationResponse, error)

	// ListVersionsWithResponse request
	ListVersionsWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*ListVersionsResponse, error)

	// ListSpacesWithResponse request
	ListSpacesWithResponse(ctx context.Context, organisationId OrganisationId, params *ListSpacesParams, reqEditors ...RequestEditorFn) (*ListSpacesResponse, error)

	// CreateSpaceWithBodyWithResponse request with any body
	CreateSpaceWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpaceResponse, error)

	CreateSpaceWithResponse(ctx context.Context, organisationId OrganisationId, body CreateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpaceResponse, error)

	// DeleteSpaceWithResponse request
	DeleteSpaceWithResponse(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, reqEditors ...RequestEditorFn) (*DeleteSpaceResponse, error)

	// GetSpaceByIdWithResponse request
	GetSpaceByIdWithResponse(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, reqEditors ...RequestEditorFn) (*GetSpaceByIdResponse, error)

	// UpdateSpaceWithBodyWithResponse request with any body
	UpdateSpaceWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSpaceResponse, error)

	UpdateSpaceWithResponse(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, body UpdateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSpaceResponse, error)

	// PostgreSQLGetAvailableClusterConfigurationsWithResponse request
	PostgreSQLGetAvailableClusterConfigurationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostgreSQLGetAvailableClusterConfigurationsResponse, error)

	// PostgreSQLGetClusterAutomaticBackupInformationWithResponse request
	PostgreSQLGetClusterAutomaticBackupInformationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostgreSQLGetClusterAutomaticBackupInformationResponse, error)

	// PostgreSQLListBackupsWithResponse request
	PostgreSQLListBackupsWithResponse(ctx context.Context, spaceId SpaceId, params *PostgreSQLListBackupsParams, reqEditors ...RequestEditorFn) (*PostgreSQLListBackupsResponse, error)

	// PostgreSQLDeleteBackupWithResponse request
	PostgreSQLDeleteBackupWithResponse(ctx context.Context, spaceId SpaceId, backupId PostgresBackupIdParameter, reqEditors ...RequestEditorFn) (*PostgreSQLDeleteBackupResponse, error)

	// PostgreSQLListClustersWithResponse request
	PostgreSQLListClustersWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*PostgreSQLListClustersResponse, error)

	// PostgreSQLCreateClusterWithBodyWithResponse request with any body
	PostgreSQLCreateClusterWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostgreSQLCreateClusterResponse, error)

	PostgreSQLCreateClusterWithResponse(ctx context.Context, spaceId SpaceId, body PostgreSQLCreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*PostgreSQLCreateClusterResponse, error)

	// PostgreSQLDeleteClusterWithBodyWithResponse request with any body
	PostgreSQLDeleteClusterWithBodyWithResponse(ctx context.Context, spaceId SpaceId, clusterId PostgresClusterIdParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostgreSQLDeleteClusterResponse, error)

	PostgreSQLDeleteClusterWithResponse(ctx context.Context, spaceId SpaceId, clusterId PostgresClusterIdParameter, body PostgreSQLDeleteClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*PostgreSQLDeleteClusterResponse, error)

	// PostgreSQLGetClusterWithResponse request
	PostgreSQLGetClusterWithResponse(ctx context.Context, spaceId SpaceId, clusterId PostgresClusterIdParameter, reqEditors ...RequestEditorFn) (*PostgreSQLGetClusterResponse, error)

	// PostgreSQLModifyClusterWithBodyWithResponse request with any body
	PostgreSQLModifyClusterWithBodyWithResponse(ctx context.Context, spaceId SpaceId, clusterId PostgresClusterIdParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostgreSQLModifyClusterResponse, error)

	PostgreSQLModifyClusterWithResponse(ctx context.Context, spaceId SpaceId, clusterId PostgresClusterIdParameter, body PostgreSQLModifyClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*PostgreSQLModifyClusterResponse, error)

	// PostgreSQLListClusterBackupsWithResponse request
	PostgreSQLListClusterBackupsWithResponse(ctx context.Context, spaceId SpaceId, clusterId PostgresClusterIdParameter, reqEditors ...RequestEditorFn) (*PostgreSQLListClusterBackupsResponse, error)

	// OldPostgreSQLResetClusterAdministrationPasswordWithResponse request
	OldPostgreSQLResetClusterAdministrationPasswordWithResponse(ctx context.Context, spaceId SpaceId, clusterId PostgresClusterIdParameter, reqEditors ...RequestEditorFn) (*OldPostgreSQLResetClusterAdministrationPasswordResponse, error)

	// PostgreSQLResetClusterAdministrationPasswordWithResponse request
	PostgreSQLResetClusterAdministrationPasswordWithResponse(ctx context.Context, spaceId SpaceId, clusterId PostgresClusterIdParameter, reqEditors ...RequestEditorFn) (*PostgreSQLResetClusterAdministrationPasswordResponse, error)
}

type DeleteLoadBalancerTagsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteLoadBalancerTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLoadBalancerTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLoadBalancerTagsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateLoadBalancerTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLoadBalancerTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTagsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTagsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadDhcpOptionsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadDhcpOptions200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadDhcpOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadDhcpOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDhcpOptionsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateDhcpOptions201Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateDhcpOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDhcpOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDhcpOptionsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteDhcpOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDhcpOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadDhcpOptionsByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadDhcpOptionsById200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadDhcpOptionsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadDhcpOptionsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadFlexibleGpusResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadFlexibleGpus200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadFlexibleGpusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadFlexibleGpusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFlexibleGpuResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateFlexibleGpu201Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateFlexibleGpuResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFlexibleGpuResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFlexibleGpuResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteFlexibleGpuResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFlexibleGpuResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadFlexibleGpusByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadFlexibleGpusById200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadFlexibleGpusByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadFlexibleGpusByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateFlexibleGpuResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateFlexibleGpu200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateFlexibleGpuResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFlexibleGpuResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkFlexibleGpuResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r LinkFlexibleGpuResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkFlexibleGpuResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkFlexibleGpuResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UnlinkFlexibleGpuResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkFlexibleGpuResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadImagesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadImages200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadImagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadImagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateImageResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateImage201Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteImageResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadImagesByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadImagesById200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadImagesByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadImagesByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateImageResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateImage200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadInternetGatewaysResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadInternetGateways200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadInternetGatewaysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadInternetGatewaysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateInternetGatewayResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateInternetGateway201Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateInternetGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateInternetGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteInternetGatewayResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteInternetGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteInternetGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadInternetGatewaysByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadInternetGatewaysById200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadInternetGatewaysByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadInternetGatewaysByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkInternetGatewayResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r LinkInternetGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkInternetGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkInternetGatewayResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UnlinkInternetGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkInternetGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadKeypairsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadKeypairs200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadKeypairsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadKeypairsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateKeypairResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateKeypair201Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateKeypairResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateKeypairResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteKeypairResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteKeypairResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteKeypairResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadKeypairsByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadKeypairsById200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadKeypairsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadKeypairsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadListenerRulesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadListenerRules200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadListenerRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadListenerRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateListenerRuleResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateListenerRule201Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateListenerRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateListenerRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteListenerRuleResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteListenerRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteListenerRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadListenerRulesByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadListenerRulesById200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadListenerRulesByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadListenerRulesByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateListenerRuleResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateListenerRule200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateListenerRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateListenerRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadLoadBalancersResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadLoadBalancers200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadLoadBalancersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadLoadBalancersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLoadBalancerResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateLoadBalancer201Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateLoadBalancerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLoadBalancerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLoadBalancerResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteLoadBalancerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLoadBalancerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadLoadBalancersByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadLoadBalancersById200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadLoadBalancersByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadLoadBalancersByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateLoadBalancerResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateLoadBalancer200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateLoadBalancerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateLoadBalancerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkLoadBalancerBackendMachinesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r LinkLoadBalancerBackendMachinesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkLoadBalancerBackendMachinesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkLoadBalancerBackendMachinesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UnlinkLoadBalancerBackendMachinesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkLoadBalancerBackendMachinesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLoadBalancerListenersResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteLoadBalancerListenersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLoadBalancerListenersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLoadBalancerListenersResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateLoadBalancerListeners201Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateLoadBalancerListenersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLoadBalancerListenersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLoadBalancerPolicyResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteLoadBalancerPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLoadBalancerPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLoadBalancerPolicyResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateLoadBalancerPolicy201Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateLoadBalancerPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLoadBalancerPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVmsHealthResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadVmsHealth200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadVmsHealthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVmsHealthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadLoadBalancerTagsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadLoadBalancerTags200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadLoadBalancerTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadLoadBalancerTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadNatGatewayResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadNatGateway200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadNatGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadNatGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNatGatewayResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateNatGateway201Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateNatGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNatGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNatGatewayResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteNatGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNatGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadNatGatewayByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadNatGatewayById200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadNatGatewayByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadNatGatewayByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadNicsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadNics200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadNicsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadNicsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNicResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateNic201Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateNicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNicResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteNicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadNicsByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadNicsById200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadNicsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadNicsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateNicResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateNic200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateNicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateNicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkPrivateIpsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r LinkPrivateIpsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkPrivateIpsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkPrivateIpsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UnlinkPrivateIpsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkPrivateIpsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkNicResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *LinkNic200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r LinkNicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkNicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkNicResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UnlinkNicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkNicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadPublicIpsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadPublicIps200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadPublicIpsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadPublicIpsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePublicIpResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreatePublicIp201Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreatePublicIpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePublicIpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePublicIpResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeletePublicIpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePublicIpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadPublicIpsByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadPublicIpsById200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadPublicIpsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadPublicIpsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkPublicIpResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *LinkPublicIp200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r LinkPublicIpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkPublicIpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkPublicIpResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UnlinkPublicIpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkPublicIpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadRouteTablesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadRouteTables200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadRouteTablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadRouteTablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRouteTableResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateRouteTable201Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateRouteTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRouteTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRouteTableResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteRouteTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRouteTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadRouteTablesByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadRouteTablesById200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadRouteTablesByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadRouteTablesByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRouteTableRoutePropagationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateRouteTableRoutePropagation200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateRouteTableRoutePropagationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRouteTableRoutePropagationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRouteResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteRouteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRouteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRouteResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateRoute201Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateRouteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRouteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRouteResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateRoute200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateRouteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRouteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkRouteTableResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *LinkRouteTable200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r LinkRouteTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkRouteTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkRouteTableResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UnlinkRouteTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkRouteTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadSecurityGroupsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadSecurityGroups200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadSecurityGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadSecurityGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSecurityGroupResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateSecurityGroup201Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateSecurityGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSecurityGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSecurityGroupResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSecurityGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSecurityGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadSecurityGroupsByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadSecurityGroupsById200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadSecurityGroupsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadSecurityGroupsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSecurityGroupRuleResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSecurityGroupRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSecurityGroupRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSecurityGroupRuleResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateSecurityGroupRule201Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateSecurityGroupRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSecurityGroupRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadServerCertificatesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadServerCertificates200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadServerCertificatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadServerCertificatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServerCertificateResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateServerCertificate201Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateServerCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServerCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServerCertificateResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteServerCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServerCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateServerCertificateResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON204                   *UpdateServerCertificate204Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateServerCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateServerCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadSnapshotsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadSnapshots200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadSnapshotsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadSnapshotsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSnapshotResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateSnapshot201Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateSnapshotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSnapshotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSnapshotResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSnapshotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSnapshotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadSnapshotsByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadSnapshotsById200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadSnapshotsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadSnapshotsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadSubnetsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadSubnets200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadSubnetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadSubnetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSubnetResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateSubnet201Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateSubnetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSubnetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSubnetResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSubnetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSubnetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadSubnetsByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadSubnetsById200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadSubnetsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadSubnetsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSubnetResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateSubnet200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateSubnetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSubnetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadTagsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadTags200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVmsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadVms200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadVmsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVmsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVmsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateVms201Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateVmsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVmsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVmsStateResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadVmsState200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadVmsStateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVmsStateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVmsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteVmsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVmsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVmsByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadVmsById200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadVmsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVmsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVmResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateVm200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateVmResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVmResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadAdminPasswordResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadAdminPassword200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadAdminPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadAdminPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadConsoleOutputResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadConsoleOutput200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadConsoleOutputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadConsoleOutputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RebootVmResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r RebootVmResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RebootVmResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartVmResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *StartVm200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r StartVmResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartVmResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StopVmResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *StopVm200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r StopVmResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StopVmResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVolumesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadVolumes200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadVolumesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVolumesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVolumeResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateVolume201Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateVolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVolumeResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteVolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVolumesByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadVolumesById200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadVolumesByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVolumesByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVolumeResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateVolume200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateVolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkVolumeResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r LinkVolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkVolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkVolumeResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UnlinkVolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkVolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVpcsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadVpcs200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadVpcsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVpcsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVpcResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateVpc201Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateVpcResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVpcResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVpcResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteVpcResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVpcResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVpcsByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadVpcsById200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ReadVpcsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVpcsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVpcResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateVpc200Response
	ApplicationproblemJSON400 *Error
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON414 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateVpcResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVpcResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClientGatewayResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON401 *Error401
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r DeleteClientGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClientGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadClientGatewayResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadClientGateway200Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON401 *Error401
	ApplicationproblemJSON404 *Error404
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ReadClientGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadClientGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListClientGatewaysResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListClientGateways200Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON401 *Error401
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ListClientGatewaysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListClientGatewaysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClientGatewayResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateClientGateway201Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON401 *Error401
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r CreateClientGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClientGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListComputeBridgesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListComputeBridges200Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON401 *Error401
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ListComputeBridgesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListComputeBridgesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateComputeBridgeResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateComputeBridge201Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON401 *Error401
	ApplicationproblemJSON409 *Error409
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r CreateComputeBridgeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateComputeBridgeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteComputeBridgeResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON401 *Error401
	ApplicationproblemJSON404 *Error404
	ApplicationproblemJSON409 *Error409
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r DeleteComputeBridgeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteComputeBridgeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadComputeBridgeResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadComputeBridge200Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON401 *Error401
	ApplicationproblemJSON404 *Error404
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ReadComputeBridgeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadComputeBridgeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDirectLinkInterfacesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListDirectLinkInterfaces200Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON401 *Error401
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ListDirectLinkInterfacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDirectLinkInterfacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDirectLinkInterfaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateDirectLinkInterface201Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON401 *Error401
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r CreateDirectLinkInterfaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDirectLinkInterfaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDirectLinkInterfaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON401 *Error401
	ApplicationproblemJSON404 *Error404
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r DeleteDirectLinkInterfaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDirectLinkInterfaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadDirectLinkInterfaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadDirectLinkInterface200Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON401 *Error401
	ApplicationproblemJSON404 *Error404
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ReadDirectLinkInterfaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadDirectLinkInterfaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDirectLinksResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListDirectLinks200Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON401 *Error401
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ListDirectLinksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDirectLinksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDirectLinkResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateDirectLink201Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON401 *Error401
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r CreateDirectLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDirectLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDirectLinkResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON401 *Error401
	ApplicationproblemJSON404 *Error404
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r DeleteDirectLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDirectLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadDirectLinkResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadDirectLink200Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON401 *Error401
	ApplicationproblemJSON404 *Error404
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ReadDirectLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadDirectLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListHybridBridgesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListHybridBridges200Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON401 *Error401
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ListHybridBridgesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListHybridBridgesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHybridBridgeResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateHybridBridge201Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON401 *Error401
	ApplicationproblemJSON409 *Error409
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r CreateHybridBridgeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHybridBridgeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHybridBridgeResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON401 *Error401
	ApplicationproblemJSON404 *Error404
	ApplicationproblemJSON409 *Error409
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r DeleteHybridBridgeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHybridBridgeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadHybridBridgeResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadHybridBridge200Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON401 *Error401
	ApplicationproblemJSON404 *Error404
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ReadHybridBridgeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadHybridBridgeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListManagedServicesBridgesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListManagedServicesBridges200Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON401 *Error401
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ListManagedServicesBridgesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListManagedServicesBridgesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateManagedServicesBridgeResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateManagedServicesBridge201Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON401 *Error401
	ApplicationproblemJSON409 *Error409
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r CreateManagedServicesBridgeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateManagedServicesBridgeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteManagedServicesBridgeResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON401 *Error401
	ApplicationproblemJSON404 *Error404
	ApplicationproblemJSON409 *Error409
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r DeleteManagedServicesBridgeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteManagedServicesBridgeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadManagedServicesBridgeResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadManagedServicesBridge200Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON401 *Error401
	ApplicationproblemJSON404 *Error404
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ReadManagedServicesBridgeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadManagedServicesBridgeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadLocationsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadLocations200Response
	ApplicationproblemJSON401 *Error401
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ReadLocationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadLocationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVirtualGatewayResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON401 *Error401
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r DeleteVirtualGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVirtualGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVirtualGatewayResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadVirtualGateway200Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON401 *Error401
	ApplicationproblemJSON404 *Error404
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ReadVirtualGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVirtualGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkVirtualGatewayResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON401 *Error401
	ApplicationproblemJSON404 *Error404
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r UnlinkVirtualGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkVirtualGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkVirtualGatewayResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON401 *Error401
	ApplicationproblemJSON404 *Error404
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r LinkVirtualGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkVirtualGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListVirtualGatewaysResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListVirtualGateways200Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON401 *Error401
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ListVirtualGatewaysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVirtualGatewaysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVirtualGatewayResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateVirtualGateway201Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON401 *Error401
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r CreateVirtualGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVirtualGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVPNConnectionResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON401 *Error401
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r DeleteVPNConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVPNConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVPNConnectionResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReadVPNConnection200Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON401 *Error401
	ApplicationproblemJSON404 *Error404
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ReadVPNConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVPNConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVPNConnectionRouteResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON401 *Error401
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r DeleteVPNConnectionRouteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVPNConnectionRouteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVPNConnectionRouteResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON401 *Error401
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r CreateVPNConnectionRouteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVPNConnectionRouteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListVPNConnectionsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListVPNConnections200Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON401 *Error401
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ListVPNConnectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVPNConnectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVPNConnectionResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateVPNConnection201Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON401 *Error401
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r CreateVPNConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVPNConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JsonWebKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JsonWebKeys200Response
	JSON400      *ErrorOauth2
	JSON401      *ErrorOauth2
}

// Status returns HTTPResponse.Status
func (r JsonWebKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JsonWebKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DiscoverOidcConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OidcConfiguration
	JSONDefault  *ErrorOauth2
}

// Status returns HTTPResponse.Status
func (r DiscoverOidcConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DiscoverOidcConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWebAuthnJavaScriptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetWebAuthnJavaScript200Response
}

// Status returns HTTPResponse.Status
func (r GetWebAuthnJavaScriptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWebAuthnJavaScriptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAdminServiceAccountSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateServiceAccount201Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateAdminServiceAccountSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAdminServiceAccountSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConsentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ConsentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConsentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFlowErrorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FlowError
	JSON403      *ErrorGeneric
	JSON404      *ErrorGeneric
	JSON500      *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r GetFlowErrorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFlowErrorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateLoginFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessfulNativeLogin
	JSON400      *LoginFlow
	JSON410      *ErrorGeneric
	JSON422      *ErrorBrowserLocationChangeRequired
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r UpdateLoginFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateLoginFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBrowserLoginFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoginFlow
	JSON400      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r CreateBrowserLoginFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBrowserLoginFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLoginFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoginFlow
	JSON403      *ErrorGeneric
	JSON404      *ErrorGeneric
	JSON410      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r GetLoginFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLoginFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateLogoutFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r UpdateLogoutFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateLogoutFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBrowserLogoutFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogoutFlow
	JSON400      *ErrorGeneric
	JSON401      *ErrorGeneric
	JSON500      *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r CreateBrowserLogoutFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBrowserLogoutFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InitRecoveryFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecoveryFlow
	JSON400      *RecoveryFlow
	JSON410      *ErrorGeneric
	JSON422      *ErrorBrowserLocationChangeRequired
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r InitRecoveryFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InitRecoveryFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRecoveryFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecoveryFlow
	JSON400      *RecoveryFlow
	JSON410      *ErrorGeneric
	JSON422      *ErrorBrowserLocationChangeRequired
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r UpdateRecoveryFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRecoveryFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBrowserRecoveryFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecoveryFlow
	JSON400      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r CreateBrowserRecoveryFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBrowserRecoveryFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRecoveryFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecoveryFlow
	JSON404      *ErrorGeneric
	JSON410      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r GetRecoveryFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRecoveryFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSettingsFloResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SettingsFlow
	JSON400      *SettingsFlow
	JSON401      *ErrorGeneric
	JSON403      *ErrorGeneric
	JSON410      *ErrorGeneric
	JSON422      *ErrorBrowserLocationChangeRequired
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r UpdateSettingsFloResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSettingsFloResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBrowserSettingsFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SettingsFlow
	JSON400      *ErrorGeneric
	JSON401      *ErrorGeneric
	JSON403      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r CreateBrowserSettingsFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBrowserSettingsFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSettingsFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SettingsFlow
	JSON401      *ErrorGeneric
	JSON403      *ErrorGeneric
	JSON404      *ErrorGeneric
	JSON410      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r GetSettingsFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSettingsFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ToSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Session
	JSON401      *ErrorGeneric
	JSON403      *ErrorGeneric
	JSONDefault  *ErrorGeneric
}

// Status returns HTTPResponse.Status
func (r ToSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ToSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IntrospectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Introspect200Response
	JSON500      *ErrorOauth2
}

// Status returns HTTPResponse.Status
func (r IntrospectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IntrospectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListOrganisationsIdentityResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListUserOrganisations200Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ListOrganisationsIdentityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListOrganisationsIdentityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIAMPolicyOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetIAMPolicy200Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetIAMPolicyOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIAMPolicyOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetIAMPolicyOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r SetIAMPolicyOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetIAMPolicyOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MatchServiceAccountOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *MatchServiceAccount200Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r MatchServiceAccountOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MatchServiceAccountOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserOrganisationByEmailResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetUser200Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetUserOrganisationByEmailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserOrganisationByEmailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPermissionsOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListPermissions200Response
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ListPermissionsOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPermissionsOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPermissionOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetPermission200Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetPermissionOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPermissionOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRolesOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListRoles200Response
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ListRolesOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRolesOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRoleOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetRole200Response
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetRoleOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRoleOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRolePermissionsOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetRolePermissions200Response
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetRolePermissionsOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRolePermissionsOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListServiceAccountOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListServiceAccount200Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ListServiceAccountOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServiceAccountOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServiceAccountOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateServiceAccount201Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateServiceAccountOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServiceAccountOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServiceAccountOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteServiceAccountOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServiceAccountOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceAccountOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetServiceAccount200Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetServiceAccountOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceAccountOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateServiceAccountOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateServiceAccount200Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateServiceAccountOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateServiceAccountOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetACLServiceAccountOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetACL200Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetACLServiceAccountOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetACLServiceAccountOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteACLServiceAccountOrganisationBulkResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteACLServiceAccountOrganisationBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteACLServiceAccountOrganisationBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateACLServiceAccountOrganisationBulkResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateACLServiceAccountOrganisationBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateACLServiceAccountOrganisationBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSpacesOfServiceAccountResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListSpacesServiceAccount200Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ListSpacesOfServiceAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSpacesOfServiceAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSpacesIdentityResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListSpacesIdentity200Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ListSpacesIdentityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSpacesIdentityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListUser200Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ListUserOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateUser201Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateUserOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteUserOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetUser200Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetUserOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchUserStateOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *PatchUserState200Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchUserStateOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchUserStateOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateUser200Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateUserOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetACLUserOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetACL200Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetACLUserOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetACLUserOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteACLUserOrganisationBulkResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteACLUserOrganisationBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteACLUserOrganisationBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateACLUserOrganisationBulkResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateACLUserOrganisationBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateACLUserOrganisationBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RecoverUserOrganisationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *RecoverUser200Response
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r RecoverUserOrganisationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RecoverUserOrganisationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSpacesOfUserResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListSpacesUser200Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ListSpacesOfUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSpacesOfUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevokeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorOauth2
	JSON401      *ErrorOauth2
}

// Status returns HTTPResponse.Status
func (r RevokeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevokeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIAMPolicySpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetIAMPolicy200Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetIAMPolicySpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIAMPolicySpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetIAMPolicySpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r SetIAMPolicySpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetIAMPolicySpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MatchServiceAccountSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *MatchServiceAccount200Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r MatchServiceAccountSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MatchServiceAccountSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserSpaceByEmailResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetUser200Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetUserSpaceByEmailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserSpaceByEmailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPermissionsSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListPermissions200Response
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ListPermissionsSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPermissionsSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPermissionSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetPermission200Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetPermissionSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPermissionSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRolesSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListRoles200Response
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ListRolesSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRolesSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRoleSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetRole200Response
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetRoleSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRoleSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRolePermissionsSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetRolePermissions200Response
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetRolePermissionsSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRolePermissionsSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListServiceAccountSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListServiceAccount200Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ListServiceAccountSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServiceAccountSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServiceAccountSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateServiceAccount201Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateServiceAccountSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServiceAccountSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServiceAccountSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteServiceAccountSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServiceAccountSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceAccountSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetServiceAccount200Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetServiceAccountSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceAccountSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignServiceAccountToSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r AssignServiceAccountToSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignServiceAccountToSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateServiceAccountSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateServiceAccount200Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateServiceAccountSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateServiceAccountSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetACLServiceAccountSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetACL200Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetACLServiceAccountSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetACLServiceAccountSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteACLServiceAccountSpaceBulkResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteACLServiceAccountSpaceBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteACLServiceAccountSpaceBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateACLServiceAccountSpaceBulkResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateACLServiceAccountSpaceBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateACLServiceAccountSpaceBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListUser200Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ListUserSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *CreateUser201Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateUserSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnassignUserSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UnassignUserSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnassignUserSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetUser200Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetUserSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchUserStateSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *PatchUserState200Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r PatchUserStateSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchUserStateSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignUserToSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r AssignUserToSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignUserToSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *UpdateUser200Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON409 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateUserSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetACLUserSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetACL200Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetACLUserSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetACLUserSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteACLUserSpaceBulkResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteACLUserSpaceBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteACLUserSpaceBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateACLUserSpaceBulkResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateACLUserSpaceBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateACLUserSpaceBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RecoverUserSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *RecoverUser200Response
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r RecoverUserSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RecoverUserSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Token200Response
	JSON400      *ErrorOauth2
	JSON401      *ErrorOauth2
	JSON500      *ErrorOauth2
}

// Status returns HTTPResponse.Status
func (r TokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConvertTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConvertToken200Response
	JSON400      *ErrorOauth2
	JSON500      *ErrorOauth2
}

// Status returns HTTPResponse.Status
func (r ConvertTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConvertTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetUserInfo200Response
	JSONDefault  *ErrorOauth2
}

// Status returns HTTPResponse.Status
func (r GetUserInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HealthcheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Healthcheck200Response
}

// Status returns HTTPResponse.Status
func (r HealthcheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HealthcheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListKubernetesSupportedNodeProfilesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *NodeProfileList200Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ListKubernetesSupportedNodeProfilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListKubernetesSupportedNodeProfilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListKubernetesClustersResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ClusterList200Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ListKubernetesClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListKubernetesClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateKubernetesClusterResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON202                   *Operation202Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON409 *Error409
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r CreateKubernetesClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateKubernetesClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteKubernetesClusterResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON202                   *Operation202Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON404 *Error404
	ApplicationproblemJSON409 *Error409
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r DeleteKubernetesClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteKubernetesClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKubernetesClusterInfoResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *Cluster200Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r GetKubernetesClusterInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKubernetesClusterInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKubernetesKubeConfigResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r GetKubernetesKubeConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKubernetesKubeConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpgradeKubernetesMastersResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON202                   *Operation202Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON409 *Error409
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r UpgradeKubernetesMastersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpgradeKubernetesMastersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListKubernetesOperationsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *OperationList200Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ListKubernetesOperationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListKubernetesOperationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKubernetesPrivateKeyResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r GetKubernetesPrivateKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKubernetesPrivateKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKubernetesClusterStateResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ClusterState200Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r GetKubernetesClusterStateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKubernetesClusterStateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateKubernetesNodesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON202                   *Operation202Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON409 *Error409
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r UpdateKubernetesNodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateKubernetesNodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddKubernetesWorkersResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON202                   *Operation202Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON409 *Error409
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r AddKubernetesWorkersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddKubernetesWorkersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveKubernetesWorkerResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON202                   *Operation202Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON409 *Error409
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r RemoveKubernetesWorkerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveKubernetesWorkerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpgradeKubernetesWorkersResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON202                   *Operation202Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON409 *Error409
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r UpgradeKubernetesWorkersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpgradeKubernetesWorkersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKubernetesOperationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *Operation200Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r GetKubernetesOperationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKubernetesOperationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListKubernetesSupportedVersionsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *VersionList200Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ListKubernetesSupportedVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListKubernetesSupportedVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListClustersResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *Clusters200Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ListClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClusterResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *ClusterCreate201Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r CreateClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClusterResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON202                   *ClusterDelete202Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON404 *Error404
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r DeleteClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ClusterGet200Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON404 *Error404
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r GetClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateClusterResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ClusterGet200Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON404 *Error404
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r UpdateClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListNodepoolsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *Nodepools200Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ListNodepoolsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListNodepoolsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNodePoolResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *NodepoolCreate201Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r CreateNodePoolResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNodePoolResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNodePoolResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON202                   *NodepoolDelete202Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON404 *Error404
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r DeleteNodePoolResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNodePoolResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateNodepoolResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON202                   *OpenShiftNodepoolUpdate202Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON404 *Error404
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r UpdateNodepoolResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateNodepoolResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListOperationsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *OpenShiftOperations200Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ListOperationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListOperationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOperationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *OpenShiftOperation200Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON401 *Error401
	ApplicationproblemJSON404 *Error404
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r GetOperationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOperationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListVersionsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *Versions202Response
	ApplicationproblemJSON400 *Error400
	ApplicationproblemJSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ListVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSpacesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ListSpaces200Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r ListSpacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSpacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *CreateSpace200Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r CreateSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpaceByIdResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *GetSpaceById200Response
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetSpaceByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpaceByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSpaceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequestError
	ApplicationproblemJSON401 *Error
	ApplicationproblemJSON403 *Error
	ApplicationproblemJSON404 *Error
	ApplicationproblemJSON500 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostgreSQLGetAvailableClusterConfigurationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostgresServiceCatalogClustersConfiguration200Response
}

// Status returns HTTPResponse.Status
func (r PostgreSQLGetAvailableClusterConfigurationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostgreSQLGetAvailableClusterConfigurationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostgreSQLGetClusterAutomaticBackupInformationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostgresServiceCatalogClustersAutomaticBackup200Response
}

// Status returns HTTPResponse.Status
func (r PostgreSQLGetClusterAutomaticBackupInformationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostgreSQLGetClusterAutomaticBackupInformationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostgreSQLListBackupsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *PostgresListBackups200Response
	ApplicationproblemJSON400 *PostgresInvalidParameterProblem
	ApplicationproblemJSON403 *PostgresInvalidAuthenticationProblem
	ApplicationproblemJSON500 *PostgresServiceMalfunctionProblem
}

// Status returns HTTPResponse.Status
func (r PostgreSQLListBackupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostgreSQLListBackupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostgreSQLDeleteBackupResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON202                   *PostgresDeleteBackup202Response
	ApplicationproblemJSON400 *PostgresInvalidParameterProblem
	ApplicationproblemJSON403 *PostgresInvalidAuthenticationProblem
	ApplicationproblemJSON404 *PostgresResourceNotFoundProblem
	ApplicationproblemJSON500 *PostgresServiceMalfunctionProblem
}

// Status returns HTTPResponse.Status
func (r PostgreSQLDeleteBackupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostgreSQLDeleteBackupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostgreSQLListClustersResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *PostgresListClusters200Response
	ApplicationproblemJSON400 *PostgresInvalidParameterProblem
	ApplicationproblemJSON403 *PostgresInvalidAuthenticationProblem
	ApplicationproblemJSON500 *PostgresServiceMalfunctionProblem
}

// Status returns HTTPResponse.Status
func (r PostgreSQLListClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostgreSQLListClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostgreSQLCreateClusterResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *PostgresCreateCluster201Response
	ApplicationproblemJSON400 *PostgresCreateCluster400Response
	ApplicationproblemJSON403 *PostgresInvalidAuthenticationProblem
	ApplicationproblemJSON500 *PostgresServiceMalfunctionProblem
}

// Status returns HTTPResponse.Status
func (r PostgreSQLCreateClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostgreSQLCreateClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostgreSQLDeleteClusterResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON202                   *PostgresDeleteCluster202Response
	ApplicationproblemJSON400 *PostgresInvalidParameterProblem
	ApplicationproblemJSON403 *PostgresInvalidAuthenticationProblem
	ApplicationproblemJSON404 *PostgresResourceNotFoundProblem
	ApplicationproblemJSON409 *PostgresIncompatibleStatusProblem
	ApplicationproblemJSON500 *PostgresServiceMalfunctionProblem
}

// Status returns HTTPResponse.Status
func (r PostgreSQLDeleteClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostgreSQLDeleteClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostgreSQLGetClusterResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *PostgresGetCluster200Response
	ApplicationproblemJSON400 *PostgresInvalidParameterProblem
	ApplicationproblemJSON403 *PostgresInvalidAuthenticationProblem
	ApplicationproblemJSON404 *PostgresResourceNotFoundProblem
	ApplicationproblemJSON500 *PostgresServiceMalfunctionProblem
}

// Status returns HTTPResponse.Status
func (r PostgreSQLGetClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostgreSQLGetClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostgreSQLModifyClusterResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *PostgresPatchCluster200Response
	ApplicationproblemJSON400 *PostgresInvalidParameterProblem
	ApplicationproblemJSON403 *PostgresInvalidAuthenticationProblem
	ApplicationproblemJSON404 *PostgresResourceNotFoundProblem
	ApplicationproblemJSON409 *PostgresIncompatibleStatusProblem
	ApplicationproblemJSON500 *PostgresServiceMalfunctionProblem
}

// Status returns HTTPResponse.Status
func (r PostgreSQLModifyClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostgreSQLModifyClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostgreSQLListClusterBackupsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *PostgresListClusterBackups200Response
	ApplicationproblemJSON400 *PostgresInvalidParameterProblem
	ApplicationproblemJSON403 *PostgresInvalidAuthenticationProblem
	ApplicationproblemJSON500 *PostgresServiceMalfunctionProblem
}

// Status returns HTTPResponse.Status
func (r PostgreSQLListClusterBackupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostgreSQLListClusterBackupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OldPostgreSQLResetClusterAdministrationPasswordResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON202                   *PostgresResetPassword202Response
	ApplicationproblemJSON400 *PostgresInvalidParameterProblem
	ApplicationproblemJSON403 *PostgresInvalidAuthenticationProblem
	ApplicationproblemJSON404 *PostgresResourceNotFoundProblem
	ApplicationproblemJSON409 *PostgresIncompatibleStatusProblem
	ApplicationproblemJSON500 *PostgresServiceMalfunctionProblem
}

// Status returns HTTPResponse.Status
func (r OldPostgreSQLResetClusterAdministrationPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OldPostgreSQLResetClusterAdministrationPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostgreSQLResetClusterAdministrationPasswordResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON202                   *PostgresResetPassword202Response
	ApplicationproblemJSON400 *PostgresInvalidParameterProblem
	ApplicationproblemJSON403 *PostgresInvalidAuthenticationProblem
	ApplicationproblemJSON404 *PostgresResourceNotFoundProblem
	ApplicationproblemJSON409 *PostgresIncompatibleStatusProblem
	ApplicationproblemJSON500 *PostgresServiceMalfunctionProblem
}

// Status returns HTTPResponse.Status
func (r PostgreSQLResetClusterAdministrationPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostgreSQLResetClusterAdministrationPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// DeleteLoadBalancerTagsWithBodyWithResponse request with arbitrary body returning *DeleteLoadBalancerTagsResponse
func (c *ClientWithResponses) DeleteLoadBalancerTagsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerTagsResponse, error) {
	rsp, err := c.DeleteLoadBalancerTagsWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLoadBalancerTagsResponse(rsp)
}

func (c *ClientWithResponses) DeleteLoadBalancerTagsWithResponse(ctx context.Context, spaceId SpaceId, body DeleteLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerTagsResponse, error) {
	rsp, err := c.DeleteLoadBalancerTags(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLoadBalancerTagsResponse(rsp)
}

// CreateLoadBalancerTagsWithBodyWithResponse request with arbitrary body returning *CreateLoadBalancerTagsResponse
func (c *ClientWithResponses) CreateLoadBalancerTagsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLoadBalancerTagsResponse, error) {
	rsp, err := c.CreateLoadBalancerTagsWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLoadBalancerTagsResponse(rsp)
}

func (c *ClientWithResponses) CreateLoadBalancerTagsWithResponse(ctx context.Context, spaceId SpaceId, body CreateLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLoadBalancerTagsResponse, error) {
	rsp, err := c.CreateLoadBalancerTags(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLoadBalancerTagsResponse(rsp)
}

// DeleteTagsWithBodyWithResponse request with arbitrary body returning *DeleteTagsResponse
func (c *ClientWithResponses) DeleteTagsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteTagsResponse, error) {
	rsp, err := c.DeleteTagsWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTagsResponse(rsp)
}

func (c *ClientWithResponses) DeleteTagsWithResponse(ctx context.Context, spaceId SpaceId, body DeleteTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteTagsResponse, error) {
	rsp, err := c.DeleteTags(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTagsResponse(rsp)
}

// CreateTagsWithBodyWithResponse request with arbitrary body returning *CreateTagsResponse
func (c *ClientWithResponses) CreateTagsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTagsResponse, error) {
	rsp, err := c.CreateTagsWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTagsResponse(rsp)
}

func (c *ClientWithResponses) CreateTagsWithResponse(ctx context.Context, spaceId SpaceId, body CreateTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTagsResponse, error) {
	rsp, err := c.CreateTags(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTagsResponse(rsp)
}

// ReadDhcpOptionsWithResponse request returning *ReadDhcpOptionsResponse
func (c *ClientWithResponses) ReadDhcpOptionsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadDhcpOptionsParams, reqEditors ...RequestEditorFn) (*ReadDhcpOptionsResponse, error) {
	rsp, err := c.ReadDhcpOptions(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadDhcpOptionsResponse(rsp)
}

// CreateDhcpOptionsWithBodyWithResponse request with arbitrary body returning *CreateDhcpOptionsResponse
func (c *ClientWithResponses) CreateDhcpOptionsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDhcpOptionsResponse, error) {
	rsp, err := c.CreateDhcpOptionsWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDhcpOptionsResponse(rsp)
}

func (c *ClientWithResponses) CreateDhcpOptionsWithResponse(ctx context.Context, spaceId SpaceId, body CreateDhcpOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDhcpOptionsResponse, error) {
	rsp, err := c.CreateDhcpOptions(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDhcpOptionsResponse(rsp)
}

// DeleteDhcpOptionsWithResponse request returning *DeleteDhcpOptionsResponse
func (c *ClientWithResponses) DeleteDhcpOptionsWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteDhcpOptionsResponse, error) {
	rsp, err := c.DeleteDhcpOptions(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDhcpOptionsResponse(rsp)
}

// ReadDhcpOptionsByIdWithResponse request returning *ReadDhcpOptionsByIdResponse
func (c *ClientWithResponses) ReadDhcpOptionsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadDhcpOptionsByIdResponse, error) {
	rsp, err := c.ReadDhcpOptionsById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadDhcpOptionsByIdResponse(rsp)
}

// ReadFlexibleGpusWithResponse request returning *ReadFlexibleGpusResponse
func (c *ClientWithResponses) ReadFlexibleGpusWithResponse(ctx context.Context, spaceId SpaceId, params *ReadFlexibleGpusParams, reqEditors ...RequestEditorFn) (*ReadFlexibleGpusResponse, error) {
	rsp, err := c.ReadFlexibleGpus(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadFlexibleGpusResponse(rsp)
}

// CreateFlexibleGpuWithBodyWithResponse request with arbitrary body returning *CreateFlexibleGpuResponse
func (c *ClientWithResponses) CreateFlexibleGpuWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFlexibleGpuResponse, error) {
	rsp, err := c.CreateFlexibleGpuWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFlexibleGpuResponse(rsp)
}

func (c *ClientWithResponses) CreateFlexibleGpuWithResponse(ctx context.Context, spaceId SpaceId, body CreateFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFlexibleGpuResponse, error) {
	rsp, err := c.CreateFlexibleGpu(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFlexibleGpuResponse(rsp)
}

// DeleteFlexibleGpuWithResponse request returning *DeleteFlexibleGpuResponse
func (c *ClientWithResponses) DeleteFlexibleGpuWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteFlexibleGpuResponse, error) {
	rsp, err := c.DeleteFlexibleGpu(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFlexibleGpuResponse(rsp)
}

// ReadFlexibleGpusByIdWithResponse request returning *ReadFlexibleGpusByIdResponse
func (c *ClientWithResponses) ReadFlexibleGpusByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadFlexibleGpusByIdResponse, error) {
	rsp, err := c.ReadFlexibleGpusById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadFlexibleGpusByIdResponse(rsp)
}

// UpdateFlexibleGpuWithBodyWithResponse request with arbitrary body returning *UpdateFlexibleGpuResponse
func (c *ClientWithResponses) UpdateFlexibleGpuWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFlexibleGpuResponse, error) {
	rsp, err := c.UpdateFlexibleGpuWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFlexibleGpuResponse(rsp)
}

func (c *ClientWithResponses) UpdateFlexibleGpuWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFlexibleGpuResponse, error) {
	rsp, err := c.UpdateFlexibleGpu(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFlexibleGpuResponse(rsp)
}

// LinkFlexibleGpuWithBodyWithResponse request with arbitrary body returning *LinkFlexibleGpuResponse
func (c *ClientWithResponses) LinkFlexibleGpuWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkFlexibleGpuResponse, error) {
	rsp, err := c.LinkFlexibleGpuWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkFlexibleGpuResponse(rsp)
}

func (c *ClientWithResponses) LinkFlexibleGpuWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkFlexibleGpuResponse, error) {
	rsp, err := c.LinkFlexibleGpu(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkFlexibleGpuResponse(rsp)
}

// UnlinkFlexibleGpuWithResponse request returning *UnlinkFlexibleGpuResponse
func (c *ClientWithResponses) UnlinkFlexibleGpuWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*UnlinkFlexibleGpuResponse, error) {
	rsp, err := c.UnlinkFlexibleGpu(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkFlexibleGpuResponse(rsp)
}

// ReadImagesWithResponse request returning *ReadImagesResponse
func (c *ClientWithResponses) ReadImagesWithResponse(ctx context.Context, spaceId SpaceId, params *ReadImagesParams, reqEditors ...RequestEditorFn) (*ReadImagesResponse, error) {
	rsp, err := c.ReadImages(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadImagesResponse(rsp)
}

// CreateImageWithBodyWithResponse request with arbitrary body returning *CreateImageResponse
func (c *ClientWithResponses) CreateImageWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateImageResponse, error) {
	rsp, err := c.CreateImageWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateImageResponse(rsp)
}

func (c *ClientWithResponses) CreateImageWithResponse(ctx context.Context, spaceId SpaceId, body CreateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateImageResponse, error) {
	rsp, err := c.CreateImage(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateImageResponse(rsp)
}

// DeleteImageWithResponse request returning *DeleteImageResponse
func (c *ClientWithResponses) DeleteImageWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteImageResponse, error) {
	rsp, err := c.DeleteImage(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteImageResponse(rsp)
}

// ReadImagesByIdWithResponse request returning *ReadImagesByIdResponse
func (c *ClientWithResponses) ReadImagesByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadImagesByIdResponse, error) {
	rsp, err := c.ReadImagesById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadImagesByIdResponse(rsp)
}

// UpdateImageWithBodyWithResponse request with arbitrary body returning *UpdateImageResponse
func (c *ClientWithResponses) UpdateImageWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateImageResponse, error) {
	rsp, err := c.UpdateImageWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateImageResponse(rsp)
}

func (c *ClientWithResponses) UpdateImageWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateImageResponse, error) {
	rsp, err := c.UpdateImage(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateImageResponse(rsp)
}

// ReadInternetGatewaysWithResponse request returning *ReadInternetGatewaysResponse
func (c *ClientWithResponses) ReadInternetGatewaysWithResponse(ctx context.Context, spaceId SpaceId, params *ReadInternetGatewaysParams, reqEditors ...RequestEditorFn) (*ReadInternetGatewaysResponse, error) {
	rsp, err := c.ReadInternetGateways(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadInternetGatewaysResponse(rsp)
}

// CreateInternetGatewayWithResponse request returning *CreateInternetGatewayResponse
func (c *ClientWithResponses) CreateInternetGatewayWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*CreateInternetGatewayResponse, error) {
	rsp, err := c.CreateInternetGateway(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateInternetGatewayResponse(rsp)
}

// DeleteInternetGatewayWithResponse request returning *DeleteInternetGatewayResponse
func (c *ClientWithResponses) DeleteInternetGatewayWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteInternetGatewayResponse, error) {
	rsp, err := c.DeleteInternetGateway(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInternetGatewayResponse(rsp)
}

// ReadInternetGatewaysByIdWithResponse request returning *ReadInternetGatewaysByIdResponse
func (c *ClientWithResponses) ReadInternetGatewaysByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadInternetGatewaysByIdResponse, error) {
	rsp, err := c.ReadInternetGatewaysById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadInternetGatewaysByIdResponse(rsp)
}

// LinkInternetGatewayWithBodyWithResponse request with arbitrary body returning *LinkInternetGatewayResponse
func (c *ClientWithResponses) LinkInternetGatewayWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkInternetGatewayResponse, error) {
	rsp, err := c.LinkInternetGatewayWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkInternetGatewayResponse(rsp)
}

func (c *ClientWithResponses) LinkInternetGatewayWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkInternetGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkInternetGatewayResponse, error) {
	rsp, err := c.LinkInternetGateway(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkInternetGatewayResponse(rsp)
}

// UnlinkInternetGatewayWithBodyWithResponse request with arbitrary body returning *UnlinkInternetGatewayResponse
func (c *ClientWithResponses) UnlinkInternetGatewayWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkInternetGatewayResponse, error) {
	rsp, err := c.UnlinkInternetGatewayWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkInternetGatewayResponse(rsp)
}

func (c *ClientWithResponses) UnlinkInternetGatewayWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkInternetGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkInternetGatewayResponse, error) {
	rsp, err := c.UnlinkInternetGateway(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkInternetGatewayResponse(rsp)
}

// ReadKeypairsWithResponse request returning *ReadKeypairsResponse
func (c *ClientWithResponses) ReadKeypairsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadKeypairsParams, reqEditors ...RequestEditorFn) (*ReadKeypairsResponse, error) {
	rsp, err := c.ReadKeypairs(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadKeypairsResponse(rsp)
}

// CreateKeypairWithBodyWithResponse request with arbitrary body returning *CreateKeypairResponse
func (c *ClientWithResponses) CreateKeypairWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeypairResponse, error) {
	rsp, err := c.CreateKeypairWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeypairResponse(rsp)
}

func (c *ClientWithResponses) CreateKeypairWithResponse(ctx context.Context, spaceId SpaceId, body CreateKeypairJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeypairResponse, error) {
	rsp, err := c.CreateKeypair(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeypairResponse(rsp)
}

// DeleteKeypairWithResponse request returning *DeleteKeypairResponse
func (c *ClientWithResponses) DeleteKeypairWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteKeypairResponse, error) {
	rsp, err := c.DeleteKeypair(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteKeypairResponse(rsp)
}

// ReadKeypairsByIdWithResponse request returning *ReadKeypairsByIdResponse
func (c *ClientWithResponses) ReadKeypairsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadKeypairsByIdResponse, error) {
	rsp, err := c.ReadKeypairsById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadKeypairsByIdResponse(rsp)
}

// ReadListenerRulesWithResponse request returning *ReadListenerRulesResponse
func (c *ClientWithResponses) ReadListenerRulesWithResponse(ctx context.Context, spaceId SpaceId, params *ReadListenerRulesParams, reqEditors ...RequestEditorFn) (*ReadListenerRulesResponse, error) {
	rsp, err := c.ReadListenerRules(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadListenerRulesResponse(rsp)
}

// CreateListenerRuleWithBodyWithResponse request with arbitrary body returning *CreateListenerRuleResponse
func (c *ClientWithResponses) CreateListenerRuleWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateListenerRuleResponse, error) {
	rsp, err := c.CreateListenerRuleWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateListenerRuleResponse(rsp)
}

func (c *ClientWithResponses) CreateListenerRuleWithResponse(ctx context.Context, spaceId SpaceId, body CreateListenerRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateListenerRuleResponse, error) {
	rsp, err := c.CreateListenerRule(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateListenerRuleResponse(rsp)
}

// DeleteListenerRuleWithResponse request returning *DeleteListenerRuleResponse
func (c *ClientWithResponses) DeleteListenerRuleWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteListenerRuleResponse, error) {
	rsp, err := c.DeleteListenerRule(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteListenerRuleResponse(rsp)
}

// ReadListenerRulesByIdWithResponse request returning *ReadListenerRulesByIdResponse
func (c *ClientWithResponses) ReadListenerRulesByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadListenerRulesByIdResponse, error) {
	rsp, err := c.ReadListenerRulesById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadListenerRulesByIdResponse(rsp)
}

// UpdateListenerRuleWithBodyWithResponse request with arbitrary body returning *UpdateListenerRuleResponse
func (c *ClientWithResponses) UpdateListenerRuleWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateListenerRuleResponse, error) {
	rsp, err := c.UpdateListenerRuleWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateListenerRuleResponse(rsp)
}

func (c *ClientWithResponses) UpdateListenerRuleWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateListenerRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateListenerRuleResponse, error) {
	rsp, err := c.UpdateListenerRule(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateListenerRuleResponse(rsp)
}

// ReadLoadBalancersWithResponse request returning *ReadLoadBalancersResponse
func (c *ClientWithResponses) ReadLoadBalancersWithResponse(ctx context.Context, spaceId SpaceId, params *ReadLoadBalancersParams, reqEditors ...RequestEditorFn) (*ReadLoadBalancersResponse, error) {
	rsp, err := c.ReadLoadBalancers(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadLoadBalancersResponse(rsp)
}

// CreateLoadBalancerWithBodyWithResponse request with arbitrary body returning *CreateLoadBalancerResponse
func (c *ClientWithResponses) CreateLoadBalancerWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLoadBalancerResponse, error) {
	rsp, err := c.CreateLoadBalancerWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLoadBalancerResponse(rsp)
}

func (c *ClientWithResponses) CreateLoadBalancerWithResponse(ctx context.Context, spaceId SpaceId, body CreateLoadBalancerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLoadBalancerResponse, error) {
	rsp, err := c.CreateLoadBalancer(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLoadBalancerResponse(rsp)
}

// DeleteLoadBalancerWithResponse request returning *DeleteLoadBalancerResponse
func (c *ClientWithResponses) DeleteLoadBalancerWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerResponse, error) {
	rsp, err := c.DeleteLoadBalancer(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLoadBalancerResponse(rsp)
}

// ReadLoadBalancersByIdWithResponse request returning *ReadLoadBalancersByIdResponse
func (c *ClientWithResponses) ReadLoadBalancersByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadLoadBalancersByIdResponse, error) {
	rsp, err := c.ReadLoadBalancersById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadLoadBalancersByIdResponse(rsp)
}

// UpdateLoadBalancerWithBodyWithResponse request with arbitrary body returning *UpdateLoadBalancerResponse
func (c *ClientWithResponses) UpdateLoadBalancerWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLoadBalancerResponse, error) {
	rsp, err := c.UpdateLoadBalancerWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLoadBalancerResponse(rsp)
}

func (c *ClientWithResponses) UpdateLoadBalancerWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateLoadBalancerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLoadBalancerResponse, error) {
	rsp, err := c.UpdateLoadBalancer(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLoadBalancerResponse(rsp)
}

// LinkLoadBalancerBackendMachinesWithBodyWithResponse request with arbitrary body returning *LinkLoadBalancerBackendMachinesResponse
func (c *ClientWithResponses) LinkLoadBalancerBackendMachinesWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkLoadBalancerBackendMachinesResponse, error) {
	rsp, err := c.LinkLoadBalancerBackendMachinesWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkLoadBalancerBackendMachinesResponse(rsp)
}

func (c *ClientWithResponses) LinkLoadBalancerBackendMachinesWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkLoadBalancerBackendMachinesJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkLoadBalancerBackendMachinesResponse, error) {
	rsp, err := c.LinkLoadBalancerBackendMachines(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkLoadBalancerBackendMachinesResponse(rsp)
}

// UnlinkLoadBalancerBackendMachinesWithBodyWithResponse request with arbitrary body returning *UnlinkLoadBalancerBackendMachinesResponse
func (c *ClientWithResponses) UnlinkLoadBalancerBackendMachinesWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkLoadBalancerBackendMachinesResponse, error) {
	rsp, err := c.UnlinkLoadBalancerBackendMachinesWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkLoadBalancerBackendMachinesResponse(rsp)
}

func (c *ClientWithResponses) UnlinkLoadBalancerBackendMachinesWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkLoadBalancerBackendMachinesJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkLoadBalancerBackendMachinesResponse, error) {
	rsp, err := c.UnlinkLoadBalancerBackendMachines(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkLoadBalancerBackendMachinesResponse(rsp)
}

// DeleteLoadBalancerListenersWithBodyWithResponse request with arbitrary body returning *DeleteLoadBalancerListenersResponse
func (c *ClientWithResponses) DeleteLoadBalancerListenersWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerListenersResponse, error) {
	rsp, err := c.DeleteLoadBalancerListenersWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLoadBalancerListenersResponse(rsp)
}

func (c *ClientWithResponses) DeleteLoadBalancerListenersWithResponse(ctx context.Context, spaceId SpaceId, id string, body DeleteLoadBalancerListenersJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerListenersResponse, error) {
	rsp, err := c.DeleteLoadBalancerListeners(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLoadBalancerListenersResponse(rsp)
}

// CreateLoadBalancerListenersWithBodyWithResponse request with arbitrary body returning *CreateLoadBalancerListenersResponse
func (c *ClientWithResponses) CreateLoadBalancerListenersWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLoadBalancerListenersResponse, error) {
	rsp, err := c.CreateLoadBalancerListenersWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLoadBalancerListenersResponse(rsp)
}

func (c *ClientWithResponses) CreateLoadBalancerListenersWithResponse(ctx context.Context, spaceId SpaceId, id string, body CreateLoadBalancerListenersJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLoadBalancerListenersResponse, error) {
	rsp, err := c.CreateLoadBalancerListeners(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLoadBalancerListenersResponse(rsp)
}

// DeleteLoadBalancerPolicyWithBodyWithResponse request with arbitrary body returning *DeleteLoadBalancerPolicyResponse
func (c *ClientWithResponses) DeleteLoadBalancerPolicyWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerPolicyResponse, error) {
	rsp, err := c.DeleteLoadBalancerPolicyWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLoadBalancerPolicyResponse(rsp)
}

func (c *ClientWithResponses) DeleteLoadBalancerPolicyWithResponse(ctx context.Context, spaceId SpaceId, id string, body DeleteLoadBalancerPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerPolicyResponse, error) {
	rsp, err := c.DeleteLoadBalancerPolicy(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLoadBalancerPolicyResponse(rsp)
}

// CreateLoadBalancerPolicyWithBodyWithResponse request with arbitrary body returning *CreateLoadBalancerPolicyResponse
func (c *ClientWithResponses) CreateLoadBalancerPolicyWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLoadBalancerPolicyResponse, error) {
	rsp, err := c.CreateLoadBalancerPolicyWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLoadBalancerPolicyResponse(rsp)
}

func (c *ClientWithResponses) CreateLoadBalancerPolicyWithResponse(ctx context.Context, spaceId SpaceId, id string, body CreateLoadBalancerPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLoadBalancerPolicyResponse, error) {
	rsp, err := c.CreateLoadBalancerPolicy(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLoadBalancerPolicyResponse(rsp)
}

// ReadVmsHealthWithBodyWithResponse request with arbitrary body returning *ReadVmsHealthResponse
func (c *ClientWithResponses) ReadVmsHealthWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReadVmsHealthResponse, error) {
	rsp, err := c.ReadVmsHealthWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVmsHealthResponse(rsp)
}

func (c *ClientWithResponses) ReadVmsHealthWithResponse(ctx context.Context, spaceId SpaceId, id string, body ReadVmsHealthJSONRequestBody, reqEditors ...RequestEditorFn) (*ReadVmsHealthResponse, error) {
	rsp, err := c.ReadVmsHealth(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVmsHealthResponse(rsp)
}

// ReadLoadBalancerTagsWithBodyWithResponse request with arbitrary body returning *ReadLoadBalancerTagsResponse
func (c *ClientWithResponses) ReadLoadBalancerTagsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReadLoadBalancerTagsResponse, error) {
	rsp, err := c.ReadLoadBalancerTagsWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadLoadBalancerTagsResponse(rsp)
}

func (c *ClientWithResponses) ReadLoadBalancerTagsWithResponse(ctx context.Context, spaceId SpaceId, body ReadLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReadLoadBalancerTagsResponse, error) {
	rsp, err := c.ReadLoadBalancerTags(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadLoadBalancerTagsResponse(rsp)
}

// ReadNatGatewayWithResponse request returning *ReadNatGatewayResponse
func (c *ClientWithResponses) ReadNatGatewayWithResponse(ctx context.Context, spaceId SpaceId, params *ReadNatGatewayParams, reqEditors ...RequestEditorFn) (*ReadNatGatewayResponse, error) {
	rsp, err := c.ReadNatGateway(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadNatGatewayResponse(rsp)
}

// CreateNatGatewayWithBodyWithResponse request with arbitrary body returning *CreateNatGatewayResponse
func (c *ClientWithResponses) CreateNatGatewayWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNatGatewayResponse, error) {
	rsp, err := c.CreateNatGatewayWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNatGatewayResponse(rsp)
}

func (c *ClientWithResponses) CreateNatGatewayWithResponse(ctx context.Context, spaceId SpaceId, body CreateNatGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNatGatewayResponse, error) {
	rsp, err := c.CreateNatGateway(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNatGatewayResponse(rsp)
}

// DeleteNatGatewayWithResponse request returning *DeleteNatGatewayResponse
func (c *ClientWithResponses) DeleteNatGatewayWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteNatGatewayResponse, error) {
	rsp, err := c.DeleteNatGateway(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNatGatewayResponse(rsp)
}

// ReadNatGatewayByIdWithResponse request returning *ReadNatGatewayByIdResponse
func (c *ClientWithResponses) ReadNatGatewayByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadNatGatewayByIdResponse, error) {
	rsp, err := c.ReadNatGatewayById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadNatGatewayByIdResponse(rsp)
}

// ReadNicsWithResponse request returning *ReadNicsResponse
func (c *ClientWithResponses) ReadNicsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadNicsParams, reqEditors ...RequestEditorFn) (*ReadNicsResponse, error) {
	rsp, err := c.ReadNics(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadNicsResponse(rsp)
}

// CreateNicWithBodyWithResponse request with arbitrary body returning *CreateNicResponse
func (c *ClientWithResponses) CreateNicWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNicResponse, error) {
	rsp, err := c.CreateNicWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNicResponse(rsp)
}

func (c *ClientWithResponses) CreateNicWithResponse(ctx context.Context, spaceId SpaceId, body CreateNicJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNicResponse, error) {
	rsp, err := c.CreateNic(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNicResponse(rsp)
}

// DeleteNicWithResponse request returning *DeleteNicResponse
func (c *ClientWithResponses) DeleteNicWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteNicResponse, error) {
	rsp, err := c.DeleteNic(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNicResponse(rsp)
}

// ReadNicsByIdWithResponse request returning *ReadNicsByIdResponse
func (c *ClientWithResponses) ReadNicsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadNicsByIdResponse, error) {
	rsp, err := c.ReadNicsById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadNicsByIdResponse(rsp)
}

// UpdateNicWithBodyWithResponse request with arbitrary body returning *UpdateNicResponse
func (c *ClientWithResponses) UpdateNicWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNicResponse, error) {
	rsp, err := c.UpdateNicWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNicResponse(rsp)
}

func (c *ClientWithResponses) UpdateNicWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateNicJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNicResponse, error) {
	rsp, err := c.UpdateNic(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNicResponse(rsp)
}

// LinkPrivateIpsWithBodyWithResponse request with arbitrary body returning *LinkPrivateIpsResponse
func (c *ClientWithResponses) LinkPrivateIpsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkPrivateIpsResponse, error) {
	rsp, err := c.LinkPrivateIpsWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkPrivateIpsResponse(rsp)
}

func (c *ClientWithResponses) LinkPrivateIpsWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkPrivateIpsJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkPrivateIpsResponse, error) {
	rsp, err := c.LinkPrivateIps(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkPrivateIpsResponse(rsp)
}

// UnlinkPrivateIpsWithBodyWithResponse request with arbitrary body returning *UnlinkPrivateIpsResponse
func (c *ClientWithResponses) UnlinkPrivateIpsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkPrivateIpsResponse, error) {
	rsp, err := c.UnlinkPrivateIpsWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkPrivateIpsResponse(rsp)
}

func (c *ClientWithResponses) UnlinkPrivateIpsWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkPrivateIpsJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkPrivateIpsResponse, error) {
	rsp, err := c.UnlinkPrivateIps(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkPrivateIpsResponse(rsp)
}

// LinkNicWithBodyWithResponse request with arbitrary body returning *LinkNicResponse
func (c *ClientWithResponses) LinkNicWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkNicResponse, error) {
	rsp, err := c.LinkNicWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkNicResponse(rsp)
}

func (c *ClientWithResponses) LinkNicWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkNicJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkNicResponse, error) {
	rsp, err := c.LinkNic(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkNicResponse(rsp)
}

// UnlinkNicWithBodyWithResponse request with arbitrary body returning *UnlinkNicResponse
func (c *ClientWithResponses) UnlinkNicWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkNicResponse, error) {
	rsp, err := c.UnlinkNicWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkNicResponse(rsp)
}

func (c *ClientWithResponses) UnlinkNicWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkNicJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkNicResponse, error) {
	rsp, err := c.UnlinkNic(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkNicResponse(rsp)
}

// ReadPublicIpsWithResponse request returning *ReadPublicIpsResponse
func (c *ClientWithResponses) ReadPublicIpsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadPublicIpsParams, reqEditors ...RequestEditorFn) (*ReadPublicIpsResponse, error) {
	rsp, err := c.ReadPublicIps(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadPublicIpsResponse(rsp)
}

// CreatePublicIpWithResponse request returning *CreatePublicIpResponse
func (c *ClientWithResponses) CreatePublicIpWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*CreatePublicIpResponse, error) {
	rsp, err := c.CreatePublicIp(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePublicIpResponse(rsp)
}

// DeletePublicIpWithResponse request returning *DeletePublicIpResponse
func (c *ClientWithResponses) DeletePublicIpWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeletePublicIpResponse, error) {
	rsp, err := c.DeletePublicIp(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePublicIpResponse(rsp)
}

// ReadPublicIpsByIdWithResponse request returning *ReadPublicIpsByIdResponse
func (c *ClientWithResponses) ReadPublicIpsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadPublicIpsByIdResponse, error) {
	rsp, err := c.ReadPublicIpsById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadPublicIpsByIdResponse(rsp)
}

// LinkPublicIpWithBodyWithResponse request with arbitrary body returning *LinkPublicIpResponse
func (c *ClientWithResponses) LinkPublicIpWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkPublicIpResponse, error) {
	rsp, err := c.LinkPublicIpWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkPublicIpResponse(rsp)
}

func (c *ClientWithResponses) LinkPublicIpWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkPublicIpJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkPublicIpResponse, error) {
	rsp, err := c.LinkPublicIp(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkPublicIpResponse(rsp)
}

// UnlinkPublicIpWithBodyWithResponse request with arbitrary body returning *UnlinkPublicIpResponse
func (c *ClientWithResponses) UnlinkPublicIpWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkPublicIpResponse, error) {
	rsp, err := c.UnlinkPublicIpWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkPublicIpResponse(rsp)
}

func (c *ClientWithResponses) UnlinkPublicIpWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkPublicIpJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkPublicIpResponse, error) {
	rsp, err := c.UnlinkPublicIp(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkPublicIpResponse(rsp)
}

// ReadRouteTablesWithResponse request returning *ReadRouteTablesResponse
func (c *ClientWithResponses) ReadRouteTablesWithResponse(ctx context.Context, spaceId SpaceId, params *ReadRouteTablesParams, reqEditors ...RequestEditorFn) (*ReadRouteTablesResponse, error) {
	rsp, err := c.ReadRouteTables(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadRouteTablesResponse(rsp)
}

// CreateRouteTableWithBodyWithResponse request with arbitrary body returning *CreateRouteTableResponse
func (c *ClientWithResponses) CreateRouteTableWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRouteTableResponse, error) {
	rsp, err := c.CreateRouteTableWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRouteTableResponse(rsp)
}

func (c *ClientWithResponses) CreateRouteTableWithResponse(ctx context.Context, spaceId SpaceId, body CreateRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRouteTableResponse, error) {
	rsp, err := c.CreateRouteTable(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRouteTableResponse(rsp)
}

// DeleteRouteTableWithResponse request returning *DeleteRouteTableResponse
func (c *ClientWithResponses) DeleteRouteTableWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteRouteTableResponse, error) {
	rsp, err := c.DeleteRouteTable(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRouteTableResponse(rsp)
}

// ReadRouteTablesByIdWithResponse request returning *ReadRouteTablesByIdResponse
func (c *ClientWithResponses) ReadRouteTablesByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadRouteTablesByIdResponse, error) {
	rsp, err := c.ReadRouteTablesById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadRouteTablesByIdResponse(rsp)
}

// UpdateRouteTableRoutePropagationWithBodyWithResponse request with arbitrary body returning *UpdateRouteTableRoutePropagationResponse
func (c *ClientWithResponses) UpdateRouteTableRoutePropagationWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRouteTableRoutePropagationResponse, error) {
	rsp, err := c.UpdateRouteTableRoutePropagationWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRouteTableRoutePropagationResponse(rsp)
}

func (c *ClientWithResponses) UpdateRouteTableRoutePropagationWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateRouteTableRoutePropagationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRouteTableRoutePropagationResponse, error) {
	rsp, err := c.UpdateRouteTableRoutePropagation(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRouteTableRoutePropagationResponse(rsp)
}

// DeleteRouteWithBodyWithResponse request with arbitrary body returning *DeleteRouteResponse
func (c *ClientWithResponses) DeleteRouteWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteRouteResponse, error) {
	rsp, err := c.DeleteRouteWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRouteResponse(rsp)
}

func (c *ClientWithResponses) DeleteRouteWithResponse(ctx context.Context, spaceId SpaceId, id string, body DeleteRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteRouteResponse, error) {
	rsp, err := c.DeleteRoute(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRouteResponse(rsp)
}

// CreateRouteWithBodyWithResponse request with arbitrary body returning *CreateRouteResponse
func (c *ClientWithResponses) CreateRouteWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRouteResponse, error) {
	rsp, err := c.CreateRouteWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRouteResponse(rsp)
}

func (c *ClientWithResponses) CreateRouteWithResponse(ctx context.Context, spaceId SpaceId, id string, body CreateRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRouteResponse, error) {
	rsp, err := c.CreateRoute(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRouteResponse(rsp)
}

// UpdateRouteWithBodyWithResponse request with arbitrary body returning *UpdateRouteResponse
func (c *ClientWithResponses) UpdateRouteWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRouteResponse, error) {
	rsp, err := c.UpdateRouteWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRouteResponse(rsp)
}

func (c *ClientWithResponses) UpdateRouteWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRouteResponse, error) {
	rsp, err := c.UpdateRoute(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRouteResponse(rsp)
}

// LinkRouteTableWithBodyWithResponse request with arbitrary body returning *LinkRouteTableResponse
func (c *ClientWithResponses) LinkRouteTableWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkRouteTableResponse, error) {
	rsp, err := c.LinkRouteTableWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkRouteTableResponse(rsp)
}

func (c *ClientWithResponses) LinkRouteTableWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkRouteTableResponse, error) {
	rsp, err := c.LinkRouteTable(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkRouteTableResponse(rsp)
}

// UnlinkRouteTableWithBodyWithResponse request with arbitrary body returning *UnlinkRouteTableResponse
func (c *ClientWithResponses) UnlinkRouteTableWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkRouteTableResponse, error) {
	rsp, err := c.UnlinkRouteTableWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkRouteTableResponse(rsp)
}

func (c *ClientWithResponses) UnlinkRouteTableWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkRouteTableResponse, error) {
	rsp, err := c.UnlinkRouteTable(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkRouteTableResponse(rsp)
}

// ReadSecurityGroupsWithResponse request returning *ReadSecurityGroupsResponse
func (c *ClientWithResponses) ReadSecurityGroupsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadSecurityGroupsParams, reqEditors ...RequestEditorFn) (*ReadSecurityGroupsResponse, error) {
	rsp, err := c.ReadSecurityGroups(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadSecurityGroupsResponse(rsp)
}

// CreateSecurityGroupWithBodyWithResponse request with arbitrary body returning *CreateSecurityGroupResponse
func (c *ClientWithResponses) CreateSecurityGroupWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSecurityGroupResponse, error) {
	rsp, err := c.CreateSecurityGroupWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSecurityGroupResponse(rsp)
}

func (c *ClientWithResponses) CreateSecurityGroupWithResponse(ctx context.Context, spaceId SpaceId, body CreateSecurityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSecurityGroupResponse, error) {
	rsp, err := c.CreateSecurityGroup(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSecurityGroupResponse(rsp)
}

// DeleteSecurityGroupWithResponse request returning *DeleteSecurityGroupResponse
func (c *ClientWithResponses) DeleteSecurityGroupWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteSecurityGroupResponse, error) {
	rsp, err := c.DeleteSecurityGroup(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSecurityGroupResponse(rsp)
}

// ReadSecurityGroupsByIdWithResponse request returning *ReadSecurityGroupsByIdResponse
func (c *ClientWithResponses) ReadSecurityGroupsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadSecurityGroupsByIdResponse, error) {
	rsp, err := c.ReadSecurityGroupsById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadSecurityGroupsByIdResponse(rsp)
}

// DeleteSecurityGroupRuleWithBodyWithResponse request with arbitrary body returning *DeleteSecurityGroupRuleResponse
func (c *ClientWithResponses) DeleteSecurityGroupRuleWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteSecurityGroupRuleResponse, error) {
	rsp, err := c.DeleteSecurityGroupRuleWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSecurityGroupRuleResponse(rsp)
}

func (c *ClientWithResponses) DeleteSecurityGroupRuleWithResponse(ctx context.Context, spaceId SpaceId, id string, body DeleteSecurityGroupRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteSecurityGroupRuleResponse, error) {
	rsp, err := c.DeleteSecurityGroupRule(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSecurityGroupRuleResponse(rsp)
}

// CreateSecurityGroupRuleWithBodyWithResponse request with arbitrary body returning *CreateSecurityGroupRuleResponse
func (c *ClientWithResponses) CreateSecurityGroupRuleWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSecurityGroupRuleResponse, error) {
	rsp, err := c.CreateSecurityGroupRuleWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSecurityGroupRuleResponse(rsp)
}

func (c *ClientWithResponses) CreateSecurityGroupRuleWithResponse(ctx context.Context, spaceId SpaceId, id string, body CreateSecurityGroupRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSecurityGroupRuleResponse, error) {
	rsp, err := c.CreateSecurityGroupRule(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSecurityGroupRuleResponse(rsp)
}

// ReadServerCertificatesWithResponse request returning *ReadServerCertificatesResponse
func (c *ClientWithResponses) ReadServerCertificatesWithResponse(ctx context.Context, spaceId SpaceId, params *ReadServerCertificatesParams, reqEditors ...RequestEditorFn) (*ReadServerCertificatesResponse, error) {
	rsp, err := c.ReadServerCertificates(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadServerCertificatesResponse(rsp)
}

// CreateServerCertificateWithBodyWithResponse request with arbitrary body returning *CreateServerCertificateResponse
func (c *ClientWithResponses) CreateServerCertificateWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServerCertificateResponse, error) {
	rsp, err := c.CreateServerCertificateWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServerCertificateResponse(rsp)
}

func (c *ClientWithResponses) CreateServerCertificateWithResponse(ctx context.Context, spaceId SpaceId, body CreateServerCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServerCertificateResponse, error) {
	rsp, err := c.CreateServerCertificate(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServerCertificateResponse(rsp)
}

// DeleteServerCertificateWithResponse request returning *DeleteServerCertificateResponse
func (c *ClientWithResponses) DeleteServerCertificateWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteServerCertificateResponse, error) {
	rsp, err := c.DeleteServerCertificate(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServerCertificateResponse(rsp)
}

// UpdateServerCertificateWithBodyWithResponse request with arbitrary body returning *UpdateServerCertificateResponse
func (c *ClientWithResponses) UpdateServerCertificateWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServerCertificateResponse, error) {
	rsp, err := c.UpdateServerCertificateWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServerCertificateResponse(rsp)
}

func (c *ClientWithResponses) UpdateServerCertificateWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateServerCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServerCertificateResponse, error) {
	rsp, err := c.UpdateServerCertificate(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServerCertificateResponse(rsp)
}

// ReadSnapshotsWithResponse request returning *ReadSnapshotsResponse
func (c *ClientWithResponses) ReadSnapshotsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadSnapshotsParams, reqEditors ...RequestEditorFn) (*ReadSnapshotsResponse, error) {
	rsp, err := c.ReadSnapshots(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadSnapshotsResponse(rsp)
}

// CreateSnapshotWithBodyWithResponse request with arbitrary body returning *CreateSnapshotResponse
func (c *ClientWithResponses) CreateSnapshotWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSnapshotResponse, error) {
	rsp, err := c.CreateSnapshotWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSnapshotResponse(rsp)
}

func (c *ClientWithResponses) CreateSnapshotWithResponse(ctx context.Context, spaceId SpaceId, body CreateSnapshotJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSnapshotResponse, error) {
	rsp, err := c.CreateSnapshot(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSnapshotResponse(rsp)
}

// DeleteSnapshotWithResponse request returning *DeleteSnapshotResponse
func (c *ClientWithResponses) DeleteSnapshotWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteSnapshotResponse, error) {
	rsp, err := c.DeleteSnapshot(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSnapshotResponse(rsp)
}

// ReadSnapshotsByIdWithResponse request returning *ReadSnapshotsByIdResponse
func (c *ClientWithResponses) ReadSnapshotsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadSnapshotsByIdResponse, error) {
	rsp, err := c.ReadSnapshotsById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadSnapshotsByIdResponse(rsp)
}

// ReadSubnetsWithResponse request returning *ReadSubnetsResponse
func (c *ClientWithResponses) ReadSubnetsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadSubnetsParams, reqEditors ...RequestEditorFn) (*ReadSubnetsResponse, error) {
	rsp, err := c.ReadSubnets(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadSubnetsResponse(rsp)
}

// CreateSubnetWithBodyWithResponse request with arbitrary body returning *CreateSubnetResponse
func (c *ClientWithResponses) CreateSubnetWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSubnetResponse, error) {
	rsp, err := c.CreateSubnetWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSubnetResponse(rsp)
}

func (c *ClientWithResponses) CreateSubnetWithResponse(ctx context.Context, spaceId SpaceId, body CreateSubnetJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSubnetResponse, error) {
	rsp, err := c.CreateSubnet(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSubnetResponse(rsp)
}

// DeleteSubnetWithResponse request returning *DeleteSubnetResponse
func (c *ClientWithResponses) DeleteSubnetWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteSubnetResponse, error) {
	rsp, err := c.DeleteSubnet(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSubnetResponse(rsp)
}

// ReadSubnetsByIdWithResponse request returning *ReadSubnetsByIdResponse
func (c *ClientWithResponses) ReadSubnetsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadSubnetsByIdResponse, error) {
	rsp, err := c.ReadSubnetsById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadSubnetsByIdResponse(rsp)
}

// UpdateSubnetWithBodyWithResponse request with arbitrary body returning *UpdateSubnetResponse
func (c *ClientWithResponses) UpdateSubnetWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSubnetResponse, error) {
	rsp, err := c.UpdateSubnetWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSubnetResponse(rsp)
}

func (c *ClientWithResponses) UpdateSubnetWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateSubnetJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSubnetResponse, error) {
	rsp, err := c.UpdateSubnet(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSubnetResponse(rsp)
}

// ReadTagsWithResponse request returning *ReadTagsResponse
func (c *ClientWithResponses) ReadTagsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadTagsParams, reqEditors ...RequestEditorFn) (*ReadTagsResponse, error) {
	rsp, err := c.ReadTags(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadTagsResponse(rsp)
}

// ReadVmsWithResponse request returning *ReadVmsResponse
func (c *ClientWithResponses) ReadVmsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadVmsParams, reqEditors ...RequestEditorFn) (*ReadVmsResponse, error) {
	rsp, err := c.ReadVms(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVmsResponse(rsp)
}

// CreateVmsWithBodyWithResponse request with arbitrary body returning *CreateVmsResponse
func (c *ClientWithResponses) CreateVmsWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVmsResponse, error) {
	rsp, err := c.CreateVmsWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVmsResponse(rsp)
}

func (c *ClientWithResponses) CreateVmsWithResponse(ctx context.Context, spaceId SpaceId, body CreateVmsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVmsResponse, error) {
	rsp, err := c.CreateVms(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVmsResponse(rsp)
}

// ReadVmsStateWithResponse request returning *ReadVmsStateResponse
func (c *ClientWithResponses) ReadVmsStateWithResponse(ctx context.Context, spaceId SpaceId, params *ReadVmsStateParams, reqEditors ...RequestEditorFn) (*ReadVmsStateResponse, error) {
	rsp, err := c.ReadVmsState(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVmsStateResponse(rsp)
}

// DeleteVmsWithResponse request returning *DeleteVmsResponse
func (c *ClientWithResponses) DeleteVmsWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteVmsResponse, error) {
	rsp, err := c.DeleteVms(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVmsResponse(rsp)
}

// ReadVmsByIdWithResponse request returning *ReadVmsByIdResponse
func (c *ClientWithResponses) ReadVmsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadVmsByIdResponse, error) {
	rsp, err := c.ReadVmsById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVmsByIdResponse(rsp)
}

// UpdateVmWithBodyWithResponse request with arbitrary body returning *UpdateVmResponse
func (c *ClientWithResponses) UpdateVmWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVmResponse, error) {
	rsp, err := c.UpdateVmWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVmResponse(rsp)
}

func (c *ClientWithResponses) UpdateVmWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateVmJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVmResponse, error) {
	rsp, err := c.UpdateVm(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVmResponse(rsp)
}

// ReadAdminPasswordWithResponse request returning *ReadAdminPasswordResponse
func (c *ClientWithResponses) ReadAdminPasswordWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadAdminPasswordResponse, error) {
	rsp, err := c.ReadAdminPassword(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadAdminPasswordResponse(rsp)
}

// ReadConsoleOutputWithResponse request returning *ReadConsoleOutputResponse
func (c *ClientWithResponses) ReadConsoleOutputWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadConsoleOutputResponse, error) {
	rsp, err := c.ReadConsoleOutput(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadConsoleOutputResponse(rsp)
}

// RebootVmWithResponse request returning *RebootVmResponse
func (c *ClientWithResponses) RebootVmWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*RebootVmResponse, error) {
	rsp, err := c.RebootVm(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRebootVmResponse(rsp)
}

// StartVmWithResponse request returning *StartVmResponse
func (c *ClientWithResponses) StartVmWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*StartVmResponse, error) {
	rsp, err := c.StartVm(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartVmResponse(rsp)
}

// StopVmWithBodyWithResponse request with arbitrary body returning *StopVmResponse
func (c *ClientWithResponses) StopVmWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StopVmResponse, error) {
	rsp, err := c.StopVmWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopVmResponse(rsp)
}

func (c *ClientWithResponses) StopVmWithResponse(ctx context.Context, spaceId SpaceId, id string, body StopVmJSONRequestBody, reqEditors ...RequestEditorFn) (*StopVmResponse, error) {
	rsp, err := c.StopVm(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopVmResponse(rsp)
}

// ReadVolumesWithResponse request returning *ReadVolumesResponse
func (c *ClientWithResponses) ReadVolumesWithResponse(ctx context.Context, spaceId SpaceId, params *ReadVolumesParams, reqEditors ...RequestEditorFn) (*ReadVolumesResponse, error) {
	rsp, err := c.ReadVolumes(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVolumesResponse(rsp)
}

// CreateVolumeWithBodyWithResponse request with arbitrary body returning *CreateVolumeResponse
func (c *ClientWithResponses) CreateVolumeWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVolumeResponse, error) {
	rsp, err := c.CreateVolumeWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVolumeResponse(rsp)
}

func (c *ClientWithResponses) CreateVolumeWithResponse(ctx context.Context, spaceId SpaceId, body CreateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVolumeResponse, error) {
	rsp, err := c.CreateVolume(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVolumeResponse(rsp)
}

// DeleteVolumeWithResponse request returning *DeleteVolumeResponse
func (c *ClientWithResponses) DeleteVolumeWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteVolumeResponse, error) {
	rsp, err := c.DeleteVolume(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVolumeResponse(rsp)
}

// ReadVolumesByIdWithResponse request returning *ReadVolumesByIdResponse
func (c *ClientWithResponses) ReadVolumesByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadVolumesByIdResponse, error) {
	rsp, err := c.ReadVolumesById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVolumesByIdResponse(rsp)
}

// UpdateVolumeWithBodyWithResponse request with arbitrary body returning *UpdateVolumeResponse
func (c *ClientWithResponses) UpdateVolumeWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVolumeResponse, error) {
	rsp, err := c.UpdateVolumeWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVolumeResponse(rsp)
}

func (c *ClientWithResponses) UpdateVolumeWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVolumeResponse, error) {
	rsp, err := c.UpdateVolume(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVolumeResponse(rsp)
}

// LinkVolumeWithBodyWithResponse request with arbitrary body returning *LinkVolumeResponse
func (c *ClientWithResponses) LinkVolumeWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkVolumeResponse, error) {
	rsp, err := c.LinkVolumeWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkVolumeResponse(rsp)
}

func (c *ClientWithResponses) LinkVolumeWithResponse(ctx context.Context, spaceId SpaceId, id string, body LinkVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkVolumeResponse, error) {
	rsp, err := c.LinkVolume(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkVolumeResponse(rsp)
}

// UnlinkVolumeWithBodyWithResponse request with arbitrary body returning *UnlinkVolumeResponse
func (c *ClientWithResponses) UnlinkVolumeWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkVolumeResponse, error) {
	rsp, err := c.UnlinkVolumeWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkVolumeResponse(rsp)
}

func (c *ClientWithResponses) UnlinkVolumeWithResponse(ctx context.Context, spaceId SpaceId, id string, body UnlinkVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkVolumeResponse, error) {
	rsp, err := c.UnlinkVolume(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkVolumeResponse(rsp)
}

// ReadVpcsWithResponse request returning *ReadVpcsResponse
func (c *ClientWithResponses) ReadVpcsWithResponse(ctx context.Context, spaceId SpaceId, params *ReadVpcsParams, reqEditors ...RequestEditorFn) (*ReadVpcsResponse, error) {
	rsp, err := c.ReadVpcs(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVpcsResponse(rsp)
}

// CreateVpcWithBodyWithResponse request with arbitrary body returning *CreateVpcResponse
func (c *ClientWithResponses) CreateVpcWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVpcResponse, error) {
	rsp, err := c.CreateVpcWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVpcResponse(rsp)
}

func (c *ClientWithResponses) CreateVpcWithResponse(ctx context.Context, spaceId SpaceId, body CreateVpcJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVpcResponse, error) {
	rsp, err := c.CreateVpc(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVpcResponse(rsp)
}

// DeleteVpcWithResponse request returning *DeleteVpcResponse
func (c *ClientWithResponses) DeleteVpcWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteVpcResponse, error) {
	rsp, err := c.DeleteVpc(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVpcResponse(rsp)
}

// ReadVpcsByIdWithResponse request returning *ReadVpcsByIdResponse
func (c *ClientWithResponses) ReadVpcsByIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*ReadVpcsByIdResponse, error) {
	rsp, err := c.ReadVpcsById(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVpcsByIdResponse(rsp)
}

// UpdateVpcWithBodyWithResponse request with arbitrary body returning *UpdateVpcResponse
func (c *ClientWithResponses) UpdateVpcWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVpcResponse, error) {
	rsp, err := c.UpdateVpcWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVpcResponse(rsp)
}

func (c *ClientWithResponses) UpdateVpcWithResponse(ctx context.Context, spaceId SpaceId, id string, body UpdateVpcJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVpcResponse, error) {
	rsp, err := c.UpdateVpc(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVpcResponse(rsp)
}

// DeleteClientGatewayWithResponse request returning *DeleteClientGatewayResponse
func (c *ClientWithResponses) DeleteClientGatewayWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*DeleteClientGatewayResponse, error) {
	rsp, err := c.DeleteClientGateway(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClientGatewayResponse(rsp)
}

// ReadClientGatewayWithResponse request returning *ReadClientGatewayResponse
func (c *ClientWithResponses) ReadClientGatewayWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*ReadClientGatewayResponse, error) {
	rsp, err := c.ReadClientGateway(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadClientGatewayResponse(rsp)
}

// ListClientGatewaysWithResponse request returning *ListClientGatewaysResponse
func (c *ClientWithResponses) ListClientGatewaysWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*ListClientGatewaysResponse, error) {
	rsp, err := c.ListClientGateways(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListClientGatewaysResponse(rsp)
}

// CreateClientGatewayWithBodyWithResponse request with arbitrary body returning *CreateClientGatewayResponse
func (c *ClientWithResponses) CreateClientGatewayWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientGatewayResponse, error) {
	rsp, err := c.CreateClientGatewayWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientGatewayResponse(rsp)
}

func (c *ClientWithResponses) CreateClientGatewayWithResponse(ctx context.Context, spaceId SpaceId, body CreateClientGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientGatewayResponse, error) {
	rsp, err := c.CreateClientGateway(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientGatewayResponse(rsp)
}

// ListComputeBridgesWithResponse request returning *ListComputeBridgesResponse
func (c *ClientWithResponses) ListComputeBridgesWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*ListComputeBridgesResponse, error) {
	rsp, err := c.ListComputeBridges(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListComputeBridgesResponse(rsp)
}

// CreateComputeBridgeWithBodyWithResponse request with arbitrary body returning *CreateComputeBridgeResponse
func (c *ClientWithResponses) CreateComputeBridgeWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateComputeBridgeResponse, error) {
	rsp, err := c.CreateComputeBridgeWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateComputeBridgeResponse(rsp)
}

func (c *ClientWithResponses) CreateComputeBridgeWithResponse(ctx context.Context, spaceId SpaceId, body CreateComputeBridgeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateComputeBridgeResponse, error) {
	rsp, err := c.CreateComputeBridge(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateComputeBridgeResponse(rsp)
}

// DeleteComputeBridgeWithResponse request returning *DeleteComputeBridgeResponse
func (c *ClientWithResponses) DeleteComputeBridgeWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*DeleteComputeBridgeResponse, error) {
	rsp, err := c.DeleteComputeBridge(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteComputeBridgeResponse(rsp)
}

// ReadComputeBridgeWithResponse request returning *ReadComputeBridgeResponse
func (c *ClientWithResponses) ReadComputeBridgeWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*ReadComputeBridgeResponse, error) {
	rsp, err := c.ReadComputeBridge(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadComputeBridgeResponse(rsp)
}

// ListDirectLinkInterfacesWithResponse request returning *ListDirectLinkInterfacesResponse
func (c *ClientWithResponses) ListDirectLinkInterfacesWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*ListDirectLinkInterfacesResponse, error) {
	rsp, err := c.ListDirectLinkInterfaces(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDirectLinkInterfacesResponse(rsp)
}

// CreateDirectLinkInterfaceWithBodyWithResponse request with arbitrary body returning *CreateDirectLinkInterfaceResponse
func (c *ClientWithResponses) CreateDirectLinkInterfaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDirectLinkInterfaceResponse, error) {
	rsp, err := c.CreateDirectLinkInterfaceWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDirectLinkInterfaceResponse(rsp)
}

func (c *ClientWithResponses) CreateDirectLinkInterfaceWithResponse(ctx context.Context, spaceId SpaceId, body CreateDirectLinkInterfaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDirectLinkInterfaceResponse, error) {
	rsp, err := c.CreateDirectLinkInterface(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDirectLinkInterfaceResponse(rsp)
}

// DeleteDirectLinkInterfaceWithResponse request returning *DeleteDirectLinkInterfaceResponse
func (c *ClientWithResponses) DeleteDirectLinkInterfaceWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*DeleteDirectLinkInterfaceResponse, error) {
	rsp, err := c.DeleteDirectLinkInterface(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDirectLinkInterfaceResponse(rsp)
}

// ReadDirectLinkInterfaceWithResponse request returning *ReadDirectLinkInterfaceResponse
func (c *ClientWithResponses) ReadDirectLinkInterfaceWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*ReadDirectLinkInterfaceResponse, error) {
	rsp, err := c.ReadDirectLinkInterface(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadDirectLinkInterfaceResponse(rsp)
}

// ListDirectLinksWithResponse request returning *ListDirectLinksResponse
func (c *ClientWithResponses) ListDirectLinksWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*ListDirectLinksResponse, error) {
	rsp, err := c.ListDirectLinks(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDirectLinksResponse(rsp)
}

// CreateDirectLinkWithBodyWithResponse request with arbitrary body returning *CreateDirectLinkResponse
func (c *ClientWithResponses) CreateDirectLinkWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDirectLinkResponse, error) {
	rsp, err := c.CreateDirectLinkWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDirectLinkResponse(rsp)
}

func (c *ClientWithResponses) CreateDirectLinkWithResponse(ctx context.Context, spaceId SpaceId, body CreateDirectLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDirectLinkResponse, error) {
	rsp, err := c.CreateDirectLink(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDirectLinkResponse(rsp)
}

// DeleteDirectLinkWithResponse request returning *DeleteDirectLinkResponse
func (c *ClientWithResponses) DeleteDirectLinkWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*DeleteDirectLinkResponse, error) {
	rsp, err := c.DeleteDirectLink(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDirectLinkResponse(rsp)
}

// ReadDirectLinkWithResponse request returning *ReadDirectLinkResponse
func (c *ClientWithResponses) ReadDirectLinkWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*ReadDirectLinkResponse, error) {
	rsp, err := c.ReadDirectLink(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadDirectLinkResponse(rsp)
}

// ListHybridBridgesWithResponse request returning *ListHybridBridgesResponse
func (c *ClientWithResponses) ListHybridBridgesWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*ListHybridBridgesResponse, error) {
	rsp, err := c.ListHybridBridges(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListHybridBridgesResponse(rsp)
}

// CreateHybridBridgeWithBodyWithResponse request with arbitrary body returning *CreateHybridBridgeResponse
func (c *ClientWithResponses) CreateHybridBridgeWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHybridBridgeResponse, error) {
	rsp, err := c.CreateHybridBridgeWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHybridBridgeResponse(rsp)
}

func (c *ClientWithResponses) CreateHybridBridgeWithResponse(ctx context.Context, spaceId SpaceId, body CreateHybridBridgeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHybridBridgeResponse, error) {
	rsp, err := c.CreateHybridBridge(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHybridBridgeResponse(rsp)
}

// DeleteHybridBridgeWithResponse request returning *DeleteHybridBridgeResponse
func (c *ClientWithResponses) DeleteHybridBridgeWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*DeleteHybridBridgeResponse, error) {
	rsp, err := c.DeleteHybridBridge(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHybridBridgeResponse(rsp)
}

// ReadHybridBridgeWithResponse request returning *ReadHybridBridgeResponse
func (c *ClientWithResponses) ReadHybridBridgeWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*ReadHybridBridgeResponse, error) {
	rsp, err := c.ReadHybridBridge(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadHybridBridgeResponse(rsp)
}

// ListManagedServicesBridgesWithResponse request returning *ListManagedServicesBridgesResponse
func (c *ClientWithResponses) ListManagedServicesBridgesWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*ListManagedServicesBridgesResponse, error) {
	rsp, err := c.ListManagedServicesBridges(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListManagedServicesBridgesResponse(rsp)
}

// CreateManagedServicesBridgeWithBodyWithResponse request with arbitrary body returning *CreateManagedServicesBridgeResponse
func (c *ClientWithResponses) CreateManagedServicesBridgeWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManagedServicesBridgeResponse, error) {
	rsp, err := c.CreateManagedServicesBridgeWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManagedServicesBridgeResponse(rsp)
}

func (c *ClientWithResponses) CreateManagedServicesBridgeWithResponse(ctx context.Context, spaceId SpaceId, body CreateManagedServicesBridgeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManagedServicesBridgeResponse, error) {
	rsp, err := c.CreateManagedServicesBridge(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManagedServicesBridgeResponse(rsp)
}

// DeleteManagedServicesBridgeWithResponse request returning *DeleteManagedServicesBridgeResponse
func (c *ClientWithResponses) DeleteManagedServicesBridgeWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*DeleteManagedServicesBridgeResponse, error) {
	rsp, err := c.DeleteManagedServicesBridge(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteManagedServicesBridgeResponse(rsp)
}

// ReadManagedServicesBridgeWithResponse request returning *ReadManagedServicesBridgeResponse
func (c *ClientWithResponses) ReadManagedServicesBridgeWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*ReadManagedServicesBridgeResponse, error) {
	rsp, err := c.ReadManagedServicesBridge(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadManagedServicesBridgeResponse(rsp)
}

// ReadLocationsWithResponse request returning *ReadLocationsResponse
func (c *ClientWithResponses) ReadLocationsWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*ReadLocationsResponse, error) {
	rsp, err := c.ReadLocations(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadLocationsResponse(rsp)
}

// DeleteVirtualGatewayWithResponse request returning *DeleteVirtualGatewayResponse
func (c *ClientWithResponses) DeleteVirtualGatewayWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*DeleteVirtualGatewayResponse, error) {
	rsp, err := c.DeleteVirtualGateway(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVirtualGatewayResponse(rsp)
}

// ReadVirtualGatewayWithResponse request returning *ReadVirtualGatewayResponse
func (c *ClientWithResponses) ReadVirtualGatewayWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*ReadVirtualGatewayResponse, error) {
	rsp, err := c.ReadVirtualGateway(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVirtualGatewayResponse(rsp)
}

// UnlinkVirtualGatewayWithBodyWithResponse request with arbitrary body returning *UnlinkVirtualGatewayResponse
func (c *ClientWithResponses) UnlinkVirtualGatewayWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkVirtualGatewayResponse, error) {
	rsp, err := c.UnlinkVirtualGatewayWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkVirtualGatewayResponse(rsp)
}

func (c *ClientWithResponses) UnlinkVirtualGatewayWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, body UnlinkVirtualGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkVirtualGatewayResponse, error) {
	rsp, err := c.UnlinkVirtualGateway(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkVirtualGatewayResponse(rsp)
}

// LinkVirtualGatewayWithBodyWithResponse request with arbitrary body returning *LinkVirtualGatewayResponse
func (c *ClientWithResponses) LinkVirtualGatewayWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkVirtualGatewayResponse, error) {
	rsp, err := c.LinkVirtualGatewayWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkVirtualGatewayResponse(rsp)
}

func (c *ClientWithResponses) LinkVirtualGatewayWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, body LinkVirtualGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkVirtualGatewayResponse, error) {
	rsp, err := c.LinkVirtualGateway(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkVirtualGatewayResponse(rsp)
}

// ListVirtualGatewaysWithResponse request returning *ListVirtualGatewaysResponse
func (c *ClientWithResponses) ListVirtualGatewaysWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*ListVirtualGatewaysResponse, error) {
	rsp, err := c.ListVirtualGateways(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVirtualGatewaysResponse(rsp)
}

// CreateVirtualGatewayWithBodyWithResponse request with arbitrary body returning *CreateVirtualGatewayResponse
func (c *ClientWithResponses) CreateVirtualGatewayWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVirtualGatewayResponse, error) {
	rsp, err := c.CreateVirtualGatewayWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVirtualGatewayResponse(rsp)
}

func (c *ClientWithResponses) CreateVirtualGatewayWithResponse(ctx context.Context, spaceId SpaceId, body CreateVirtualGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVirtualGatewayResponse, error) {
	rsp, err := c.CreateVirtualGateway(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVirtualGatewayResponse(rsp)
}

// DeleteVPNConnectionWithResponse request returning *DeleteVPNConnectionResponse
func (c *ClientWithResponses) DeleteVPNConnectionWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*DeleteVPNConnectionResponse, error) {
	rsp, err := c.DeleteVPNConnection(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVPNConnectionResponse(rsp)
}

// ReadVPNConnectionWithResponse request returning *ReadVPNConnectionResponse
func (c *ClientWithResponses) ReadVPNConnectionWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, reqEditors ...RequestEditorFn) (*ReadVPNConnectionResponse, error) {
	rsp, err := c.ReadVPNConnection(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVPNConnectionResponse(rsp)
}

// DeleteVPNConnectionRouteWithBodyWithResponse request with arbitrary body returning *DeleteVPNConnectionRouteResponse
func (c *ClientWithResponses) DeleteVPNConnectionRouteWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteVPNConnectionRouteResponse, error) {
	rsp, err := c.DeleteVPNConnectionRouteWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVPNConnectionRouteResponse(rsp)
}

func (c *ClientWithResponses) DeleteVPNConnectionRouteWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, body DeleteVPNConnectionRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteVPNConnectionRouteResponse, error) {
	rsp, err := c.DeleteVPNConnectionRoute(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVPNConnectionRouteResponse(rsp)
}

// CreateVPNConnectionRouteWithBodyWithResponse request with arbitrary body returning *CreateVPNConnectionRouteResponse
func (c *ClientWithResponses) CreateVPNConnectionRouteWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVPNConnectionRouteResponse, error) {
	rsp, err := c.CreateVPNConnectionRouteWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVPNConnectionRouteResponse(rsp)
}

func (c *ClientWithResponses) CreateVPNConnectionRouteWithResponse(ctx context.Context, spaceId SpaceId, id ResourceIdentifier, body CreateVPNConnectionRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVPNConnectionRouteResponse, error) {
	rsp, err := c.CreateVPNConnectionRoute(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVPNConnectionRouteResponse(rsp)
}

// ListVPNConnectionsWithResponse request returning *ListVPNConnectionsResponse
func (c *ClientWithResponses) ListVPNConnectionsWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*ListVPNConnectionsResponse, error) {
	rsp, err := c.ListVPNConnections(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVPNConnectionsResponse(rsp)
}

// CreateVPNConnectionWithBodyWithResponse request with arbitrary body returning *CreateVPNConnectionResponse
func (c *ClientWithResponses) CreateVPNConnectionWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVPNConnectionResponse, error) {
	rsp, err := c.CreateVPNConnectionWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVPNConnectionResponse(rsp)
}

func (c *ClientWithResponses) CreateVPNConnectionWithResponse(ctx context.Context, spaceId SpaceId, body CreateVPNConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVPNConnectionResponse, error) {
	rsp, err := c.CreateVPNConnection(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVPNConnectionResponse(rsp)
}

// JsonWebKeysWithResponse request returning *JsonWebKeysResponse
func (c *ClientWithResponses) JsonWebKeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*JsonWebKeysResponse, error) {
	rsp, err := c.JsonWebKeys(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJsonWebKeysResponse(rsp)
}

// DiscoverOidcConfigurationWithResponse request returning *DiscoverOidcConfigurationResponse
func (c *ClientWithResponses) DiscoverOidcConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DiscoverOidcConfigurationResponse, error) {
	rsp, err := c.DiscoverOidcConfiguration(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDiscoverOidcConfigurationResponse(rsp)
}

// GetWebAuthnJavaScriptWithResponse request returning *GetWebAuthnJavaScriptResponse
func (c *ClientWithResponses) GetWebAuthnJavaScriptWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWebAuthnJavaScriptResponse, error) {
	rsp, err := c.GetWebAuthnJavaScript(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebAuthnJavaScriptResponse(rsp)
}

// CreateAdminServiceAccountSpaceWithBodyWithResponse request with arbitrary body returning *CreateAdminServiceAccountSpaceResponse
func (c *ClientWithResponses) CreateAdminServiceAccountSpaceWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAdminServiceAccountSpaceResponse, error) {
	rsp, err := c.CreateAdminServiceAccountSpaceWithBody(ctx, organisationId, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAdminServiceAccountSpaceResponse(rsp)
}

func (c *ClientWithResponses) CreateAdminServiceAccountSpaceWithResponse(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, body CreateAdminServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAdminServiceAccountSpaceResponse, error) {
	rsp, err := c.CreateAdminServiceAccountSpace(ctx, organisationId, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAdminServiceAccountSpaceResponse(rsp)
}

// ConsentWithResponse request returning *ConsentResponse
func (c *ClientWithResponses) ConsentWithResponse(ctx context.Context, params *ConsentParams, reqEditors ...RequestEditorFn) (*ConsentResponse, error) {
	rsp, err := c.Consent(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConsentResponse(rsp)
}

// GetFlowErrorWithResponse request returning *GetFlowErrorResponse
func (c *ClientWithResponses) GetFlowErrorWithResponse(ctx context.Context, params *GetFlowErrorParams, reqEditors ...RequestEditorFn) (*GetFlowErrorResponse, error) {
	rsp, err := c.GetFlowError(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFlowErrorResponse(rsp)
}

// UpdateLoginFlowWithBodyWithResponse request with arbitrary body returning *UpdateLoginFlowResponse
func (c *ClientWithResponses) UpdateLoginFlowWithBodyWithResponse(ctx context.Context, params *UpdateLoginFlowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLoginFlowResponse, error) {
	rsp, err := c.UpdateLoginFlowWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLoginFlowResponse(rsp)
}

func (c *ClientWithResponses) UpdateLoginFlowWithResponse(ctx context.Context, params *UpdateLoginFlowParams, body UpdateLoginFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLoginFlowResponse, error) {
	rsp, err := c.UpdateLoginFlow(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLoginFlowResponse(rsp)
}

func (c *ClientWithResponses) UpdateLoginFlowWithFormdataBodyWithResponse(ctx context.Context, params *UpdateLoginFlowParams, body UpdateLoginFlowFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateLoginFlowResponse, error) {
	rsp, err := c.UpdateLoginFlowWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLoginFlowResponse(rsp)
}

// CreateBrowserLoginFlowWithResponse request returning *CreateBrowserLoginFlowResponse
func (c *ClientWithResponses) CreateBrowserLoginFlowWithResponse(ctx context.Context, params *CreateBrowserLoginFlowParams, reqEditors ...RequestEditorFn) (*CreateBrowserLoginFlowResponse, error) {
	rsp, err := c.CreateBrowserLoginFlow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBrowserLoginFlowResponse(rsp)
}

// GetLoginFlowWithResponse request returning *GetLoginFlowResponse
func (c *ClientWithResponses) GetLoginFlowWithResponse(ctx context.Context, params *GetLoginFlowParams, reqEditors ...RequestEditorFn) (*GetLoginFlowResponse, error) {
	rsp, err := c.GetLoginFlow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLoginFlowResponse(rsp)
}

// UpdateLogoutFlowWithResponse request returning *UpdateLogoutFlowResponse
func (c *ClientWithResponses) UpdateLogoutFlowWithResponse(ctx context.Context, params *UpdateLogoutFlowParams, reqEditors ...RequestEditorFn) (*UpdateLogoutFlowResponse, error) {
	rsp, err := c.UpdateLogoutFlow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLogoutFlowResponse(rsp)
}

// CreateBrowserLogoutFlowWithResponse request returning *CreateBrowserLogoutFlowResponse
func (c *ClientWithResponses) CreateBrowserLogoutFlowWithResponse(ctx context.Context, params *CreateBrowserLogoutFlowParams, reqEditors ...RequestEditorFn) (*CreateBrowserLogoutFlowResponse, error) {
	rsp, err := c.CreateBrowserLogoutFlow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBrowserLogoutFlowResponse(rsp)
}

// InitRecoveryFlowWithResponse request returning *InitRecoveryFlowResponse
func (c *ClientWithResponses) InitRecoveryFlowWithResponse(ctx context.Context, params *InitRecoveryFlowParams, reqEditors ...RequestEditorFn) (*InitRecoveryFlowResponse, error) {
	rsp, err := c.InitRecoveryFlow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInitRecoveryFlowResponse(rsp)
}

// UpdateRecoveryFlowWithBodyWithResponse request with arbitrary body returning *UpdateRecoveryFlowResponse
func (c *ClientWithResponses) UpdateRecoveryFlowWithBodyWithResponse(ctx context.Context, params *UpdateRecoveryFlowParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRecoveryFlowResponse, error) {
	rsp, err := c.UpdateRecoveryFlowWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRecoveryFlowResponse(rsp)
}

func (c *ClientWithResponses) UpdateRecoveryFlowWithResponse(ctx context.Context, params *UpdateRecoveryFlowParams, body UpdateRecoveryFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRecoveryFlowResponse, error) {
	rsp, err := c.UpdateRecoveryFlow(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRecoveryFlowResponse(rsp)
}

func (c *ClientWithResponses) UpdateRecoveryFlowWithFormdataBodyWithResponse(ctx context.Context, params *UpdateRecoveryFlowParams, body UpdateRecoveryFlowFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateRecoveryFlowResponse, error) {
	rsp, err := c.UpdateRecoveryFlowWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRecoveryFlowResponse(rsp)
}

// CreateBrowserRecoveryFlowWithResponse request returning *CreateBrowserRecoveryFlowResponse
func (c *ClientWithResponses) CreateBrowserRecoveryFlowWithResponse(ctx context.Context, params *CreateBrowserRecoveryFlowParams, reqEditors ...RequestEditorFn) (*CreateBrowserRecoveryFlowResponse, error) {
	rsp, err := c.CreateBrowserRecoveryFlow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBrowserRecoveryFlowResponse(rsp)
}

// GetRecoveryFlowWithResponse request returning *GetRecoveryFlowResponse
func (c *ClientWithResponses) GetRecoveryFlowWithResponse(ctx context.Context, params *GetRecoveryFlowParams, reqEditors ...RequestEditorFn) (*GetRecoveryFlowResponse, error) {
	rsp, err := c.GetRecoveryFlow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRecoveryFlowResponse(rsp)
}

// UpdateSettingsFloWithBodyWithResponse request with arbitrary body returning *UpdateSettingsFloResponse
func (c *ClientWithResponses) UpdateSettingsFloWithBodyWithResponse(ctx context.Context, params *UpdateSettingsFloParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSettingsFloResponse, error) {
	rsp, err := c.UpdateSettingsFloWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSettingsFloResponse(rsp)
}

func (c *ClientWithResponses) UpdateSettingsFloWithResponse(ctx context.Context, params *UpdateSettingsFloParams, body UpdateSettingsFloJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSettingsFloResponse, error) {
	rsp, err := c.UpdateSettingsFlo(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSettingsFloResponse(rsp)
}

func (c *ClientWithResponses) UpdateSettingsFloWithFormdataBodyWithResponse(ctx context.Context, params *UpdateSettingsFloParams, body UpdateSettingsFloFormdataRequestBody, reqEditors ...RequestEditorFn) (*UpdateSettingsFloResponse, error) {
	rsp, err := c.UpdateSettingsFloWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSettingsFloResponse(rsp)
}

// CreateBrowserSettingsFlowWithResponse request returning *CreateBrowserSettingsFlowResponse
func (c *ClientWithResponses) CreateBrowserSettingsFlowWithResponse(ctx context.Context, params *CreateBrowserSettingsFlowParams, reqEditors ...RequestEditorFn) (*CreateBrowserSettingsFlowResponse, error) {
	rsp, err := c.CreateBrowserSettingsFlow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBrowserSettingsFlowResponse(rsp)
}

// GetSettingsFlowWithResponse request returning *GetSettingsFlowResponse
func (c *ClientWithResponses) GetSettingsFlowWithResponse(ctx context.Context, params *GetSettingsFlowParams, reqEditors ...RequestEditorFn) (*GetSettingsFlowResponse, error) {
	rsp, err := c.GetSettingsFlow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSettingsFlowResponse(rsp)
}

// ToSessionWithResponse request returning *ToSessionResponse
func (c *ClientWithResponses) ToSessionWithResponse(ctx context.Context, params *ToSessionParams, reqEditors ...RequestEditorFn) (*ToSessionResponse, error) {
	rsp, err := c.ToSession(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToSessionResponse(rsp)
}

// IntrospectWithBodyWithResponse request with arbitrary body returning *IntrospectResponse
func (c *ClientWithResponses) IntrospectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IntrospectResponse, error) {
	rsp, err := c.IntrospectWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIntrospectResponse(rsp)
}

func (c *ClientWithResponses) IntrospectWithFormdataBodyWithResponse(ctx context.Context, body IntrospectFormdataRequestBody, reqEditors ...RequestEditorFn) (*IntrospectResponse, error) {
	rsp, err := c.IntrospectWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIntrospectResponse(rsp)
}

// ListOrganisationsIdentityWithResponse request returning *ListOrganisationsIdentityResponse
func (c *ClientWithResponses) ListOrganisationsIdentityWithResponse(ctx context.Context, params *ListOrganisationsIdentityParams, reqEditors ...RequestEditorFn) (*ListOrganisationsIdentityResponse, error) {
	rsp, err := c.ListOrganisationsIdentity(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListOrganisationsIdentityResponse(rsp)
}

// GetIAMPolicyOrganisationWithResponse request returning *GetIAMPolicyOrganisationResponse
func (c *ClientWithResponses) GetIAMPolicyOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, reqEditors ...RequestEditorFn) (*GetIAMPolicyOrganisationResponse, error) {
	rsp, err := c.GetIAMPolicyOrganisation(ctx, organisationId, subjectType, subjectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIAMPolicyOrganisationResponse(rsp)
}

// SetIAMPolicyOrganisationWithBodyWithResponse request with arbitrary body returning *SetIAMPolicyOrganisationResponse
func (c *ClientWithResponses) SetIAMPolicyOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetIAMPolicyOrganisationResponse, error) {
	rsp, err := c.SetIAMPolicyOrganisationWithBody(ctx, organisationId, subjectType, subjectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetIAMPolicyOrganisationResponse(rsp)
}

func (c *ClientWithResponses) SetIAMPolicyOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, subjectType SubjectTypeParam, subjectId SubjectId, body SetIAMPolicyOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*SetIAMPolicyOrganisationResponse, error) {
	rsp, err := c.SetIAMPolicyOrganisation(ctx, organisationId, subjectType, subjectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetIAMPolicyOrganisationResponse(rsp)
}

// MatchServiceAccountOrganisationWithResponse request returning *MatchServiceAccountOrganisationResponse
func (c *ClientWithResponses) MatchServiceAccountOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, params *MatchServiceAccountOrganisationParams, reqEditors ...RequestEditorFn) (*MatchServiceAccountOrganisationResponse, error) {
	rsp, err := c.MatchServiceAccountOrganisation(ctx, organisationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMatchServiceAccountOrganisationResponse(rsp)
}

// GetUserOrganisationByEmailWithResponse request returning *GetUserOrganisationByEmailResponse
func (c *ClientWithResponses) GetUserOrganisationByEmailWithResponse(ctx context.Context, organisationId OrganisationId, params *GetUserOrganisationByEmailParams, reqEditors ...RequestEditorFn) (*GetUserOrganisationByEmailResponse, error) {
	rsp, err := c.GetUserOrganisationByEmail(ctx, organisationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserOrganisationByEmailResponse(rsp)
}

// ListPermissionsOrganisationWithResponse request returning *ListPermissionsOrganisationResponse
func (c *ClientWithResponses) ListPermissionsOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, params *ListPermissionsOrganisationParams, reqEditors ...RequestEditorFn) (*ListPermissionsOrganisationResponse, error) {
	rsp, err := c.ListPermissionsOrganisation(ctx, organisationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPermissionsOrganisationResponse(rsp)
}

// GetPermissionOrganisationWithResponse request returning *GetPermissionOrganisationResponse
func (c *ClientWithResponses) GetPermissionOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, permissionUuid PermissionUuid, reqEditors ...RequestEditorFn) (*GetPermissionOrganisationResponse, error) {
	rsp, err := c.GetPermissionOrganisation(ctx, organisationId, permissionUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPermissionOrganisationResponse(rsp)
}

// ListRolesOrganisationWithResponse request returning *ListRolesOrganisationResponse
func (c *ClientWithResponses) ListRolesOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, params *ListRolesOrganisationParams, reqEditors ...RequestEditorFn) (*ListRolesOrganisationResponse, error) {
	rsp, err := c.ListRolesOrganisation(ctx, organisationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRolesOrganisationResponse(rsp)
}

// GetRoleOrganisationWithResponse request returning *GetRoleOrganisationResponse
func (c *ClientWithResponses) GetRoleOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*GetRoleOrganisationResponse, error) {
	rsp, err := c.GetRoleOrganisation(ctx, organisationId, roleUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRoleOrganisationResponse(rsp)
}

// GetRolePermissionsOrganisationWithResponse request returning *GetRolePermissionsOrganisationResponse
func (c *ClientWithResponses) GetRolePermissionsOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, roleUuid RoleUuid, params *GetRolePermissionsOrganisationParams, reqEditors ...RequestEditorFn) (*GetRolePermissionsOrganisationResponse, error) {
	rsp, err := c.GetRolePermissionsOrganisation(ctx, organisationId, roleUuid, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRolePermissionsOrganisationResponse(rsp)
}

// ListServiceAccountOrganisationWithResponse request returning *ListServiceAccountOrganisationResponse
func (c *ClientWithResponses) ListServiceAccountOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, params *ListServiceAccountOrganisationParams, reqEditors ...RequestEditorFn) (*ListServiceAccountOrganisationResponse, error) {
	rsp, err := c.ListServiceAccountOrganisation(ctx, organisationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListServiceAccountOrganisationResponse(rsp)
}

// CreateServiceAccountOrganisationWithBodyWithResponse request with arbitrary body returning *CreateServiceAccountOrganisationResponse
func (c *ClientWithResponses) CreateServiceAccountOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceAccountOrganisationResponse, error) {
	rsp, err := c.CreateServiceAccountOrganisationWithBody(ctx, organisationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceAccountOrganisationResponse(rsp)
}

func (c *ClientWithResponses) CreateServiceAccountOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, body CreateServiceAccountOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceAccountOrganisationResponse, error) {
	rsp, err := c.CreateServiceAccountOrganisation(ctx, organisationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceAccountOrganisationResponse(rsp)
}

// DeleteServiceAccountOrganisationWithResponse request returning *DeleteServiceAccountOrganisationResponse
func (c *ClientWithResponses) DeleteServiceAccountOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*DeleteServiceAccountOrganisationResponse, error) {
	rsp, err := c.DeleteServiceAccountOrganisation(ctx, organisationId, serviceAccountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServiceAccountOrganisationResponse(rsp)
}

// GetServiceAccountOrganisationWithResponse request returning *GetServiceAccountOrganisationResponse
func (c *ClientWithResponses) GetServiceAccountOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*GetServiceAccountOrganisationResponse, error) {
	rsp, err := c.GetServiceAccountOrganisation(ctx, organisationId, serviceAccountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServiceAccountOrganisationResponse(rsp)
}

// UpdateServiceAccountOrganisationWithBodyWithResponse request with arbitrary body returning *UpdateServiceAccountOrganisationResponse
func (c *ClientWithResponses) UpdateServiceAccountOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServiceAccountOrganisationResponse, error) {
	rsp, err := c.UpdateServiceAccountOrganisationWithBody(ctx, organisationId, serviceAccountId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServiceAccountOrganisationResponse(rsp)
}

func (c *ClientWithResponses) UpdateServiceAccountOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, body UpdateServiceAccountOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServiceAccountOrganisationResponse, error) {
	rsp, err := c.UpdateServiceAccountOrganisation(ctx, organisationId, serviceAccountId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServiceAccountOrganisationResponse(rsp)
}

// GetACLServiceAccountOrganisationWithResponse request returning *GetACLServiceAccountOrganisationResponse
func (c *ClientWithResponses) GetACLServiceAccountOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, params *GetACLServiceAccountOrganisationParams, reqEditors ...RequestEditorFn) (*GetACLServiceAccountOrganisationResponse, error) {
	rsp, err := c.GetACLServiceAccountOrganisation(ctx, organisationId, serviceAccountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetACLServiceAccountOrganisationResponse(rsp)
}

// DeleteACLServiceAccountOrganisationBulkWithBodyWithResponse request with arbitrary body returning *DeleteACLServiceAccountOrganisationBulkResponse
func (c *ClientWithResponses) DeleteACLServiceAccountOrganisationBulkWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteACLServiceAccountOrganisationBulkResponse, error) {
	rsp, err := c.DeleteACLServiceAccountOrganisationBulkWithBody(ctx, organisationId, serviceAccountId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteACLServiceAccountOrganisationBulkResponse(rsp)
}

func (c *ClientWithResponses) DeleteACLServiceAccountOrganisationBulkWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, body DeleteACLServiceAccountOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteACLServiceAccountOrganisationBulkResponse, error) {
	rsp, err := c.DeleteACLServiceAccountOrganisationBulk(ctx, organisationId, serviceAccountId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteACLServiceAccountOrganisationBulkResponse(rsp)
}

// CreateACLServiceAccountOrganisationBulkWithBodyWithResponse request with arbitrary body returning *CreateACLServiceAccountOrganisationBulkResponse
func (c *ClientWithResponses) CreateACLServiceAccountOrganisationBulkWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateACLServiceAccountOrganisationBulkResponse, error) {
	rsp, err := c.CreateACLServiceAccountOrganisationBulkWithBody(ctx, organisationId, serviceAccountId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateACLServiceAccountOrganisationBulkResponse(rsp)
}

func (c *ClientWithResponses) CreateACLServiceAccountOrganisationBulkWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, body CreateACLServiceAccountOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateACLServiceAccountOrganisationBulkResponse, error) {
	rsp, err := c.CreateACLServiceAccountOrganisationBulk(ctx, organisationId, serviceAccountId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateACLServiceAccountOrganisationBulkResponse(rsp)
}

// ListSpacesOfServiceAccountWithResponse request returning *ListSpacesOfServiceAccountResponse
func (c *ClientWithResponses) ListSpacesOfServiceAccountWithResponse(ctx context.Context, organisationId OrganisationId, serviceAccountId ServiceAccountId, params *ListSpacesOfServiceAccountParams, reqEditors ...RequestEditorFn) (*ListSpacesOfServiceAccountResponse, error) {
	rsp, err := c.ListSpacesOfServiceAccount(ctx, organisationId, serviceAccountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSpacesOfServiceAccountResponse(rsp)
}

// ListSpacesIdentityWithResponse request returning *ListSpacesIdentityResponse
func (c *ClientWithResponses) ListSpacesIdentityWithResponse(ctx context.Context, organisationId OrganisationId, params *ListSpacesIdentityParams, reqEditors ...RequestEditorFn) (*ListSpacesIdentityResponse, error) {
	rsp, err := c.ListSpacesIdentity(ctx, organisationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSpacesIdentityResponse(rsp)
}

// ListUserOrganisationWithResponse request returning *ListUserOrganisationResponse
func (c *ClientWithResponses) ListUserOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, params *ListUserOrganisationParams, reqEditors ...RequestEditorFn) (*ListUserOrganisationResponse, error) {
	rsp, err := c.ListUserOrganisation(ctx, organisationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserOrganisationResponse(rsp)
}

// CreateUserOrganisationWithBodyWithResponse request with arbitrary body returning *CreateUserOrganisationResponse
func (c *ClientWithResponses) CreateUserOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserOrganisationResponse, error) {
	rsp, err := c.CreateUserOrganisationWithBody(ctx, organisationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserOrganisationResponse(rsp)
}

func (c *ClientWithResponses) CreateUserOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, body CreateUserOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserOrganisationResponse, error) {
	rsp, err := c.CreateUserOrganisation(ctx, organisationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserOrganisationResponse(rsp)
}

// DeleteUserOrganisationWithResponse request returning *DeleteUserOrganisationResponse
func (c *ClientWithResponses) DeleteUserOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, reqEditors ...RequestEditorFn) (*DeleteUserOrganisationResponse, error) {
	rsp, err := c.DeleteUserOrganisation(ctx, organisationId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserOrganisationResponse(rsp)
}

// GetUserOrganisationWithResponse request returning *GetUserOrganisationResponse
func (c *ClientWithResponses) GetUserOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, reqEditors ...RequestEditorFn) (*GetUserOrganisationResponse, error) {
	rsp, err := c.GetUserOrganisation(ctx, organisationId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserOrganisationResponse(rsp)
}

// PatchUserStateOrganisationWithBodyWithResponse request with arbitrary body returning *PatchUserStateOrganisationResponse
func (c *ClientWithResponses) PatchUserStateOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchUserStateOrganisationResponse, error) {
	rsp, err := c.PatchUserStateOrganisationWithBody(ctx, organisationId, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchUserStateOrganisationResponse(rsp)
}

func (c *ClientWithResponses) PatchUserStateOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, body PatchUserStateOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchUserStateOrganisationResponse, error) {
	rsp, err := c.PatchUserStateOrganisation(ctx, organisationId, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchUserStateOrganisationResponse(rsp)
}

// UpdateUserOrganisationWithBodyWithResponse request with arbitrary body returning *UpdateUserOrganisationResponse
func (c *ClientWithResponses) UpdateUserOrganisationWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserOrganisationResponse, error) {
	rsp, err := c.UpdateUserOrganisationWithBody(ctx, organisationId, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserOrganisationResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, body UpdateUserOrganisationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserOrganisationResponse, error) {
	rsp, err := c.UpdateUserOrganisation(ctx, organisationId, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserOrganisationResponse(rsp)
}

// GetACLUserOrganisationWithResponse request returning *GetACLUserOrganisationResponse
func (c *ClientWithResponses) GetACLUserOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, params *GetACLUserOrganisationParams, reqEditors ...RequestEditorFn) (*GetACLUserOrganisationResponse, error) {
	rsp, err := c.GetACLUserOrganisation(ctx, organisationId, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetACLUserOrganisationResponse(rsp)
}

// DeleteACLUserOrganisationBulkWithBodyWithResponse request with arbitrary body returning *DeleteACLUserOrganisationBulkResponse
func (c *ClientWithResponses) DeleteACLUserOrganisationBulkWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteACLUserOrganisationBulkResponse, error) {
	rsp, err := c.DeleteACLUserOrganisationBulkWithBody(ctx, organisationId, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteACLUserOrganisationBulkResponse(rsp)
}

func (c *ClientWithResponses) DeleteACLUserOrganisationBulkWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, body DeleteACLUserOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteACLUserOrganisationBulkResponse, error) {
	rsp, err := c.DeleteACLUserOrganisationBulk(ctx, organisationId, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteACLUserOrganisationBulkResponse(rsp)
}

// CreateACLUserOrganisationBulkWithBodyWithResponse request with arbitrary body returning *CreateACLUserOrganisationBulkResponse
func (c *ClientWithResponses) CreateACLUserOrganisationBulkWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateACLUserOrganisationBulkResponse, error) {
	rsp, err := c.CreateACLUserOrganisationBulkWithBody(ctx, organisationId, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateACLUserOrganisationBulkResponse(rsp)
}

func (c *ClientWithResponses) CreateACLUserOrganisationBulkWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, body CreateACLUserOrganisationBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateACLUserOrganisationBulkResponse, error) {
	rsp, err := c.CreateACLUserOrganisationBulk(ctx, organisationId, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateACLUserOrganisationBulkResponse(rsp)
}

// RecoverUserOrganisationWithResponse request returning *RecoverUserOrganisationResponse
func (c *ClientWithResponses) RecoverUserOrganisationWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, reqEditors ...RequestEditorFn) (*RecoverUserOrganisationResponse, error) {
	rsp, err := c.RecoverUserOrganisation(ctx, organisationId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRecoverUserOrganisationResponse(rsp)
}

// ListSpacesOfUserWithResponse request returning *ListSpacesOfUserResponse
func (c *ClientWithResponses) ListSpacesOfUserWithResponse(ctx context.Context, organisationId OrganisationId, userId UserId, params *ListSpacesOfUserParams, reqEditors ...RequestEditorFn) (*ListSpacesOfUserResponse, error) {
	rsp, err := c.ListSpacesOfUser(ctx, organisationId, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSpacesOfUserResponse(rsp)
}

// RevokeWithBodyWithResponse request with arbitrary body returning *RevokeResponse
func (c *ClientWithResponses) RevokeWithBodyWithResponse(ctx context.Context, params *RevokeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevokeResponse, error) {
	rsp, err := c.RevokeWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokeResponse(rsp)
}

func (c *ClientWithResponses) RevokeWithFormdataBodyWithResponse(ctx context.Context, params *RevokeParams, body RevokeFormdataRequestBody, reqEditors ...RequestEditorFn) (*RevokeResponse, error) {
	rsp, err := c.RevokeWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokeResponse(rsp)
}

// GetIAMPolicySpaceWithResponse request returning *GetIAMPolicySpaceResponse
func (c *ClientWithResponses) GetIAMPolicySpaceWithResponse(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, reqEditors ...RequestEditorFn) (*GetIAMPolicySpaceResponse, error) {
	rsp, err := c.GetIAMPolicySpace(ctx, spaceId, subjectType, subjectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIAMPolicySpaceResponse(rsp)
}

// SetIAMPolicySpaceWithBodyWithResponse request with arbitrary body returning *SetIAMPolicySpaceResponse
func (c *ClientWithResponses) SetIAMPolicySpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetIAMPolicySpaceResponse, error) {
	rsp, err := c.SetIAMPolicySpaceWithBody(ctx, spaceId, subjectType, subjectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetIAMPolicySpaceResponse(rsp)
}

func (c *ClientWithResponses) SetIAMPolicySpaceWithResponse(ctx context.Context, spaceId SpaceId, subjectType SubjectTypeParam, subjectId SubjectId, body SetIAMPolicySpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*SetIAMPolicySpaceResponse, error) {
	rsp, err := c.SetIAMPolicySpace(ctx, spaceId, subjectType, subjectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetIAMPolicySpaceResponse(rsp)
}

// MatchServiceAccountSpaceWithResponse request returning *MatchServiceAccountSpaceResponse
func (c *ClientWithResponses) MatchServiceAccountSpaceWithResponse(ctx context.Context, spaceId SpaceId, params *MatchServiceAccountSpaceParams, reqEditors ...RequestEditorFn) (*MatchServiceAccountSpaceResponse, error) {
	rsp, err := c.MatchServiceAccountSpace(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMatchServiceAccountSpaceResponse(rsp)
}

// GetUserSpaceByEmailWithResponse request returning *GetUserSpaceByEmailResponse
func (c *ClientWithResponses) GetUserSpaceByEmailWithResponse(ctx context.Context, spaceId SpaceId, params *GetUserSpaceByEmailParams, reqEditors ...RequestEditorFn) (*GetUserSpaceByEmailResponse, error) {
	rsp, err := c.GetUserSpaceByEmail(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserSpaceByEmailResponse(rsp)
}

// ListPermissionsSpaceWithResponse request returning *ListPermissionsSpaceResponse
func (c *ClientWithResponses) ListPermissionsSpaceWithResponse(ctx context.Context, spaceId SpaceId, params *ListPermissionsSpaceParams, reqEditors ...RequestEditorFn) (*ListPermissionsSpaceResponse, error) {
	rsp, err := c.ListPermissionsSpace(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPermissionsSpaceResponse(rsp)
}

// GetPermissionSpaceWithResponse request returning *GetPermissionSpaceResponse
func (c *ClientWithResponses) GetPermissionSpaceWithResponse(ctx context.Context, spaceId SpaceId, permissionUuid PermissionUuid, reqEditors ...RequestEditorFn) (*GetPermissionSpaceResponse, error) {
	rsp, err := c.GetPermissionSpace(ctx, spaceId, permissionUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPermissionSpaceResponse(rsp)
}

// ListRolesSpaceWithResponse request returning *ListRolesSpaceResponse
func (c *ClientWithResponses) ListRolesSpaceWithResponse(ctx context.Context, spaceId SpaceId, params *ListRolesSpaceParams, reqEditors ...RequestEditorFn) (*ListRolesSpaceResponse, error) {
	rsp, err := c.ListRolesSpace(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRolesSpaceResponse(rsp)
}

// GetRoleSpaceWithResponse request returning *GetRoleSpaceResponse
func (c *ClientWithResponses) GetRoleSpaceWithResponse(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, reqEditors ...RequestEditorFn) (*GetRoleSpaceResponse, error) {
	rsp, err := c.GetRoleSpace(ctx, spaceId, roleUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRoleSpaceResponse(rsp)
}

// GetRolePermissionsSpaceWithResponse request returning *GetRolePermissionsSpaceResponse
func (c *ClientWithResponses) GetRolePermissionsSpaceWithResponse(ctx context.Context, spaceId SpaceId, roleUuid RoleUuid, params *GetRolePermissionsSpaceParams, reqEditors ...RequestEditorFn) (*GetRolePermissionsSpaceResponse, error) {
	rsp, err := c.GetRolePermissionsSpace(ctx, spaceId, roleUuid, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRolePermissionsSpaceResponse(rsp)
}

// ListServiceAccountSpaceWithResponse request returning *ListServiceAccountSpaceResponse
func (c *ClientWithResponses) ListServiceAccountSpaceWithResponse(ctx context.Context, spaceId SpaceId, params *ListServiceAccountSpaceParams, reqEditors ...RequestEditorFn) (*ListServiceAccountSpaceResponse, error) {
	rsp, err := c.ListServiceAccountSpace(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListServiceAccountSpaceResponse(rsp)
}

// CreateServiceAccountSpaceWithBodyWithResponse request with arbitrary body returning *CreateServiceAccountSpaceResponse
func (c *ClientWithResponses) CreateServiceAccountSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceAccountSpaceResponse, error) {
	rsp, err := c.CreateServiceAccountSpaceWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceAccountSpaceResponse(rsp)
}

func (c *ClientWithResponses) CreateServiceAccountSpaceWithResponse(ctx context.Context, spaceId SpaceId, body CreateServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceAccountSpaceResponse, error) {
	rsp, err := c.CreateServiceAccountSpace(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceAccountSpaceResponse(rsp)
}

// DeleteServiceAccountSpaceWithResponse request returning *DeleteServiceAccountSpaceResponse
func (c *ClientWithResponses) DeleteServiceAccountSpaceWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*DeleteServiceAccountSpaceResponse, error) {
	rsp, err := c.DeleteServiceAccountSpace(ctx, spaceId, serviceAccountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServiceAccountSpaceResponse(rsp)
}

// GetServiceAccountSpaceWithResponse request returning *GetServiceAccountSpaceResponse
func (c *ClientWithResponses) GetServiceAccountSpaceWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*GetServiceAccountSpaceResponse, error) {
	rsp, err := c.GetServiceAccountSpace(ctx, spaceId, serviceAccountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServiceAccountSpaceResponse(rsp)
}

// AssignServiceAccountToSpaceWithResponse request returning *AssignServiceAccountToSpaceResponse
func (c *ClientWithResponses) AssignServiceAccountToSpaceWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, reqEditors ...RequestEditorFn) (*AssignServiceAccountToSpaceResponse, error) {
	rsp, err := c.AssignServiceAccountToSpace(ctx, spaceId, serviceAccountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignServiceAccountToSpaceResponse(rsp)
}

// UpdateServiceAccountSpaceWithBodyWithResponse request with arbitrary body returning *UpdateServiceAccountSpaceResponse
func (c *ClientWithResponses) UpdateServiceAccountSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServiceAccountSpaceResponse, error) {
	rsp, err := c.UpdateServiceAccountSpaceWithBody(ctx, spaceId, serviceAccountId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServiceAccountSpaceResponse(rsp)
}

func (c *ClientWithResponses) UpdateServiceAccountSpaceWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, body UpdateServiceAccountSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServiceAccountSpaceResponse, error) {
	rsp, err := c.UpdateServiceAccountSpace(ctx, spaceId, serviceAccountId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServiceAccountSpaceResponse(rsp)
}

// GetACLServiceAccountSpaceWithResponse request returning *GetACLServiceAccountSpaceResponse
func (c *ClientWithResponses) GetACLServiceAccountSpaceWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, params *GetACLServiceAccountSpaceParams, reqEditors ...RequestEditorFn) (*GetACLServiceAccountSpaceResponse, error) {
	rsp, err := c.GetACLServiceAccountSpace(ctx, spaceId, serviceAccountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetACLServiceAccountSpaceResponse(rsp)
}

// DeleteACLServiceAccountSpaceBulkWithBodyWithResponse request with arbitrary body returning *DeleteACLServiceAccountSpaceBulkResponse
func (c *ClientWithResponses) DeleteACLServiceAccountSpaceBulkWithBodyWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteACLServiceAccountSpaceBulkResponse, error) {
	rsp, err := c.DeleteACLServiceAccountSpaceBulkWithBody(ctx, spaceId, serviceAccountId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteACLServiceAccountSpaceBulkResponse(rsp)
}

func (c *ClientWithResponses) DeleteACLServiceAccountSpaceBulkWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, body DeleteACLServiceAccountSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteACLServiceAccountSpaceBulkResponse, error) {
	rsp, err := c.DeleteACLServiceAccountSpaceBulk(ctx, spaceId, serviceAccountId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteACLServiceAccountSpaceBulkResponse(rsp)
}

// CreateACLServiceAccountSpaceBulkWithBodyWithResponse request with arbitrary body returning *CreateACLServiceAccountSpaceBulkResponse
func (c *ClientWithResponses) CreateACLServiceAccountSpaceBulkWithBodyWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateACLServiceAccountSpaceBulkResponse, error) {
	rsp, err := c.CreateACLServiceAccountSpaceBulkWithBody(ctx, spaceId, serviceAccountId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateACLServiceAccountSpaceBulkResponse(rsp)
}

func (c *ClientWithResponses) CreateACLServiceAccountSpaceBulkWithResponse(ctx context.Context, spaceId SpaceId, serviceAccountId ServiceAccountId, body CreateACLServiceAccountSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateACLServiceAccountSpaceBulkResponse, error) {
	rsp, err := c.CreateACLServiceAccountSpaceBulk(ctx, spaceId, serviceAccountId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateACLServiceAccountSpaceBulkResponse(rsp)
}

// ListUserSpaceWithResponse request returning *ListUserSpaceResponse
func (c *ClientWithResponses) ListUserSpaceWithResponse(ctx context.Context, spaceId SpaceId, params *ListUserSpaceParams, reqEditors ...RequestEditorFn) (*ListUserSpaceResponse, error) {
	rsp, err := c.ListUserSpace(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserSpaceResponse(rsp)
}

// CreateUserSpaceWithBodyWithResponse request with arbitrary body returning *CreateUserSpaceResponse
func (c *ClientWithResponses) CreateUserSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserSpaceResponse, error) {
	rsp, err := c.CreateUserSpaceWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserSpaceResponse(rsp)
}

func (c *ClientWithResponses) CreateUserSpaceWithResponse(ctx context.Context, spaceId SpaceId, body CreateUserSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserSpaceResponse, error) {
	rsp, err := c.CreateUserSpace(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserSpaceResponse(rsp)
}

// UnassignUserSpaceWithResponse request returning *UnassignUserSpaceResponse
func (c *ClientWithResponses) UnassignUserSpaceWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*UnassignUserSpaceResponse, error) {
	rsp, err := c.UnassignUserSpace(ctx, spaceId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnassignUserSpaceResponse(rsp)
}

// GetUserSpaceWithResponse request returning *GetUserSpaceResponse
func (c *ClientWithResponses) GetUserSpaceWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*GetUserSpaceResponse, error) {
	rsp, err := c.GetUserSpace(ctx, spaceId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserSpaceResponse(rsp)
}

// PatchUserStateSpaceWithBodyWithResponse request with arbitrary body returning *PatchUserStateSpaceResponse
func (c *ClientWithResponses) PatchUserStateSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchUserStateSpaceResponse, error) {
	rsp, err := c.PatchUserStateSpaceWithBody(ctx, spaceId, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchUserStateSpaceResponse(rsp)
}

func (c *ClientWithResponses) PatchUserStateSpaceWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, body PatchUserStateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchUserStateSpaceResponse, error) {
	rsp, err := c.PatchUserStateSpace(ctx, spaceId, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchUserStateSpaceResponse(rsp)
}

// AssignUserToSpaceWithResponse request returning *AssignUserToSpaceResponse
func (c *ClientWithResponses) AssignUserToSpaceWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*AssignUserToSpaceResponse, error) {
	rsp, err := c.AssignUserToSpace(ctx, spaceId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignUserToSpaceResponse(rsp)
}

// UpdateUserSpaceWithBodyWithResponse request with arbitrary body returning *UpdateUserSpaceResponse
func (c *ClientWithResponses) UpdateUserSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserSpaceResponse, error) {
	rsp, err := c.UpdateUserSpaceWithBody(ctx, spaceId, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserSpaceResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserSpaceWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, body UpdateUserSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserSpaceResponse, error) {
	rsp, err := c.UpdateUserSpace(ctx, spaceId, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserSpaceResponse(rsp)
}

// GetACLUserSpaceWithResponse request returning *GetACLUserSpaceResponse
func (c *ClientWithResponses) GetACLUserSpaceWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, params *GetACLUserSpaceParams, reqEditors ...RequestEditorFn) (*GetACLUserSpaceResponse, error) {
	rsp, err := c.GetACLUserSpace(ctx, spaceId, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetACLUserSpaceResponse(rsp)
}

// DeleteACLUserSpaceBulkWithBodyWithResponse request with arbitrary body returning *DeleteACLUserSpaceBulkResponse
func (c *ClientWithResponses) DeleteACLUserSpaceBulkWithBodyWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteACLUserSpaceBulkResponse, error) {
	rsp, err := c.DeleteACLUserSpaceBulkWithBody(ctx, spaceId, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteACLUserSpaceBulkResponse(rsp)
}

func (c *ClientWithResponses) DeleteACLUserSpaceBulkWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, body DeleteACLUserSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteACLUserSpaceBulkResponse, error) {
	rsp, err := c.DeleteACLUserSpaceBulk(ctx, spaceId, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteACLUserSpaceBulkResponse(rsp)
}

// CreateACLUserSpaceBulkWithBodyWithResponse request with arbitrary body returning *CreateACLUserSpaceBulkResponse
func (c *ClientWithResponses) CreateACLUserSpaceBulkWithBodyWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateACLUserSpaceBulkResponse, error) {
	rsp, err := c.CreateACLUserSpaceBulkWithBody(ctx, spaceId, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateACLUserSpaceBulkResponse(rsp)
}

func (c *ClientWithResponses) CreateACLUserSpaceBulkWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, body CreateACLUserSpaceBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateACLUserSpaceBulkResponse, error) {
	rsp, err := c.CreateACLUserSpaceBulk(ctx, spaceId, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateACLUserSpaceBulkResponse(rsp)
}

// RecoverUserSpaceWithResponse request returning *RecoverUserSpaceResponse
func (c *ClientWithResponses) RecoverUserSpaceWithResponse(ctx context.Context, spaceId SpaceId, userId UserId, reqEditors ...RequestEditorFn) (*RecoverUserSpaceResponse, error) {
	rsp, err := c.RecoverUserSpace(ctx, spaceId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRecoverUserSpaceResponse(rsp)
}

// TokenWithBodyWithResponse request with arbitrary body returning *TokenResponse
func (c *ClientWithResponses) TokenWithBodyWithResponse(ctx context.Context, params *TokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TokenResponse, error) {
	rsp, err := c.TokenWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTokenResponse(rsp)
}

func (c *ClientWithResponses) TokenWithFormdataBodyWithResponse(ctx context.Context, params *TokenParams, body TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*TokenResponse, error) {
	rsp, err := c.TokenWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTokenResponse(rsp)
}

// ConvertTokenWithBodyWithResponse request with arbitrary body returning *ConvertTokenResponse
func (c *ClientWithResponses) ConvertTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConvertTokenResponse, error) {
	rsp, err := c.ConvertTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConvertTokenResponse(rsp)
}

func (c *ClientWithResponses) ConvertTokenWithResponse(ctx context.Context, body ConvertTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*ConvertTokenResponse, error) {
	rsp, err := c.ConvertToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConvertTokenResponse(rsp)
}

// GetUserInfoWithResponse request returning *GetUserInfoResponse
func (c *ClientWithResponses) GetUserInfoWithResponse(ctx context.Context, params *GetUserInfoParams, reqEditors ...RequestEditorFn) (*GetUserInfoResponse, error) {
	rsp, err := c.GetUserInfo(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserInfoResponse(rsp)
}

// HealthcheckWithResponse request returning *HealthcheckResponse
func (c *ClientWithResponses) HealthcheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthcheckResponse, error) {
	rsp, err := c.Healthcheck(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHealthcheckResponse(rsp)
}

// ListKubernetesSupportedNodeProfilesWithResponse request returning *ListKubernetesSupportedNodeProfilesResponse
func (c *ClientWithResponses) ListKubernetesSupportedNodeProfilesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListKubernetesSupportedNodeProfilesResponse, error) {
	rsp, err := c.ListKubernetesSupportedNodeProfiles(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListKubernetesSupportedNodeProfilesResponse(rsp)
}

// ListKubernetesClustersWithResponse request returning *ListKubernetesClustersResponse
func (c *ClientWithResponses) ListKubernetesClustersWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*ListKubernetesClustersResponse, error) {
	rsp, err := c.ListKubernetesClusters(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListKubernetesClustersResponse(rsp)
}

// CreateKubernetesClusterWithBodyWithResponse request with arbitrary body returning *CreateKubernetesClusterResponse
func (c *ClientWithResponses) CreateKubernetesClusterWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKubernetesClusterResponse, error) {
	rsp, err := c.CreateKubernetesClusterWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKubernetesClusterResponse(rsp)
}

func (c *ClientWithResponses) CreateKubernetesClusterWithResponse(ctx context.Context, spaceId SpaceId, body CreateKubernetesClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKubernetesClusterResponse, error) {
	rsp, err := c.CreateKubernetesCluster(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKubernetesClusterResponse(rsp)
}

// DeleteKubernetesClusterWithResponse request returning *DeleteKubernetesClusterResponse
func (c *ClientWithResponses) DeleteKubernetesClusterWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*DeleteKubernetesClusterResponse, error) {
	rsp, err := c.DeleteKubernetesCluster(ctx, spaceId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteKubernetesClusterResponse(rsp)
}

// GetKubernetesClusterInfoWithResponse request returning *GetKubernetesClusterInfoResponse
func (c *ClientWithResponses) GetKubernetesClusterInfoWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*GetKubernetesClusterInfoResponse, error) {
	rsp, err := c.GetKubernetesClusterInfo(ctx, spaceId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKubernetesClusterInfoResponse(rsp)
}

// GetKubernetesKubeConfigWithResponse request returning *GetKubernetesKubeConfigResponse
func (c *ClientWithResponses) GetKubernetesKubeConfigWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*GetKubernetesKubeConfigResponse, error) {
	rsp, err := c.GetKubernetesKubeConfig(ctx, spaceId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKubernetesKubeConfigResponse(rsp)
}

// UpgradeKubernetesMastersWithBodyWithResponse request with arbitrary body returning *UpgradeKubernetesMastersResponse
func (c *ClientWithResponses) UpgradeKubernetesMastersWithBodyWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpgradeKubernetesMastersResponse, error) {
	rsp, err := c.UpgradeKubernetesMastersWithBody(ctx, spaceId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpgradeKubernetesMastersResponse(rsp)
}

func (c *ClientWithResponses) UpgradeKubernetesMastersWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, body UpgradeKubernetesMastersJSONRequestBody, reqEditors ...RequestEditorFn) (*UpgradeKubernetesMastersResponse, error) {
	rsp, err := c.UpgradeKubernetesMasters(ctx, spaceId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpgradeKubernetesMastersResponse(rsp)
}

// ListKubernetesOperationsWithResponse request returning *ListKubernetesOperationsResponse
func (c *ClientWithResponses) ListKubernetesOperationsWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*ListKubernetesOperationsResponse, error) {
	rsp, err := c.ListKubernetesOperations(ctx, spaceId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListKubernetesOperationsResponse(rsp)
}

// GetKubernetesPrivateKeyWithResponse request returning *GetKubernetesPrivateKeyResponse
func (c *ClientWithResponses) GetKubernetesPrivateKeyWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*GetKubernetesPrivateKeyResponse, error) {
	rsp, err := c.GetKubernetesPrivateKey(ctx, spaceId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKubernetesPrivateKeyResponse(rsp)
}

// GetKubernetesClusterStateWithResponse request returning *GetKubernetesClusterStateResponse
func (c *ClientWithResponses) GetKubernetesClusterStateWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*GetKubernetesClusterStateResponse, error) {
	rsp, err := c.GetKubernetesClusterState(ctx, spaceId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKubernetesClusterStateResponse(rsp)
}

// UpdateKubernetesNodesWithResponse request returning *UpdateKubernetesNodesResponse
func (c *ClientWithResponses) UpdateKubernetesNodesWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, reqEditors ...RequestEditorFn) (*UpdateKubernetesNodesResponse, error) {
	rsp, err := c.UpdateKubernetesNodes(ctx, spaceId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateKubernetesNodesResponse(rsp)
}

// AddKubernetesWorkersWithBodyWithResponse request with arbitrary body returning *AddKubernetesWorkersResponse
func (c *ClientWithResponses) AddKubernetesWorkersWithBodyWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddKubernetesWorkersResponse, error) {
	rsp, err := c.AddKubernetesWorkersWithBody(ctx, spaceId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddKubernetesWorkersResponse(rsp)
}

func (c *ClientWithResponses) AddKubernetesWorkersWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, body AddKubernetesWorkersJSONRequestBody, reqEditors ...RequestEditorFn) (*AddKubernetesWorkersResponse, error) {
	rsp, err := c.AddKubernetesWorkers(ctx, spaceId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddKubernetesWorkersResponse(rsp)
}

// RemoveKubernetesWorkerWithBodyWithResponse request with arbitrary body returning *RemoveKubernetesWorkerResponse
func (c *ClientWithResponses) RemoveKubernetesWorkerWithBodyWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveKubernetesWorkerResponse, error) {
	rsp, err := c.RemoveKubernetesWorkerWithBody(ctx, spaceId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveKubernetesWorkerResponse(rsp)
}

func (c *ClientWithResponses) RemoveKubernetesWorkerWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, body RemoveKubernetesWorkerJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveKubernetesWorkerResponse, error) {
	rsp, err := c.RemoveKubernetesWorker(ctx, spaceId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveKubernetesWorkerResponse(rsp)
}

// UpgradeKubernetesWorkersWithBodyWithResponse request with arbitrary body returning *UpgradeKubernetesWorkersResponse
func (c *ClientWithResponses) UpgradeKubernetesWorkersWithBodyWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpgradeKubernetesWorkersResponse, error) {
	rsp, err := c.UpgradeKubernetesWorkersWithBody(ctx, spaceId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpgradeKubernetesWorkersResponse(rsp)
}

func (c *ClientWithResponses) UpgradeKubernetesWorkersWithResponse(ctx context.Context, spaceId SpaceId, clusterId KubernetesClusterId, body UpgradeKubernetesWorkersJSONRequestBody, reqEditors ...RequestEditorFn) (*UpgradeKubernetesWorkersResponse, error) {
	rsp, err := c.UpgradeKubernetesWorkers(ctx, spaceId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpgradeKubernetesWorkersResponse(rsp)
}

// GetKubernetesOperationWithResponse request returning *GetKubernetesOperationResponse
func (c *ClientWithResponses) GetKubernetesOperationWithResponse(ctx context.Context, spaceId SpaceId, operationId OperationId, params *GetKubernetesOperationParams, reqEditors ...RequestEditorFn) (*GetKubernetesOperationResponse, error) {
	rsp, err := c.GetKubernetesOperation(ctx, spaceId, operationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKubernetesOperationResponse(rsp)
}

// ListKubernetesSupportedVersionsWithResponse request returning *ListKubernetesSupportedVersionsResponse
func (c *ClientWithResponses) ListKubernetesSupportedVersionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListKubernetesSupportedVersionsResponse, error) {
	rsp, err := c.ListKubernetesSupportedVersions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListKubernetesSupportedVersionsResponse(rsp)
}

// ListClustersWithResponse request returning *ListClustersResponse
func (c *ClientWithResponses) ListClustersWithResponse(ctx context.Context, spaceId SpaceId, params *ListClustersParams, reqEditors ...RequestEditorFn) (*ListClustersResponse, error) {
	rsp, err := c.ListClusters(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListClustersResponse(rsp)
}

// CreateClusterWithBodyWithResponse request with arbitrary body returning *CreateClusterResponse
func (c *ClientWithResponses) CreateClusterWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error) {
	rsp, err := c.CreateClusterWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClusterResponse(rsp)
}

func (c *ClientWithResponses) CreateClusterWithResponse(ctx context.Context, spaceId SpaceId, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error) {
	rsp, err := c.CreateCluster(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClusterResponse(rsp)
}

// DeleteClusterWithResponse request returning *DeleteClusterResponse
func (c *ClientWithResponses) DeleteClusterWithResponse(ctx context.Context, spaceId SpaceId, clusterId OpenShiftClusterId, reqEditors ...RequestEditorFn) (*DeleteClusterResponse, error) {
	rsp, err := c.DeleteCluster(ctx, spaceId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClusterResponse(rsp)
}

// GetClusterWithResponse request returning *GetClusterResponse
func (c *ClientWithResponses) GetClusterWithResponse(ctx context.Context, spaceId SpaceId, clusterId OpenShiftClusterId, reqEditors ...RequestEditorFn) (*GetClusterResponse, error) {
	rsp, err := c.GetCluster(ctx, spaceId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterResponse(rsp)
}

// UpdateClusterWithBodyWithResponse request with arbitrary body returning *UpdateClusterResponse
func (c *ClientWithResponses) UpdateClusterWithBodyWithResponse(ctx context.Context, spaceId SpaceId, clusterId OpenShiftClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error) {
	rsp, err := c.UpdateClusterWithBody(ctx, spaceId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClusterResponse(rsp)
}

func (c *ClientWithResponses) UpdateClusterWithResponse(ctx context.Context, spaceId SpaceId, clusterId OpenShiftClusterId, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error) {
	rsp, err := c.UpdateCluster(ctx, spaceId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClusterResponse(rsp)
}

// ListNodepoolsWithResponse request returning *ListNodepoolsResponse
func (c *ClientWithResponses) ListNodepoolsWithResponse(ctx context.Context, spaceId SpaceId, clusterId OpenShiftClusterId, reqEditors ...RequestEditorFn) (*ListNodepoolsResponse, error) {
	rsp, err := c.ListNodepools(ctx, spaceId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListNodepoolsResponse(rsp)
}

// CreateNodePoolWithBodyWithResponse request with arbitrary body returning *CreateNodePoolResponse
func (c *ClientWithResponses) CreateNodePoolWithBodyWithResponse(ctx context.Context, spaceId SpaceId, clusterId OpenShiftClusterId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNodePoolResponse, error) {
	rsp, err := c.CreateNodePoolWithBody(ctx, spaceId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNodePoolResponse(rsp)
}

func (c *ClientWithResponses) CreateNodePoolWithResponse(ctx context.Context, spaceId SpaceId, clusterId OpenShiftClusterId, body CreateNodePoolJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNodePoolResponse, error) {
	rsp, err := c.CreateNodePool(ctx, spaceId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNodePoolResponse(rsp)
}

// DeleteNodePoolWithResponse request returning *DeleteNodePoolResponse
func (c *ClientWithResponses) DeleteNodePoolWithResponse(ctx context.Context, spaceId SpaceId, clusterId OpenShiftClusterId, nodePoolName OpenShiftNodepoolName, reqEditors ...RequestEditorFn) (*DeleteNodePoolResponse, error) {
	rsp, err := c.DeleteNodePool(ctx, spaceId, clusterId, nodePoolName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNodePoolResponse(rsp)
}

// UpdateNodepoolWithBodyWithResponse request with arbitrary body returning *UpdateNodepoolResponse
func (c *ClientWithResponses) UpdateNodepoolWithBodyWithResponse(ctx context.Context, spaceId SpaceId, clusterId OpenShiftClusterId, nodePoolName OpenShiftNodepoolName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNodepoolResponse, error) {
	rsp, err := c.UpdateNodepoolWithBody(ctx, spaceId, clusterId, nodePoolName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNodepoolResponse(rsp)
}

func (c *ClientWithResponses) UpdateNodepoolWithResponse(ctx context.Context, spaceId SpaceId, clusterId OpenShiftClusterId, nodePoolName OpenShiftNodepoolName, body UpdateNodepoolJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNodepoolResponse, error) {
	rsp, err := c.UpdateNodepool(ctx, spaceId, clusterId, nodePoolName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNodepoolResponse(rsp)
}

// ListOperationsWithResponse request returning *ListOperationsResponse
func (c *ClientWithResponses) ListOperationsWithResponse(ctx context.Context, spaceId SpaceId, params *ListOperationsParams, reqEditors ...RequestEditorFn) (*ListOperationsResponse, error) {
	rsp, err := c.ListOperations(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListOperationsResponse(rsp)
}

// GetOperationWithResponse request returning *GetOperationResponse
func (c *ClientWithResponses) GetOperationWithResponse(ctx context.Context, spaceId SpaceId, operationId OperationId, reqEditors ...RequestEditorFn) (*GetOperationResponse, error) {
	rsp, err := c.GetOperation(ctx, spaceId, operationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOperationResponse(rsp)
}

// ListVersionsWithResponse request returning *ListVersionsResponse
func (c *ClientWithResponses) ListVersionsWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*ListVersionsResponse, error) {
	rsp, err := c.ListVersions(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVersionsResponse(rsp)
}

// ListSpacesWithResponse request returning *ListSpacesResponse
func (c *ClientWithResponses) ListSpacesWithResponse(ctx context.Context, organisationId OrganisationId, params *ListSpacesParams, reqEditors ...RequestEditorFn) (*ListSpacesResponse, error) {
	rsp, err := c.ListSpaces(ctx, organisationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSpacesResponse(rsp)
}

// CreateSpaceWithBodyWithResponse request with arbitrary body returning *CreateSpaceResponse
func (c *ClientWithResponses) CreateSpaceWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpaceResponse, error) {
	rsp, err := c.CreateSpaceWithBody(ctx, organisationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpaceResponse(rsp)
}

func (c *ClientWithResponses) CreateSpaceWithResponse(ctx context.Context, organisationId OrganisationId, body CreateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpaceResponse, error) {
	rsp, err := c.CreateSpace(ctx, organisationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpaceResponse(rsp)
}

// DeleteSpaceWithResponse request returning *DeleteSpaceResponse
func (c *ClientWithResponses) DeleteSpaceWithResponse(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, reqEditors ...RequestEditorFn) (*DeleteSpaceResponse, error) {
	rsp, err := c.DeleteSpace(ctx, organisationId, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSpaceResponse(rsp)
}

// GetSpaceByIdWithResponse request returning *GetSpaceByIdResponse
func (c *ClientWithResponses) GetSpaceByIdWithResponse(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, reqEditors ...RequestEditorFn) (*GetSpaceByIdResponse, error) {
	rsp, err := c.GetSpaceById(ctx, organisationId, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpaceByIdResponse(rsp)
}

// UpdateSpaceWithBodyWithResponse request with arbitrary body returning *UpdateSpaceResponse
func (c *ClientWithResponses) UpdateSpaceWithBodyWithResponse(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSpaceResponse, error) {
	rsp, err := c.UpdateSpaceWithBody(ctx, organisationId, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSpaceResponse(rsp)
}

func (c *ClientWithResponses) UpdateSpaceWithResponse(ctx context.Context, organisationId OrganisationId, spaceId SpaceId, body UpdateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSpaceResponse, error) {
	rsp, err := c.UpdateSpace(ctx, organisationId, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSpaceResponse(rsp)
}

// PostgreSQLGetAvailableClusterConfigurationsWithResponse request returning *PostgreSQLGetAvailableClusterConfigurationsResponse
func (c *ClientWithResponses) PostgreSQLGetAvailableClusterConfigurationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostgreSQLGetAvailableClusterConfigurationsResponse, error) {
	rsp, err := c.PostgreSQLGetAvailableClusterConfigurations(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostgreSQLGetAvailableClusterConfigurationsResponse(rsp)
}

// PostgreSQLGetClusterAutomaticBackupInformationWithResponse request returning *PostgreSQLGetClusterAutomaticBackupInformationResponse
func (c *ClientWithResponses) PostgreSQLGetClusterAutomaticBackupInformationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostgreSQLGetClusterAutomaticBackupInformationResponse, error) {
	rsp, err := c.PostgreSQLGetClusterAutomaticBackupInformation(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostgreSQLGetClusterAutomaticBackupInformationResponse(rsp)
}

// PostgreSQLListBackupsWithResponse request returning *PostgreSQLListBackupsResponse
func (c *ClientWithResponses) PostgreSQLListBackupsWithResponse(ctx context.Context, spaceId SpaceId, params *PostgreSQLListBackupsParams, reqEditors ...RequestEditorFn) (*PostgreSQLListBackupsResponse, error) {
	rsp, err := c.PostgreSQLListBackups(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostgreSQLListBackupsResponse(rsp)
}

// PostgreSQLDeleteBackupWithResponse request returning *PostgreSQLDeleteBackupResponse
func (c *ClientWithResponses) PostgreSQLDeleteBackupWithResponse(ctx context.Context, spaceId SpaceId, backupId PostgresBackupIdParameter, reqEditors ...RequestEditorFn) (*PostgreSQLDeleteBackupResponse, error) {
	rsp, err := c.PostgreSQLDeleteBackup(ctx, spaceId, backupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostgreSQLDeleteBackupResponse(rsp)
}

// PostgreSQLListClustersWithResponse request returning *PostgreSQLListClustersResponse
func (c *ClientWithResponses) PostgreSQLListClustersWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*PostgreSQLListClustersResponse, error) {
	rsp, err := c.PostgreSQLListClusters(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostgreSQLListClustersResponse(rsp)
}

// PostgreSQLCreateClusterWithBodyWithResponse request with arbitrary body returning *PostgreSQLCreateClusterResponse
func (c *ClientWithResponses) PostgreSQLCreateClusterWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostgreSQLCreateClusterResponse, error) {
	rsp, err := c.PostgreSQLCreateClusterWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostgreSQLCreateClusterResponse(rsp)
}

func (c *ClientWithResponses) PostgreSQLCreateClusterWithResponse(ctx context.Context, spaceId SpaceId, body PostgreSQLCreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*PostgreSQLCreateClusterResponse, error) {
	rsp, err := c.PostgreSQLCreateCluster(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostgreSQLCreateClusterResponse(rsp)
}

// PostgreSQLDeleteClusterWithBodyWithResponse request with arbitrary body returning *PostgreSQLDeleteClusterResponse
func (c *ClientWithResponses) PostgreSQLDeleteClusterWithBodyWithResponse(ctx context.Context, spaceId SpaceId, clusterId PostgresClusterIdParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostgreSQLDeleteClusterResponse, error) {
	rsp, err := c.PostgreSQLDeleteClusterWithBody(ctx, spaceId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostgreSQLDeleteClusterResponse(rsp)
}

func (c *ClientWithResponses) PostgreSQLDeleteClusterWithResponse(ctx context.Context, spaceId SpaceId, clusterId PostgresClusterIdParameter, body PostgreSQLDeleteClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*PostgreSQLDeleteClusterResponse, error) {
	rsp, err := c.PostgreSQLDeleteCluster(ctx, spaceId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostgreSQLDeleteClusterResponse(rsp)
}

// PostgreSQLGetClusterWithResponse request returning *PostgreSQLGetClusterResponse
func (c *ClientWithResponses) PostgreSQLGetClusterWithResponse(ctx context.Context, spaceId SpaceId, clusterId PostgresClusterIdParameter, reqEditors ...RequestEditorFn) (*PostgreSQLGetClusterResponse, error) {
	rsp, err := c.PostgreSQLGetCluster(ctx, spaceId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostgreSQLGetClusterResponse(rsp)
}

// PostgreSQLModifyClusterWithBodyWithResponse request with arbitrary body returning *PostgreSQLModifyClusterResponse
func (c *ClientWithResponses) PostgreSQLModifyClusterWithBodyWithResponse(ctx context.Context, spaceId SpaceId, clusterId PostgresClusterIdParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostgreSQLModifyClusterResponse, error) {
	rsp, err := c.PostgreSQLModifyClusterWithBody(ctx, spaceId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostgreSQLModifyClusterResponse(rsp)
}

func (c *ClientWithResponses) PostgreSQLModifyClusterWithResponse(ctx context.Context, spaceId SpaceId, clusterId PostgresClusterIdParameter, body PostgreSQLModifyClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*PostgreSQLModifyClusterResponse, error) {
	rsp, err := c.PostgreSQLModifyCluster(ctx, spaceId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostgreSQLModifyClusterResponse(rsp)
}

// PostgreSQLListClusterBackupsWithResponse request returning *PostgreSQLListClusterBackupsResponse
func (c *ClientWithResponses) PostgreSQLListClusterBackupsWithResponse(ctx context.Context, spaceId SpaceId, clusterId PostgresClusterIdParameter, reqEditors ...RequestEditorFn) (*PostgreSQLListClusterBackupsResponse, error) {
	rsp, err := c.PostgreSQLListClusterBackups(ctx, spaceId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostgreSQLListClusterBackupsResponse(rsp)
}

// OldPostgreSQLResetClusterAdministrationPasswordWithResponse request returning *OldPostgreSQLResetClusterAdministrationPasswordResponse
func (c *ClientWithResponses) OldPostgreSQLResetClusterAdministrationPasswordWithResponse(ctx context.Context, spaceId SpaceId, clusterId PostgresClusterIdParameter, reqEditors ...RequestEditorFn) (*OldPostgreSQLResetClusterAdministrationPasswordResponse, error) {
	rsp, err := c.OldPostgreSQLResetClusterAdministrationPassword(ctx, spaceId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOldPostgreSQLResetClusterAdministrationPasswordResponse(rsp)
}

// PostgreSQLResetClusterAdministrationPasswordWithResponse request returning *PostgreSQLResetClusterAdministrationPasswordResponse
func (c *ClientWithResponses) PostgreSQLResetClusterAdministrationPasswordWithResponse(ctx context.Context, spaceId SpaceId, clusterId PostgresClusterIdParameter, reqEditors ...RequestEditorFn) (*PostgreSQLResetClusterAdministrationPasswordResponse, error) {
	rsp, err := c.PostgreSQLResetClusterAdministrationPassword(ctx, spaceId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostgreSQLResetClusterAdministrationPasswordResponse(rsp)
}

// ParseDeleteLoadBalancerTagsResponse parses an HTTP response from a DeleteLoadBalancerTagsWithResponse call
func ParseDeleteLoadBalancerTagsResponse(rsp *http.Response) (*DeleteLoadBalancerTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLoadBalancerTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateLoadBalancerTagsResponse parses an HTTP response from a CreateLoadBalancerTagsWithResponse call
func ParseCreateLoadBalancerTagsResponse(rsp *http.Response) (*CreateLoadBalancerTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLoadBalancerTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteTagsResponse parses an HTTP response from a DeleteTagsWithResponse call
func ParseDeleteTagsResponse(rsp *http.Response) (*DeleteTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateTagsResponse parses an HTTP response from a CreateTagsWithResponse call
func ParseCreateTagsResponse(rsp *http.Response) (*CreateTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadDhcpOptionsResponse parses an HTTP response from a ReadDhcpOptionsWithResponse call
func ParseReadDhcpOptionsResponse(rsp *http.Response) (*ReadDhcpOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadDhcpOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadDhcpOptions200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateDhcpOptionsResponse parses an HTTP response from a CreateDhcpOptionsWithResponse call
func ParseCreateDhcpOptionsResponse(rsp *http.Response) (*CreateDhcpOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDhcpOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateDhcpOptions201Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteDhcpOptionsResponse parses an HTTP response from a DeleteDhcpOptionsWithResponse call
func ParseDeleteDhcpOptionsResponse(rsp *http.Response) (*DeleteDhcpOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDhcpOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadDhcpOptionsByIdResponse parses an HTTP response from a ReadDhcpOptionsByIdWithResponse call
func ParseReadDhcpOptionsByIdResponse(rsp *http.Response) (*ReadDhcpOptionsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadDhcpOptionsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadDhcpOptionsById200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadFlexibleGpusResponse parses an HTTP response from a ReadFlexibleGpusWithResponse call
func ParseReadFlexibleGpusResponse(rsp *http.Response) (*ReadFlexibleGpusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadFlexibleGpusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadFlexibleGpus200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateFlexibleGpuResponse parses an HTTP response from a CreateFlexibleGpuWithResponse call
func ParseCreateFlexibleGpuResponse(rsp *http.Response) (*CreateFlexibleGpuResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFlexibleGpuResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateFlexibleGpu201Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteFlexibleGpuResponse parses an HTTP response from a DeleteFlexibleGpuWithResponse call
func ParseDeleteFlexibleGpuResponse(rsp *http.Response) (*DeleteFlexibleGpuResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFlexibleGpuResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadFlexibleGpusByIdResponse parses an HTTP response from a ReadFlexibleGpusByIdWithResponse call
func ParseReadFlexibleGpusByIdResponse(rsp *http.Response) (*ReadFlexibleGpusByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadFlexibleGpusByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadFlexibleGpusById200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateFlexibleGpuResponse parses an HTTP response from a UpdateFlexibleGpuWithResponse call
func ParseUpdateFlexibleGpuResponse(rsp *http.Response) (*UpdateFlexibleGpuResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateFlexibleGpuResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateFlexibleGpu200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseLinkFlexibleGpuResponse parses an HTTP response from a LinkFlexibleGpuWithResponse call
func ParseLinkFlexibleGpuResponse(rsp *http.Response) (*LinkFlexibleGpuResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkFlexibleGpuResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnlinkFlexibleGpuResponse parses an HTTP response from a UnlinkFlexibleGpuWithResponse call
func ParseUnlinkFlexibleGpuResponse(rsp *http.Response) (*UnlinkFlexibleGpuResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkFlexibleGpuResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadImagesResponse parses an HTTP response from a ReadImagesWithResponse call
func ParseReadImagesResponse(rsp *http.Response) (*ReadImagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadImagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadImages200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateImageResponse parses an HTTP response from a CreateImageWithResponse call
func ParseCreateImageResponse(rsp *http.Response) (*CreateImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateImage201Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteImageResponse parses an HTTP response from a DeleteImageWithResponse call
func ParseDeleteImageResponse(rsp *http.Response) (*DeleteImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadImagesByIdResponse parses an HTTP response from a ReadImagesByIdWithResponse call
func ParseReadImagesByIdResponse(rsp *http.Response) (*ReadImagesByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadImagesByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadImagesById200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateImageResponse parses an HTTP response from a UpdateImageWithResponse call
func ParseUpdateImageResponse(rsp *http.Response) (*UpdateImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateImage200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadInternetGatewaysResponse parses an HTTP response from a ReadInternetGatewaysWithResponse call
func ParseReadInternetGatewaysResponse(rsp *http.Response) (*ReadInternetGatewaysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadInternetGatewaysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadInternetGateways200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateInternetGatewayResponse parses an HTTP response from a CreateInternetGatewayWithResponse call
func ParseCreateInternetGatewayResponse(rsp *http.Response) (*CreateInternetGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateInternetGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateInternetGateway201Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteInternetGatewayResponse parses an HTTP response from a DeleteInternetGatewayWithResponse call
func ParseDeleteInternetGatewayResponse(rsp *http.Response) (*DeleteInternetGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteInternetGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadInternetGatewaysByIdResponse parses an HTTP response from a ReadInternetGatewaysByIdWithResponse call
func ParseReadInternetGatewaysByIdResponse(rsp *http.Response) (*ReadInternetGatewaysByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadInternetGatewaysByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadInternetGatewaysById200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseLinkInternetGatewayResponse parses an HTTP response from a LinkInternetGatewayWithResponse call
func ParseLinkInternetGatewayResponse(rsp *http.Response) (*LinkInternetGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkInternetGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnlinkInternetGatewayResponse parses an HTTP response from a UnlinkInternetGatewayWithResponse call
func ParseUnlinkInternetGatewayResponse(rsp *http.Response) (*UnlinkInternetGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkInternetGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadKeypairsResponse parses an HTTP response from a ReadKeypairsWithResponse call
func ParseReadKeypairsResponse(rsp *http.Response) (*ReadKeypairsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadKeypairsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadKeypairs200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateKeypairResponse parses an HTTP response from a CreateKeypairWithResponse call
func ParseCreateKeypairResponse(rsp *http.Response) (*CreateKeypairResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateKeypairResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateKeypair201Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteKeypairResponse parses an HTTP response from a DeleteKeypairWithResponse call
func ParseDeleteKeypairResponse(rsp *http.Response) (*DeleteKeypairResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteKeypairResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadKeypairsByIdResponse parses an HTTP response from a ReadKeypairsByIdWithResponse call
func ParseReadKeypairsByIdResponse(rsp *http.Response) (*ReadKeypairsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadKeypairsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadKeypairsById200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadListenerRulesResponse parses an HTTP response from a ReadListenerRulesWithResponse call
func ParseReadListenerRulesResponse(rsp *http.Response) (*ReadListenerRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadListenerRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadListenerRules200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateListenerRuleResponse parses an HTTP response from a CreateListenerRuleWithResponse call
func ParseCreateListenerRuleResponse(rsp *http.Response) (*CreateListenerRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateListenerRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateListenerRule201Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteListenerRuleResponse parses an HTTP response from a DeleteListenerRuleWithResponse call
func ParseDeleteListenerRuleResponse(rsp *http.Response) (*DeleteListenerRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteListenerRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadListenerRulesByIdResponse parses an HTTP response from a ReadListenerRulesByIdWithResponse call
func ParseReadListenerRulesByIdResponse(rsp *http.Response) (*ReadListenerRulesByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadListenerRulesByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadListenerRulesById200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateListenerRuleResponse parses an HTTP response from a UpdateListenerRuleWithResponse call
func ParseUpdateListenerRuleResponse(rsp *http.Response) (*UpdateListenerRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateListenerRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateListenerRule200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadLoadBalancersResponse parses an HTTP response from a ReadLoadBalancersWithResponse call
func ParseReadLoadBalancersResponse(rsp *http.Response) (*ReadLoadBalancersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadLoadBalancersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadLoadBalancers200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateLoadBalancerResponse parses an HTTP response from a CreateLoadBalancerWithResponse call
func ParseCreateLoadBalancerResponse(rsp *http.Response) (*CreateLoadBalancerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLoadBalancerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateLoadBalancer201Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteLoadBalancerResponse parses an HTTP response from a DeleteLoadBalancerWithResponse call
func ParseDeleteLoadBalancerResponse(rsp *http.Response) (*DeleteLoadBalancerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLoadBalancerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadLoadBalancersByIdResponse parses an HTTP response from a ReadLoadBalancersByIdWithResponse call
func ParseReadLoadBalancersByIdResponse(rsp *http.Response) (*ReadLoadBalancersByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadLoadBalancersByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadLoadBalancersById200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateLoadBalancerResponse parses an HTTP response from a UpdateLoadBalancerWithResponse call
func ParseUpdateLoadBalancerResponse(rsp *http.Response) (*UpdateLoadBalancerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateLoadBalancerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateLoadBalancer200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseLinkLoadBalancerBackendMachinesResponse parses an HTTP response from a LinkLoadBalancerBackendMachinesWithResponse call
func ParseLinkLoadBalancerBackendMachinesResponse(rsp *http.Response) (*LinkLoadBalancerBackendMachinesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkLoadBalancerBackendMachinesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnlinkLoadBalancerBackendMachinesResponse parses an HTTP response from a UnlinkLoadBalancerBackendMachinesWithResponse call
func ParseUnlinkLoadBalancerBackendMachinesResponse(rsp *http.Response) (*UnlinkLoadBalancerBackendMachinesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkLoadBalancerBackendMachinesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteLoadBalancerListenersResponse parses an HTTP response from a DeleteLoadBalancerListenersWithResponse call
func ParseDeleteLoadBalancerListenersResponse(rsp *http.Response) (*DeleteLoadBalancerListenersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLoadBalancerListenersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateLoadBalancerListenersResponse parses an HTTP response from a CreateLoadBalancerListenersWithResponse call
func ParseCreateLoadBalancerListenersResponse(rsp *http.Response) (*CreateLoadBalancerListenersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLoadBalancerListenersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateLoadBalancerListeners201Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteLoadBalancerPolicyResponse parses an HTTP response from a DeleteLoadBalancerPolicyWithResponse call
func ParseDeleteLoadBalancerPolicyResponse(rsp *http.Response) (*DeleteLoadBalancerPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLoadBalancerPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateLoadBalancerPolicyResponse parses an HTTP response from a CreateLoadBalancerPolicyWithResponse call
func ParseCreateLoadBalancerPolicyResponse(rsp *http.Response) (*CreateLoadBalancerPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLoadBalancerPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateLoadBalancerPolicy201Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadVmsHealthResponse parses an HTTP response from a ReadVmsHealthWithResponse call
func ParseReadVmsHealthResponse(rsp *http.Response) (*ReadVmsHealthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVmsHealthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVmsHealth200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadLoadBalancerTagsResponse parses an HTTP response from a ReadLoadBalancerTagsWithResponse call
func ParseReadLoadBalancerTagsResponse(rsp *http.Response) (*ReadLoadBalancerTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadLoadBalancerTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadLoadBalancerTags200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadNatGatewayResponse parses an HTTP response from a ReadNatGatewayWithResponse call
func ParseReadNatGatewayResponse(rsp *http.Response) (*ReadNatGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadNatGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadNatGateway200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateNatGatewayResponse parses an HTTP response from a CreateNatGatewayWithResponse call
func ParseCreateNatGatewayResponse(rsp *http.Response) (*CreateNatGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNatGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateNatGateway201Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteNatGatewayResponse parses an HTTP response from a DeleteNatGatewayWithResponse call
func ParseDeleteNatGatewayResponse(rsp *http.Response) (*DeleteNatGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNatGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadNatGatewayByIdResponse parses an HTTP response from a ReadNatGatewayByIdWithResponse call
func ParseReadNatGatewayByIdResponse(rsp *http.Response) (*ReadNatGatewayByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadNatGatewayByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadNatGatewayById200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadNicsResponse parses an HTTP response from a ReadNicsWithResponse call
func ParseReadNicsResponse(rsp *http.Response) (*ReadNicsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadNicsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadNics200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateNicResponse parses an HTTP response from a CreateNicWithResponse call
func ParseCreateNicResponse(rsp *http.Response) (*CreateNicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateNic201Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteNicResponse parses an HTTP response from a DeleteNicWithResponse call
func ParseDeleteNicResponse(rsp *http.Response) (*DeleteNicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadNicsByIdResponse parses an HTTP response from a ReadNicsByIdWithResponse call
func ParseReadNicsByIdResponse(rsp *http.Response) (*ReadNicsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadNicsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadNicsById200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateNicResponse parses an HTTP response from a UpdateNicWithResponse call
func ParseUpdateNicResponse(rsp *http.Response) (*UpdateNicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateNicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateNic200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseLinkPrivateIpsResponse parses an HTTP response from a LinkPrivateIpsWithResponse call
func ParseLinkPrivateIpsResponse(rsp *http.Response) (*LinkPrivateIpsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkPrivateIpsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnlinkPrivateIpsResponse parses an HTTP response from a UnlinkPrivateIpsWithResponse call
func ParseUnlinkPrivateIpsResponse(rsp *http.Response) (*UnlinkPrivateIpsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkPrivateIpsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseLinkNicResponse parses an HTTP response from a LinkNicWithResponse call
func ParseLinkNicResponse(rsp *http.Response) (*LinkNicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkNicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinkNic200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnlinkNicResponse parses an HTTP response from a UnlinkNicWithResponse call
func ParseUnlinkNicResponse(rsp *http.Response) (*UnlinkNicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkNicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadPublicIpsResponse parses an HTTP response from a ReadPublicIpsWithResponse call
func ParseReadPublicIpsResponse(rsp *http.Response) (*ReadPublicIpsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadPublicIpsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadPublicIps200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreatePublicIpResponse parses an HTTP response from a CreatePublicIpWithResponse call
func ParseCreatePublicIpResponse(rsp *http.Response) (*CreatePublicIpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePublicIpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreatePublicIp201Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeletePublicIpResponse parses an HTTP response from a DeletePublicIpWithResponse call
func ParseDeletePublicIpResponse(rsp *http.Response) (*DeletePublicIpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePublicIpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadPublicIpsByIdResponse parses an HTTP response from a ReadPublicIpsByIdWithResponse call
func ParseReadPublicIpsByIdResponse(rsp *http.Response) (*ReadPublicIpsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadPublicIpsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadPublicIpsById200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseLinkPublicIpResponse parses an HTTP response from a LinkPublicIpWithResponse call
func ParseLinkPublicIpResponse(rsp *http.Response) (*LinkPublicIpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkPublicIpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinkPublicIp200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnlinkPublicIpResponse parses an HTTP response from a UnlinkPublicIpWithResponse call
func ParseUnlinkPublicIpResponse(rsp *http.Response) (*UnlinkPublicIpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkPublicIpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadRouteTablesResponse parses an HTTP response from a ReadRouteTablesWithResponse call
func ParseReadRouteTablesResponse(rsp *http.Response) (*ReadRouteTablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadRouteTablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadRouteTables200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateRouteTableResponse parses an HTTP response from a CreateRouteTableWithResponse call
func ParseCreateRouteTableResponse(rsp *http.Response) (*CreateRouteTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRouteTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateRouteTable201Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteRouteTableResponse parses an HTTP response from a DeleteRouteTableWithResponse call
func ParseDeleteRouteTableResponse(rsp *http.Response) (*DeleteRouteTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRouteTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadRouteTablesByIdResponse parses an HTTP response from a ReadRouteTablesByIdWithResponse call
func ParseReadRouteTablesByIdResponse(rsp *http.Response) (*ReadRouteTablesByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadRouteTablesByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadRouteTablesById200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateRouteTableRoutePropagationResponse parses an HTTP response from a UpdateRouteTableRoutePropagationWithResponse call
func ParseUpdateRouteTableRoutePropagationResponse(rsp *http.Response) (*UpdateRouteTableRoutePropagationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRouteTableRoutePropagationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateRouteTableRoutePropagation200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteRouteResponse parses an HTTP response from a DeleteRouteWithResponse call
func ParseDeleteRouteResponse(rsp *http.Response) (*DeleteRouteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRouteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateRouteResponse parses an HTTP response from a CreateRouteWithResponse call
func ParseCreateRouteResponse(rsp *http.Response) (*CreateRouteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRouteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateRoute201Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateRouteResponse parses an HTTP response from a UpdateRouteWithResponse call
func ParseUpdateRouteResponse(rsp *http.Response) (*UpdateRouteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRouteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateRoute200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseLinkRouteTableResponse parses an HTTP response from a LinkRouteTableWithResponse call
func ParseLinkRouteTableResponse(rsp *http.Response) (*LinkRouteTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkRouteTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinkRouteTable200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnlinkRouteTableResponse parses an HTTP response from a UnlinkRouteTableWithResponse call
func ParseUnlinkRouteTableResponse(rsp *http.Response) (*UnlinkRouteTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkRouteTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadSecurityGroupsResponse parses an HTTP response from a ReadSecurityGroupsWithResponse call
func ParseReadSecurityGroupsResponse(rsp *http.Response) (*ReadSecurityGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadSecurityGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadSecurityGroups200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateSecurityGroupResponse parses an HTTP response from a CreateSecurityGroupWithResponse call
func ParseCreateSecurityGroupResponse(rsp *http.Response) (*CreateSecurityGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSecurityGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateSecurityGroup201Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSecurityGroupResponse parses an HTTP response from a DeleteSecurityGroupWithResponse call
func ParseDeleteSecurityGroupResponse(rsp *http.Response) (*DeleteSecurityGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSecurityGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadSecurityGroupsByIdResponse parses an HTTP response from a ReadSecurityGroupsByIdWithResponse call
func ParseReadSecurityGroupsByIdResponse(rsp *http.Response) (*ReadSecurityGroupsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadSecurityGroupsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadSecurityGroupsById200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSecurityGroupRuleResponse parses an HTTP response from a DeleteSecurityGroupRuleWithResponse call
func ParseDeleteSecurityGroupRuleResponse(rsp *http.Response) (*DeleteSecurityGroupRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSecurityGroupRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateSecurityGroupRuleResponse parses an HTTP response from a CreateSecurityGroupRuleWithResponse call
func ParseCreateSecurityGroupRuleResponse(rsp *http.Response) (*CreateSecurityGroupRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSecurityGroupRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateSecurityGroupRule201Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadServerCertificatesResponse parses an HTTP response from a ReadServerCertificatesWithResponse call
func ParseReadServerCertificatesResponse(rsp *http.Response) (*ReadServerCertificatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadServerCertificatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadServerCertificates200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateServerCertificateResponse parses an HTTP response from a CreateServerCertificateWithResponse call
func ParseCreateServerCertificateResponse(rsp *http.Response) (*CreateServerCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServerCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateServerCertificate201Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteServerCertificateResponse parses an HTTP response from a DeleteServerCertificateWithResponse call
func ParseDeleteServerCertificateResponse(rsp *http.Response) (*DeleteServerCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServerCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateServerCertificateResponse parses an HTTP response from a UpdateServerCertificateWithResponse call
func ParseUpdateServerCertificateResponse(rsp *http.Response) (*UpdateServerCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateServerCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest UpdateServerCertificate204Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadSnapshotsResponse parses an HTTP response from a ReadSnapshotsWithResponse call
func ParseReadSnapshotsResponse(rsp *http.Response) (*ReadSnapshotsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadSnapshotsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadSnapshots200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateSnapshotResponse parses an HTTP response from a CreateSnapshotWithResponse call
func ParseCreateSnapshotResponse(rsp *http.Response) (*CreateSnapshotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSnapshotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateSnapshot201Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSnapshotResponse parses an HTTP response from a DeleteSnapshotWithResponse call
func ParseDeleteSnapshotResponse(rsp *http.Response) (*DeleteSnapshotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSnapshotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadSnapshotsByIdResponse parses an HTTP response from a ReadSnapshotsByIdWithResponse call
func ParseReadSnapshotsByIdResponse(rsp *http.Response) (*ReadSnapshotsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadSnapshotsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadSnapshotsById200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadSubnetsResponse parses an HTTP response from a ReadSubnetsWithResponse call
func ParseReadSubnetsResponse(rsp *http.Response) (*ReadSubnetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadSubnetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadSubnets200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateSubnetResponse parses an HTTP response from a CreateSubnetWithResponse call
func ParseCreateSubnetResponse(rsp *http.Response) (*CreateSubnetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSubnetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateSubnet201Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSubnetResponse parses an HTTP response from a DeleteSubnetWithResponse call
func ParseDeleteSubnetResponse(rsp *http.Response) (*DeleteSubnetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSubnetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadSubnetsByIdResponse parses an HTTP response from a ReadSubnetsByIdWithResponse call
func ParseReadSubnetsByIdResponse(rsp *http.Response) (*ReadSubnetsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadSubnetsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadSubnetsById200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateSubnetResponse parses an HTTP response from a UpdateSubnetWithResponse call
func ParseUpdateSubnetResponse(rsp *http.Response) (*UpdateSubnetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSubnetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateSubnet200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadTagsResponse parses an HTTP response from a ReadTagsWithResponse call
func ParseReadTagsResponse(rsp *http.Response) (*ReadTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadTags200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadVmsResponse parses an HTTP response from a ReadVmsWithResponse call
func ParseReadVmsResponse(rsp *http.Response) (*ReadVmsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVmsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVms200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateVmsResponse parses an HTTP response from a CreateVmsWithResponse call
func ParseCreateVmsResponse(rsp *http.Response) (*CreateVmsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVmsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateVms201Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadVmsStateResponse parses an HTTP response from a ReadVmsStateWithResponse call
func ParseReadVmsStateResponse(rsp *http.Response) (*ReadVmsStateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVmsStateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVmsState200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteVmsResponse parses an HTTP response from a DeleteVmsWithResponse call
func ParseDeleteVmsResponse(rsp *http.Response) (*DeleteVmsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVmsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadVmsByIdResponse parses an HTTP response from a ReadVmsByIdWithResponse call
func ParseReadVmsByIdResponse(rsp *http.Response) (*ReadVmsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVmsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVmsById200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateVmResponse parses an HTTP response from a UpdateVmWithResponse call
func ParseUpdateVmResponse(rsp *http.Response) (*UpdateVmResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVmResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateVm200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadAdminPasswordResponse parses an HTTP response from a ReadAdminPasswordWithResponse call
func ParseReadAdminPasswordResponse(rsp *http.Response) (*ReadAdminPasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadAdminPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadAdminPassword200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadConsoleOutputResponse parses an HTTP response from a ReadConsoleOutputWithResponse call
func ParseReadConsoleOutputResponse(rsp *http.Response) (*ReadConsoleOutputResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadConsoleOutputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadConsoleOutput200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseRebootVmResponse parses an HTTP response from a RebootVmWithResponse call
func ParseRebootVmResponse(rsp *http.Response) (*RebootVmResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RebootVmResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseStartVmResponse parses an HTTP response from a StartVmWithResponse call
func ParseStartVmResponse(rsp *http.Response) (*StartVmResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartVmResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StartVm200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseStopVmResponse parses an HTTP response from a StopVmWithResponse call
func ParseStopVmResponse(rsp *http.Response) (*StopVmResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StopVmResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StopVm200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadVolumesResponse parses an HTTP response from a ReadVolumesWithResponse call
func ParseReadVolumesResponse(rsp *http.Response) (*ReadVolumesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVolumesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVolumes200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateVolumeResponse parses an HTTP response from a CreateVolumeWithResponse call
func ParseCreateVolumeResponse(rsp *http.Response) (*CreateVolumeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateVolume201Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteVolumeResponse parses an HTTP response from a DeleteVolumeWithResponse call
func ParseDeleteVolumeResponse(rsp *http.Response) (*DeleteVolumeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadVolumesByIdResponse parses an HTTP response from a ReadVolumesByIdWithResponse call
func ParseReadVolumesByIdResponse(rsp *http.Response) (*ReadVolumesByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVolumesByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVolumesById200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateVolumeResponse parses an HTTP response from a UpdateVolumeWithResponse call
func ParseUpdateVolumeResponse(rsp *http.Response) (*UpdateVolumeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateVolume200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseLinkVolumeResponse parses an HTTP response from a LinkVolumeWithResponse call
func ParseLinkVolumeResponse(rsp *http.Response) (*LinkVolumeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkVolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnlinkVolumeResponse parses an HTTP response from a UnlinkVolumeWithResponse call
func ParseUnlinkVolumeResponse(rsp *http.Response) (*UnlinkVolumeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkVolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadVpcsResponse parses an HTTP response from a ReadVpcsWithResponse call
func ParseReadVpcsResponse(rsp *http.Response) (*ReadVpcsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVpcsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVpcs200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateVpcResponse parses an HTTP response from a CreateVpcWithResponse call
func ParseCreateVpcResponse(rsp *http.Response) (*CreateVpcResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVpcResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateVpc201Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteVpcResponse parses an HTTP response from a DeleteVpcWithResponse call
func ParseDeleteVpcResponse(rsp *http.Response) (*DeleteVpcResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVpcResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadVpcsByIdResponse parses an HTTP response from a ReadVpcsByIdWithResponse call
func ParseReadVpcsByIdResponse(rsp *http.Response) (*ReadVpcsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVpcsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVpcsById200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateVpcResponse parses an HTTP response from a UpdateVpcWithResponse call
func ParseUpdateVpcResponse(rsp *http.Response) (*UpdateVpcResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVpcResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateVpc200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 414:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON414 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteClientGatewayResponse parses an HTTP response from a DeleteClientGatewayWithResponse call
func ParseDeleteClientGatewayResponse(rsp *http.Response) (*DeleteClientGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClientGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadClientGatewayResponse parses an HTTP response from a ReadClientGatewayWithResponse call
func ParseReadClientGatewayResponse(rsp *http.Response) (*ReadClientGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadClientGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadClientGateway200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListClientGatewaysResponse parses an HTTP response from a ListClientGatewaysWithResponse call
func ParseListClientGatewaysResponse(rsp *http.Response) (*ListClientGatewaysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListClientGatewaysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListClientGateways200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateClientGatewayResponse parses an HTTP response from a CreateClientGatewayWithResponse call
func ParseCreateClientGatewayResponse(rsp *http.Response) (*CreateClientGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateClientGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateClientGateway201Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListComputeBridgesResponse parses an HTTP response from a ListComputeBridgesWithResponse call
func ParseListComputeBridgesResponse(rsp *http.Response) (*ListComputeBridgesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListComputeBridgesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListComputeBridges200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateComputeBridgeResponse parses an HTTP response from a CreateComputeBridgeWithResponse call
func ParseCreateComputeBridgeResponse(rsp *http.Response) (*CreateComputeBridgeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateComputeBridgeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateComputeBridge201Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error409
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteComputeBridgeResponse parses an HTTP response from a DeleteComputeBridgeWithResponse call
func ParseDeleteComputeBridgeResponse(rsp *http.Response) (*DeleteComputeBridgeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteComputeBridgeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error409
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadComputeBridgeResponse parses an HTTP response from a ReadComputeBridgeWithResponse call
func ParseReadComputeBridgeResponse(rsp *http.Response) (*ReadComputeBridgeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadComputeBridgeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadComputeBridge200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListDirectLinkInterfacesResponse parses an HTTP response from a ListDirectLinkInterfacesWithResponse call
func ParseListDirectLinkInterfacesResponse(rsp *http.Response) (*ListDirectLinkInterfacesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDirectLinkInterfacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListDirectLinkInterfaces200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateDirectLinkInterfaceResponse parses an HTTP response from a CreateDirectLinkInterfaceWithResponse call
func ParseCreateDirectLinkInterfaceResponse(rsp *http.Response) (*CreateDirectLinkInterfaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDirectLinkInterfaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateDirectLinkInterface201Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteDirectLinkInterfaceResponse parses an HTTP response from a DeleteDirectLinkInterfaceWithResponse call
func ParseDeleteDirectLinkInterfaceResponse(rsp *http.Response) (*DeleteDirectLinkInterfaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDirectLinkInterfaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadDirectLinkInterfaceResponse parses an HTTP response from a ReadDirectLinkInterfaceWithResponse call
func ParseReadDirectLinkInterfaceResponse(rsp *http.Response) (*ReadDirectLinkInterfaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadDirectLinkInterfaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadDirectLinkInterface200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListDirectLinksResponse parses an HTTP response from a ListDirectLinksWithResponse call
func ParseListDirectLinksResponse(rsp *http.Response) (*ListDirectLinksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDirectLinksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListDirectLinks200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateDirectLinkResponse parses an HTTP response from a CreateDirectLinkWithResponse call
func ParseCreateDirectLinkResponse(rsp *http.Response) (*CreateDirectLinkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDirectLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateDirectLink201Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteDirectLinkResponse parses an HTTP response from a DeleteDirectLinkWithResponse call
func ParseDeleteDirectLinkResponse(rsp *http.Response) (*DeleteDirectLinkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDirectLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadDirectLinkResponse parses an HTTP response from a ReadDirectLinkWithResponse call
func ParseReadDirectLinkResponse(rsp *http.Response) (*ReadDirectLinkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadDirectLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadDirectLink200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListHybridBridgesResponse parses an HTTP response from a ListHybridBridgesWithResponse call
func ParseListHybridBridgesResponse(rsp *http.Response) (*ListHybridBridgesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListHybridBridgesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListHybridBridges200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateHybridBridgeResponse parses an HTTP response from a CreateHybridBridgeWithResponse call
func ParseCreateHybridBridgeResponse(rsp *http.Response) (*CreateHybridBridgeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHybridBridgeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateHybridBridge201Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error409
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteHybridBridgeResponse parses an HTTP response from a DeleteHybridBridgeWithResponse call
func ParseDeleteHybridBridgeResponse(rsp *http.Response) (*DeleteHybridBridgeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHybridBridgeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error409
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadHybridBridgeResponse parses an HTTP response from a ReadHybridBridgeWithResponse call
func ParseReadHybridBridgeResponse(rsp *http.Response) (*ReadHybridBridgeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadHybridBridgeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadHybridBridge200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListManagedServicesBridgesResponse parses an HTTP response from a ListManagedServicesBridgesWithResponse call
func ParseListManagedServicesBridgesResponse(rsp *http.Response) (*ListManagedServicesBridgesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListManagedServicesBridgesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListManagedServicesBridges200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateManagedServicesBridgeResponse parses an HTTP response from a CreateManagedServicesBridgeWithResponse call
func ParseCreateManagedServicesBridgeResponse(rsp *http.Response) (*CreateManagedServicesBridgeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateManagedServicesBridgeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateManagedServicesBridge201Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error409
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteManagedServicesBridgeResponse parses an HTTP response from a DeleteManagedServicesBridgeWithResponse call
func ParseDeleteManagedServicesBridgeResponse(rsp *http.Response) (*DeleteManagedServicesBridgeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteManagedServicesBridgeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error409
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadManagedServicesBridgeResponse parses an HTTP response from a ReadManagedServicesBridgeWithResponse call
func ParseReadManagedServicesBridgeResponse(rsp *http.Response) (*ReadManagedServicesBridgeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadManagedServicesBridgeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadManagedServicesBridge200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadLocationsResponse parses an HTTP response from a ReadLocationsWithResponse call
func ParseReadLocationsResponse(rsp *http.Response) (*ReadLocationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadLocationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadLocations200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteVirtualGatewayResponse parses an HTTP response from a DeleteVirtualGatewayWithResponse call
func ParseDeleteVirtualGatewayResponse(rsp *http.Response) (*DeleteVirtualGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVirtualGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadVirtualGatewayResponse parses an HTTP response from a ReadVirtualGatewayWithResponse call
func ParseReadVirtualGatewayResponse(rsp *http.Response) (*ReadVirtualGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVirtualGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVirtualGateway200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnlinkVirtualGatewayResponse parses an HTTP response from a UnlinkVirtualGatewayWithResponse call
func ParseUnlinkVirtualGatewayResponse(rsp *http.Response) (*UnlinkVirtualGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkVirtualGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseLinkVirtualGatewayResponse parses an HTTP response from a LinkVirtualGatewayWithResponse call
func ParseLinkVirtualGatewayResponse(rsp *http.Response) (*LinkVirtualGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkVirtualGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListVirtualGatewaysResponse parses an HTTP response from a ListVirtualGatewaysWithResponse call
func ParseListVirtualGatewaysResponse(rsp *http.Response) (*ListVirtualGatewaysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVirtualGatewaysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListVirtualGateways200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateVirtualGatewayResponse parses an HTTP response from a CreateVirtualGatewayWithResponse call
func ParseCreateVirtualGatewayResponse(rsp *http.Response) (*CreateVirtualGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVirtualGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateVirtualGateway201Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteVPNConnectionResponse parses an HTTP response from a DeleteVPNConnectionWithResponse call
func ParseDeleteVPNConnectionResponse(rsp *http.Response) (*DeleteVPNConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVPNConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseReadVPNConnectionResponse parses an HTTP response from a ReadVPNConnectionWithResponse call
func ParseReadVPNConnectionResponse(rsp *http.Response) (*ReadVPNConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVPNConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVPNConnection200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteVPNConnectionRouteResponse parses an HTTP response from a DeleteVPNConnectionRouteWithResponse call
func ParseDeleteVPNConnectionRouteResponse(rsp *http.Response) (*DeleteVPNConnectionRouteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVPNConnectionRouteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateVPNConnectionRouteResponse parses an HTTP response from a CreateVPNConnectionRouteWithResponse call
func ParseCreateVPNConnectionRouteResponse(rsp *http.Response) (*CreateVPNConnectionRouteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVPNConnectionRouteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListVPNConnectionsResponse parses an HTTP response from a ListVPNConnectionsWithResponse call
func ParseListVPNConnectionsResponse(rsp *http.Response) (*ListVPNConnectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVPNConnectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListVPNConnections200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateVPNConnectionResponse parses an HTTP response from a CreateVPNConnectionWithResponse call
func ParseCreateVPNConnectionResponse(rsp *http.Response) (*CreateVPNConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVPNConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateVPNConnection201Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseJsonWebKeysResponse parses an HTTP response from a JsonWebKeysWithResponse call
func ParseJsonWebKeysResponse(rsp *http.Response) (*JsonWebKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JsonWebKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JsonWebKeys200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorOauth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorOauth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDiscoverOidcConfigurationResponse parses an HTTP response from a DiscoverOidcConfigurationWithResponse call
func ParseDiscoverOidcConfigurationResponse(rsp *http.Response) (*DiscoverOidcConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DiscoverOidcConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OidcConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorOauth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetWebAuthnJavaScriptResponse parses an HTTP response from a GetWebAuthnJavaScriptWithResponse call
func ParseGetWebAuthnJavaScriptResponse(rsp *http.Response) (*GetWebAuthnJavaScriptResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWebAuthnJavaScriptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetWebAuthnJavaScript200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateAdminServiceAccountSpaceResponse parses an HTTP response from a CreateAdminServiceAccountSpaceWithResponse call
func ParseCreateAdminServiceAccountSpaceResponse(rsp *http.Response) (*CreateAdminServiceAccountSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAdminServiceAccountSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateServiceAccount201Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseConsentResponse parses an HTTP response from a ConsentWithResponse call
func ParseConsentResponse(rsp *http.Response) (*ConsentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConsentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetFlowErrorResponse parses an HTTP response from a GetFlowErrorWithResponse call
func ParseGetFlowErrorResponse(rsp *http.Response) (*GetFlowErrorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFlowErrorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FlowError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateLoginFlowResponse parses an HTTP response from a UpdateLoginFlowWithResponse call
func ParseUpdateLoginFlowResponse(rsp *http.Response) (*UpdateLoginFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateLoginFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessfulNativeLogin
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest LoginFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorBrowserLocationChangeRequired
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBrowserLoginFlowResponse parses an HTTP response from a CreateBrowserLoginFlowWithResponse call
func ParseCreateBrowserLoginFlowResponse(rsp *http.Response) (*CreateBrowserLoginFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBrowserLoginFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoginFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLoginFlowResponse parses an HTTP response from a GetLoginFlowWithResponse call
func ParseGetLoginFlowResponse(rsp *http.Response) (*GetLoginFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLoginFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoginFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateLogoutFlowResponse parses an HTTP response from a UpdateLogoutFlowWithResponse call
func ParseUpdateLogoutFlowResponse(rsp *http.Response) (*UpdateLogoutFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateLogoutFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBrowserLogoutFlowResponse parses an HTTP response from a CreateBrowserLogoutFlowWithResponse call
func ParseCreateBrowserLogoutFlowResponse(rsp *http.Response) (*CreateBrowserLogoutFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBrowserLogoutFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogoutFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseInitRecoveryFlowResponse parses an HTTP response from a InitRecoveryFlowWithResponse call
func ParseInitRecoveryFlowResponse(rsp *http.Response) (*InitRecoveryFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InitRecoveryFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecoveryFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RecoveryFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorBrowserLocationChangeRequired
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateRecoveryFlowResponse parses an HTTP response from a UpdateRecoveryFlowWithResponse call
func ParseUpdateRecoveryFlowResponse(rsp *http.Response) (*UpdateRecoveryFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRecoveryFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecoveryFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RecoveryFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorBrowserLocationChangeRequired
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBrowserRecoveryFlowResponse parses an HTTP response from a CreateBrowserRecoveryFlowWithResponse call
func ParseCreateBrowserRecoveryFlowResponse(rsp *http.Response) (*CreateBrowserRecoveryFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBrowserRecoveryFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecoveryFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRecoveryFlowResponse parses an HTTP response from a GetRecoveryFlowWithResponse call
func ParseGetRecoveryFlowResponse(rsp *http.Response) (*GetRecoveryFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRecoveryFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecoveryFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateSettingsFloResponse parses an HTTP response from a UpdateSettingsFloWithResponse call
func ParseUpdateSettingsFloResponse(rsp *http.Response) (*UpdateSettingsFloResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSettingsFloResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SettingsFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest SettingsFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorBrowserLocationChangeRequired
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBrowserSettingsFlowResponse parses an HTTP response from a CreateBrowserSettingsFlowWithResponse call
func ParseCreateBrowserSettingsFlowResponse(rsp *http.Response) (*CreateBrowserSettingsFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBrowserSettingsFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SettingsFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSettingsFlowResponse parses an HTTP response from a GetSettingsFlowWithResponse call
func ParseGetSettingsFlowResponse(rsp *http.Response) (*GetSettingsFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSettingsFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SettingsFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseToSessionResponse parses an HTTP response from a ToSessionWithResponse call
func ParseToSessionResponse(rsp *http.Response) (*ToSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ToSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Session
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorGeneric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseIntrospectResponse parses an HTTP response from a IntrospectWithResponse call
func ParseIntrospectResponse(rsp *http.Response) (*IntrospectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IntrospectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Introspect200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorOauth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListOrganisationsIdentityResponse parses an HTTP response from a ListOrganisationsIdentityWithResponse call
func ParseListOrganisationsIdentityResponse(rsp *http.Response) (*ListOrganisationsIdentityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListOrganisationsIdentityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListUserOrganisations200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetIAMPolicyOrganisationResponse parses an HTTP response from a GetIAMPolicyOrganisationWithResponse call
func ParseGetIAMPolicyOrganisationResponse(rsp *http.Response) (*GetIAMPolicyOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIAMPolicyOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetIAMPolicy200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseSetIAMPolicyOrganisationResponse parses an HTTP response from a SetIAMPolicyOrganisationWithResponse call
func ParseSetIAMPolicyOrganisationResponse(rsp *http.Response) (*SetIAMPolicyOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetIAMPolicyOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseMatchServiceAccountOrganisationResponse parses an HTTP response from a MatchServiceAccountOrganisationWithResponse call
func ParseMatchServiceAccountOrganisationResponse(rsp *http.Response) (*MatchServiceAccountOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MatchServiceAccountOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MatchServiceAccount200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetUserOrganisationByEmailResponse parses an HTTP response from a GetUserOrganisationByEmailWithResponse call
func ParseGetUserOrganisationByEmailResponse(rsp *http.Response) (*GetUserOrganisationByEmailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserOrganisationByEmailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetUser200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListPermissionsOrganisationResponse parses an HTTP response from a ListPermissionsOrganisationWithResponse call
func ParseListPermissionsOrganisationResponse(rsp *http.Response) (*ListPermissionsOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPermissionsOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPermissions200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetPermissionOrganisationResponse parses an HTTP response from a GetPermissionOrganisationWithResponse call
func ParseGetPermissionOrganisationResponse(rsp *http.Response) (*GetPermissionOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPermissionOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPermission200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListRolesOrganisationResponse parses an HTTP response from a ListRolesOrganisationWithResponse call
func ParseListRolesOrganisationResponse(rsp *http.Response) (*ListRolesOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRolesOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListRoles200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetRoleOrganisationResponse parses an HTTP response from a GetRoleOrganisationWithResponse call
func ParseGetRoleOrganisationResponse(rsp *http.Response) (*GetRoleOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRoleOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetRole200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetRolePermissionsOrganisationResponse parses an HTTP response from a GetRolePermissionsOrganisationWithResponse call
func ParseGetRolePermissionsOrganisationResponse(rsp *http.Response) (*GetRolePermissionsOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRolePermissionsOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetRolePermissions200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListServiceAccountOrganisationResponse parses an HTTP response from a ListServiceAccountOrganisationWithResponse call
func ParseListServiceAccountOrganisationResponse(rsp *http.Response) (*ListServiceAccountOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListServiceAccountOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListServiceAccount200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateServiceAccountOrganisationResponse parses an HTTP response from a CreateServiceAccountOrganisationWithResponse call
func ParseCreateServiceAccountOrganisationResponse(rsp *http.Response) (*CreateServiceAccountOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServiceAccountOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateServiceAccount201Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteServiceAccountOrganisationResponse parses an HTTP response from a DeleteServiceAccountOrganisationWithResponse call
func ParseDeleteServiceAccountOrganisationResponse(rsp *http.Response) (*DeleteServiceAccountOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServiceAccountOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetServiceAccountOrganisationResponse parses an HTTP response from a GetServiceAccountOrganisationWithResponse call
func ParseGetServiceAccountOrganisationResponse(rsp *http.Response) (*GetServiceAccountOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceAccountOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetServiceAccount200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateServiceAccountOrganisationResponse parses an HTTP response from a UpdateServiceAccountOrganisationWithResponse call
func ParseUpdateServiceAccountOrganisationResponse(rsp *http.Response) (*UpdateServiceAccountOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateServiceAccountOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateServiceAccount200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetACLServiceAccountOrganisationResponse parses an HTTP response from a GetACLServiceAccountOrganisationWithResponse call
func ParseGetACLServiceAccountOrganisationResponse(rsp *http.Response) (*GetACLServiceAccountOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetACLServiceAccountOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetACL200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteACLServiceAccountOrganisationBulkResponse parses an HTTP response from a DeleteACLServiceAccountOrganisationBulkWithResponse call
func ParseDeleteACLServiceAccountOrganisationBulkResponse(rsp *http.Response) (*DeleteACLServiceAccountOrganisationBulkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteACLServiceAccountOrganisationBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateACLServiceAccountOrganisationBulkResponse parses an HTTP response from a CreateACLServiceAccountOrganisationBulkWithResponse call
func ParseCreateACLServiceAccountOrganisationBulkResponse(rsp *http.Response) (*CreateACLServiceAccountOrganisationBulkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateACLServiceAccountOrganisationBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListSpacesOfServiceAccountResponse parses an HTTP response from a ListSpacesOfServiceAccountWithResponse call
func ParseListSpacesOfServiceAccountResponse(rsp *http.Response) (*ListSpacesOfServiceAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSpacesOfServiceAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListSpacesServiceAccount200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListSpacesIdentityResponse parses an HTTP response from a ListSpacesIdentityWithResponse call
func ParseListSpacesIdentityResponse(rsp *http.Response) (*ListSpacesIdentityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSpacesIdentityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListSpacesIdentity200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListUserOrganisationResponse parses an HTTP response from a ListUserOrganisationWithResponse call
func ParseListUserOrganisationResponse(rsp *http.Response) (*ListUserOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUserOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListUser200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateUserOrganisationResponse parses an HTTP response from a CreateUserOrganisationWithResponse call
func ParseCreateUserOrganisationResponse(rsp *http.Response) (*CreateUserOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateUser201Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteUserOrganisationResponse parses an HTTP response from a DeleteUserOrganisationWithResponse call
func ParseDeleteUserOrganisationResponse(rsp *http.Response) (*DeleteUserOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetUserOrganisationResponse parses an HTTP response from a GetUserOrganisationWithResponse call
func ParseGetUserOrganisationResponse(rsp *http.Response) (*GetUserOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetUser200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParsePatchUserStateOrganisationResponse parses an HTTP response from a PatchUserStateOrganisationWithResponse call
func ParsePatchUserStateOrganisationResponse(rsp *http.Response) (*PatchUserStateOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchUserStateOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PatchUserState200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateUserOrganisationResponse parses an HTTP response from a UpdateUserOrganisationWithResponse call
func ParseUpdateUserOrganisationResponse(rsp *http.Response) (*UpdateUserOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateUser200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetACLUserOrganisationResponse parses an HTTP response from a GetACLUserOrganisationWithResponse call
func ParseGetACLUserOrganisationResponse(rsp *http.Response) (*GetACLUserOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetACLUserOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetACL200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteACLUserOrganisationBulkResponse parses an HTTP response from a DeleteACLUserOrganisationBulkWithResponse call
func ParseDeleteACLUserOrganisationBulkResponse(rsp *http.Response) (*DeleteACLUserOrganisationBulkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteACLUserOrganisationBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateACLUserOrganisationBulkResponse parses an HTTP response from a CreateACLUserOrganisationBulkWithResponse call
func ParseCreateACLUserOrganisationBulkResponse(rsp *http.Response) (*CreateACLUserOrganisationBulkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateACLUserOrganisationBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseRecoverUserOrganisationResponse parses an HTTP response from a RecoverUserOrganisationWithResponse call
func ParseRecoverUserOrganisationResponse(rsp *http.Response) (*RecoverUserOrganisationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RecoverUserOrganisationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecoverUser200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListSpacesOfUserResponse parses an HTTP response from a ListSpacesOfUserWithResponse call
func ParseListSpacesOfUserResponse(rsp *http.Response) (*ListSpacesOfUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSpacesOfUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListSpacesUser200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseRevokeResponse parses an HTTP response from a RevokeWithResponse call
func ParseRevokeResponse(rsp *http.Response) (*RevokeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevokeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorOauth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorOauth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetIAMPolicySpaceResponse parses an HTTP response from a GetIAMPolicySpaceWithResponse call
func ParseGetIAMPolicySpaceResponse(rsp *http.Response) (*GetIAMPolicySpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIAMPolicySpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetIAMPolicy200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseSetIAMPolicySpaceResponse parses an HTTP response from a SetIAMPolicySpaceWithResponse call
func ParseSetIAMPolicySpaceResponse(rsp *http.Response) (*SetIAMPolicySpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetIAMPolicySpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseMatchServiceAccountSpaceResponse parses an HTTP response from a MatchServiceAccountSpaceWithResponse call
func ParseMatchServiceAccountSpaceResponse(rsp *http.Response) (*MatchServiceAccountSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MatchServiceAccountSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MatchServiceAccount200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetUserSpaceByEmailResponse parses an HTTP response from a GetUserSpaceByEmailWithResponse call
func ParseGetUserSpaceByEmailResponse(rsp *http.Response) (*GetUserSpaceByEmailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserSpaceByEmailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetUser200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListPermissionsSpaceResponse parses an HTTP response from a ListPermissionsSpaceWithResponse call
func ParseListPermissionsSpaceResponse(rsp *http.Response) (*ListPermissionsSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPermissionsSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPermissions200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetPermissionSpaceResponse parses an HTTP response from a GetPermissionSpaceWithResponse call
func ParseGetPermissionSpaceResponse(rsp *http.Response) (*GetPermissionSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPermissionSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPermission200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListRolesSpaceResponse parses an HTTP response from a ListRolesSpaceWithResponse call
func ParseListRolesSpaceResponse(rsp *http.Response) (*ListRolesSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRolesSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListRoles200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetRoleSpaceResponse parses an HTTP response from a GetRoleSpaceWithResponse call
func ParseGetRoleSpaceResponse(rsp *http.Response) (*GetRoleSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRoleSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetRole200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetRolePermissionsSpaceResponse parses an HTTP response from a GetRolePermissionsSpaceWithResponse call
func ParseGetRolePermissionsSpaceResponse(rsp *http.Response) (*GetRolePermissionsSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRolePermissionsSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetRolePermissions200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListServiceAccountSpaceResponse parses an HTTP response from a ListServiceAccountSpaceWithResponse call
func ParseListServiceAccountSpaceResponse(rsp *http.Response) (*ListServiceAccountSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListServiceAccountSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListServiceAccount200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateServiceAccountSpaceResponse parses an HTTP response from a CreateServiceAccountSpaceWithResponse call
func ParseCreateServiceAccountSpaceResponse(rsp *http.Response) (*CreateServiceAccountSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServiceAccountSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateServiceAccount201Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteServiceAccountSpaceResponse parses an HTTP response from a DeleteServiceAccountSpaceWithResponse call
func ParseDeleteServiceAccountSpaceResponse(rsp *http.Response) (*DeleteServiceAccountSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServiceAccountSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetServiceAccountSpaceResponse parses an HTTP response from a GetServiceAccountSpaceWithResponse call
func ParseGetServiceAccountSpaceResponse(rsp *http.Response) (*GetServiceAccountSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceAccountSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetServiceAccount200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseAssignServiceAccountToSpaceResponse parses an HTTP response from a AssignServiceAccountToSpaceWithResponse call
func ParseAssignServiceAccountToSpaceResponse(rsp *http.Response) (*AssignServiceAccountToSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignServiceAccountToSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateServiceAccountSpaceResponse parses an HTTP response from a UpdateServiceAccountSpaceWithResponse call
func ParseUpdateServiceAccountSpaceResponse(rsp *http.Response) (*UpdateServiceAccountSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateServiceAccountSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateServiceAccount200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetACLServiceAccountSpaceResponse parses an HTTP response from a GetACLServiceAccountSpaceWithResponse call
func ParseGetACLServiceAccountSpaceResponse(rsp *http.Response) (*GetACLServiceAccountSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetACLServiceAccountSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetACL200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteACLServiceAccountSpaceBulkResponse parses an HTTP response from a DeleteACLServiceAccountSpaceBulkWithResponse call
func ParseDeleteACLServiceAccountSpaceBulkResponse(rsp *http.Response) (*DeleteACLServiceAccountSpaceBulkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteACLServiceAccountSpaceBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateACLServiceAccountSpaceBulkResponse parses an HTTP response from a CreateACLServiceAccountSpaceBulkWithResponse call
func ParseCreateACLServiceAccountSpaceBulkResponse(rsp *http.Response) (*CreateACLServiceAccountSpaceBulkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateACLServiceAccountSpaceBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListUserSpaceResponse parses an HTTP response from a ListUserSpaceWithResponse call
func ParseListUserSpaceResponse(rsp *http.Response) (*ListUserSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUserSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListUser200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateUserSpaceResponse parses an HTTP response from a CreateUserSpaceWithResponse call
func ParseCreateUserSpaceResponse(rsp *http.Response) (*CreateUserSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateUser201Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUnassignUserSpaceResponse parses an HTTP response from a UnassignUserSpaceWithResponse call
func ParseUnassignUserSpaceResponse(rsp *http.Response) (*UnassignUserSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnassignUserSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetUserSpaceResponse parses an HTTP response from a GetUserSpaceWithResponse call
func ParseGetUserSpaceResponse(rsp *http.Response) (*GetUserSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetUser200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParsePatchUserStateSpaceResponse parses an HTTP response from a PatchUserStateSpaceWithResponse call
func ParsePatchUserStateSpaceResponse(rsp *http.Response) (*PatchUserStateSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchUserStateSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PatchUserState200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseAssignUserToSpaceResponse parses an HTTP response from a AssignUserToSpaceWithResponse call
func ParseAssignUserToSpaceResponse(rsp *http.Response) (*AssignUserToSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignUserToSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateUserSpaceResponse parses an HTTP response from a UpdateUserSpaceWithResponse call
func ParseUpdateUserSpaceResponse(rsp *http.Response) (*UpdateUserSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateUser200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetACLUserSpaceResponse parses an HTTP response from a GetACLUserSpaceWithResponse call
func ParseGetACLUserSpaceResponse(rsp *http.Response) (*GetACLUserSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetACLUserSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetACL200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteACLUserSpaceBulkResponse parses an HTTP response from a DeleteACLUserSpaceBulkWithResponse call
func ParseDeleteACLUserSpaceBulkResponse(rsp *http.Response) (*DeleteACLUserSpaceBulkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteACLUserSpaceBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateACLUserSpaceBulkResponse parses an HTTP response from a CreateACLUserSpaceBulkWithResponse call
func ParseCreateACLUserSpaceBulkResponse(rsp *http.Response) (*CreateACLUserSpaceBulkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateACLUserSpaceBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseRecoverUserSpaceResponse parses an HTTP response from a RecoverUserSpaceWithResponse call
func ParseRecoverUserSpaceResponse(rsp *http.Response) (*RecoverUserSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RecoverUserSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecoverUser200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseTokenResponse parses an HTTP response from a TokenWithResponse call
func ParseTokenResponse(rsp *http.Response) (*TokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Token200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorOauth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorOauth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorOauth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseConvertTokenResponse parses an HTTP response from a ConvertTokenWithResponse call
func ParseConvertTokenResponse(rsp *http.Response) (*ConvertTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConvertTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConvertToken200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorOauth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorOauth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserInfoResponse parses an HTTP response from a GetUserInfoWithResponse call
func ParseGetUserInfoResponse(rsp *http.Response) (*GetUserInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetUserInfo200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorOauth2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseHealthcheckResponse parses an HTTP response from a HealthcheckWithResponse call
func ParseHealthcheckResponse(rsp *http.Response) (*HealthcheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HealthcheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Healthcheck200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListKubernetesSupportedNodeProfilesResponse parses an HTTP response from a ListKubernetesSupportedNodeProfilesWithResponse call
func ParseListKubernetesSupportedNodeProfilesResponse(rsp *http.Response) (*ListKubernetesSupportedNodeProfilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListKubernetesSupportedNodeProfilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NodeProfileList200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListKubernetesClustersResponse parses an HTTP response from a ListKubernetesClustersWithResponse call
func ParseListKubernetesClustersResponse(rsp *http.Response) (*ListKubernetesClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListKubernetesClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterList200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateKubernetesClusterResponse parses an HTTP response from a CreateKubernetesClusterWithResponse call
func ParseCreateKubernetesClusterResponse(rsp *http.Response) (*CreateKubernetesClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateKubernetesClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Operation202Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error409
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteKubernetesClusterResponse parses an HTTP response from a DeleteKubernetesClusterWithResponse call
func ParseDeleteKubernetesClusterResponse(rsp *http.Response) (*DeleteKubernetesClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteKubernetesClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Operation202Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error409
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetKubernetesClusterInfoResponse parses an HTTP response from a GetKubernetesClusterInfoWithResponse call
func ParseGetKubernetesClusterInfoResponse(rsp *http.Response) (*GetKubernetesClusterInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKubernetesClusterInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Cluster200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetKubernetesKubeConfigResponse parses an HTTP response from a GetKubernetesKubeConfigWithResponse call
func ParseGetKubernetesKubeConfigResponse(rsp *http.Response) (*GetKubernetesKubeConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKubernetesKubeConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpgradeKubernetesMastersResponse parses an HTTP response from a UpgradeKubernetesMastersWithResponse call
func ParseUpgradeKubernetesMastersResponse(rsp *http.Response) (*UpgradeKubernetesMastersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpgradeKubernetesMastersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Operation202Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error409
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListKubernetesOperationsResponse parses an HTTP response from a ListKubernetesOperationsWithResponse call
func ParseListKubernetesOperationsResponse(rsp *http.Response) (*ListKubernetesOperationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListKubernetesOperationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OperationList200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetKubernetesPrivateKeyResponse parses an HTTP response from a GetKubernetesPrivateKeyWithResponse call
func ParseGetKubernetesPrivateKeyResponse(rsp *http.Response) (*GetKubernetesPrivateKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKubernetesPrivateKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetKubernetesClusterStateResponse parses an HTTP response from a GetKubernetesClusterStateWithResponse call
func ParseGetKubernetesClusterStateResponse(rsp *http.Response) (*GetKubernetesClusterStateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKubernetesClusterStateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterState200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateKubernetesNodesResponse parses an HTTP response from a UpdateKubernetesNodesWithResponse call
func ParseUpdateKubernetesNodesResponse(rsp *http.Response) (*UpdateKubernetesNodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateKubernetesNodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Operation202Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error409
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseAddKubernetesWorkersResponse parses an HTTP response from a AddKubernetesWorkersWithResponse call
func ParseAddKubernetesWorkersResponse(rsp *http.Response) (*AddKubernetesWorkersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddKubernetesWorkersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Operation202Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error409
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseRemoveKubernetesWorkerResponse parses an HTTP response from a RemoveKubernetesWorkerWithResponse call
func ParseRemoveKubernetesWorkerResponse(rsp *http.Response) (*RemoveKubernetesWorkerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveKubernetesWorkerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Operation202Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error409
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpgradeKubernetesWorkersResponse parses an HTTP response from a UpgradeKubernetesWorkersWithResponse call
func ParseUpgradeKubernetesWorkersResponse(rsp *http.Response) (*UpgradeKubernetesWorkersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpgradeKubernetesWorkersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Operation202Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error409
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetKubernetesOperationResponse parses an HTTP response from a GetKubernetesOperationWithResponse call
func ParseGetKubernetesOperationResponse(rsp *http.Response) (*GetKubernetesOperationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKubernetesOperationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Operation200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListKubernetesSupportedVersionsResponse parses an HTTP response from a ListKubernetesSupportedVersionsWithResponse call
func ParseListKubernetesSupportedVersionsResponse(rsp *http.Response) (*ListKubernetesSupportedVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListKubernetesSupportedVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VersionList200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListClustersResponse parses an HTTP response from a ListClustersWithResponse call
func ParseListClustersResponse(rsp *http.Response) (*ListClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Clusters200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateClusterResponse parses an HTTP response from a CreateClusterWithResponse call
func ParseCreateClusterResponse(rsp *http.Response) (*CreateClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ClusterCreate201Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteClusterResponse parses an HTTP response from a DeleteClusterWithResponse call
func ParseDeleteClusterResponse(rsp *http.Response) (*DeleteClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ClusterDelete202Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetClusterResponse parses an HTTP response from a GetClusterWithResponse call
func ParseGetClusterResponse(rsp *http.Response) (*GetClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterGet200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateClusterResponse parses an HTTP response from a UpdateClusterWithResponse call
func ParseUpdateClusterResponse(rsp *http.Response) (*UpdateClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterGet200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListNodepoolsResponse parses an HTTP response from a ListNodepoolsWithResponse call
func ParseListNodepoolsResponse(rsp *http.Response) (*ListNodepoolsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListNodepoolsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Nodepools200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateNodePoolResponse parses an HTTP response from a CreateNodePoolWithResponse call
func ParseCreateNodePoolResponse(rsp *http.Response) (*CreateNodePoolResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNodePoolResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest NodepoolCreate201Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteNodePoolResponse parses an HTTP response from a DeleteNodePoolWithResponse call
func ParseDeleteNodePoolResponse(rsp *http.Response) (*DeleteNodePoolResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNodePoolResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest NodepoolDelete202Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateNodepoolResponse parses an HTTP response from a UpdateNodepoolWithResponse call
func ParseUpdateNodepoolResponse(rsp *http.Response) (*UpdateNodepoolResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateNodepoolResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest OpenShiftNodepoolUpdate202Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListOperationsResponse parses an HTTP response from a ListOperationsWithResponse call
func ParseListOperationsResponse(rsp *http.Response) (*ListOperationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListOperationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OpenShiftOperations200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetOperationResponse parses an HTTP response from a GetOperationWithResponse call
func ParseGetOperationResponse(rsp *http.Response) (*GetOperationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOperationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OpenShiftOperation200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListVersionsResponse parses an HTTP response from a ListVersionsWithResponse call
func ParseListVersionsResponse(rsp *http.Response) (*ListVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Versions202Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListSpacesResponse parses an HTTP response from a ListSpacesWithResponse call
func ParseListSpacesResponse(rsp *http.Response) (*ListSpacesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSpacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListSpaces200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateSpaceResponse parses an HTTP response from a CreateSpaceWithResponse call
func ParseCreateSpaceResponse(rsp *http.Response) (*CreateSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateSpace200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSpaceResponse parses an HTTP response from a DeleteSpaceWithResponse call
func ParseDeleteSpaceResponse(rsp *http.Response) (*DeleteSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetSpaceByIdResponse parses an HTTP response from a GetSpaceByIdWithResponse call
func ParseGetSpaceByIdResponse(rsp *http.Response) (*GetSpaceByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpaceByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetSpaceById200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateSpaceResponse parses an HTTP response from a UpdateSpaceWithResponse call
func ParseUpdateSpaceResponse(rsp *http.Response) (*UpdateSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParsePostgreSQLGetAvailableClusterConfigurationsResponse parses an HTTP response from a PostgreSQLGetAvailableClusterConfigurationsWithResponse call
func ParsePostgreSQLGetAvailableClusterConfigurationsResponse(rsp *http.Response) (*PostgreSQLGetAvailableClusterConfigurationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostgreSQLGetAvailableClusterConfigurationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostgresServiceCatalogClustersConfiguration200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostgreSQLGetClusterAutomaticBackupInformationResponse parses an HTTP response from a PostgreSQLGetClusterAutomaticBackupInformationWithResponse call
func ParsePostgreSQLGetClusterAutomaticBackupInformationResponse(rsp *http.Response) (*PostgreSQLGetClusterAutomaticBackupInformationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostgreSQLGetClusterAutomaticBackupInformationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostgresServiceCatalogClustersAutomaticBackup200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostgreSQLListBackupsResponse parses an HTTP response from a PostgreSQLListBackupsWithResponse call
func ParsePostgreSQLListBackupsResponse(rsp *http.Response) (*PostgreSQLListBackupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostgreSQLListBackupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostgresListBackups200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest PostgresInvalidParameterProblem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest PostgresInvalidAuthenticationProblem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest PostgresServiceMalfunctionProblem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParsePostgreSQLDeleteBackupResponse parses an HTTP response from a PostgreSQLDeleteBackupWithResponse call
func ParsePostgreSQLDeleteBackupResponse(rsp *http.Response) (*PostgreSQLDeleteBackupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostgreSQLDeleteBackupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest PostgresDeleteBackup202Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest PostgresInvalidParameterProblem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest PostgresInvalidAuthenticationProblem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest PostgresResourceNotFoundProblem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest PostgresServiceMalfunctionProblem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParsePostgreSQLListClustersResponse parses an HTTP response from a PostgreSQLListClustersWithResponse call
func ParsePostgreSQLListClustersResponse(rsp *http.Response) (*PostgreSQLListClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostgreSQLListClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostgresListClusters200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest PostgresInvalidParameterProblem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest PostgresInvalidAuthenticationProblem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest PostgresServiceMalfunctionProblem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParsePostgreSQLCreateClusterResponse parses an HTTP response from a PostgreSQLCreateClusterWithResponse call
func ParsePostgreSQLCreateClusterResponse(rsp *http.Response) (*PostgreSQLCreateClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostgreSQLCreateClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PostgresCreateCluster201Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest PostgresCreateCluster400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest PostgresInvalidAuthenticationProblem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest PostgresServiceMalfunctionProblem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParsePostgreSQLDeleteClusterResponse parses an HTTP response from a PostgreSQLDeleteClusterWithResponse call
func ParsePostgreSQLDeleteClusterResponse(rsp *http.Response) (*PostgreSQLDeleteClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostgreSQLDeleteClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest PostgresDeleteCluster202Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest PostgresInvalidParameterProblem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest PostgresInvalidAuthenticationProblem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest PostgresResourceNotFoundProblem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest PostgresIncompatibleStatusProblem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest PostgresServiceMalfunctionProblem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParsePostgreSQLGetClusterResponse parses an HTTP response from a PostgreSQLGetClusterWithResponse call
func ParsePostgreSQLGetClusterResponse(rsp *http.Response) (*PostgreSQLGetClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostgreSQLGetClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostgresGetCluster200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest PostgresInvalidParameterProblem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest PostgresInvalidAuthenticationProblem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest PostgresResourceNotFoundProblem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest PostgresServiceMalfunctionProblem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParsePostgreSQLModifyClusterResponse parses an HTTP response from a PostgreSQLModifyClusterWithResponse call
func ParsePostgreSQLModifyClusterResponse(rsp *http.Response) (*PostgreSQLModifyClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostgreSQLModifyClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostgresPatchCluster200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest PostgresInvalidParameterProblem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest PostgresInvalidAuthenticationProblem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest PostgresResourceNotFoundProblem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest PostgresIncompatibleStatusProblem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest PostgresServiceMalfunctionProblem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParsePostgreSQLListClusterBackupsResponse parses an HTTP response from a PostgreSQLListClusterBackupsWithResponse call
func ParsePostgreSQLListClusterBackupsResponse(rsp *http.Response) (*PostgreSQLListClusterBackupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostgreSQLListClusterBackupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostgresListClusterBackups200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest PostgresInvalidParameterProblem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest PostgresInvalidAuthenticationProblem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest PostgresServiceMalfunctionProblem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseOldPostgreSQLResetClusterAdministrationPasswordResponse parses an HTTP response from a OldPostgreSQLResetClusterAdministrationPasswordWithResponse call
func ParseOldPostgreSQLResetClusterAdministrationPasswordResponse(rsp *http.Response) (*OldPostgreSQLResetClusterAdministrationPasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OldPostgreSQLResetClusterAdministrationPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest PostgresResetPassword202Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest PostgresInvalidParameterProblem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest PostgresInvalidAuthenticationProblem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest PostgresResourceNotFoundProblem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest PostgresIncompatibleStatusProblem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest PostgresServiceMalfunctionProblem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParsePostgreSQLResetClusterAdministrationPasswordResponse parses an HTTP response from a PostgreSQLResetClusterAdministrationPasswordWithResponse call
func ParsePostgreSQLResetClusterAdministrationPasswordResponse(rsp *http.Response) (*PostgreSQLResetClusterAdministrationPasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostgreSQLResetClusterAdministrationPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest PostgresResetPassword202Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest PostgresInvalidParameterProblem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest PostgresInvalidAuthenticationProblem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest PostgresResourceNotFoundProblem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest PostgresIncompatibleStatusProblem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest PostgresServiceMalfunctionProblem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}
