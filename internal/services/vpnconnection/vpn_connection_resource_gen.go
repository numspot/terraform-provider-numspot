// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package vpnconnection

import (
	"context"
	"fmt"
	"gitlab.numspot.cloud/cloud/terraform-provider-numspot/internal/services/tags"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
)

func VpnConnectionResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"client_gateway_configuration": schema.StringAttribute{
				Computed:            true,
				Description:         "Example configuration for the client gateway.",
				MarkdownDescription: "Example configuration for the client gateway.",
			},
			"client_gateway_id": schema.StringAttribute{
				Required:            true,
				Description:         "The ID of the client gateway.",
				MarkdownDescription: "The ID of the client gateway.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplaceIfConfigured(),
				},
			},
			"connection_type": schema.StringAttribute{
				Required:            true,
				Description:         "The type of VPN connection (only `ipsec.1` is supported).",
				MarkdownDescription: "The type of VPN connection (only `ipsec.1` is supported).",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"id": schema.StringAttribute{
				Computed:            true,
				Description:         "The ID of the VPN connection.",
				MarkdownDescription: "The ID of the VPN connection.",
			},
			"routes": schema.SetNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"destination_ip_range": schema.StringAttribute{
							Computed:            true,
							Optional:            true,
							Description:         "The IP range used for the destination match, in CIDR notation (for example, `10.0.0.0/24`).",
							MarkdownDescription: "The IP range used for the destination match, in CIDR notation (for example, `10.0.0.0/24`).",
						},
						"route_type": schema.StringAttribute{
							Computed:            true,
							Description:         "The type of route (always `static`).",
							MarkdownDescription: "The type of route (always `static`).",
						},
						"state": schema.StringAttribute{
							Computed:            true,
							Description:         "The current state of the static route (`pending` \\| `available` \\| `deleting` \\| `deleted`).",
							MarkdownDescription: "The current state of the static route (`pending` \\| `available` \\| `deleting` \\| `deleted`).",
						},
					},
					CustomType: RoutesType{
						ObjectType: types.ObjectType{
							AttrTypes: RoutesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed:            true,
				Optional:            true,
				Description:         "Information about one or more static routes associated with the VPN connection, if any.",
				MarkdownDescription: "Information about one or more static routes associated with the VPN connection, if any.",
			},
			"state": schema.StringAttribute{
				Computed:            true,
				Description:         "The state of the VPN connection (`pending` \\| `available` \\| `deleting` \\| `deleted`).",
				MarkdownDescription: "The state of the VPN connection (`pending` \\| `available` \\| `deleting` \\| `deleted`).",
			},
			"static_routes_only": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "If false, the VPN connection uses dynamic routing with Border Gateway Protocol (BGP). If true, routing is controlled using static routes. For more information about how to create and delete static routes, see [CreateVpnConnectionRoute](#createvpnconnectionroute) and [DeleteVpnConnectionRoute](#deletevpnconnectionroute).",
				MarkdownDescription: "If false, the VPN connection uses dynamic routing with Border Gateway Protocol (BGP). If true, routing is controlled using static routes. For more information about how to create and delete static routes, see [CreateVpnConnectionRoute](#createvpnconnectionroute) and [DeleteVpnConnectionRoute](#deletevpnconnectionroute).",
				PlanModifiers: []planmodifier.Bool{
					boolplanmodifier.RequiresReplace(),
				},
			},
			"vgw_telemetries": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"accepted_route_count": schema.Int64Attribute{
							Computed:            true,
							Description:         "The number of routes accepted through BGP (Border Gateway Protocol) route exchanges.",
							MarkdownDescription: "The number of routes accepted through BGP (Border Gateway Protocol) route exchanges.",
						},
						"last_state_change_date": schema.StringAttribute{
							Computed:            true,
							Description:         "The date and time (UTC) of the latest state update.",
							MarkdownDescription: "The date and time (UTC) of the latest state update.",
						},
						"outside_ip_address": schema.StringAttribute{
							Computed:            true,
							Description:         "The IP on the OUTSCALE side of the tunnel.",
							MarkdownDescription: "The IP on the OUTSCALE side of the tunnel.",
						},
						"state": schema.StringAttribute{
							Computed:            true,
							Description:         "The state of the IPSEC tunnel (`UP` \\| `DOWN`).",
							MarkdownDescription: "The state of the IPSEC tunnel (`UP` \\| `DOWN`).",
						},
						"state_description": schema.StringAttribute{
							Computed:            true,
							Description:         "A description of the current state of the tunnel.",
							MarkdownDescription: "A description of the current state of the tunnel.",
						},
					},
					CustomType: VgwTelemetriesType{
						ObjectType: types.ObjectType{
							AttrTypes: VgwTelemetriesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed:            true,
				Description:         "Information about the current state of one or more of the VPN tunnels.",
				MarkdownDescription: "Information about the current state of one or more of the VPN tunnels.",
			},
			"virtual_gateway_id": schema.StringAttribute{
				Required:            true,
				Description:         "The ID of the virtual gateway.",
				MarkdownDescription: "The ID of the virtual gateway.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplaceIfConfigured(),
				},
			},
			"vpn_options": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"phase1options": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"dpd_timeout_action": schema.StringAttribute{
								Computed:            true,
								Description:         "The action to carry out after a Dead Peer Detection (DPD) timeout occurs.",
								MarkdownDescription: "The action to carry out after a Dead Peer Detection (DPD) timeout occurs.",
							},
							"dpd_timeout_seconds": schema.Int64Attribute{
								Computed:            true,
								Description:         "The maximum waiting time for a Dead Peer Detection (DPD) response before considering the peer as dead, in seconds.",
								MarkdownDescription: "The maximum waiting time for a Dead Peer Detection (DPD) response before considering the peer as dead, in seconds.",
							},
							"ike_versions": schema.ListAttribute{
								ElementType:         types.StringType,
								Computed:            true,
								Description:         "The Internet Key Exchange (IKE) versions allowed for the VPN tunnel.",
								MarkdownDescription: "The Internet Key Exchange (IKE) versions allowed for the VPN tunnel.",
							},
							"phase1dh_group_numbers": schema.ListAttribute{
								ElementType:         types.Int64Type,
								Computed:            true,
								Description:         "The Diffie-Hellman (DH) group numbers allowed for the VPN tunnel for phase 1.",
								MarkdownDescription: "The Diffie-Hellman (DH) group numbers allowed for the VPN tunnel for phase 1.",
							},
							"phase1encryption_algorithms": schema.ListAttribute{
								ElementType:         types.StringType,
								Computed:            true,
								Description:         "The encryption algorithms allowed for the VPN tunnel for phase 1.",
								MarkdownDescription: "The encryption algorithms allowed for the VPN tunnel for phase 1.",
							},
							"phase1integrity_algorithms": schema.ListAttribute{
								ElementType:         types.StringType,
								Computed:            true,
								Description:         "The integrity algorithms allowed for the VPN tunnel for phase 1.",
								MarkdownDescription: "The integrity algorithms allowed for the VPN tunnel for phase 1.",
							},
							"phase1lifetime_seconds": schema.Int64Attribute{
								Computed:            true,
								Description:         "The lifetime for phase 1 of the IKE negotiation process, in seconds.",
								MarkdownDescription: "The lifetime for phase 1 of the IKE negotiation process, in seconds.",
							},
							"replay_window_size": schema.Int64Attribute{
								Computed:            true,
								Description:         "The number of packets in an IKE replay window.",
								MarkdownDescription: "The number of packets in an IKE replay window.",
							},
							"startup_action": schema.StringAttribute{
								Computed:            true,
								Description:         "The action to carry out when establishing tunnels for a VPN connection.",
								MarkdownDescription: "The action to carry out when establishing tunnels for a VPN connection.",
							},
						},
						CustomType: Phase1optionsType{
							ObjectType: types.ObjectType{
								AttrTypes: Phase1optionsValue{}.AttributeTypes(ctx),
							},
						},
						Computed:            true,
						Description:         "Information about Phase 1 of the Internet Key Exchange (IKE) negotiation. When Phase 1 finishes successfully, peers proceed to Phase 2 negotiations. ",
						MarkdownDescription: "Information about Phase 1 of the Internet Key Exchange (IKE) negotiation. When Phase 1 finishes successfully, peers proceed to Phase 2 negotiations. ",
					},
					"phase2options": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"phase2dh_group_numbers": schema.ListAttribute{
								ElementType:         types.Int64Type,
								Computed:            true,
								Description:         "The Diffie-Hellman (DH) group numbers allowed for the VPN tunnel for phase 2.",
								MarkdownDescription: "The Diffie-Hellman (DH) group numbers allowed for the VPN tunnel for phase 2.",
							},
							"phase2encryption_algorithms": schema.ListAttribute{
								ElementType:         types.StringType,
								Computed:            true,
								Description:         "The encryption algorithms allowed for the VPN tunnel for phase 2.",
								MarkdownDescription: "The encryption algorithms allowed for the VPN tunnel for phase 2.",
							},
							"phase2integrity_algorithms": schema.ListAttribute{
								ElementType:         types.StringType,
								Computed:            true,
								Description:         "The integrity algorithms allowed for the VPN tunnel for phase 2.",
								MarkdownDescription: "The integrity algorithms allowed for the VPN tunnel for phase 2.",
							},
							"phase2lifetime_seconds": schema.Int64Attribute{
								Computed:            true,
								Description:         "The lifetime for phase 2 of the Internet Key Exchange (IKE) negociation process, in seconds.",
								MarkdownDescription: "The lifetime for phase 2 of the Internet Key Exchange (IKE) negociation process, in seconds.",
							},
							"pre_shared_key": schema.StringAttribute{
								Computed:            true,
								Optional:            true,
								Description:         "The pre-shared key to establish the initial authentication between the client gateway and the virtual gateway. This key can contain any character except line breaks and double quotes (&quot;).",
								MarkdownDescription: "The pre-shared key to establish the initial authentication between the client gateway and the virtual gateway. This key can contain any character except line breaks and double quotes (&quot;).",
							},
						},
						CustomType: Phase2optionsType{
							ObjectType: types.ObjectType{
								AttrTypes: Phase2optionsValue{}.AttributeTypes(ctx),
							},
						},
						Computed:            true,
						Optional:            true,
						Description:         "Information about Phase 2 of the Internet Key Exchange (IKE) negotiation. ",
						MarkdownDescription: "Information about Phase 2 of the Internet Key Exchange (IKE) negotiation. ",
					},
					"tunnel_inside_ip_range": schema.StringAttribute{
						Computed:            true,
						Optional:            true,
						Description:         "The range of inside IPs for the tunnel. This must be a /30 CIDR block from the 169.254.254.0/24 range.",
						MarkdownDescription: "The range of inside IPs for the tunnel. This must be a /30 CIDR block from the 169.254.254.0/24 range.",
					},
				},
				CustomType: VpnOptionsType{
					ObjectType: types.ObjectType{
						AttrTypes: VpnOptionsValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Optional:            true,
				Description:         "Information about the VPN options.",
				MarkdownDescription: "Information about the VPN options.",
			},
			"tags": tags.TagsSchema(ctx),
		},
		DeprecationMessage: "Managing IAAS services with Terraform is deprecated",
	}
}

type VpnConnectionModel struct {
	ClientGatewayConfiguration types.String    `tfsdk:"client_gateway_configuration"`
	ClientGatewayId            types.String    `tfsdk:"client_gateway_id"`
	ConnectionType             types.String    `tfsdk:"connection_type"`
	Id                         types.String    `tfsdk:"id"`
	Routes                     types.Set       `tfsdk:"routes"`
	State                      types.String    `tfsdk:"state"`
	StaticRoutesOnly           types.Bool      `tfsdk:"static_routes_only"`
	VgwTelemetries             types.List      `tfsdk:"vgw_telemetries"`
	VirtualGatewayId           types.String    `tfsdk:"virtual_gateway_id"`
	VpnOptions                 VpnOptionsValue `tfsdk:"vpn_options"`
	Tags                       types.List      `tfsdk:"tags"`
}

var _ basetypes.ObjectTypable = RoutesType{}

type RoutesType struct {
	basetypes.ObjectType
}

func (t RoutesType) Equal(o attr.Type) bool {
	other, ok := o.(RoutesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RoutesType) String() string {
	return "RoutesType"
}

func (t RoutesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	destinationIpRangeAttribute, ok := attributes["destination_ip_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_ip_range is missing from object`)

		return nil, diags
	}

	destinationIpRangeVal, ok := destinationIpRangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_ip_range expected to be basetypes.StringValue, was: %T`, destinationIpRangeAttribute))
	}

	routeTypeAttribute, ok := attributes["route_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`route_type is missing from object`)

		return nil, diags
	}

	routeTypeVal, ok := routeTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`route_type expected to be basetypes.StringValue, was: %T`, routeTypeAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return nil, diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RoutesValue{
		DestinationIpRange: destinationIpRangeVal,
		RouteType:          routeTypeVal,
		State:              stateVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewRoutesValueNull() RoutesValue {
	return RoutesValue{
		state: attr.ValueStateNull,
	}
}

func NewRoutesValueUnknown() RoutesValue {
	return RoutesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRoutesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RoutesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RoutesValue Attribute Value",
				"While creating a RoutesValue value, a missing attribute value was detected. "+
					"A RoutesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RoutesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RoutesValue Attribute Type",
				"While creating a RoutesValue value, an invalid attribute value was detected. "+
					"A RoutesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RoutesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RoutesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RoutesValue Attribute Value",
				"While creating a RoutesValue value, an extra attribute value was detected. "+
					"A RoutesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RoutesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRoutesValueUnknown(), diags
	}

	destinationIpRangeAttribute, ok := attributes["destination_ip_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_ip_range is missing from object`)

		return NewRoutesValueUnknown(), diags
	}

	destinationIpRangeVal, ok := destinationIpRangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_ip_range expected to be basetypes.StringValue, was: %T`, destinationIpRangeAttribute))
	}

	routeTypeAttribute, ok := attributes["route_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`route_type is missing from object`)

		return NewRoutesValueUnknown(), diags
	}

	routeTypeVal, ok := routeTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`route_type expected to be basetypes.StringValue, was: %T`, routeTypeAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return NewRoutesValueUnknown(), diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	if diags.HasError() {
		return NewRoutesValueUnknown(), diags
	}

	return RoutesValue{
		DestinationIpRange: destinationIpRangeVal,
		RouteType:          routeTypeVal,
		State:              stateVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewRoutesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RoutesValue {
	object, diags := NewRoutesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRoutesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RoutesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRoutesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRoutesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRoutesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRoutesValueMust(RoutesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RoutesType) ValueType(ctx context.Context) attr.Value {
	return RoutesValue{}
}

var _ basetypes.ObjectValuable = RoutesValue{}

type RoutesValue struct {
	DestinationIpRange basetypes.StringValue `tfsdk:"destination_ip_range"`
	RouteType          basetypes.StringValue `tfsdk:"route_type"`
	State              basetypes.StringValue `tfsdk:"state"`
	state              attr.ValueState
}

func (v RoutesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["destination_ip_range"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["route_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["state"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.DestinationIpRange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["destination_ip_range"] = val

		val, err = v.RouteType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["route_type"] = val

		val, err = v.State.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["state"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RoutesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RoutesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RoutesValue) String() string {
	return "RoutesValue"
}

func (v RoutesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"destination_ip_range": basetypes.StringType{},
			"route_type":           basetypes.StringType{},
			"state":                basetypes.StringType{},
		},
		map[string]attr.Value{
			"destination_ip_range": v.DestinationIpRange,
			"route_type":           v.RouteType,
			"state":                v.State,
		})

	return objVal, diags
}

func (v RoutesValue) Equal(o attr.Value) bool {
	other, ok := o.(RoutesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DestinationIpRange.Equal(other.DestinationIpRange) {
		return false
	}

	if !v.RouteType.Equal(other.RouteType) {
		return false
	}

	if !v.State.Equal(other.State) {
		return false
	}

	return true
}

func (v RoutesValue) Type(ctx context.Context) attr.Type {
	return RoutesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RoutesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"destination_ip_range": basetypes.StringType{},
		"route_type":           basetypes.StringType{},
		"state":                basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = VgwTelemetriesType{}

type VgwTelemetriesType struct {
	basetypes.ObjectType
}

func (t VgwTelemetriesType) Equal(o attr.Type) bool {
	other, ok := o.(VgwTelemetriesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VgwTelemetriesType) String() string {
	return "VgwTelemetriesType"
}

func (t VgwTelemetriesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	acceptedRouteCountAttribute, ok := attributes["accepted_route_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`accepted_route_count is missing from object`)

		return nil, diags
	}

	acceptedRouteCountVal, ok := acceptedRouteCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`accepted_route_count expected to be basetypes.Int64Value, was: %T`, acceptedRouteCountAttribute))
	}

	lastStateChangeDateAttribute, ok := attributes["last_state_change_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_state_change_date is missing from object`)

		return nil, diags
	}

	lastStateChangeDateVal, ok := lastStateChangeDateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_state_change_date expected to be basetypes.StringValue, was: %T`, lastStateChangeDateAttribute))
	}

	outsideIpAddressAttribute, ok := attributes["outside_ip_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`outside_ip_address is missing from object`)

		return nil, diags
	}

	outsideIpAddressVal, ok := outsideIpAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`outside_ip_address expected to be basetypes.StringValue, was: %T`, outsideIpAddressAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return nil, diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	stateDescriptionAttribute, ok := attributes["state_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state_description is missing from object`)

		return nil, diags
	}

	stateDescriptionVal, ok := stateDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state_description expected to be basetypes.StringValue, was: %T`, stateDescriptionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VgwTelemetriesValue{
		AcceptedRouteCount:  acceptedRouteCountVal,
		LastStateChangeDate: lastStateChangeDateVal,
		OutsideIpAddress:    outsideIpAddressVal,
		State:               stateVal,
		StateDescription:    stateDescriptionVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewVgwTelemetriesValueNull() VgwTelemetriesValue {
	return VgwTelemetriesValue{
		state: attr.ValueStateNull,
	}
}

func NewVgwTelemetriesValueUnknown() VgwTelemetriesValue {
	return VgwTelemetriesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVgwTelemetriesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VgwTelemetriesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VgwTelemetriesValue Attribute Value",
				"While creating a VgwTelemetriesValue value, a missing attribute value was detected. "+
					"A VgwTelemetriesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VgwTelemetriesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VgwTelemetriesValue Attribute Type",
				"While creating a VgwTelemetriesValue value, an invalid attribute value was detected. "+
					"A VgwTelemetriesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VgwTelemetriesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VgwTelemetriesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VgwTelemetriesValue Attribute Value",
				"While creating a VgwTelemetriesValue value, an extra attribute value was detected. "+
					"A VgwTelemetriesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VgwTelemetriesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVgwTelemetriesValueUnknown(), diags
	}

	acceptedRouteCountAttribute, ok := attributes["accepted_route_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`accepted_route_count is missing from object`)

		return NewVgwTelemetriesValueUnknown(), diags
	}

	acceptedRouteCountVal, ok := acceptedRouteCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`accepted_route_count expected to be basetypes.Int64Value, was: %T`, acceptedRouteCountAttribute))
	}

	lastStateChangeDateAttribute, ok := attributes["last_state_change_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_state_change_date is missing from object`)

		return NewVgwTelemetriesValueUnknown(), diags
	}

	lastStateChangeDateVal, ok := lastStateChangeDateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_state_change_date expected to be basetypes.StringValue, was: %T`, lastStateChangeDateAttribute))
	}

	outsideIpAddressAttribute, ok := attributes["outside_ip_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`outside_ip_address is missing from object`)

		return NewVgwTelemetriesValueUnknown(), diags
	}

	outsideIpAddressVal, ok := outsideIpAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`outside_ip_address expected to be basetypes.StringValue, was: %T`, outsideIpAddressAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return NewVgwTelemetriesValueUnknown(), diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	stateDescriptionAttribute, ok := attributes["state_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state_description is missing from object`)

		return NewVgwTelemetriesValueUnknown(), diags
	}

	stateDescriptionVal, ok := stateDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state_description expected to be basetypes.StringValue, was: %T`, stateDescriptionAttribute))
	}

	if diags.HasError() {
		return NewVgwTelemetriesValueUnknown(), diags
	}

	return VgwTelemetriesValue{
		AcceptedRouteCount:  acceptedRouteCountVal,
		LastStateChangeDate: lastStateChangeDateVal,
		OutsideIpAddress:    outsideIpAddressVal,
		State:               stateVal,
		StateDescription:    stateDescriptionVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewVgwTelemetriesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VgwTelemetriesValue {
	object, diags := NewVgwTelemetriesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVgwTelemetriesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VgwTelemetriesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVgwTelemetriesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVgwTelemetriesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVgwTelemetriesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVgwTelemetriesValueMust(VgwTelemetriesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VgwTelemetriesType) ValueType(ctx context.Context) attr.Value {
	return VgwTelemetriesValue{}
}

var _ basetypes.ObjectValuable = VgwTelemetriesValue{}

type VgwTelemetriesValue struct {
	AcceptedRouteCount  basetypes.Int64Value  `tfsdk:"accepted_route_count"`
	LastStateChangeDate basetypes.StringValue `tfsdk:"last_state_change_date"`
	OutsideIpAddress    basetypes.StringValue `tfsdk:"outside_ip_address"`
	State               basetypes.StringValue `tfsdk:"state"`
	StateDescription    basetypes.StringValue `tfsdk:"state_description"`
	state               attr.ValueState
}

func (v VgwTelemetriesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["accepted_route_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["last_state_change_date"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["outside_ip_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["state_description"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.AcceptedRouteCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["accepted_route_count"] = val

		val, err = v.LastStateChangeDate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_state_change_date"] = val

		val, err = v.OutsideIpAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["outside_ip_address"] = val

		val, err = v.State.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["state"] = val

		val, err = v.StateDescription.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["state_description"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VgwTelemetriesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VgwTelemetriesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VgwTelemetriesValue) String() string {
	return "VgwTelemetriesValue"
}

func (v VgwTelemetriesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"accepted_route_count":   basetypes.Int64Type{},
			"last_state_change_date": basetypes.StringType{},
			"outside_ip_address":     basetypes.StringType{},
			"state":                  basetypes.StringType{},
			"state_description":      basetypes.StringType{},
		},
		map[string]attr.Value{
			"accepted_route_count":   v.AcceptedRouteCount,
			"last_state_change_date": v.LastStateChangeDate,
			"outside_ip_address":     v.OutsideIpAddress,
			"state":                  v.State,
			"state_description":      v.StateDescription,
		})

	return objVal, diags
}

func (v VgwTelemetriesValue) Equal(o attr.Value) bool {
	other, ok := o.(VgwTelemetriesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AcceptedRouteCount.Equal(other.AcceptedRouteCount) {
		return false
	}

	if !v.LastStateChangeDate.Equal(other.LastStateChangeDate) {
		return false
	}

	if !v.OutsideIpAddress.Equal(other.OutsideIpAddress) {
		return false
	}

	if !v.State.Equal(other.State) {
		return false
	}

	if !v.StateDescription.Equal(other.StateDescription) {
		return false
	}

	return true
}

func (v VgwTelemetriesValue) Type(ctx context.Context) attr.Type {
	return VgwTelemetriesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VgwTelemetriesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"accepted_route_count":   basetypes.Int64Type{},
		"last_state_change_date": basetypes.StringType{},
		"outside_ip_address":     basetypes.StringType{},
		"state":                  basetypes.StringType{},
		"state_description":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = VpnOptionsType{}

type VpnOptionsType struct {
	basetypes.ObjectType
}

func (t VpnOptionsType) Equal(o attr.Type) bool {
	other, ok := o.(VpnOptionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VpnOptionsType) String() string {
	return "VpnOptionsType"
}

func (t VpnOptionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	phase1optionsAttribute, ok := attributes["phase1options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`phase1options is missing from object`)

		return nil, diags
	}

	phase1optionsVal, ok := phase1optionsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`phase1options expected to be basetypes.ObjectValue, was: %T`, phase1optionsAttribute))
	}

	phase2optionsAttribute, ok := attributes["phase2options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`phase2options is missing from object`)

		return nil, diags
	}

	phase2optionsVal, ok := phase2optionsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`phase2options expected to be basetypes.ObjectValue, was: %T`, phase2optionsAttribute))
	}

	tunnelInsideIpRangeAttribute, ok := attributes["tunnel_inside_ip_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tunnel_inside_ip_range is missing from object`)

		return nil, diags
	}

	tunnelInsideIpRangeVal, ok := tunnelInsideIpRangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tunnel_inside_ip_range expected to be basetypes.StringValue, was: %T`, tunnelInsideIpRangeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VpnOptionsValue{
		Phase1options:       phase1optionsVal,
		Phase2options:       phase2optionsVal,
		TunnelInsideIpRange: tunnelInsideIpRangeVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewVpnOptionsValueNull() VpnOptionsValue {
	return VpnOptionsValue{
		state: attr.ValueStateNull,
	}
}

func NewVpnOptionsValueUnknown() VpnOptionsValue {
	return VpnOptionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVpnOptionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VpnOptionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VpnOptionsValue Attribute Value",
				"While creating a VpnOptionsValue value, a missing attribute value was detected. "+
					"A VpnOptionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VpnOptionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VpnOptionsValue Attribute Type",
				"While creating a VpnOptionsValue value, an invalid attribute value was detected. "+
					"A VpnOptionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VpnOptionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VpnOptionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VpnOptionsValue Attribute Value",
				"While creating a VpnOptionsValue value, an extra attribute value was detected. "+
					"A VpnOptionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VpnOptionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVpnOptionsValueUnknown(), diags
	}

	phase1optionsAttribute, ok := attributes["phase1options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`phase1options is missing from object`)

		return NewVpnOptionsValueUnknown(), diags
	}

	phase1optionsVal, ok := phase1optionsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`phase1options expected to be basetypes.ObjectValue, was: %T`, phase1optionsAttribute))
	}

	phase2optionsAttribute, ok := attributes["phase2options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`phase2options is missing from object`)

		return NewVpnOptionsValueUnknown(), diags
	}

	phase2optionsVal, ok := phase2optionsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`phase2options expected to be basetypes.ObjectValue, was: %T`, phase2optionsAttribute))
	}

	tunnelInsideIpRangeAttribute, ok := attributes["tunnel_inside_ip_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tunnel_inside_ip_range is missing from object`)

		return NewVpnOptionsValueUnknown(), diags
	}

	tunnelInsideIpRangeVal, ok := tunnelInsideIpRangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tunnel_inside_ip_range expected to be basetypes.StringValue, was: %T`, tunnelInsideIpRangeAttribute))
	}

	if diags.HasError() {
		return NewVpnOptionsValueUnknown(), diags
	}

	return VpnOptionsValue{
		Phase1options:       phase1optionsVal,
		Phase2options:       phase2optionsVal,
		TunnelInsideIpRange: tunnelInsideIpRangeVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewVpnOptionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VpnOptionsValue {
	object, diags := NewVpnOptionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVpnOptionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VpnOptionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVpnOptionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVpnOptionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVpnOptionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVpnOptionsValueMust(VpnOptionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VpnOptionsType) ValueType(ctx context.Context) attr.Value {
	return VpnOptionsValue{}
}

var _ basetypes.ObjectValuable = VpnOptionsValue{}

type VpnOptionsValue struct {
	Phase1options       basetypes.ObjectValue `tfsdk:"phase1options"`
	Phase2options       basetypes.ObjectValue `tfsdk:"phase2options"`
	TunnelInsideIpRange basetypes.StringValue `tfsdk:"tunnel_inside_ip_range"`
	state               attr.ValueState
}

func (v VpnOptionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["phase1options"] = basetypes.ObjectType{
		AttrTypes: Phase1optionsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["phase2options"] = basetypes.ObjectType{
		AttrTypes: Phase2optionsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["tunnel_inside_ip_range"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Phase1options.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["phase1options"] = val

		val, err = v.Phase2options.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["phase2options"] = val

		val, err = v.TunnelInsideIpRange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tunnel_inside_ip_range"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VpnOptionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VpnOptionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VpnOptionsValue) String() string {
	return "VpnOptionsValue"
}

func (v VpnOptionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var phase1options basetypes.ObjectValue

	if v.Phase1options.IsNull() {
		phase1options = types.ObjectNull(
			Phase1optionsValue{}.AttributeTypes(ctx),
		)
	}

	if v.Phase1options.IsUnknown() {
		phase1options = types.ObjectUnknown(
			Phase1optionsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Phase1options.IsNull() && !v.Phase1options.IsUnknown() {
		phase1options = types.ObjectValueMust(
			Phase1optionsValue{}.AttributeTypes(ctx),
			v.Phase1options.Attributes(),
		)
	}

	var phase2options basetypes.ObjectValue

	if v.Phase2options.IsNull() {
		phase2options = types.ObjectNull(
			Phase2optionsValue{}.AttributeTypes(ctx),
		)
	}

	if v.Phase2options.IsUnknown() {
		phase2options = types.ObjectUnknown(
			Phase2optionsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Phase2options.IsNull() && !v.Phase2options.IsUnknown() {
		phase2options = types.ObjectValueMust(
			Phase2optionsValue{}.AttributeTypes(ctx),
			v.Phase2options.Attributes(),
		)
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"phase1options": basetypes.ObjectType{
				AttrTypes: Phase1optionsValue{}.AttributeTypes(ctx),
			},
			"phase2options": basetypes.ObjectType{
				AttrTypes: Phase2optionsValue{}.AttributeTypes(ctx),
			},
			"tunnel_inside_ip_range": basetypes.StringType{},
		},
		map[string]attr.Value{
			"phase1options":          phase1options,
			"phase2options":          phase2options,
			"tunnel_inside_ip_range": v.TunnelInsideIpRange,
		})

	return objVal, diags
}

func (v VpnOptionsValue) Equal(o attr.Value) bool {
	other, ok := o.(VpnOptionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Phase1options.Equal(other.Phase1options) {
		return false
	}

	if !v.Phase2options.Equal(other.Phase2options) {
		return false
	}

	if !v.TunnelInsideIpRange.Equal(other.TunnelInsideIpRange) {
		return false
	}

	return true
}

func (v VpnOptionsValue) Type(ctx context.Context) attr.Type {
	return VpnOptionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VpnOptionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"phase1options": basetypes.ObjectType{
			AttrTypes: Phase1optionsValue{}.AttributeTypes(ctx),
		},
		"phase2options": basetypes.ObjectType{
			AttrTypes: Phase2optionsValue{}.AttributeTypes(ctx),
		},
		"tunnel_inside_ip_range": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Phase1optionsType{}

type Phase1optionsType struct {
	basetypes.ObjectType
}

func (t Phase1optionsType) Equal(o attr.Type) bool {
	other, ok := o.(Phase1optionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Phase1optionsType) String() string {
	return "Phase1optionsType"
}

func (t Phase1optionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dpdTimeoutActionAttribute, ok := attributes["dpd_timeout_action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dpd_timeout_action is missing from object`)

		return nil, diags
	}

	dpdTimeoutActionVal, ok := dpdTimeoutActionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dpd_timeout_action expected to be basetypes.StringValue, was: %T`, dpdTimeoutActionAttribute))
	}

	dpdTimeoutSecondsAttribute, ok := attributes["dpd_timeout_seconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dpd_timeout_seconds is missing from object`)

		return nil, diags
	}

	dpdTimeoutSecondsVal, ok := dpdTimeoutSecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dpd_timeout_seconds expected to be basetypes.Int64Value, was: %T`, dpdTimeoutSecondsAttribute))
	}

	ikeVersionsAttribute, ok := attributes["ike_versions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ike_versions is missing from object`)

		return nil, diags
	}

	ikeVersionsVal, ok := ikeVersionsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ike_versions expected to be basetypes.ListValue, was: %T`, ikeVersionsAttribute))
	}

	phase1dhGroupNumbersAttribute, ok := attributes["phase1dh_group_numbers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`phase1dh_group_numbers is missing from object`)

		return nil, diags
	}

	phase1dhGroupNumbersVal, ok := phase1dhGroupNumbersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`phase1dh_group_numbers expected to be basetypes.ListValue, was: %T`, phase1dhGroupNumbersAttribute))
	}

	phase1encryptionAlgorithmsAttribute, ok := attributes["phase1encryption_algorithms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`phase1encryption_algorithms is missing from object`)

		return nil, diags
	}

	phase1encryptionAlgorithmsVal, ok := phase1encryptionAlgorithmsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`phase1encryption_algorithms expected to be basetypes.ListValue, was: %T`, phase1encryptionAlgorithmsAttribute))
	}

	phase1integrityAlgorithmsAttribute, ok := attributes["phase1integrity_algorithms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`phase1integrity_algorithms is missing from object`)

		return nil, diags
	}

	phase1integrityAlgorithmsVal, ok := phase1integrityAlgorithmsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`phase1integrity_algorithms expected to be basetypes.ListValue, was: %T`, phase1integrityAlgorithmsAttribute))
	}

	phase1lifetimeSecondsAttribute, ok := attributes["phase1lifetime_seconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`phase1lifetime_seconds is missing from object`)

		return nil, diags
	}

	phase1lifetimeSecondsVal, ok := phase1lifetimeSecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`phase1lifetime_seconds expected to be basetypes.Int64Value, was: %T`, phase1lifetimeSecondsAttribute))
	}

	replayWindowSizeAttribute, ok := attributes["replay_window_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`replay_window_size is missing from object`)

		return nil, diags
	}

	replayWindowSizeVal, ok := replayWindowSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`replay_window_size expected to be basetypes.Int64Value, was: %T`, replayWindowSizeAttribute))
	}

	startupActionAttribute, ok := attributes["startup_action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`startup_action is missing from object`)

		return nil, diags
	}

	startupActionVal, ok := startupActionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`startup_action expected to be basetypes.StringValue, was: %T`, startupActionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Phase1optionsValue{
		DpdTimeoutAction:           dpdTimeoutActionVal,
		DpdTimeoutSeconds:          dpdTimeoutSecondsVal,
		IkeVersions:                ikeVersionsVal,
		Phase1dhGroupNumbers:       phase1dhGroupNumbersVal,
		Phase1encryptionAlgorithms: phase1encryptionAlgorithmsVal,
		Phase1integrityAlgorithms:  phase1integrityAlgorithmsVal,
		Phase1lifetimeSeconds:      phase1lifetimeSecondsVal,
		ReplayWindowSize:           replayWindowSizeVal,
		StartupAction:              startupActionVal,
		state:                      attr.ValueStateKnown,
	}, diags
}

func NewPhase1optionsValueNull() Phase1optionsValue {
	return Phase1optionsValue{
		state: attr.ValueStateNull,
	}
}

func NewPhase1optionsValueUnknown() Phase1optionsValue {
	return Phase1optionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPhase1optionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Phase1optionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Phase1optionsValue Attribute Value",
				"While creating a Phase1optionsValue value, a missing attribute value was detected. "+
					"A Phase1optionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Phase1optionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Phase1optionsValue Attribute Type",
				"While creating a Phase1optionsValue value, an invalid attribute value was detected. "+
					"A Phase1optionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Phase1optionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Phase1optionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Phase1optionsValue Attribute Value",
				"While creating a Phase1optionsValue value, an extra attribute value was detected. "+
					"A Phase1optionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Phase1optionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPhase1optionsValueUnknown(), diags
	}

	dpdTimeoutActionAttribute, ok := attributes["dpd_timeout_action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dpd_timeout_action is missing from object`)

		return NewPhase1optionsValueUnknown(), diags
	}

	dpdTimeoutActionVal, ok := dpdTimeoutActionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dpd_timeout_action expected to be basetypes.StringValue, was: %T`, dpdTimeoutActionAttribute))
	}

	dpdTimeoutSecondsAttribute, ok := attributes["dpd_timeout_seconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dpd_timeout_seconds is missing from object`)

		return NewPhase1optionsValueUnknown(), diags
	}

	dpdTimeoutSecondsVal, ok := dpdTimeoutSecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dpd_timeout_seconds expected to be basetypes.Int64Value, was: %T`, dpdTimeoutSecondsAttribute))
	}

	ikeVersionsAttribute, ok := attributes["ike_versions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ike_versions is missing from object`)

		return NewPhase1optionsValueUnknown(), diags
	}

	ikeVersionsVal, ok := ikeVersionsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ike_versions expected to be basetypes.ListValue, was: %T`, ikeVersionsAttribute))
	}

	phase1dhGroupNumbersAttribute, ok := attributes["phase1dh_group_numbers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`phase1dh_group_numbers is missing from object`)

		return NewPhase1optionsValueUnknown(), diags
	}

	phase1dhGroupNumbersVal, ok := phase1dhGroupNumbersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`phase1dh_group_numbers expected to be basetypes.ListValue, was: %T`, phase1dhGroupNumbersAttribute))
	}

	phase1encryptionAlgorithmsAttribute, ok := attributes["phase1encryption_algorithms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`phase1encryption_algorithms is missing from object`)

		return NewPhase1optionsValueUnknown(), diags
	}

	phase1encryptionAlgorithmsVal, ok := phase1encryptionAlgorithmsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`phase1encryption_algorithms expected to be basetypes.ListValue, was: %T`, phase1encryptionAlgorithmsAttribute))
	}

	phase1integrityAlgorithmsAttribute, ok := attributes["phase1integrity_algorithms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`phase1integrity_algorithms is missing from object`)

		return NewPhase1optionsValueUnknown(), diags
	}

	phase1integrityAlgorithmsVal, ok := phase1integrityAlgorithmsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`phase1integrity_algorithms expected to be basetypes.ListValue, was: %T`, phase1integrityAlgorithmsAttribute))
	}

	phase1lifetimeSecondsAttribute, ok := attributes["phase1lifetime_seconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`phase1lifetime_seconds is missing from object`)

		return NewPhase1optionsValueUnknown(), diags
	}

	phase1lifetimeSecondsVal, ok := phase1lifetimeSecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`phase1lifetime_seconds expected to be basetypes.Int64Value, was: %T`, phase1lifetimeSecondsAttribute))
	}

	replayWindowSizeAttribute, ok := attributes["replay_window_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`replay_window_size is missing from object`)

		return NewPhase1optionsValueUnknown(), diags
	}

	replayWindowSizeVal, ok := replayWindowSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`replay_window_size expected to be basetypes.Int64Value, was: %T`, replayWindowSizeAttribute))
	}

	startupActionAttribute, ok := attributes["startup_action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`startup_action is missing from object`)

		return NewPhase1optionsValueUnknown(), diags
	}

	startupActionVal, ok := startupActionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`startup_action expected to be basetypes.StringValue, was: %T`, startupActionAttribute))
	}

	if diags.HasError() {
		return NewPhase1optionsValueUnknown(), diags
	}

	return Phase1optionsValue{
		DpdTimeoutAction:           dpdTimeoutActionVal,
		DpdTimeoutSeconds:          dpdTimeoutSecondsVal,
		IkeVersions:                ikeVersionsVal,
		Phase1dhGroupNumbers:       phase1dhGroupNumbersVal,
		Phase1encryptionAlgorithms: phase1encryptionAlgorithmsVal,
		Phase1integrityAlgorithms:  phase1integrityAlgorithmsVal,
		Phase1lifetimeSeconds:      phase1lifetimeSecondsVal,
		ReplayWindowSize:           replayWindowSizeVal,
		StartupAction:              startupActionVal,
		state:                      attr.ValueStateKnown,
	}, diags
}

func NewPhase1optionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Phase1optionsValue {
	object, diags := NewPhase1optionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPhase1optionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Phase1optionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPhase1optionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPhase1optionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPhase1optionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPhase1optionsValueMust(Phase1optionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t Phase1optionsType) ValueType(ctx context.Context) attr.Value {
	return Phase1optionsValue{}
}

var _ basetypes.ObjectValuable = Phase1optionsValue{}

type Phase1optionsValue struct {
	DpdTimeoutAction           basetypes.StringValue `tfsdk:"dpd_timeout_action"`
	DpdTimeoutSeconds          basetypes.Int64Value  `tfsdk:"dpd_timeout_seconds"`
	IkeVersions                basetypes.ListValue   `tfsdk:"ike_versions"`
	Phase1dhGroupNumbers       basetypes.ListValue   `tfsdk:"phase1dh_group_numbers"`
	Phase1encryptionAlgorithms basetypes.ListValue   `tfsdk:"phase1encryption_algorithms"`
	Phase1integrityAlgorithms  basetypes.ListValue   `tfsdk:"phase1integrity_algorithms"`
	Phase1lifetimeSeconds      basetypes.Int64Value  `tfsdk:"phase1lifetime_seconds"`
	ReplayWindowSize           basetypes.Int64Value  `tfsdk:"replay_window_size"`
	StartupAction              basetypes.StringValue `tfsdk:"startup_action"`
	state                      attr.ValueState
}

func (v Phase1optionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["dpd_timeout_action"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dpd_timeout_seconds"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ike_versions"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["phase1dh_group_numbers"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["phase1encryption_algorithms"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["phase1integrity_algorithms"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["phase1lifetime_seconds"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["replay_window_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["startup_action"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.DpdTimeoutAction.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dpd_timeout_action"] = val

		val, err = v.DpdTimeoutSeconds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dpd_timeout_seconds"] = val

		val, err = v.IkeVersions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ike_versions"] = val

		val, err = v.Phase1dhGroupNumbers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["phase1dh_group_numbers"] = val

		val, err = v.Phase1encryptionAlgorithms.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["phase1encryption_algorithms"] = val

		val, err = v.Phase1integrityAlgorithms.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["phase1integrity_algorithms"] = val

		val, err = v.Phase1lifetimeSeconds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["phase1lifetime_seconds"] = val

		val, err = v.ReplayWindowSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["replay_window_size"] = val

		val, err = v.StartupAction.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["startup_action"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Phase1optionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Phase1optionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Phase1optionsValue) String() string {
	return "Phase1optionsValue"
}

func (v Phase1optionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	ikeVersionsVal, d := types.ListValue(types.StringType, v.IkeVersions.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dpd_timeout_action":  basetypes.StringType{},
			"dpd_timeout_seconds": basetypes.Int64Type{},
			"ike_versions": basetypes.ListType{
				ElemType: types.StringType,
			},
			"phase1dh_group_numbers": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"phase1encryption_algorithms": basetypes.ListType{
				ElemType: types.StringType,
			},
			"phase1integrity_algorithms": basetypes.ListType{
				ElemType: types.StringType,
			},
			"phase1lifetime_seconds": basetypes.Int64Type{},
			"replay_window_size":     basetypes.Int64Type{},
			"startup_action":         basetypes.StringType{},
		}), diags
	}

	phase1dhGroupNumbersVal, d := types.ListValue(types.Int64Type, v.Phase1dhGroupNumbers.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dpd_timeout_action":  basetypes.StringType{},
			"dpd_timeout_seconds": basetypes.Int64Type{},
			"ike_versions": basetypes.ListType{
				ElemType: types.StringType,
			},
			"phase1dh_group_numbers": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"phase1encryption_algorithms": basetypes.ListType{
				ElemType: types.StringType,
			},
			"phase1integrity_algorithms": basetypes.ListType{
				ElemType: types.StringType,
			},
			"phase1lifetime_seconds": basetypes.Int64Type{},
			"replay_window_size":     basetypes.Int64Type{},
			"startup_action":         basetypes.StringType{},
		}), diags
	}

	phase1encryptionAlgorithmsVal, d := types.ListValue(types.StringType, v.Phase1encryptionAlgorithms.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dpd_timeout_action":  basetypes.StringType{},
			"dpd_timeout_seconds": basetypes.Int64Type{},
			"ike_versions": basetypes.ListType{
				ElemType: types.StringType,
			},
			"phase1dh_group_numbers": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"phase1encryption_algorithms": basetypes.ListType{
				ElemType: types.StringType,
			},
			"phase1integrity_algorithms": basetypes.ListType{
				ElemType: types.StringType,
			},
			"phase1lifetime_seconds": basetypes.Int64Type{},
			"replay_window_size":     basetypes.Int64Type{},
			"startup_action":         basetypes.StringType{},
		}), diags
	}

	phase1integrityAlgorithmsVal, d := types.ListValue(types.StringType, v.Phase1integrityAlgorithms.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dpd_timeout_action":  basetypes.StringType{},
			"dpd_timeout_seconds": basetypes.Int64Type{},
			"ike_versions": basetypes.ListType{
				ElemType: types.StringType,
			},
			"phase1dh_group_numbers": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"phase1encryption_algorithms": basetypes.ListType{
				ElemType: types.StringType,
			},
			"phase1integrity_algorithms": basetypes.ListType{
				ElemType: types.StringType,
			},
			"phase1lifetime_seconds": basetypes.Int64Type{},
			"replay_window_size":     basetypes.Int64Type{},
			"startup_action":         basetypes.StringType{},
		}), diags
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"dpd_timeout_action":  basetypes.StringType{},
			"dpd_timeout_seconds": basetypes.Int64Type{},
			"ike_versions": basetypes.ListType{
				ElemType: types.StringType,
			},
			"phase1dh_group_numbers": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"phase1encryption_algorithms": basetypes.ListType{
				ElemType: types.StringType,
			},
			"phase1integrity_algorithms": basetypes.ListType{
				ElemType: types.StringType,
			},
			"phase1lifetime_seconds": basetypes.Int64Type{},
			"replay_window_size":     basetypes.Int64Type{},
			"startup_action":         basetypes.StringType{},
		},
		map[string]attr.Value{
			"dpd_timeout_action":          v.DpdTimeoutAction,
			"dpd_timeout_seconds":         v.DpdTimeoutSeconds,
			"ike_versions":                ikeVersionsVal,
			"phase1dh_group_numbers":      phase1dhGroupNumbersVal,
			"phase1encryption_algorithms": phase1encryptionAlgorithmsVal,
			"phase1integrity_algorithms":  phase1integrityAlgorithmsVal,
			"phase1lifetime_seconds":      v.Phase1lifetimeSeconds,
			"replay_window_size":          v.ReplayWindowSize,
			"startup_action":              v.StartupAction,
		})

	return objVal, diags
}

func (v Phase1optionsValue) Equal(o attr.Value) bool {
	other, ok := o.(Phase1optionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DpdTimeoutAction.Equal(other.DpdTimeoutAction) {
		return false
	}

	if !v.DpdTimeoutSeconds.Equal(other.DpdTimeoutSeconds) {
		return false
	}

	if !v.IkeVersions.Equal(other.IkeVersions) {
		return false
	}

	if !v.Phase1dhGroupNumbers.Equal(other.Phase1dhGroupNumbers) {
		return false
	}

	if !v.Phase1encryptionAlgorithms.Equal(other.Phase1encryptionAlgorithms) {
		return false
	}

	if !v.Phase1integrityAlgorithms.Equal(other.Phase1integrityAlgorithms) {
		return false
	}

	if !v.Phase1lifetimeSeconds.Equal(other.Phase1lifetimeSeconds) {
		return false
	}

	if !v.ReplayWindowSize.Equal(other.ReplayWindowSize) {
		return false
	}

	if !v.StartupAction.Equal(other.StartupAction) {
		return false
	}

	return true
}

func (v Phase1optionsValue) Type(ctx context.Context) attr.Type {
	return Phase1optionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Phase1optionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"dpd_timeout_action":  basetypes.StringType{},
		"dpd_timeout_seconds": basetypes.Int64Type{},
		"ike_versions": basetypes.ListType{
			ElemType: types.StringType,
		},
		"phase1dh_group_numbers": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"phase1encryption_algorithms": basetypes.ListType{
			ElemType: types.StringType,
		},
		"phase1integrity_algorithms": basetypes.ListType{
			ElemType: types.StringType,
		},
		"phase1lifetime_seconds": basetypes.Int64Type{},
		"replay_window_size":     basetypes.Int64Type{},
		"startup_action":         basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Phase2optionsType{}

type Phase2optionsType struct {
	basetypes.ObjectType
}

func (t Phase2optionsType) Equal(o attr.Type) bool {
	other, ok := o.(Phase2optionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Phase2optionsType) String() string {
	return "Phase2optionsType"
}

func (t Phase2optionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	phase2dhGroupNumbersAttribute, ok := attributes["phase2dh_group_numbers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`phase2dh_group_numbers is missing from object`)

		return nil, diags
	}

	phase2dhGroupNumbersVal, ok := phase2dhGroupNumbersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`phase2dh_group_numbers expected to be basetypes.ListValue, was: %T`, phase2dhGroupNumbersAttribute))
	}

	phase2encryptionAlgorithmsAttribute, ok := attributes["phase2encryption_algorithms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`phase2encryption_algorithms is missing from object`)

		return nil, diags
	}

	phase2encryptionAlgorithmsVal, ok := phase2encryptionAlgorithmsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`phase2encryption_algorithms expected to be basetypes.ListValue, was: %T`, phase2encryptionAlgorithmsAttribute))
	}

	phase2integrityAlgorithmsAttribute, ok := attributes["phase2integrity_algorithms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`phase2integrity_algorithms is missing from object`)

		return nil, diags
	}

	phase2integrityAlgorithmsVal, ok := phase2integrityAlgorithmsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`phase2integrity_algorithms expected to be basetypes.ListValue, was: %T`, phase2integrityAlgorithmsAttribute))
	}

	phase2lifetimeSecondsAttribute, ok := attributes["phase2lifetime_seconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`phase2lifetime_seconds is missing from object`)

		return nil, diags
	}

	phase2lifetimeSecondsVal, ok := phase2lifetimeSecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`phase2lifetime_seconds expected to be basetypes.Int64Value, was: %T`, phase2lifetimeSecondsAttribute))
	}

	preSharedKeyAttribute, ok := attributes["pre_shared_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pre_shared_key is missing from object`)

		return nil, diags
	}

	preSharedKeyVal, ok := preSharedKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pre_shared_key expected to be basetypes.StringValue, was: %T`, preSharedKeyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Phase2optionsValue{
		Phase2dhGroupNumbers:       phase2dhGroupNumbersVal,
		Phase2encryptionAlgorithms: phase2encryptionAlgorithmsVal,
		Phase2integrityAlgorithms:  phase2integrityAlgorithmsVal,
		Phase2lifetimeSeconds:      phase2lifetimeSecondsVal,
		PreSharedKey:               preSharedKeyVal,
		state:                      attr.ValueStateKnown,
	}, diags
}

func NewPhase2optionsValueNull() Phase2optionsValue {
	return Phase2optionsValue{
		state: attr.ValueStateNull,
	}
}

func NewPhase2optionsValueUnknown() Phase2optionsValue {
	return Phase2optionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPhase2optionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Phase2optionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Phase2optionsValue Attribute Value",
				"While creating a Phase2optionsValue value, a missing attribute value was detected. "+
					"A Phase2optionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Phase2optionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Phase2optionsValue Attribute Type",
				"While creating a Phase2optionsValue value, an invalid attribute value was detected. "+
					"A Phase2optionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Phase2optionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Phase2optionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Phase2optionsValue Attribute Value",
				"While creating a Phase2optionsValue value, an extra attribute value was detected. "+
					"A Phase2optionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Phase2optionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPhase2optionsValueUnknown(), diags
	}

	phase2dhGroupNumbersAttribute, ok := attributes["phase2dh_group_numbers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`phase2dh_group_numbers is missing from object`)

		return NewPhase2optionsValueUnknown(), diags
	}

	phase2dhGroupNumbersVal, ok := phase2dhGroupNumbersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`phase2dh_group_numbers expected to be basetypes.ListValue, was: %T`, phase2dhGroupNumbersAttribute))
	}

	phase2encryptionAlgorithmsAttribute, ok := attributes["phase2encryption_algorithms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`phase2encryption_algorithms is missing from object`)

		return NewPhase2optionsValueUnknown(), diags
	}

	phase2encryptionAlgorithmsVal, ok := phase2encryptionAlgorithmsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`phase2encryption_algorithms expected to be basetypes.ListValue, was: %T`, phase2encryptionAlgorithmsAttribute))
	}

	phase2integrityAlgorithmsAttribute, ok := attributes["phase2integrity_algorithms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`phase2integrity_algorithms is missing from object`)

		return NewPhase2optionsValueUnknown(), diags
	}

	phase2integrityAlgorithmsVal, ok := phase2integrityAlgorithmsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`phase2integrity_algorithms expected to be basetypes.ListValue, was: %T`, phase2integrityAlgorithmsAttribute))
	}

	phase2lifetimeSecondsAttribute, ok := attributes["phase2lifetime_seconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`phase2lifetime_seconds is missing from object`)

		return NewPhase2optionsValueUnknown(), diags
	}

	phase2lifetimeSecondsVal, ok := phase2lifetimeSecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`phase2lifetime_seconds expected to be basetypes.Int64Value, was: %T`, phase2lifetimeSecondsAttribute))
	}

	preSharedKeyAttribute, ok := attributes["pre_shared_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pre_shared_key is missing from object`)

		return NewPhase2optionsValueUnknown(), diags
	}

	preSharedKeyVal, ok := preSharedKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pre_shared_key expected to be basetypes.StringValue, was: %T`, preSharedKeyAttribute))
	}

	if diags.HasError() {
		return NewPhase2optionsValueUnknown(), diags
	}

	return Phase2optionsValue{
		Phase2dhGroupNumbers:       phase2dhGroupNumbersVal,
		Phase2encryptionAlgorithms: phase2encryptionAlgorithmsVal,
		Phase2integrityAlgorithms:  phase2integrityAlgorithmsVal,
		Phase2lifetimeSeconds:      phase2lifetimeSecondsVal,
		PreSharedKey:               preSharedKeyVal,
		state:                      attr.ValueStateKnown,
	}, diags
}

func NewPhase2optionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Phase2optionsValue {
	object, diags := NewPhase2optionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPhase2optionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Phase2optionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPhase2optionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPhase2optionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPhase2optionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPhase2optionsValueMust(Phase2optionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t Phase2optionsType) ValueType(ctx context.Context) attr.Value {
	return Phase2optionsValue{}
}

var _ basetypes.ObjectValuable = Phase2optionsValue{}

type Phase2optionsValue struct {
	Phase2dhGroupNumbers       basetypes.ListValue   `tfsdk:"phase2dh_group_numbers"`
	Phase2encryptionAlgorithms basetypes.ListValue   `tfsdk:"phase2encryption_algorithms"`
	Phase2integrityAlgorithms  basetypes.ListValue   `tfsdk:"phase2integrity_algorithms"`
	Phase2lifetimeSeconds      basetypes.Int64Value  `tfsdk:"phase2lifetime_seconds"`
	PreSharedKey               basetypes.StringValue `tfsdk:"pre_shared_key"`
	state                      attr.ValueState
}

func (v Phase2optionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["phase2dh_group_numbers"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["phase2encryption_algorithms"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["phase2integrity_algorithms"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["phase2lifetime_seconds"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["pre_shared_key"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Phase2dhGroupNumbers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["phase2dh_group_numbers"] = val

		val, err = v.Phase2encryptionAlgorithms.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["phase2encryption_algorithms"] = val

		val, err = v.Phase2integrityAlgorithms.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["phase2integrity_algorithms"] = val

		val, err = v.Phase2lifetimeSeconds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["phase2lifetime_seconds"] = val

		val, err = v.PreSharedKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pre_shared_key"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Phase2optionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Phase2optionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Phase2optionsValue) String() string {
	return "Phase2optionsValue"
}

func (v Phase2optionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	phase2dhGroupNumbersVal, d := types.ListValue(types.Int64Type, v.Phase2dhGroupNumbers.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"phase2dh_group_numbers": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"phase2encryption_algorithms": basetypes.ListType{
				ElemType: types.StringType,
			},
			"phase2integrity_algorithms": basetypes.ListType{
				ElemType: types.StringType,
			},
			"phase2lifetime_seconds": basetypes.Int64Type{},
			"pre_shared_key":         basetypes.StringType{},
		}), diags
	}

	phase2encryptionAlgorithmsVal, d := types.ListValue(types.StringType, v.Phase2encryptionAlgorithms.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"phase2dh_group_numbers": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"phase2encryption_algorithms": basetypes.ListType{
				ElemType: types.StringType,
			},
			"phase2integrity_algorithms": basetypes.ListType{
				ElemType: types.StringType,
			},
			"phase2lifetime_seconds": basetypes.Int64Type{},
			"pre_shared_key":         basetypes.StringType{},
		}), diags
	}

	phase2integrityAlgorithmsVal, d := types.ListValue(types.StringType, v.Phase2integrityAlgorithms.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"phase2dh_group_numbers": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"phase2encryption_algorithms": basetypes.ListType{
				ElemType: types.StringType,
			},
			"phase2integrity_algorithms": basetypes.ListType{
				ElemType: types.StringType,
			},
			"phase2lifetime_seconds": basetypes.Int64Type{},
			"pre_shared_key":         basetypes.StringType{},
		}), diags
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"phase2dh_group_numbers": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"phase2encryption_algorithms": basetypes.ListType{
				ElemType: types.StringType,
			},
			"phase2integrity_algorithms": basetypes.ListType{
				ElemType: types.StringType,
			},
			"phase2lifetime_seconds": basetypes.Int64Type{},
			"pre_shared_key":         basetypes.StringType{},
		},
		map[string]attr.Value{
			"phase2dh_group_numbers":      phase2dhGroupNumbersVal,
			"phase2encryption_algorithms": phase2encryptionAlgorithmsVal,
			"phase2integrity_algorithms":  phase2integrityAlgorithmsVal,
			"phase2lifetime_seconds":      v.Phase2lifetimeSeconds,
			"pre_shared_key":              v.PreSharedKey,
		})

	return objVal, diags
}

func (v Phase2optionsValue) Equal(o attr.Value) bool {
	other, ok := o.(Phase2optionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Phase2dhGroupNumbers.Equal(other.Phase2dhGroupNumbers) {
		return false
	}

	if !v.Phase2encryptionAlgorithms.Equal(other.Phase2encryptionAlgorithms) {
		return false
	}

	if !v.Phase2integrityAlgorithms.Equal(other.Phase2integrityAlgorithms) {
		return false
	}

	if !v.Phase2lifetimeSeconds.Equal(other.Phase2lifetimeSeconds) {
		return false
	}

	if !v.PreSharedKey.Equal(other.PreSharedKey) {
		return false
	}

	return true
}

func (v Phase2optionsValue) Type(ctx context.Context) attr.Type {
	return Phase2optionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Phase2optionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"phase2dh_group_numbers": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"phase2encryption_algorithms": basetypes.ListType{
			ElemType: types.StringType,
		},
		"phase2integrity_algorithms": basetypes.ListType{
			ElemType: types.StringType,
		},
		"phase2lifetime_seconds": basetypes.Int64Type{},
		"pre_shared_key":         basetypes.StringType{},
	}
}
