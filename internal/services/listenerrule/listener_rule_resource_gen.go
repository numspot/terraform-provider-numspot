// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package listenerrule

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func ListenerRuleResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"action": schema.StringAttribute{
				Computed:            true,
				Description:         "The type of action for the rule (always `forward`).",
				MarkdownDescription: "The type of action for the rule (always `forward`).",
			},
			"host_name_pattern": schema.StringAttribute{
				Computed:            true,
				Description:         "A host-name pattern for the rule, with a maximum length of 128 characters. This host-name pattern supports maximum three wildcards, and must not contain any special characters except [-.?].",
				MarkdownDescription: "A host-name pattern for the rule, with a maximum length of 128 characters. This host-name pattern supports maximum three wildcards, and must not contain any special characters except [-.?].",
			},
			"id": schema.Int64Attribute{
				Computed:            true,
				Description:         "The ID of the listener rule.",
				MarkdownDescription: "The ID of the listener rule.",
			},
			"listener": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"load_balancer_name": schema.StringAttribute{
						Required:            true,
						Description:         "The name of the load balancer to which the listener is attached.",
						MarkdownDescription: "The name of the load balancer to which the listener is attached.",
					},
					"load_balancer_port": schema.Int64Attribute{
						Required:            true,
						Description:         "The port of load balancer on which the load balancer is listening (between `1` and `65535` both included).",
						MarkdownDescription: "The port of load balancer on which the load balancer is listening (between `1` and `65535` both included).",
					},
				},
				CustomType: ListenerType{
					ObjectType: types.ObjectType{
						AttrTypes: ListenerValue{}.AttributeTypes(ctx),
					},
				},
				Required:            true,
				Description:         "Information about the load balancer.",
				MarkdownDescription: "Information about the load balancer.",
			},
			"listener_id": schema.Int64Attribute{
				Computed:            true,
				Description:         "The ID of the listener.",
				MarkdownDescription: "The ID of the listener.",
			},
			"listener_rule": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"action": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The type of action for the rule (always `forward`).",
						MarkdownDescription: "The type of action for the rule (always `forward`).",
					},
					"host_name_pattern": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "A host-name pattern for the rule, with a maximum length of 128 characters. This host-name pattern supports maximum three wildcards, and must not contain any special characters except [-.?]. ",
						MarkdownDescription: "A host-name pattern for the rule, with a maximum length of 128 characters. This host-name pattern supports maximum three wildcards, and must not contain any special characters except [-.?]. ",
					},
					"listener_rule_name": schema.StringAttribute{
						Required:            true,
						Description:         "A human-readable name for the listener rule.",
						MarkdownDescription: "A human-readable name for the listener rule.",
					},
					"path_pattern": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "A path pattern for the rule, with a maximum length of 128 characters. This path pattern supports maximum three wildcards, and must not contain any special characters except [_-.$/~\"'@:+?].",
						MarkdownDescription: "A path pattern for the rule, with a maximum length of 128 characters. This path pattern supports maximum three wildcards, and must not contain any special characters except [_-.$/~\"'@:+?].",
					},
					"priority": schema.Int64Attribute{
						Required:            true,
						Description:         "The priority level of the listener rule, between `1` and `19999` both included. Each rule must have a unique priority level. Otherwise, an error is returned.",
						MarkdownDescription: "The priority level of the listener rule, between `1` and `19999` both included. Each rule must have a unique priority level. Otherwise, an error is returned.",
					},
				},
				CustomType: ListenerRuleType{
					ObjectType: types.ObjectType{
						AttrTypes: ListenerRuleValue{}.AttributeTypes(ctx),
					},
				},
				Required:            true,
				Description:         "Information about the listener rule.",
				MarkdownDescription: "Information about the listener rule.",
			},
			"name": schema.StringAttribute{
				Computed:            true,
				Description:         "A human-readable name for the listener rule.",
				MarkdownDescription: "A human-readable name for the listener rule.",
			},
			"path_pattern": schema.StringAttribute{
				Computed:            true,
				Description:         "A path pattern for the rule, with a maximum length of 128 characters. This path pattern supports maximum three wildcards, and must not contain any special characters except [_-.$/~\"'@:+?].",
				MarkdownDescription: "A path pattern for the rule, with a maximum length of 128 characters. This path pattern supports maximum three wildcards, and must not contain any special characters except [_-.$/~\"'@:+?].",
			},
			"priority": schema.Int64Attribute{
				Computed:            true,
				Description:         "The priority level of the listener rule, between `1` and `19999` both included. Each rule must have a unique priority level. Otherwise, an error is returned.",
				MarkdownDescription: "The priority level of the listener rule, between `1` and `19999` both included. Each rule must have a unique priority level. Otherwise, an error is returned.",
			},
			"vm_ids": schema.ListAttribute{
				ElementType:         types.StringType,
				Required:            true,
				Description:         "The IDs of the backend VMs.",
				MarkdownDescription: "The IDs of the backend VMs.",
			},
		},
		MarkdownDescription: "This resource is not implemented yet. Please consider not using it.",
		DeprecationMessage:  "Managing IAAS services with Terraform is deprecated",
	}
}

type ListenerRuleModel struct {
	Action          types.String      `tfsdk:"action"`
	HostNamePattern types.String      `tfsdk:"host_name_pattern"`
	Id              types.Int64       `tfsdk:"id"`
	Listener        ListenerValue     `tfsdk:"listener"`
	ListenerId      types.Int64       `tfsdk:"listener_id"`
	ListenerRule    ListenerRuleValue `tfsdk:"listener_rule"`
	Name            types.String      `tfsdk:"name"`
	PathPattern     types.String      `tfsdk:"path_pattern"`
	Priority        types.Int64       `tfsdk:"priority"`
	VmIds           types.List        `tfsdk:"vm_ids"`
}

var _ basetypes.ObjectTypable = ListenerType{}

type ListenerType struct {
	basetypes.ObjectType
}

func (t ListenerType) Equal(o attr.Type) bool {
	other, ok := o.(ListenerType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ListenerType) String() string {
	return "ListenerType"
}

func (t ListenerType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	loadBalancerNameAttribute, ok := attributes["load_balancer_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`load_balancer_name is missing from object`)

		return nil, diags
	}

	loadBalancerNameVal, ok := loadBalancerNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`load_balancer_name expected to be basetypes.StringValue, was: %T`, loadBalancerNameAttribute))
	}

	loadBalancerPortAttribute, ok := attributes["load_balancer_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`load_balancer_port is missing from object`)

		return nil, diags
	}

	loadBalancerPortVal, ok := loadBalancerPortAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`load_balancer_port expected to be basetypes.Int64Value, was: %T`, loadBalancerPortAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ListenerValue{
		LoadBalancerName: loadBalancerNameVal,
		LoadBalancerPort: loadBalancerPortVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewListenerValueNull() ListenerValue {
	return ListenerValue{
		state: attr.ValueStateNull,
	}
}

func NewListenerValueUnknown() ListenerValue {
	return ListenerValue{
		state: attr.ValueStateUnknown,
	}
}

func NewListenerValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ListenerValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ListenerValue Attribute Value",
				"While creating a ListenerValue value, a missing attribute value was detected. "+
					"A ListenerValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ListenerValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ListenerValue Attribute Type",
				"While creating a ListenerValue value, an invalid attribute value was detected. "+
					"A ListenerValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ListenerValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ListenerValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ListenerValue Attribute Value",
				"While creating a ListenerValue value, an extra attribute value was detected. "+
					"A ListenerValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ListenerValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewListenerValueUnknown(), diags
	}

	loadBalancerNameAttribute, ok := attributes["load_balancer_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`load_balancer_name is missing from object`)

		return NewListenerValueUnknown(), diags
	}

	loadBalancerNameVal, ok := loadBalancerNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`load_balancer_name expected to be basetypes.StringValue, was: %T`, loadBalancerNameAttribute))
	}

	loadBalancerPortAttribute, ok := attributes["load_balancer_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`load_balancer_port is missing from object`)

		return NewListenerValueUnknown(), diags
	}

	loadBalancerPortVal, ok := loadBalancerPortAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`load_balancer_port expected to be basetypes.Int64Value, was: %T`, loadBalancerPortAttribute))
	}

	if diags.HasError() {
		return NewListenerValueUnknown(), diags
	}

	return ListenerValue{
		LoadBalancerName: loadBalancerNameVal,
		LoadBalancerPort: loadBalancerPortVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewListenerValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ListenerValue {
	object, diags := NewListenerValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewListenerValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ListenerType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewListenerValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewListenerValueUnknown(), nil
	}

	if in.IsNull() {
		return NewListenerValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewListenerValueMust(ListenerValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ListenerType) ValueType(ctx context.Context) attr.Value {
	return ListenerValue{}
}

var _ basetypes.ObjectValuable = ListenerValue{}

type ListenerValue struct {
	LoadBalancerName basetypes.StringValue `tfsdk:"load_balancer_name"`
	LoadBalancerPort basetypes.Int64Value  `tfsdk:"load_balancer_port"`
	state            attr.ValueState
}

func (v ListenerValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["load_balancer_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["load_balancer_port"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.LoadBalancerName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["load_balancer_name"] = val

		val, err = v.LoadBalancerPort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["load_balancer_port"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ListenerValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ListenerValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ListenerValue) String() string {
	return "ListenerValue"
}

func (v ListenerValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"load_balancer_name": basetypes.StringType{},
			"load_balancer_port": basetypes.Int64Type{},
		},
		map[string]attr.Value{
			"load_balancer_name": v.LoadBalancerName,
			"load_balancer_port": v.LoadBalancerPort,
		})

	return objVal, diags
}

func (v ListenerValue) Equal(o attr.Value) bool {
	other, ok := o.(ListenerValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.LoadBalancerName.Equal(other.LoadBalancerName) {
		return false
	}

	if !v.LoadBalancerPort.Equal(other.LoadBalancerPort) {
		return false
	}

	return true
}

func (v ListenerValue) Type(ctx context.Context) attr.Type {
	return ListenerType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ListenerValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"load_balancer_name": basetypes.StringType{},
		"load_balancer_port": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = ListenerRuleType{}

type ListenerRuleType struct {
	basetypes.ObjectType
}

func (t ListenerRuleType) Equal(o attr.Type) bool {
	other, ok := o.(ListenerRuleType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ListenerRuleType) String() string {
	return "ListenerRuleType"
}

func (t ListenerRuleType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return nil, diags
	}

	actionVal, ok := actionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.StringValue, was: %T`, actionAttribute))
	}

	hostNamePatternAttribute, ok := attributes["host_name_pattern"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host_name_pattern is missing from object`)

		return nil, diags
	}

	hostNamePatternVal, ok := hostNamePatternAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host_name_pattern expected to be basetypes.StringValue, was: %T`, hostNamePatternAttribute))
	}

	listenerRuleNameAttribute, ok := attributes["listener_rule_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`listener_rule_name is missing from object`)

		return nil, diags
	}

	listenerRuleNameVal, ok := listenerRuleNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`listener_rule_name expected to be basetypes.StringValue, was: %T`, listenerRuleNameAttribute))
	}

	pathPatternAttribute, ok := attributes["path_pattern"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`path_pattern is missing from object`)

		return nil, diags
	}

	pathPatternVal, ok := pathPatternAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`path_pattern expected to be basetypes.StringValue, was: %T`, pathPatternAttribute))
	}

	priorityAttribute, ok := attributes["priority"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`priority is missing from object`)

		return nil, diags
	}

	priorityVal, ok := priorityAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`priority expected to be basetypes.Int64Value, was: %T`, priorityAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ListenerRuleValue{
		Action:           actionVal,
		HostNamePattern:  hostNamePatternVal,
		ListenerRuleName: listenerRuleNameVal,
		PathPattern:      pathPatternVal,
		Priority:         priorityVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewListenerRuleValueNull() ListenerRuleValue {
	return ListenerRuleValue{
		state: attr.ValueStateNull,
	}
}

func NewListenerRuleValueUnknown() ListenerRuleValue {
	return ListenerRuleValue{
		state: attr.ValueStateUnknown,
	}
}

func NewListenerRuleValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ListenerRuleValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ListenerRuleValue Attribute Value",
				"While creating a ListenerRuleValue value, a missing attribute value was detected. "+
					"A ListenerRuleValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ListenerRuleValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ListenerRuleValue Attribute Type",
				"While creating a ListenerRuleValue value, an invalid attribute value was detected. "+
					"A ListenerRuleValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ListenerRuleValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ListenerRuleValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ListenerRuleValue Attribute Value",
				"While creating a ListenerRuleValue value, an extra attribute value was detected. "+
					"A ListenerRuleValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ListenerRuleValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewListenerRuleValueUnknown(), diags
	}

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return NewListenerRuleValueUnknown(), diags
	}

	actionVal, ok := actionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.StringValue, was: %T`, actionAttribute))
	}

	hostNamePatternAttribute, ok := attributes["host_name_pattern"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host_name_pattern is missing from object`)

		return NewListenerRuleValueUnknown(), diags
	}

	hostNamePatternVal, ok := hostNamePatternAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host_name_pattern expected to be basetypes.StringValue, was: %T`, hostNamePatternAttribute))
	}

	listenerRuleNameAttribute, ok := attributes["listener_rule_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`listener_rule_name is missing from object`)

		return NewListenerRuleValueUnknown(), diags
	}

	listenerRuleNameVal, ok := listenerRuleNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`listener_rule_name expected to be basetypes.StringValue, was: %T`, listenerRuleNameAttribute))
	}

	pathPatternAttribute, ok := attributes["path_pattern"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`path_pattern is missing from object`)

		return NewListenerRuleValueUnknown(), diags
	}

	pathPatternVal, ok := pathPatternAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`path_pattern expected to be basetypes.StringValue, was: %T`, pathPatternAttribute))
	}

	priorityAttribute, ok := attributes["priority"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`priority is missing from object`)

		return NewListenerRuleValueUnknown(), diags
	}

	priorityVal, ok := priorityAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`priority expected to be basetypes.Int64Value, was: %T`, priorityAttribute))
	}

	if diags.HasError() {
		return NewListenerRuleValueUnknown(), diags
	}

	return ListenerRuleValue{
		Action:           actionVal,
		HostNamePattern:  hostNamePatternVal,
		ListenerRuleName: listenerRuleNameVal,
		PathPattern:      pathPatternVal,
		Priority:         priorityVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewListenerRuleValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ListenerRuleValue {
	object, diags := NewListenerRuleValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewListenerRuleValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ListenerRuleType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewListenerRuleValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewListenerRuleValueUnknown(), nil
	}

	if in.IsNull() {
		return NewListenerRuleValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewListenerRuleValueMust(ListenerRuleValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ListenerRuleType) ValueType(ctx context.Context) attr.Value {
	return ListenerRuleValue{}
}

var _ basetypes.ObjectValuable = ListenerRuleValue{}

type ListenerRuleValue struct {
	Action           basetypes.StringValue `tfsdk:"action"`
	HostNamePattern  basetypes.StringValue `tfsdk:"host_name_pattern"`
	ListenerRuleName basetypes.StringValue `tfsdk:"listener_rule_name"`
	PathPattern      basetypes.StringValue `tfsdk:"path_pattern"`
	Priority         basetypes.Int64Value  `tfsdk:"priority"`
	state            attr.ValueState
}

func (v ListenerRuleValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["action"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["host_name_pattern"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["listener_rule_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["path_pattern"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["priority"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Action.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["action"] = val

		val, err = v.HostNamePattern.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host_name_pattern"] = val

		val, err = v.ListenerRuleName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["listener_rule_name"] = val

		val, err = v.PathPattern.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["path_pattern"] = val

		val, err = v.Priority.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["priority"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ListenerRuleValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ListenerRuleValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ListenerRuleValue) String() string {
	return "ListenerRuleValue"
}

func (v ListenerRuleValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"action":             basetypes.StringType{},
			"host_name_pattern":  basetypes.StringType{},
			"listener_rule_name": basetypes.StringType{},
			"path_pattern":       basetypes.StringType{},
			"priority":           basetypes.Int64Type{},
		},
		map[string]attr.Value{
			"action":             v.Action,
			"host_name_pattern":  v.HostNamePattern,
			"listener_rule_name": v.ListenerRuleName,
			"path_pattern":       v.PathPattern,
			"priority":           v.Priority,
		})

	return objVal, diags
}

func (v ListenerRuleValue) Equal(o attr.Value) bool {
	other, ok := o.(ListenerRuleValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Action.Equal(other.Action) {
		return false
	}

	if !v.HostNamePattern.Equal(other.HostNamePattern) {
		return false
	}

	if !v.ListenerRuleName.Equal(other.ListenerRuleName) {
		return false
	}

	if !v.PathPattern.Equal(other.PathPattern) {
		return false
	}

	if !v.Priority.Equal(other.Priority) {
		return false
	}

	return true
}

func (v ListenerRuleValue) Type(ctx context.Context) attr.Type {
	return ListenerRuleType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ListenerRuleValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"action":             basetypes.StringType{},
		"host_name_pattern":  basetypes.StringType{},
		"listener_rule_name": basetypes.StringType{},
		"path_pattern":       basetypes.StringType{},
		"priority":           basetypes.Int64Type{},
	}
}
