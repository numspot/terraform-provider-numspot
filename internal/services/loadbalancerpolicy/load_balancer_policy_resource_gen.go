// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package loadbalancerpolicy

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"gitlab.numspot.cloud/cloud/terraform-provider-numspot/internal/services/tags"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func LoadBalancerPolicyResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"application_sticky_cookie_policies": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"cookie_name": schema.StringAttribute{
							Computed:            true,
							Description:         "The name of the application cookie used for stickiness.",
							MarkdownDescription: "The name of the application cookie used for stickiness.",
						},
						"policy_name": schema.StringAttribute{
							Computed:            true,
							Description:         "The mnemonic name for the policy being created. The name must be unique within a set of policies for this load balancer.",
							MarkdownDescription: "The mnemonic name for the policy being created. The name must be unique within a set of policies for this load balancer.",
						},
					},
					CustomType: ApplicationStickyCookiePoliciesType{
						ObjectType: types.ObjectType{
							AttrTypes: ApplicationStickyCookiePoliciesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed:            true,
				Description:         "The stickiness policies defined for the load balancer.",
				MarkdownDescription: "The stickiness policies defined for the load balancer.",
			},
			"availability_zone_names": schema.ListAttribute{
				ElementType:         types.StringType,
				Computed:            true,
				Description:         "The ID of the Subregion in which the load balancer was created.",
				MarkdownDescription: "The ID of the Subregion in which the load balancer was created.",
			},
			"backend_ips": schema.ListAttribute{
				ElementType:         types.StringType,
				Computed:            true,
				Description:         "One or more public IPs of back-end VMs.",
				MarkdownDescription: "One or more public IPs of back-end VMs.",
			},
			"backend_vm_ids": schema.ListAttribute{
				ElementType:         types.StringType,
				Computed:            true,
				Description:         "One or more IDs of back-end VMs for the load balancer.",
				MarkdownDescription: "One or more IDs of back-end VMs for the load balancer.",
			},
			"cookie_expiration_period": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "The lifetime of the cookie, in seconds. If not specified, the default value of this parameter is `1`, which means that the sticky session lasts for the duration of the browser session.",
				MarkdownDescription: "The lifetime of the cookie, in seconds. If not specified, the default value of this parameter is `1`, which means that the sticky session lasts for the duration of the browser session.",
			},
			"cookie_name": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The name of the application cookie used for stickiness. This parameter is required if you create a stickiness policy based on an application-generated cookie.",
				MarkdownDescription: "The name of the application cookie used for stickiness. This parameter is required if you create a stickiness policy based on an application-generated cookie.",
			},
			"dns_name": schema.StringAttribute{
				Computed:            true,
				Description:         "The DNS name of the load balancer.",
				MarkdownDescription: "The DNS name of the load balancer.",
			},
			"health_check": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"check_interval": schema.Int64Attribute{
						Computed:            true,
						Description:         "The number of seconds between two requests (between `5` and `600` both included).",
						MarkdownDescription: "The number of seconds between two requests (between `5` and `600` both included).",
					},
					"healthy_threshold": schema.Int64Attribute{
						Computed:            true,
						Description:         "The number of consecutive successful requests before considering the VM as healthy (between `2` and `10` both included).",
						MarkdownDescription: "The number of consecutive successful requests before considering the VM as healthy (between `2` and `10` both included).",
					},
					"path": schema.StringAttribute{
						Computed:            true,
						Description:         "If you use the HTTP or HTTPS protocols, the request URL path.",
						MarkdownDescription: "If you use the HTTP or HTTPS protocols, the request URL path.",
					},
					"port": schema.Int64Attribute{
						Computed:            true,
						Description:         "The port number (between `1` and `65535`, both included).",
						MarkdownDescription: "The port number (between `1` and `65535`, both included).",
					},
					"protocol": schema.StringAttribute{
						Computed:            true,
						Description:         "The protocol for the URL of the VM (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).",
						MarkdownDescription: "The protocol for the URL of the VM (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).",
					},
					"timeout": schema.Int64Attribute{
						Computed:            true,
						Description:         "The maximum waiting time for a response before considering the VM as unhealthy, in seconds (between `2` and `60` both included).",
						MarkdownDescription: "The maximum waiting time for a response before considering the VM as unhealthy, in seconds (between `2` and `60` both included).",
					},
					"unhealthy_threshold": schema.Int64Attribute{
						Computed:            true,
						Description:         "The number of consecutive failed requests before considering the VM as unhealthy (between `2` and `10` both included).",
						MarkdownDescription: "The number of consecutive failed requests before considering the VM as unhealthy (between `2` and `10` both included).",
					},
				},
				CustomType: HealthCheckType{
					ObjectType: types.ObjectType{
						AttrTypes: HealthCheckValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "Information about the health check configuration.",
				MarkdownDescription: "Information about the health check configuration.",
			},
			"id": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The name of the load balancer for which you want to create a policy.",
				MarkdownDescription: "The name of the load balancer for which you want to create a policy.",
			},
			"listeners": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"backend_port": schema.Int64Attribute{
							Computed:            true,
							Description:         "The port on which the back-end VM is listening (between `1` and `65535`, both included).",
							MarkdownDescription: "The port on which the back-end VM is listening (between `1` and `65535`, both included).",
						},
						"backend_protocol": schema.StringAttribute{
							Computed:            true,
							Description:         "The protocol for routing traffic to back-end VMs (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).",
							MarkdownDescription: "The protocol for routing traffic to back-end VMs (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).",
						},
						"load_balancer_port": schema.Int64Attribute{
							Computed:            true,
							Description:         "The port on which the load balancer is listening (between `1` and `65535`, both included).",
							MarkdownDescription: "The port on which the load balancer is listening (between `1` and `65535`, both included).",
						},
						"load_balancer_protocol": schema.StringAttribute{
							Computed:            true,
							Description:         "The routing protocol (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).",
							MarkdownDescription: "The routing protocol (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).",
						},
						"policy_names": schema.ListAttribute{
							ElementType:         types.StringType,
							Computed:            true,
							Description:         "The names of the policies. If there are no policies enabled, the list is empty.",
							MarkdownDescription: "The names of the policies. If there are no policies enabled, the list is empty.",
						},
						"server_certificate_id": schema.StringAttribute{
							Computed:            true,
							Description:         "The NumSpot Resource Name of the server certificate.",
							MarkdownDescription: "The NumSpot Resource Name of the server certificate.",
						},
					},
					CustomType: ListenersType{
						ObjectType: types.ObjectType{
							AttrTypes: ListenersValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed:            true,
				Description:         "The listeners for the load balancer.",
				MarkdownDescription: "The listeners for the load balancer.",
			},
			"name": schema.StringAttribute{
				Computed:            true,
				Description:         "The name of the load balancer.",
				MarkdownDescription: "The name of the load balancer.",
			},
			"policy_name": schema.StringAttribute{
				Required:            true,
				Description:         "The name of the policy. This name must be unique and consist of alphanumeric characters and dashes (-).",
				MarkdownDescription: "The name of the policy. This name must be unique and consist of alphanumeric characters and dashes (-).",
			},
			"policy_type": schema.StringAttribute{
				Required:            true,
				Description:         "The type of stickiness policy you want to create: `app` or `load_balancer`.",
				MarkdownDescription: "The type of stickiness policy you want to create: `app` or `load_balancer`.",
			},
			"public_ip": schema.StringAttribute{
				Computed:            true,
				Description:         "(internet-facing only) The public IP associated with the load balancer.",
				MarkdownDescription: "(internet-facing only) The public IP associated with the load balancer.",
			},
			"secured_cookies": schema.BoolAttribute{
				Computed:            true,
				Description:         "Whether secure cookies are enabled for the load balancer.",
				MarkdownDescription: "Whether secure cookies are enabled for the load balancer.",
			},
			"security_groups": schema.ListAttribute{
				ElementType:         types.StringType,
				Computed:            true,
				Description:         "One or more IDs of security groups for the load balancers. Valid only for load balancers in a Net.",
				MarkdownDescription: "One or more IDs of security groups for the load balancers. Valid only for load balancers in a Net.",
			},
			"source_security_group": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"security_group_account_id": schema.StringAttribute{
						Computed:            true,
						Description:         "The account ID of the owner of the security group.",
						MarkdownDescription: "The account ID of the owner of the security group.",
					},
					"security_group_name": schema.StringAttribute{
						Computed:            true,
						Description:         "The name of the security group.",
						MarkdownDescription: "The name of the security group.",
					},
				},
				CustomType: SourceSecurityGroupType{
					ObjectType: types.ObjectType{
						AttrTypes: SourceSecurityGroupValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "Information about the source security group of the load balancer, which you can use as part of your inbound rules for your registered VMs.<br />\nTo only allow traffic from load balancers, add a security group rule that specifies this source security group as the inbound source.",
				MarkdownDescription: "Information about the source security group of the load balancer, which you can use as part of your inbound rules for your registered VMs.<br />\nTo only allow traffic from load balancers, add a security group rule that specifies this source security group as the inbound source.",
			},
			"space_id": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Space ID",
				MarkdownDescription: "Space ID",
			},
			"sticky_cookie_policies": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"cookie_expiration_period": schema.Int64Attribute{
							Computed:            true,
							Description:         "The time period, in seconds, after which the cookie should be considered stale.<br />\nIf `1`, the stickiness session lasts for the duration of the browser session.",
							MarkdownDescription: "The time period, in seconds, after which the cookie should be considered stale.<br />\nIf `1`, the stickiness session lasts for the duration of the browser session.",
						},
						"policy_name": schema.StringAttribute{
							Computed:            true,
							Description:         "The name of the stickiness policy.",
							MarkdownDescription: "The name of the stickiness policy.",
						},
					},
					CustomType: StickyCookiePoliciesType{
						ObjectType: types.ObjectType{
							AttrTypes: StickyCookiePoliciesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed:            true,
				Description:         "The policies defined for the load balancer.",
				MarkdownDescription: "The policies defined for the load balancer.",
			},
			"subnets": schema.ListAttribute{
				ElementType:         types.StringType,
				Computed:            true,
				Description:         "The ID of the Subnet in which the load balancer was created.",
				MarkdownDescription: "The ID of the Subnet in which the load balancer was created.",
			},
			"tags": tags.TagsSchema(ctx),
			"type": schema.StringAttribute{
				Computed:            true,
				Description:         "The type of load balancer. Valid only for load balancers in a Net.<br />\nIf `LoadBalancerType` is `internet-facing`, the load balancer has a public DNS name that resolves to a public IP.<br />\nIf `LoadBalancerType` is `internal`, the load balancer has a public DNS name that resolves to a private IP.",
				MarkdownDescription: "The type of load balancer. Valid only for load balancers in a Net.<br />\nIf `LoadBalancerType` is `internet-facing`, the load balancer has a public DNS name that resolves to a public IP.<br />\nIf `LoadBalancerType` is `internal`, the load balancer has a public DNS name that resolves to a private IP.",
			},
			"vpc_id": schema.StringAttribute{
				Computed:            true,
				Description:         "The ID of the Net for the load balancer.",
				MarkdownDescription: "The ID of the Net for the load balancer.",
			},
		},
		DeprecationMessage: "Managing IAAS services with Terraform is deprecated",
	}
}

type LoadBalancerPolicyModel struct {
	ApplicationStickyCookiePolicies types.List               `tfsdk:"application_sticky_cookie_policies"`
	AvailabilityZoneNames           types.List               `tfsdk:"availability_zone_names"`
	BackendIps                      types.List               `tfsdk:"backend_ips"`
	BackendVmIds                    types.List               `tfsdk:"backend_vm_ids"`
	CookieExpirationPeriod          types.Int64              `tfsdk:"cookie_expiration_period"`
	CookieName                      types.String             `tfsdk:"cookie_name"`
	DnsName                         types.String             `tfsdk:"dns_name"`
	HealthCheck                     HealthCheckValue         `tfsdk:"health_check"`
	Id                              types.String             `tfsdk:"id"`
	Listeners                       types.List               `tfsdk:"listeners"`
	Name                            types.String             `tfsdk:"name"`
	PolicyName                      types.String             `tfsdk:"policy_name"`
	PolicyType                      types.String             `tfsdk:"policy_type"`
	PublicIp                        types.String             `tfsdk:"public_ip"`
	SecuredCookies                  types.Bool               `tfsdk:"secured_cookies"`
	SecurityGroups                  types.List               `tfsdk:"security_groups"`
	SourceSecurityGroup             SourceSecurityGroupValue `tfsdk:"source_security_group"`
	SpaceId                         types.String             `tfsdk:"space_id"`
	StickyCookiePolicies            types.List               `tfsdk:"sticky_cookie_policies"`
	Subnets                         types.List               `tfsdk:"subnets"`
	Tags                            types.List               `tfsdk:"tags"`
	Type                            types.String             `tfsdk:"type"`
	VpcId                           types.String             `tfsdk:"vpc_id"`
}

var _ basetypes.ObjectTypable = ApplicationStickyCookiePoliciesType{}

type ApplicationStickyCookiePoliciesType struct {
	basetypes.ObjectType
}

func (t ApplicationStickyCookiePoliciesType) Equal(o attr.Type) bool {
	other, ok := o.(ApplicationStickyCookiePoliciesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ApplicationStickyCookiePoliciesType) String() string {
	return "ApplicationStickyCookiePoliciesType"
}

func (t ApplicationStickyCookiePoliciesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cookieNameAttribute, ok := attributes["cookie_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cookie_name is missing from object`)

		return nil, diags
	}

	cookieNameVal, ok := cookieNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cookie_name expected to be basetypes.StringValue, was: %T`, cookieNameAttribute))
	}

	policyNameAttribute, ok := attributes["policy_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_name is missing from object`)

		return nil, diags
	}

	policyNameVal, ok := policyNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_name expected to be basetypes.StringValue, was: %T`, policyNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ApplicationStickyCookiePoliciesValue{
		CookieName: cookieNameVal,
		PolicyName: policyNameVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewApplicationStickyCookiePoliciesValueNull() ApplicationStickyCookiePoliciesValue {
	return ApplicationStickyCookiePoliciesValue{
		state: attr.ValueStateNull,
	}
}

func NewApplicationStickyCookiePoliciesValueUnknown() ApplicationStickyCookiePoliciesValue {
	return ApplicationStickyCookiePoliciesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewApplicationStickyCookiePoliciesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ApplicationStickyCookiePoliciesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ApplicationStickyCookiePoliciesValue Attribute Value",
				"While creating a ApplicationStickyCookiePoliciesValue value, a missing attribute value was detected. "+
					"A ApplicationStickyCookiePoliciesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ApplicationStickyCookiePoliciesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ApplicationStickyCookiePoliciesValue Attribute Type",
				"While creating a ApplicationStickyCookiePoliciesValue value, an invalid attribute value was detected. "+
					"A ApplicationStickyCookiePoliciesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ApplicationStickyCookiePoliciesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ApplicationStickyCookiePoliciesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ApplicationStickyCookiePoliciesValue Attribute Value",
				"While creating a ApplicationStickyCookiePoliciesValue value, an extra attribute value was detected. "+
					"A ApplicationStickyCookiePoliciesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ApplicationStickyCookiePoliciesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewApplicationStickyCookiePoliciesValueUnknown(), diags
	}

	cookieNameAttribute, ok := attributes["cookie_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cookie_name is missing from object`)

		return NewApplicationStickyCookiePoliciesValueUnknown(), diags
	}

	cookieNameVal, ok := cookieNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cookie_name expected to be basetypes.StringValue, was: %T`, cookieNameAttribute))
	}

	policyNameAttribute, ok := attributes["policy_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_name is missing from object`)

		return NewApplicationStickyCookiePoliciesValueUnknown(), diags
	}

	policyNameVal, ok := policyNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_name expected to be basetypes.StringValue, was: %T`, policyNameAttribute))
	}

	if diags.HasError() {
		return NewApplicationStickyCookiePoliciesValueUnknown(), diags
	}

	return ApplicationStickyCookiePoliciesValue{
		CookieName: cookieNameVal,
		PolicyName: policyNameVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewApplicationStickyCookiePoliciesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ApplicationStickyCookiePoliciesValue {
	object, diags := NewApplicationStickyCookiePoliciesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewApplicationStickyCookiePoliciesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ApplicationStickyCookiePoliciesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewApplicationStickyCookiePoliciesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewApplicationStickyCookiePoliciesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewApplicationStickyCookiePoliciesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewApplicationStickyCookiePoliciesValueMust(ApplicationStickyCookiePoliciesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ApplicationStickyCookiePoliciesType) ValueType(ctx context.Context) attr.Value {
	return ApplicationStickyCookiePoliciesValue{}
}

var _ basetypes.ObjectValuable = ApplicationStickyCookiePoliciesValue{}

type ApplicationStickyCookiePoliciesValue struct {
	CookieName basetypes.StringValue `tfsdk:"cookie_name"`
	PolicyName basetypes.StringValue `tfsdk:"policy_name"`
	state      attr.ValueState
}

func (v ApplicationStickyCookiePoliciesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["cookie_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["policy_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.CookieName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cookie_name"] = val

		val, err = v.PolicyName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["policy_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ApplicationStickyCookiePoliciesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ApplicationStickyCookiePoliciesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ApplicationStickyCookiePoliciesValue) String() string {
	return "ApplicationStickyCookiePoliciesValue"
}

func (v ApplicationStickyCookiePoliciesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"cookie_name": basetypes.StringType{},
		"policy_name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cookie_name": v.CookieName,
			"policy_name": v.PolicyName,
		})

	return objVal, diags
}

func (v ApplicationStickyCookiePoliciesValue) Equal(o attr.Value) bool {
	other, ok := o.(ApplicationStickyCookiePoliciesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CookieName.Equal(other.CookieName) {
		return false
	}

	if !v.PolicyName.Equal(other.PolicyName) {
		return false
	}

	return true
}

func (v ApplicationStickyCookiePoliciesValue) Type(ctx context.Context) attr.Type {
	return ApplicationStickyCookiePoliciesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ApplicationStickyCookiePoliciesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cookie_name": basetypes.StringType{},
		"policy_name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = HealthCheckType{}

type HealthCheckType struct {
	basetypes.ObjectType
}

func (t HealthCheckType) Equal(o attr.Type) bool {
	other, ok := o.(HealthCheckType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t HealthCheckType) String() string {
	return "HealthCheckType"
}

func (t HealthCheckType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	checkIntervalAttribute, ok := attributes["check_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`check_interval is missing from object`)

		return nil, diags
	}

	checkIntervalVal, ok := checkIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`check_interval expected to be basetypes.Int64Value, was: %T`, checkIntervalAttribute))
	}

	healthyThresholdAttribute, ok := attributes["healthy_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`healthy_threshold is missing from object`)

		return nil, diags
	}

	healthyThresholdVal, ok := healthyThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`healthy_threshold expected to be basetypes.Int64Value, was: %T`, healthyThresholdAttribute))
	}

	pathAttribute, ok := attributes["path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`path is missing from object`)

		return nil, diags
	}

	pathVal, ok := pathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`path expected to be basetypes.StringValue, was: %T`, pathAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return nil, diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	timeoutAttribute, ok := attributes["timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timeout is missing from object`)

		return nil, diags
	}

	timeoutVal, ok := timeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timeout expected to be basetypes.Int64Value, was: %T`, timeoutAttribute))
	}

	unhealthyThresholdAttribute, ok := attributes["unhealthy_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unhealthy_threshold is missing from object`)

		return nil, diags
	}

	unhealthyThresholdVal, ok := unhealthyThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unhealthy_threshold expected to be basetypes.Int64Value, was: %T`, unhealthyThresholdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return HealthCheckValue{
		CheckInterval:      checkIntervalVal,
		HealthyThreshold:   healthyThresholdVal,
		Path:               pathVal,
		Port:               portVal,
		Protocol:           protocolVal,
		Timeout:            timeoutVal,
		UnhealthyThreshold: unhealthyThresholdVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewHealthCheckValueNull() HealthCheckValue {
	return HealthCheckValue{
		state: attr.ValueStateNull,
	}
}

func NewHealthCheckValueUnknown() HealthCheckValue {
	return HealthCheckValue{
		state: attr.ValueStateUnknown,
	}
}

func NewHealthCheckValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (HealthCheckValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing HealthCheckValue Attribute Value",
				"While creating a HealthCheckValue value, a missing attribute value was detected. "+
					"A HealthCheckValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("HealthCheckValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid HealthCheckValue Attribute Type",
				"While creating a HealthCheckValue value, an invalid attribute value was detected. "+
					"A HealthCheckValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("HealthCheckValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("HealthCheckValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra HealthCheckValue Attribute Value",
				"While creating a HealthCheckValue value, an extra attribute value was detected. "+
					"A HealthCheckValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra HealthCheckValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewHealthCheckValueUnknown(), diags
	}

	checkIntervalAttribute, ok := attributes["check_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`check_interval is missing from object`)

		return NewHealthCheckValueUnknown(), diags
	}

	checkIntervalVal, ok := checkIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`check_interval expected to be basetypes.Int64Value, was: %T`, checkIntervalAttribute))
	}

	healthyThresholdAttribute, ok := attributes["healthy_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`healthy_threshold is missing from object`)

		return NewHealthCheckValueUnknown(), diags
	}

	healthyThresholdVal, ok := healthyThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`healthy_threshold expected to be basetypes.Int64Value, was: %T`, healthyThresholdAttribute))
	}

	pathAttribute, ok := attributes["path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`path is missing from object`)

		return NewHealthCheckValueUnknown(), diags
	}

	pathVal, ok := pathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`path expected to be basetypes.StringValue, was: %T`, pathAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewHealthCheckValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return NewHealthCheckValueUnknown(), diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	timeoutAttribute, ok := attributes["timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timeout is missing from object`)

		return NewHealthCheckValueUnknown(), diags
	}

	timeoutVal, ok := timeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timeout expected to be basetypes.Int64Value, was: %T`, timeoutAttribute))
	}

	unhealthyThresholdAttribute, ok := attributes["unhealthy_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unhealthy_threshold is missing from object`)

		return NewHealthCheckValueUnknown(), diags
	}

	unhealthyThresholdVal, ok := unhealthyThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unhealthy_threshold expected to be basetypes.Int64Value, was: %T`, unhealthyThresholdAttribute))
	}

	if diags.HasError() {
		return NewHealthCheckValueUnknown(), diags
	}

	return HealthCheckValue{
		CheckInterval:      checkIntervalVal,
		HealthyThreshold:   healthyThresholdVal,
		Path:               pathVal,
		Port:               portVal,
		Protocol:           protocolVal,
		Timeout:            timeoutVal,
		UnhealthyThreshold: unhealthyThresholdVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewHealthCheckValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) HealthCheckValue {
	object, diags := NewHealthCheckValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewHealthCheckValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t HealthCheckType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewHealthCheckValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewHealthCheckValueUnknown(), nil
	}

	if in.IsNull() {
		return NewHealthCheckValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewHealthCheckValueMust(HealthCheckValue{}.AttributeTypes(ctx), attributes), nil
}

func (t HealthCheckType) ValueType(ctx context.Context) attr.Value {
	return HealthCheckValue{}
}

var _ basetypes.ObjectValuable = HealthCheckValue{}

type HealthCheckValue struct {
	CheckInterval      basetypes.Int64Value  `tfsdk:"check_interval"`
	HealthyThreshold   basetypes.Int64Value  `tfsdk:"healthy_threshold"`
	Path               basetypes.StringValue `tfsdk:"path"`
	Port               basetypes.Int64Value  `tfsdk:"port"`
	Protocol           basetypes.StringValue `tfsdk:"protocol"`
	Timeout            basetypes.Int64Value  `tfsdk:"timeout"`
	UnhealthyThreshold basetypes.Int64Value  `tfsdk:"unhealthy_threshold"`
	state              attr.ValueState
}

func (v HealthCheckValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["check_interval"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["healthy_threshold"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["path"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["protocol"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["timeout"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["unhealthy_threshold"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.CheckInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["check_interval"] = val

		val, err = v.HealthyThreshold.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["healthy_threshold"] = val

		val, err = v.Path.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["path"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.Protocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protocol"] = val

		val, err = v.Timeout.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["timeout"] = val

		val, err = v.UnhealthyThreshold.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["unhealthy_threshold"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v HealthCheckValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v HealthCheckValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v HealthCheckValue) String() string {
	return "HealthCheckValue"
}

func (v HealthCheckValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"check_interval":      basetypes.Int64Type{},
		"healthy_threshold":   basetypes.Int64Type{},
		"path":                basetypes.StringType{},
		"port":                basetypes.Int64Type{},
		"protocol":            basetypes.StringType{},
		"timeout":             basetypes.Int64Type{},
		"unhealthy_threshold": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"check_interval":      v.CheckInterval,
			"healthy_threshold":   v.HealthyThreshold,
			"path":                v.Path,
			"port":                v.Port,
			"protocol":            v.Protocol,
			"timeout":             v.Timeout,
			"unhealthy_threshold": v.UnhealthyThreshold,
		})

	return objVal, diags
}

func (v HealthCheckValue) Equal(o attr.Value) bool {
	other, ok := o.(HealthCheckValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CheckInterval.Equal(other.CheckInterval) {
		return false
	}

	if !v.HealthyThreshold.Equal(other.HealthyThreshold) {
		return false
	}

	if !v.Path.Equal(other.Path) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.Protocol.Equal(other.Protocol) {
		return false
	}

	if !v.Timeout.Equal(other.Timeout) {
		return false
	}

	if !v.UnhealthyThreshold.Equal(other.UnhealthyThreshold) {
		return false
	}

	return true
}

func (v HealthCheckValue) Type(ctx context.Context) attr.Type {
	return HealthCheckType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v HealthCheckValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"check_interval":      basetypes.Int64Type{},
		"healthy_threshold":   basetypes.Int64Type{},
		"path":                basetypes.StringType{},
		"port":                basetypes.Int64Type{},
		"protocol":            basetypes.StringType{},
		"timeout":             basetypes.Int64Type{},
		"unhealthy_threshold": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = ListenersType{}

type ListenersType struct {
	basetypes.ObjectType
}

func (t ListenersType) Equal(o attr.Type) bool {
	other, ok := o.(ListenersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ListenersType) String() string {
	return "ListenersType"
}

func (t ListenersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	backendPortAttribute, ok := attributes["backend_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backend_port is missing from object`)

		return nil, diags
	}

	backendPortVal, ok := backendPortAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backend_port expected to be basetypes.Int64Value, was: %T`, backendPortAttribute))
	}

	backendProtocolAttribute, ok := attributes["backend_protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backend_protocol is missing from object`)

		return nil, diags
	}

	backendProtocolVal, ok := backendProtocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backend_protocol expected to be basetypes.StringValue, was: %T`, backendProtocolAttribute))
	}

	loadBalancerPortAttribute, ok := attributes["load_balancer_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`load_balancer_port is missing from object`)

		return nil, diags
	}

	loadBalancerPortVal, ok := loadBalancerPortAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`load_balancer_port expected to be basetypes.Int64Value, was: %T`, loadBalancerPortAttribute))
	}

	loadBalancerProtocolAttribute, ok := attributes["load_balancer_protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`load_balancer_protocol is missing from object`)

		return nil, diags
	}

	loadBalancerProtocolVal, ok := loadBalancerProtocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`load_balancer_protocol expected to be basetypes.StringValue, was: %T`, loadBalancerProtocolAttribute))
	}

	policyNamesAttribute, ok := attributes["policy_names"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_names is missing from object`)

		return nil, diags
	}

	policyNamesVal, ok := policyNamesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_names expected to be basetypes.ListValue, was: %T`, policyNamesAttribute))
	}

	serverCertificateIdAttribute, ok := attributes["server_certificate_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`server_certificate_id is missing from object`)

		return nil, diags
	}

	serverCertificateIdVal, ok := serverCertificateIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`server_certificate_id expected to be basetypes.StringValue, was: %T`, serverCertificateIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ListenersValue{
		BackendPort:          backendPortVal,
		BackendProtocol:      backendProtocolVal,
		LoadBalancerPort:     loadBalancerPortVal,
		LoadBalancerProtocol: loadBalancerProtocolVal,
		PolicyNames:          policyNamesVal,
		ServerCertificateId:  serverCertificateIdVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewListenersValueNull() ListenersValue {
	return ListenersValue{
		state: attr.ValueStateNull,
	}
}

func NewListenersValueUnknown() ListenersValue {
	return ListenersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewListenersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ListenersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ListenersValue Attribute Value",
				"While creating a ListenersValue value, a missing attribute value was detected. "+
					"A ListenersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ListenersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ListenersValue Attribute Type",
				"While creating a ListenersValue value, an invalid attribute value was detected. "+
					"A ListenersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ListenersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ListenersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ListenersValue Attribute Value",
				"While creating a ListenersValue value, an extra attribute value was detected. "+
					"A ListenersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ListenersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewListenersValueUnknown(), diags
	}

	backendPortAttribute, ok := attributes["backend_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backend_port is missing from object`)

		return NewListenersValueUnknown(), diags
	}

	backendPortVal, ok := backendPortAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backend_port expected to be basetypes.Int64Value, was: %T`, backendPortAttribute))
	}

	backendProtocolAttribute, ok := attributes["backend_protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backend_protocol is missing from object`)

		return NewListenersValueUnknown(), diags
	}

	backendProtocolVal, ok := backendProtocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backend_protocol expected to be basetypes.StringValue, was: %T`, backendProtocolAttribute))
	}

	loadBalancerPortAttribute, ok := attributes["load_balancer_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`load_balancer_port is missing from object`)

		return NewListenersValueUnknown(), diags
	}

	loadBalancerPortVal, ok := loadBalancerPortAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`load_balancer_port expected to be basetypes.Int64Value, was: %T`, loadBalancerPortAttribute))
	}

	loadBalancerProtocolAttribute, ok := attributes["load_balancer_protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`load_balancer_protocol is missing from object`)

		return NewListenersValueUnknown(), diags
	}

	loadBalancerProtocolVal, ok := loadBalancerProtocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`load_balancer_protocol expected to be basetypes.StringValue, was: %T`, loadBalancerProtocolAttribute))
	}

	policyNamesAttribute, ok := attributes["policy_names"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_names is missing from object`)

		return NewListenersValueUnknown(), diags
	}

	policyNamesVal, ok := policyNamesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_names expected to be basetypes.ListValue, was: %T`, policyNamesAttribute))
	}

	serverCertificateIdAttribute, ok := attributes["server_certificate_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`server_certificate_id is missing from object`)

		return NewListenersValueUnknown(), diags
	}

	serverCertificateIdVal, ok := serverCertificateIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`server_certificate_id expected to be basetypes.StringValue, was: %T`, serverCertificateIdAttribute))
	}

	if diags.HasError() {
		return NewListenersValueUnknown(), diags
	}

	return ListenersValue{
		BackendPort:          backendPortVal,
		BackendProtocol:      backendProtocolVal,
		LoadBalancerPort:     loadBalancerPortVal,
		LoadBalancerProtocol: loadBalancerProtocolVal,
		PolicyNames:          policyNamesVal,
		ServerCertificateId:  serverCertificateIdVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewListenersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ListenersValue {
	object, diags := NewListenersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewListenersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ListenersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewListenersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewListenersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewListenersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewListenersValueMust(ListenersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ListenersType) ValueType(ctx context.Context) attr.Value {
	return ListenersValue{}
}

var _ basetypes.ObjectValuable = ListenersValue{}

type ListenersValue struct {
	BackendPort          basetypes.Int64Value  `tfsdk:"backend_port"`
	BackendProtocol      basetypes.StringValue `tfsdk:"backend_protocol"`
	LoadBalancerPort     basetypes.Int64Value  `tfsdk:"load_balancer_port"`
	LoadBalancerProtocol basetypes.StringValue `tfsdk:"load_balancer_protocol"`
	PolicyNames          basetypes.ListValue   `tfsdk:"policy_names"`
	ServerCertificateId  basetypes.StringValue `tfsdk:"server_certificate_id"`
	state                attr.ValueState
}

func (v ListenersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["backend_port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["backend_protocol"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["load_balancer_port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["load_balancer_protocol"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["policy_names"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["server_certificate_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.BackendPort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["backend_port"] = val

		val, err = v.BackendProtocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["backend_protocol"] = val

		val, err = v.LoadBalancerPort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["load_balancer_port"] = val

		val, err = v.LoadBalancerProtocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["load_balancer_protocol"] = val

		val, err = v.PolicyNames.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["policy_names"] = val

		val, err = v.ServerCertificateId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["server_certificate_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ListenersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ListenersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ListenersValue) String() string {
	return "ListenersValue"
}

func (v ListenersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	policyNamesVal, d := types.ListValue(types.StringType, v.PolicyNames.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"backend_port":           basetypes.Int64Type{},
			"backend_protocol":       basetypes.StringType{},
			"load_balancer_port":     basetypes.Int64Type{},
			"load_balancer_protocol": basetypes.StringType{},
			"policy_names": basetypes.ListType{
				ElemType: types.StringType,
			},
			"server_certificate_id": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"backend_port":           basetypes.Int64Type{},
		"backend_protocol":       basetypes.StringType{},
		"load_balancer_port":     basetypes.Int64Type{},
		"load_balancer_protocol": basetypes.StringType{},
		"policy_names": basetypes.ListType{
			ElemType: types.StringType,
		},
		"server_certificate_id": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"backend_port":           v.BackendPort,
			"backend_protocol":       v.BackendProtocol,
			"load_balancer_port":     v.LoadBalancerPort,
			"load_balancer_protocol": v.LoadBalancerProtocol,
			"policy_names":           policyNamesVal,
			"server_certificate_id":  v.ServerCertificateId,
		})

	return objVal, diags
}

func (v ListenersValue) Equal(o attr.Value) bool {
	other, ok := o.(ListenersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BackendPort.Equal(other.BackendPort) {
		return false
	}

	if !v.BackendProtocol.Equal(other.BackendProtocol) {
		return false
	}

	if !v.LoadBalancerPort.Equal(other.LoadBalancerPort) {
		return false
	}

	if !v.LoadBalancerProtocol.Equal(other.LoadBalancerProtocol) {
		return false
	}

	if !v.PolicyNames.Equal(other.PolicyNames) {
		return false
	}

	if !v.ServerCertificateId.Equal(other.ServerCertificateId) {
		return false
	}

	return true
}

func (v ListenersValue) Type(ctx context.Context) attr.Type {
	return ListenersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ListenersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"backend_port":           basetypes.Int64Type{},
		"backend_protocol":       basetypes.StringType{},
		"load_balancer_port":     basetypes.Int64Type{},
		"load_balancer_protocol": basetypes.StringType{},
		"policy_names": basetypes.ListType{
			ElemType: types.StringType,
		},
		"server_certificate_id": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SourceSecurityGroupType{}

type SourceSecurityGroupType struct {
	basetypes.ObjectType
}

func (t SourceSecurityGroupType) Equal(o attr.Type) bool {
	other, ok := o.(SourceSecurityGroupType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SourceSecurityGroupType) String() string {
	return "SourceSecurityGroupType"
}

func (t SourceSecurityGroupType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	securityGroupAccountIdAttribute, ok := attributes["security_group_account_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_group_account_id is missing from object`)

		return nil, diags
	}

	securityGroupAccountIdVal, ok := securityGroupAccountIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_group_account_id expected to be basetypes.StringValue, was: %T`, securityGroupAccountIdAttribute))
	}

	securityGroupNameAttribute, ok := attributes["security_group_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_group_name is missing from object`)

		return nil, diags
	}

	securityGroupNameVal, ok := securityGroupNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_group_name expected to be basetypes.StringValue, was: %T`, securityGroupNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SourceSecurityGroupValue{
		SecurityGroupAccountId: securityGroupAccountIdVal,
		SecurityGroupName:      securityGroupNameVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewSourceSecurityGroupValueNull() SourceSecurityGroupValue {
	return SourceSecurityGroupValue{
		state: attr.ValueStateNull,
	}
}

func NewSourceSecurityGroupValueUnknown() SourceSecurityGroupValue {
	return SourceSecurityGroupValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSourceSecurityGroupValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SourceSecurityGroupValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SourceSecurityGroupValue Attribute Value",
				"While creating a SourceSecurityGroupValue value, a missing attribute value was detected. "+
					"A SourceSecurityGroupValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SourceSecurityGroupValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SourceSecurityGroupValue Attribute Type",
				"While creating a SourceSecurityGroupValue value, an invalid attribute value was detected. "+
					"A SourceSecurityGroupValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SourceSecurityGroupValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SourceSecurityGroupValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SourceSecurityGroupValue Attribute Value",
				"While creating a SourceSecurityGroupValue value, an extra attribute value was detected. "+
					"A SourceSecurityGroupValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SourceSecurityGroupValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSourceSecurityGroupValueUnknown(), diags
	}

	securityGroupAccountIdAttribute, ok := attributes["security_group_account_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_group_account_id is missing from object`)

		return NewSourceSecurityGroupValueUnknown(), diags
	}

	securityGroupAccountIdVal, ok := securityGroupAccountIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_group_account_id expected to be basetypes.StringValue, was: %T`, securityGroupAccountIdAttribute))
	}

	securityGroupNameAttribute, ok := attributes["security_group_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_group_name is missing from object`)

		return NewSourceSecurityGroupValueUnknown(), diags
	}

	securityGroupNameVal, ok := securityGroupNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_group_name expected to be basetypes.StringValue, was: %T`, securityGroupNameAttribute))
	}

	if diags.HasError() {
		return NewSourceSecurityGroupValueUnknown(), diags
	}

	return SourceSecurityGroupValue{
		SecurityGroupAccountId: securityGroupAccountIdVal,
		SecurityGroupName:      securityGroupNameVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewSourceSecurityGroupValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SourceSecurityGroupValue {
	object, diags := NewSourceSecurityGroupValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSourceSecurityGroupValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SourceSecurityGroupType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSourceSecurityGroupValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSourceSecurityGroupValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSourceSecurityGroupValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSourceSecurityGroupValueMust(SourceSecurityGroupValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SourceSecurityGroupType) ValueType(ctx context.Context) attr.Value {
	return SourceSecurityGroupValue{}
}

var _ basetypes.ObjectValuable = SourceSecurityGroupValue{}

type SourceSecurityGroupValue struct {
	SecurityGroupAccountId basetypes.StringValue `tfsdk:"security_group_account_id"`
	SecurityGroupName      basetypes.StringValue `tfsdk:"security_group_name"`
	state                  attr.ValueState
}

func (v SourceSecurityGroupValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["security_group_account_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["security_group_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.SecurityGroupAccountId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["security_group_account_id"] = val

		val, err = v.SecurityGroupName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["security_group_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SourceSecurityGroupValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SourceSecurityGroupValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SourceSecurityGroupValue) String() string {
	return "SourceSecurityGroupValue"
}

func (v SourceSecurityGroupValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"security_group_account_id": basetypes.StringType{},
		"security_group_name":       basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"security_group_account_id": v.SecurityGroupAccountId,
			"security_group_name":       v.SecurityGroupName,
		})

	return objVal, diags
}

func (v SourceSecurityGroupValue) Equal(o attr.Value) bool {
	other, ok := o.(SourceSecurityGroupValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.SecurityGroupAccountId.Equal(other.SecurityGroupAccountId) {
		return false
	}

	if !v.SecurityGroupName.Equal(other.SecurityGroupName) {
		return false
	}

	return true
}

func (v SourceSecurityGroupValue) Type(ctx context.Context) attr.Type {
	return SourceSecurityGroupType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SourceSecurityGroupValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"security_group_account_id": basetypes.StringType{},
		"security_group_name":       basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = StickyCookiePoliciesType{}

type StickyCookiePoliciesType struct {
	basetypes.ObjectType
}

func (t StickyCookiePoliciesType) Equal(o attr.Type) bool {
	other, ok := o.(StickyCookiePoliciesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StickyCookiePoliciesType) String() string {
	return "StickyCookiePoliciesType"
}

func (t StickyCookiePoliciesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cookieExpirationPeriodAttribute, ok := attributes["cookie_expiration_period"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cookie_expiration_period is missing from object`)

		return nil, diags
	}

	cookieExpirationPeriodVal, ok := cookieExpirationPeriodAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cookie_expiration_period expected to be basetypes.Int64Value, was: %T`, cookieExpirationPeriodAttribute))
	}

	policyNameAttribute, ok := attributes["policy_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_name is missing from object`)

		return nil, diags
	}

	policyNameVal, ok := policyNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_name expected to be basetypes.StringValue, was: %T`, policyNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StickyCookiePoliciesValue{
		CookieExpirationPeriod: cookieExpirationPeriodVal,
		PolicyName:             policyNameVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewStickyCookiePoliciesValueNull() StickyCookiePoliciesValue {
	return StickyCookiePoliciesValue{
		state: attr.ValueStateNull,
	}
}

func NewStickyCookiePoliciesValueUnknown() StickyCookiePoliciesValue {
	return StickyCookiePoliciesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStickyCookiePoliciesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StickyCookiePoliciesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StickyCookiePoliciesValue Attribute Value",
				"While creating a StickyCookiePoliciesValue value, a missing attribute value was detected. "+
					"A StickyCookiePoliciesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StickyCookiePoliciesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StickyCookiePoliciesValue Attribute Type",
				"While creating a StickyCookiePoliciesValue value, an invalid attribute value was detected. "+
					"A StickyCookiePoliciesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StickyCookiePoliciesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StickyCookiePoliciesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StickyCookiePoliciesValue Attribute Value",
				"While creating a StickyCookiePoliciesValue value, an extra attribute value was detected. "+
					"A StickyCookiePoliciesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StickyCookiePoliciesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStickyCookiePoliciesValueUnknown(), diags
	}

	cookieExpirationPeriodAttribute, ok := attributes["cookie_expiration_period"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cookie_expiration_period is missing from object`)

		return NewStickyCookiePoliciesValueUnknown(), diags
	}

	cookieExpirationPeriodVal, ok := cookieExpirationPeriodAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cookie_expiration_period expected to be basetypes.Int64Value, was: %T`, cookieExpirationPeriodAttribute))
	}

	policyNameAttribute, ok := attributes["policy_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_name is missing from object`)

		return NewStickyCookiePoliciesValueUnknown(), diags
	}

	policyNameVal, ok := policyNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_name expected to be basetypes.StringValue, was: %T`, policyNameAttribute))
	}

	if diags.HasError() {
		return NewStickyCookiePoliciesValueUnknown(), diags
	}

	return StickyCookiePoliciesValue{
		CookieExpirationPeriod: cookieExpirationPeriodVal,
		PolicyName:             policyNameVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewStickyCookiePoliciesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StickyCookiePoliciesValue {
	object, diags := NewStickyCookiePoliciesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStickyCookiePoliciesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StickyCookiePoliciesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStickyCookiePoliciesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStickyCookiePoliciesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStickyCookiePoliciesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStickyCookiePoliciesValueMust(StickyCookiePoliciesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StickyCookiePoliciesType) ValueType(ctx context.Context) attr.Value {
	return StickyCookiePoliciesValue{}
}

var _ basetypes.ObjectValuable = StickyCookiePoliciesValue{}

type StickyCookiePoliciesValue struct {
	CookieExpirationPeriod basetypes.Int64Value  `tfsdk:"cookie_expiration_period"`
	PolicyName             basetypes.StringValue `tfsdk:"policy_name"`
	state                  attr.ValueState
}

func (v StickyCookiePoliciesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["cookie_expiration_period"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["policy_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.CookieExpirationPeriod.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cookie_expiration_period"] = val

		val, err = v.PolicyName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["policy_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StickyCookiePoliciesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StickyCookiePoliciesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StickyCookiePoliciesValue) String() string {
	return "StickyCookiePoliciesValue"
}

func (v StickyCookiePoliciesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"cookie_expiration_period": basetypes.Int64Type{},
		"policy_name":              basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cookie_expiration_period": v.CookieExpirationPeriod,
			"policy_name":              v.PolicyName,
		})

	return objVal, diags
}

func (v StickyCookiePoliciesValue) Equal(o attr.Value) bool {
	other, ok := o.(StickyCookiePoliciesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CookieExpirationPeriod.Equal(other.CookieExpirationPeriod) {
		return false
	}

	if !v.PolicyName.Equal(other.PolicyName) {
		return false
	}

	return true
}

func (v StickyCookiePoliciesValue) Type(ctx context.Context) attr.Type {
	return StickyCookiePoliciesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StickyCookiePoliciesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cookie_expiration_period": basetypes.Int64Type{},
		"policy_name":              basetypes.StringType{},
	}
}
