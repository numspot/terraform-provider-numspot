// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package loadbalancer

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"gitlab.numspot.cloud/cloud/terraform-provider-numspot/internal/services/tags"
)

func LoadBalancerDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"items": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"application_sticky_cookie_policies": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"cookie_name": schema.StringAttribute{
										Computed:            true,
										Description:         "The name of the application cookie used for stickiness.",
										MarkdownDescription: "The name of the application cookie used for stickiness.",
									},
									"policy_name": schema.StringAttribute{
										Computed:            true,
										Description:         "The mnemonic name for the policy being created. The name must be unique within a set of policies for this load balancer.",
										MarkdownDescription: "The mnemonic name for the policy being created. The name must be unique within a set of policies for this load balancer.",
									},
								},
								CustomType: ApplicationStickyCookiePoliciesType{
									ObjectType: types.ObjectType{
										AttrTypes: ApplicationStickyCookiePoliciesValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed:            true,
							Description:         "The stickiness policies defined for the load balancer.",
							MarkdownDescription: "The stickiness policies defined for the load balancer.",
						},
						"availability_zone_names": schema.ListAttribute{
							ElementType:         types.StringType,
							Computed:            true,
							Description:         "The ID of the Subregion in which the load balancer was created.",
							MarkdownDescription: "The ID of the Subregion in which the load balancer was created.",
						},
						"backend_ips": schema.ListAttribute{
							ElementType:         types.StringType,
							Computed:            true,
							Description:         "One or more public IPs of back-end VMs.",
							MarkdownDescription: "One or more public IPs of back-end VMs.",
						},
						"backend_vm_ids": schema.ListAttribute{
							ElementType:         types.StringType,
							Computed:            true,
							Description:         "One or more IDs of back-end VMs for the load balancer.",
							MarkdownDescription: "One or more IDs of back-end VMs for the load balancer.",
						},
						"dns_name": schema.StringAttribute{
							Computed:            true,
							Description:         "The DNS name of the load balancer.",
							MarkdownDescription: "The DNS name of the load balancer.",
						},
						"health_check": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"check_interval": schema.Int64Attribute{
									Computed:            true,
									Description:         "The number of seconds between two requests (between `5` and `600` both included).",
									MarkdownDescription: "The number of seconds between two requests (between `5` and `600` both included).",
								},
								"healthy_threshold": schema.Int64Attribute{
									Computed:            true,
									Description:         "The number of consecutive successful requests before considering the VM as healthy (between `2` and `10` both included).",
									MarkdownDescription: "The number of consecutive successful requests before considering the VM as healthy (between `2` and `10` both included).",
								},
								"path": schema.StringAttribute{
									Computed:            true,
									Description:         "If you use the HTTP or HTTPS protocols, the request URL path.",
									MarkdownDescription: "If you use the HTTP or HTTPS protocols, the request URL path.",
								},
								"port": schema.Int64Attribute{
									Computed:            true,
									Description:         "The port number (between `1` and `65535`, both included).",
									MarkdownDescription: "The port number (between `1` and `65535`, both included).",
								},
								"protocol": schema.StringAttribute{
									Computed:            true,
									Description:         "The protocol for the URL of the VM (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).",
									MarkdownDescription: "The protocol for the URL of the VM (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).",
								},
								"timeout": schema.Int64Attribute{
									Computed:            true,
									Description:         "The maximum waiting time for a response before considering the VM as unhealthy, in seconds (between `2` and `60` both included).",
									MarkdownDescription: "The maximum waiting time for a response before considering the VM as unhealthy, in seconds (between `2` and `60` both included).",
								},
								"unhealthy_threshold": schema.Int64Attribute{
									Computed:            true,
									Description:         "The number of consecutive failed requests before considering the VM as unhealthy (between `2` and `10` both included).",
									MarkdownDescription: "The number of consecutive failed requests before considering the VM as unhealthy (between `2` and `10` both included).",
								},
							},
							CustomType: HealthCheckType{
								ObjectType: types.ObjectType{
									AttrTypes: HealthCheckValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "Information about the health check configuration.",
							MarkdownDescription: "Information about the health check configuration.",
						},
						"listeners": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"backend_port": schema.Int64Attribute{
										Computed:            true,
										Description:         "The port on which the back-end VM is listening (between `1` and `65535`, both included).",
										MarkdownDescription: "The port on which the back-end VM is listening (between `1` and `65535`, both included).",
									},
									"backend_protocol": schema.StringAttribute{
										Computed:            true,
										Description:         "The protocol for routing traffic to back-end VMs (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).",
										MarkdownDescription: "The protocol for routing traffic to back-end VMs (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).",
									},
									"load_balancer_port": schema.Int64Attribute{
										Computed:            true,
										Description:         "The port on which the load balancer is listening (between `1` and `65535`, both included).",
										MarkdownDescription: "The port on which the load balancer is listening (between `1` and `65535`, both included).",
									},
									"load_balancer_protocol": schema.StringAttribute{
										Computed:            true,
										Description:         "The routing protocol (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).",
										MarkdownDescription: "The routing protocol (`HTTP` \\| `HTTPS` \\| `TCP` \\| `SSL`).",
									},
									"policy_names": schema.ListAttribute{
										ElementType:         types.StringType,
										Computed:            true,
										Description:         "The names of the policies. If there are no policies enabled, the list is empty.",
										MarkdownDescription: "The names of the policies. If there are no policies enabled, the list is empty.",
									},
									"server_certificate_id": schema.StringAttribute{
										Computed:            true,
										Description:         "The NumSpot Resource Name of the server certificate.",
										MarkdownDescription: "The NumSpot Resource Name of the server certificate.",
									},
								},
								CustomType: ListenersType{
									ObjectType: types.ObjectType{
										AttrTypes: ListenersValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed:            true,
							Description:         "The listeners for the load balancer.",
							MarkdownDescription: "The listeners for the load balancer.",
						},
						"name": schema.StringAttribute{
							Computed:            true,
							Description:         "The name of the load balancer.",
							MarkdownDescription: "The name of the load balancer.",
						},
						"public_ip": schema.StringAttribute{
							Computed:            true,
							Description:         "(internet-facing only) The public IP associated with the load balancer.",
							MarkdownDescription: "(internet-facing only) The public IP associated with the load balancer.",
						},
						"secured_cookies": schema.BoolAttribute{
							Computed:            true,
							Description:         "Whether secure cookies are enabled for the load balancer.",
							MarkdownDescription: "Whether secure cookies are enabled for the load balancer.",
						},
						"security_groups": schema.ListAttribute{
							ElementType:         types.StringType,
							Computed:            true,
							Description:         "One or more IDs of security groups for the load balancers. Valid only for load balancers in a Vpc.",
							MarkdownDescription: "One or more IDs of security groups for the load balancers. Valid only for load balancers in a Vpc.",
						},
						"source_security_group": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"security_group_name": schema.StringAttribute{
									Computed:            true,
									Description:         "The name of the security group.",
									MarkdownDescription: "The name of the security group.",
								},
							},
							CustomType: SourceSecurityGroupType{
								ObjectType: types.ObjectType{
									AttrTypes: SourceSecurityGroupValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "Information about the source security group of the load balancer, which you can use as part of your inbound rules for your registered VMs.<br />\nTo only allow traffic from load balancers, add a security group rule that specifies this source security group as the inbound source.",
							MarkdownDescription: "Information about the source security group of the load balancer, which you can use as part of your inbound rules for your registered VMs.<br />\nTo only allow traffic from load balancers, add a security group rule that specifies this source security group as the inbound source.",
						},
						"sticky_cookie_policies": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"cookie_expiration_period": schema.Int64Attribute{
										Computed:            true,
										Description:         "The time period, in seconds, after which the cookie should be considered stale.<br />\nIf `1`, the stickiness session lasts for the duration of the browser session.",
										MarkdownDescription: "The time period, in seconds, after which the cookie should be considered stale.<br />\nIf `1`, the stickiness session lasts for the duration of the browser session.",
									},
									"policy_name": schema.StringAttribute{
										Computed:            true,
										Description:         "The name of the stickiness policy.",
										MarkdownDescription: "The name of the stickiness policy.",
									},
								},
								CustomType: StickyCookiePoliciesType{
									ObjectType: types.ObjectType{
										AttrTypes: StickyCookiePoliciesValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed:            true,
							Description:         "The policies defined for the load balancer.",
							MarkdownDescription: "The policies defined for the load balancer.",
						},
						"subnets": schema.ListAttribute{
							ElementType:         types.StringType,
							Computed:            true,
							Description:         "The ID of the Subnet in which the load balancer was created.",
							MarkdownDescription: "The ID of the Subnet in which the load balancer was created.",
						},
						"tags": tags.TagsSchema(ctx),
						"type": schema.StringAttribute{
							Computed:            true,
							Description:         "The type of load balancer. Valid only for load balancers in a Vpc.<br />\nIf `LoadBalancerType` is `internet-facing`, the load balancer has a public DNS name that resolves to a public IP.<br />\nIf `LoadBalancerType` is `internal`, the load balancer has a public DNS name that resolves to a private IP.",
							MarkdownDescription: "The type of load balancer. Valid only for load balancers in a Vpc.<br />\nIf `LoadBalancerType` is `internet-facing`, the load balancer has a public DNS name that resolves to a public IP.<br />\nIf `LoadBalancerType` is `internal`, the load balancer has a public DNS name that resolves to a private IP.",
						},
						"vpc_id": schema.StringAttribute{
							Computed:            true,
							Description:         "The ID of the Vpc for the load balancer.",
							MarkdownDescription: "The ID of the Vpc for the load balancer.",
						},
					},
				},
				Computed:            true,
				Description:         "Information about one or more load balancers.",
				MarkdownDescription: "Information about one or more load balancers.",
			},
			"load_balancer_names": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "The names of the load balancers.",
				MarkdownDescription: "The names of the load balancers.",
			},
		},
		DeprecationMessage: "Managing IAAS services with Terraform is deprecated",
	}

}
