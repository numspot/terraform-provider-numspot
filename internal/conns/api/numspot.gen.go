// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.0.0 DO NOT EDIT.
package api

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for CreateVmsRequestSchemaPerformance.
const (
	CreateVmsRequestSchemaPerformanceHigh    CreateVmsRequestSchemaPerformance = "high"
	CreateVmsRequestSchemaPerformanceHighest CreateVmsRequestSchemaPerformance = "highest"
	CreateVmsRequestSchemaPerformanceMedium  CreateVmsRequestSchemaPerformance = "medium"
)

// Defines values for UpdateDirectLinkInterfaceRequestSchemaMtu.
const (
	N1500 UpdateDirectLinkInterfaceRequestSchemaMtu = 1500
)

// Defines values for UpdateVmRequestSchemaPerformance.
const (
	UpdateVmRequestSchemaPerformanceHigh    UpdateVmRequestSchemaPerformance = "high"
	UpdateVmRequestSchemaPerformanceHighest UpdateVmRequestSchemaPerformance = "highest"
	UpdateVmRequestSchemaPerformanceMedium  UpdateVmRequestSchemaPerformance = "medium"
)

// AcceptNetPeeringRequestSchema defines model for AcceptNetPeeringRequestSchema.
type AcceptNetPeeringRequestSchema struct {
	// NetPeeringId The ID of the Net peering you want to accept.
	NetPeeringId string `json:"netPeeringId"`
}

// AcceptNetPeeringResponseSchema defines model for AcceptNetPeeringResponseSchema.
type AcceptNetPeeringResponseSchema struct {
	// NetPeering Information about the Net peering.
	NetPeering *NetPeeringSchema `json:"netPeering,omitempty"`
}

// AccepterNetSchema Information about the accepter Net.
type AccepterNetSchema struct {
	// AccountId The account ID of the owner of the accepter Net.
	AccountId *string `json:"accountId,omitempty"`

	// IpRange The IP range for the accepter Net, in CIDR notation (for example, `10.0.0.0/16`).
	IpRange *string `json:"ipRange,omitempty"`

	// NetId The ID of the accepter Net.
	NetId *string `json:"netId,omitempty"`
}

// ApplicationStickyCookiePolicySchema Information about the stickiness policy.
type ApplicationStickyCookiePolicySchema struct {
	// CookieName The name of the application cookie used for stickiness.
	CookieName *string `json:"cookieName,omitempty"`

	// PolicyName The mnemonic name for the policy being created. The name must be unique within a set of policies for this load balancer.
	PolicyName *string `json:"policyName,omitempty"`
}

// BackendVmHealthSchema Information about the health of a back-end VM.
type BackendVmHealthSchema struct {
	// Description The description of the state of the back-end VM.
	Description *string `json:"description,omitempty"`

	// State The state of the back-end VM (`InService` \| `OutOfService` \| `Unknown`).
	State *string `json:"state,omitempty"`

	// StateReason Information about the cause of `OutOfService` VMs.<br />
	//  Specifically, whether the cause is Elastic Load Balancing or the VM (`ELB` \| `Instance` \| `N/A`).
	StateReason *string `json:"stateReason,omitempty"`

	// VmId The ID of the back-end VM.
	VmId *string `json:"vmId,omitempty"`
}

// BlockDeviceMappingCreatedSchema Information about the created block device mapping.
type BlockDeviceMappingCreatedSchema struct {
	// Bsu Information about the created BSU volume.
	Bsu *BsuCreatedSchema `json:"bsu,omitempty"`

	// DeviceName The name of the device.
	DeviceName *string `json:"deviceName,omitempty"`
}

// BlockDeviceMappingImageSchema One or more parameters used to automatically set up volumes when the VM is created.
type BlockDeviceMappingImageSchema struct {
	// Bsu Information about the BSU volume to create.
	Bsu *BsuToCreateSchema `json:"bsu,omitempty"`

	// DeviceName The device name for the volume. For a root device, you must use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, and the second `X` is a letter between `a` and `z`).
	DeviceName *string `json:"deviceName,omitempty"`

	// VirtualDeviceName The name of the virtual device (`ephemeralN`).
	VirtualDeviceName *string `json:"virtualDeviceName,omitempty"`
}

// BlockDeviceMappingVmCreationSchema Information about the block device mapping.
type BlockDeviceMappingVmCreationSchema struct {
	// Bsu Information about the BSU volume to create.
	Bsu *BsuToCreateSchema `json:"bsu,omitempty"`

	// DeviceName The device name for the volume. For a root device, you must use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, and the second `X` is a letter between `a` and `z`).
	DeviceName *string `json:"deviceName,omitempty"`

	// NoDevice Removes the device which is included in the block device mapping of the OMI.
	NoDevice *string `json:"noDevice,omitempty"`

	// VirtualDeviceName The name of the virtual device (`ephemeralN`).
	VirtualDeviceName *string `json:"virtualDeviceName,omitempty"`
}

// BlockDeviceMappingVmUpdateSchema Information about the block device mapping.
type BlockDeviceMappingVmUpdateSchema struct {
	// Bsu Information about the BSU volume.
	Bsu *BsuToUpdateVmSchema `json:"bsu,omitempty"`

	// DeviceName The device name for the volume. For a root device, you must use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, and the second `X` is a letter between `a` and `z`).
	DeviceName *string `json:"deviceName,omitempty"`

	// NoDevice Removes the device which is included in the block device mapping of the OMI.
	NoDevice *string `json:"noDevice,omitempty"`

	// VirtualDeviceName The name of the virtual device (`ephemeralN`).
	VirtualDeviceName *string `json:"virtualDeviceName,omitempty"`
}

// BsuCreatedSchema Information about the created BSU volume.
type BsuCreatedSchema struct {
	// DeleteOnVmDeletion If true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.
	DeleteOnVmDeletion *bool `json:"deleteOnVmDeletion,omitempty"`

	// LinkDate The date and time of attachment of the volume to the VM, in ISO 8601 date-time format.
	LinkDate *time.Time `json:"linkDate,omitempty"`

	// State The state of the volume.
	State *string `json:"state,omitempty"`

	// VolumeId The ID of the volume.
	VolumeId *string `json:"volumeId,omitempty"`
}

// BsuToCreateSchema Information about the BSU volume to create.
type BsuToCreateSchema struct {
	// DeleteOnVmDeletion By default or if set to true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.
	DeleteOnVmDeletion *bool `json:"deleteOnVmDeletion,omitempty"`

	// Iops The number of I/O operations per second (IOPS). This parameter must be specified only if you create an `io1` volume. The maximum number of IOPS allowed for `io1` volumes is `13000` with a maximum performance ratio of 300 IOPS per gibibyte.
	Iops *int `json:"iops,omitempty"`

	// SnapshotId The ID of the snapshot used to create the volume.
	SnapshotId *string `json:"snapshotId,omitempty"`

	// VolumeSize The size of the volume, in gibibytes (GiB).<br />
	// If you specify a snapshot ID, the volume size must be at least equal to the snapshot size.<br />
	// If you specify a snapshot ID but no volume size, the volume is created with a size similar to the snapshot one.
	VolumeSize *int `json:"volumeSize,omitempty"`

	// VolumeType The type of the volume (`standard` \| `io1` \| `gp2`). If not specified in the request, a `standard` volume is created.<br />
	//  For more information about volume types, see [About Volumes > Volume Types and IOPS](https://docs.outscale.com/en/userguide/About-Volumes.html#_volume_types_and_iops).
	VolumeType *string `json:"volumeType,omitempty"`
}

// BsuToUpdateVmSchema Information about the BSU volume.
type BsuToUpdateVmSchema struct {
	// DeleteOnVmDeletion If set to true, the volume is deleted when terminating the VM. If set to false, the volume is not deleted when terminating the VM.
	DeleteOnVmDeletion *bool `json:"deleteOnVmDeletion,omitempty"`

	// VolumeId The ID of the volume.
	VolumeId *string `json:"volumeId,omitempty"`
}

// ClientGatewaySchema Information about the client gateway.
type ClientGatewaySchema struct {
	// BgpAsn The Autonomous System Number (ASN) used by the Border Gateway Protocol (BGP) to find the path to your client gateway through the Internet.
	BgpAsn *int `json:"bgpAsn,omitempty"`

	// ConnectionType The type of communication tunnel used by the client gateway (only `ipsec.1` is supported).
	ConnectionType *string `json:"connectionType,omitempty"`

	// Id The ID of the client gateway.
	Id *string `json:"id,omitempty"`

	// PublicIp The public IPv4 address of the client gateway (must be a fixed address into a NATed network).
	PublicIp *string `json:"publicIp,omitempty"`

	// State The state of the client gateway (`pending` \| `available` \| `deleting` \| `deleted`).
	State *string `json:"state,omitempty"`

	// Tags One or more tags associated with the client gateway.
	Tags *[]ResourceTagSchema `json:"tags,omitempty"`
}

// CreateClientGatewayRequestSchema defines model for CreateClientGatewayRequestSchema.
type CreateClientGatewayRequestSchema struct {
	// BgpAsn The Autonomous System Number (ASN) used by the Border Gateway Protocol (BGP) to find the path to your client gateway through the Internet. This number must be between `1` and `4294967295`.
	BgpAsn int `json:"bgpAsn"`

	// ConnectionType The communication protocol used to establish tunnel with your client gateway (only `ipsec.1` is supported).
	ConnectionType string `json:"connectionType"`

	// PublicIp The public fixed IPv4 address of your client gateway.
	PublicIp string `json:"publicIp"`
}

// CreateDhcpOptionsRequestSchema defines model for CreateDhcpOptionsRequestSchema.
type CreateDhcpOptionsRequestSchema struct {
	// DomainName Specify a domain name (for example, `MyCompany.com`). You can specify only one domain name. You must specify at least one of the following parameters: `DomainName`, `DomainNameServers`, `LogServers`, or `NtpServers`.
	DomainName *string `json:"domainName,omitempty"`

	// DomainNameServers The IPs of domain name servers. If no IPs are specified, the `OutscaleProvidedDNS` value is set by default. You must specify at least one of the following parameters: `DomainName`, `DomainNameServers`, `LogServers`, or `NtpServers`.
	DomainNameServers *[]string `json:"domainNameServers,omitempty"`

	// LogServers The IPs of the log servers. You must specify at least one of the following parameters: `DomainName`, `DomainNameServers`, `LogServers`, or `NtpServers`.
	LogServers *[]string `json:"logServers,omitempty"`

	// NtpServers The IPs of the Network Time Protocol (NTP) servers. You must specify at least one of the following parameters: `DomainName`, `DomainNameServers`, `LogServers`, or `NtpServers`.
	NtpServers *[]string `json:"ntpServers,omitempty"`
}

// CreateDirectLinkInterfaceRequestSchema defines model for CreateDirectLinkInterfaceRequestSchema.
type CreateDirectLinkInterfaceRequestSchema struct {
	// DirectLinkId The ID of the existing DirectLink for which you want to create the DirectLink interface.
	DirectLinkId string `json:"directLinkId"`

	// DirectLinkInterface Information about the DirectLink interface.
	DirectLinkInterface DirectLinkInterfaceSchema `json:"directLinkInterface"`
}

// CreateDirectLinkRequestSchema defines model for CreateDirectLinkRequestSchema.
type CreateDirectLinkRequestSchema struct {
	// Bandwidth The bandwidth of the DirectLink (`1Gbps` \| `10Gbps`).
	Bandwidth string `json:"bandwidth"`

	// Location The code of the requested location for the DirectLink, returned by the [ReadLocations](#readlocations) method.
	Location string `json:"location"`

	// Name The name of the DirectLink.
	Name *string `json:"name,omitempty"`
}

// CreateFlexibleGpuRequestSchema defines model for CreateFlexibleGpuRequestSchema.
type CreateFlexibleGpuRequestSchema struct {
	// DeleteOnVmDeletion If true, the fGPU is deleted when the VM is terminated.
	DeleteOnVmDeletion *bool `json:"deleteOnVmDeletion,omitempty"`

	// Generation The processor generation that the fGPU must be compatible with. If not specified, the oldest possible processor generation is selected (as provided by [ReadFlexibleGpuCatalog](#readflexiblegpucatalog) for the specified model of fGPU).
	Generation *string `json:"generation,omitempty"`

	// ModelName The model of fGPU you want to allocate. For more information, see [About Flexible GPUs](https://docs.outscale.com/en/userguide/About-Flexible-GPUs.html).
	ModelName string `json:"modelName"`

	// SubregionName The Subregion in which you want to create the fGPU.
	SubregionName string `json:"subregionName"`
}

// CreateImageRequestSchema defines model for CreateImageRequestSchema.
type CreateImageRequestSchema struct {
	// Architecture The architecture of the OMI (by default, `i386` if you specified the `FileLocation` or `RootDeviceName` parameter).
	Architecture *string `json:"architecture,omitempty"`

	// BlockDeviceMappings One or more block device mappings.
	BlockDeviceMappings *[]BlockDeviceMappingImageSchema `json:"blockDeviceMappings,omitempty"`

	// Description A description for the new OMI.
	Description *string `json:"description,omitempty"`

	// Name A unique name for the new OMI.<br />
	// Constraints: 3-128 alphanumeric characters, underscores (_), spaces ( ), parentheses (()), slashes (/), periods (.), or dashes (-).
	Name *string `json:"name,omitempty"`

	// NoReboot If false, the VM shuts down before creating the OMI and then reboots. If true, the VM does not.
	NoReboot *bool `json:"noReboot,omitempty"`

	// ProductCodes The product codes associated with the OMI.
	ProductCodes *[]string `json:"productCodes,omitempty"`

	// RootDeviceName The name of the root device. You must specify only one of the following parameters: `FileLocation`, `RootDeviceName`, `SourceImageId` or `VmId`.
	RootDeviceName *string `json:"rootDeviceName,omitempty"`

	// SourceRegionName The name of the source Region, which must be the same as the Region of your account.
	SourceRegionName *string `json:"sourceRegionName,omitempty"`

	// VmId The ID of the VM from which you want to create the OMI. You must specify only one of the following parameters: `FileLocation`, `RootDeviceName`, `SourceImageId` or `VmId`.
	VmId *string `json:"vmId,omitempty"`
}

// CreateInternetServiceRequestSchema defines model for CreateInternetServiceRequestSchema.
type CreateInternetServiceRequestSchema = map[string]interface{}

// CreateKeypairRequestSchema defines model for CreateKeypairRequestSchema.
type CreateKeypairRequestSchema struct {
	// Name A unique name for the keypair, with a maximum length of 255 [ASCII printable characters](https://en.wikipedia.org/wiki/ASCII#Printable_characters).
	Name *string `json:"name,omitempty"`

	// PublicKey The public key. It must be Base64-encoded.
	PublicKey *string `json:"publicKey,omitempty"`
}

// CreateListenerRuleRequestSchema defines model for CreateListenerRuleRequestSchema.
type CreateListenerRuleRequestSchema struct {
	// Listener Information about the load balancer.
	Listener LoadBalancerLightSchema `json:"listener"`

	// ListenerRule Information about the listener rule.
	ListenerRule ListenerRuleForCreationSchema `json:"listenerRule"`

	// VmIds The IDs of the backend VMs.
	VmIds []string `json:"vmIds"`
}

// CreateLoadBalancerListenersRequestSchema defines model for CreateLoadBalancerListenersRequestSchema.
type CreateLoadBalancerListenersRequestSchema struct {
	// Listeners One or more listeners for the load balancer.
	Listeners []ListenerForCreationSchema `json:"listeners"`

	// LoadBalancerName The name of the load balancer for which you want to create listeners.
	LoadBalancerName string `json:"loadBalancerName"`
}

// CreateLoadBalancerPolicyRequestSchema defines model for CreateLoadBalancerPolicyRequestSchema.
type CreateLoadBalancerPolicyRequestSchema struct {
	// CookieExpirationPeriod The lifetime of the cookie, in seconds. If not specified, the default value of this parameter is `1`, which means that the sticky session lasts for the duration of the browser session.
	CookieExpirationPeriod *int `json:"cookieExpirationPeriod,omitempty"`

	// CookieName The name of the application cookie used for stickiness. This parameter is required if you create a stickiness policy based on an application-generated cookie.
	CookieName *string `json:"cookieName,omitempty"`

	// LoadBalancerName The name of the load balancer for which you want to create a policy.
	LoadBalancerName string `json:"loadBalancerName"`

	// PolicyName The name of the policy. This name must be unique and consist of alphanumeric characters and dashes (-).
	PolicyName string `json:"policyName"`

	// PolicyType The type of stickiness policy you want to create: `app` or `load_balancer`.
	PolicyType string `json:"policyType"`
}

// CreateLoadBalancerRequestSchema defines model for CreateLoadBalancerRequestSchema.
type CreateLoadBalancerRequestSchema struct {
	// Listeners One or more listeners to create.
	Listeners []ListenerForCreationSchema `json:"listeners"`

	// Name The unique name of the load balancer (32 alphanumeric or hyphen characters maximum, but cannot start or end with a hyphen).
	Name *string `json:"name,omitempty"`

	// PublicIp (internet-facing only) The public IP you want to associate with the load balancer. If not specified, a public IP owned by 3DS OUTSCALE is associated.
	PublicIp *string `json:"publicIp,omitempty"`

	// SecurityGroups (Net only) One or more IDs of security groups you want to assign to the load balancer. If not specified, the default security group of the Net is assigned to the load balancer.
	SecurityGroups *[]string `json:"securityGroups,omitempty"`

	// Subnets (Net only) The ID of the Subnet in which you want to create the load balancer. Regardless of this Subnet, the load balancer can distribute traffic to all Subnets. This parameter is required in a Net.
	Subnets *[]string `json:"subnets,omitempty"`

	// Tags One or more tags assigned to the load balancer.
	Tags *[]ResourceTagSchema `json:"tags,omitempty"`

	// Type The type of load balancer: `internet-facing` or `internal`. Use this parameter only for load balancers in a Net.
	Type *string `json:"type,omitempty"`
}

// CreateLoadBalancerTagsRequestSchema defines model for CreateLoadBalancerTagsRequestSchema.
type CreateLoadBalancerTagsRequestSchema struct {
	// LoadBalancerNames One or more load balancer names.
	LoadBalancerNames []string `json:"loadBalancerNames"`

	// Tags One or more tags to add to the specified load balancers.
	Tags []ResourceTagSchema `json:"tags"`
}

// CreateNatServiceRequestSchema defines model for CreateNatServiceRequestSchema.
type CreateNatServiceRequestSchema struct {
	// PublicIpId The allocation ID of the public IP to associate with the NAT service.<br />
	// If the public IP is already associated with another resource, you must first disassociate it.
	PublicIpId string `json:"publicIpId"`

	// SubnetId The ID of the Subnet in which you want to create the NAT service.
	SubnetId string `json:"subnetId"`
}

// CreateNetAccessPointRequestSchema defines model for CreateNetAccessPointRequestSchema.
type CreateNetAccessPointRequestSchema struct {
	// NetId The ID of the Net.
	NetId string `json:"netId"`

	// RouteTableIds One or more IDs of route tables to use for the connection.
	RouteTableIds *[]string `json:"routeTableIds,omitempty"`

	// ServiceName The name of the service (in the format `com.outscale.region.service`).
	ServiceName string `json:"serviceName"`
}

// CreateNetPeeringRequestSchema defines model for CreateNetPeeringRequestSchema.
type CreateNetPeeringRequestSchema struct {
	// AccepterNetId The ID of the Net you want to connect with.
	AccepterNetId string `json:"accepterNetId"`

	// SourceNetId The ID of the Net you send the peering request from.
	SourceNetId string `json:"sourceNetId"`
}

// CreateNetRequestSchema defines model for CreateNetRequestSchema.
type CreateNetRequestSchema struct {
	// IpRange The IP range for the Net, in CIDR notation (for example, `10.0.0.0/16`).
	IpRange string `json:"ipRange"`

	// Tenancy The tenancy options for the VMs (`default` if a VM created in a Net can be launched with any tenancy, `dedicated` if it can be launched with dedicated tenancy VMs running on single-tenant hardware).
	Tenancy *string `json:"tenancy,omitempty"`
}

// CreateNicRequestSchema defines model for CreateNicRequestSchema.
type CreateNicRequestSchema struct {
	// Description A description for the NIC.
	Description *string `json:"description,omitempty"`

	// PrivateIps The primary private IP for the NIC.<br />
	// This IP must be within the IP range of the Subnet that you specify with the `SubnetId` attribute.<br />
	// If you do not specify this attribute, a random private IP is selected within the IP range of the Subnet.
	PrivateIps *[]PrivateIpLightSchema `json:"privateIps,omitempty"`

	// SecurityGroupIds One or more IDs of security groups for the NIC.
	SecurityGroupIds *[]string `json:"securityGroupIds,omitempty"`

	// SubnetId The ID of the Subnet in which you want to create the NIC.
	SubnetId string `json:"subnetId"`
}

// CreatePublicIpRequestSchema defines model for CreatePublicIpRequestSchema.
type CreatePublicIpRequestSchema = map[string]interface{}

// CreateRouteRequestSchema defines model for CreateRouteRequestSchema.
type CreateRouteRequestSchema struct {
	// DestinationIpRange The IP range used for the destination match, in CIDR notation (for example, `10.0.0.0/24`).
	DestinationIpRange string `json:"destinationIpRange"`

	// GatewayId The ID of an Internet service or virtual gateway attached to your Net.
	GatewayId *string `json:"gatewayId,omitempty"`

	// NatServiceId The ID of a NAT service.
	NatServiceId *string `json:"natServiceId,omitempty"`

	// NetPeeringId The ID of a Net peering.
	NetPeeringId *string `json:"netPeeringId,omitempty"`

	// NicId The ID of a NIC.
	NicId *string `json:"nicId,omitempty"`

	// TableId The ID of the route table for which you want to create a route.
	TableId *string `json:"tableId,omitempty"`

	// VmId The ID of a NAT VM in your Net (attached to exactly one NIC).
	VmId *string `json:"vmId,omitempty"`
}

// CreateRouteTableRequestSchema defines model for CreateRouteTableRequestSchema.
type CreateRouteTableRequestSchema struct {
	// NetId The ID of the Net for which you want to create a route table.
	NetId string `json:"netId"`
}

// CreateSecurityGroupRequestSchema defines model for CreateSecurityGroupRequestSchema.
type CreateSecurityGroupRequestSchema struct {
	// Description A description for the security group, with a maximum length of 255 [ASCII printable characters](https://en.wikipedia.org/wiki/ASCII#Printable_characters).
	Description string `json:"description"`

	// Name The name of the security group.<br />
	// This name must not start with `sg-`.</br>
	// This name must be unique and contain between 1 and 255 ASCII characters. Accented letters are not allowed.
	Name *string `json:"name,omitempty"`

	// NetId The ID of the Net for the security group.
	NetId *string `json:"netId,omitempty"`
}

// CreateSecurityGroupRuleRequestSchema defines model for CreateSecurityGroupRuleRequestSchema.
type CreateSecurityGroupRuleRequestSchema struct {
	// Flow The direction of the flow: `Inbound` or `Outbound`. You can specify `Outbound` for Nets only.
	Flow string `json:"flow"`

	// FromPortRange The beginning of the port range for the TCP and UDP protocols, or an ICMP type number. If you specify this parameter, you cannot specify the `Rules` parameter and its subparameters.
	FromPortRange *int `json:"fromPortRange,omitempty"`

	// IpProtocol The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all protocols). By default, `-1`. In a Net, this can also be an IP protocol number. For more information, see the [IANA.org website](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml). If you specify this parameter, you cannot specify the `Rules` parameter and its subparameters.
	IpProtocol *string `json:"ipProtocol,omitempty"`

	// IpRange The IP range for the security group rule, in CIDR notation (for example, 10.0.0.0/16). If you specify this parameter, you cannot specify the `Rules` parameter and its subparameters.
	IpRange *string `json:"ipRange,omitempty"`

	// Rules Information about the security group rule to create. If you specify this parent parameter and its subparameters, you cannot specify the following parent parameters: `FromPortRange`, `IpProtocol`, `IpRange`, and `ToPortRange`.
	Rules *[]SecurityGroupRuleSchema `json:"rules,omitempty"`

	// SecurityGroupAccountIdToLink The account ID that owns the source or destination security group specified in the `SecurityGroupNameToLink` parameter.
	SecurityGroupAccountIdToLink *string `json:"securityGroupAccountIdToLink,omitempty"`

	// SecurityGroupId The ID of the security group for which you want to create a rule.
	SecurityGroupId string `json:"securityGroupId"`

	// SecurityGroupNameToLink The ID of a source or destination security group that you want to link to the security group of the rule.
	SecurityGroupNameToLink *string `json:"securityGroupNameToLink,omitempty"`

	// ToPortRange The end of the port range for the TCP and UDP protocols, or an ICMP code number. If you specify this parameter, you cannot specify the `Rules` parameter and its subparameters.
	ToPortRange *int `json:"toPortRange,omitempty"`
}

// CreateSnapshotRequestSchema defines model for CreateSnapshotRequestSchema.
type CreateSnapshotRequestSchema struct {
	// Description A description for the snapshot.
	Description *string `json:"description,omitempty"`

	// SourceRegionName (When copying) The name of the source Region, which must be the same as the Region of your account.
	SourceRegionName *string `json:"sourceRegionName,omitempty"`

	// VolumeId (When creating) The ID of the volume you want to create a snapshot of.
	VolumeId *string `json:"volumeId,omitempty"`
}

// CreateSubnetRequestSchema defines model for CreateSubnetRequestSchema.
type CreateSubnetRequestSchema struct {
	// IpRange The IP range in the Subnet, in CIDR notation (for example, `10.0.0.0/16`).<br />
	// The IP range of the Subnet can be either the same as the Net one if you create only a single Subnet in this Net, or a subset of the Net one. In case of several Subnets in a Net, their IP ranges must not overlap. The smallest Subnet you can create uses a /29 netmask (eight IPs). For more information, see [About VPCs](https://docs.outscale.com/en/userguide/About-VPCs.html).
	IpRange string `json:"ipRange"`

	// NetId The ID of the Net for which you want to create a Subnet.
	NetId string `json:"netId"`

	// SubregionName The name of the Subregion in which you want to create the Subnet.
	SubregionName *string `json:"subregionName,omitempty"`
}

// CreateTagsRequestSchema defines model for CreateTagsRequestSchema.
type CreateTagsRequestSchema struct {
	// ResourceIds One or more resource IDs.
	ResourceIds []string `json:"resourceIds"`

	// Tags One or more tags to add to the specified resources.
	Tags []ResourceTagSchema `json:"tags"`
}

// CreateVirtualGatewayRequestSchema defines model for CreateVirtualGatewayRequestSchema.
type CreateVirtualGatewayRequestSchema struct {
	// ConnectionType The type of VPN connection supported by the virtual gateway (only `ipsec.1` is supported).
	ConnectionType string `json:"connectionType"`
}

// CreateVmsRequestSchema defines model for CreateVmsRequestSchema.
type CreateVmsRequestSchema struct {
	// BlockDeviceMappings One or more block device mappings.
	BlockDeviceMappings *[]BlockDeviceMappingVmCreationSchema `json:"blockDeviceMappings,omitempty"`

	// BootOnCreation By default or if true, the VM is started on creation. If false, the VM is stopped on creation.
	BootOnCreation *bool `json:"bootOnCreation,omitempty"`

	// BsuOptimized This parameter is not available. It is present in our API for the sake of historical compatibility with AWS.
	BsuOptimized *bool `json:"bsuOptimized,omitempty"`

	// ClientToken A unique identifier which enables you to manage the idempotency.
	ClientToken *string `json:"clientToken,omitempty"`

	// DeletionProtection If true, you cannot delete the VM unless you change this parameter back to false.
	DeletionProtection *bool `json:"deletionProtection,omitempty"`

	// ImageId The ID of the OMI used to create the VM. You can find the list of OMIs by calling the [ReadImages](#readimages) method.
	ImageId string `json:"imageId"`

	// KeypairName The name of the keypair.
	KeypairName *string `json:"keypairName,omitempty"`

	// NestedVirtualization (dedicated tenancy only) If true, nested virtualization is enabled. If false, it is disabled.
	NestedVirtualization *bool `json:"nestedVirtualization,omitempty"`

	// Nics One or more NICs. If you specify this parameter, you must not specify the `SubnetId` and `SubregionName` parameters. You also must define one NIC as the primary network interface of the VM with `0` as its device number.
	Nics *[]NicForVmCreationSchema `json:"nics,omitempty"`

	// Performance The performance of the VM (`medium` \| `high` \|  `highest`). By default, `high`. This parameter is ignored if you specify a performance flag directly in the `VmType` parameter.
	Performance *CreateVmsRequestSchemaPerformance `json:"performance,omitempty"`

	// Placement Information about the placement of the VM.
	Placement *PlacementSchema `json:"placement,omitempty"`

	// PrivateIps One or more private IPs of the VM.
	PrivateIps *[]string `json:"privateIps,omitempty"`

	// SecurityGroupIds One or more IDs of security group for the VMs.
	SecurityGroupIds *[]string `json:"securityGroupIds,omitempty"`

	// SecurityGroups One or more names of security groups for the VMs.
	SecurityGroups *[]string `json:"securityGroups,omitempty"`

	// SubnetId The ID of the Subnet in which you want to create the VM. If you specify this parameter, you must not specify the `Nics` parameter.
	SubnetId *string `json:"subnetId,omitempty"`

	// UserData Data or script used to add a specific configuration to the VM. It must be Base64-encoded and is limited to 500 kibibytes (KiB).
	UserData *string `json:"userData,omitempty"`

	// VmInitiatedShutdownBehavior The VM behavior when you stop it. By default or if set to `stop`, the VM stops. If set to `restart`, the VM stops then automatically restarts. If set to `terminate`, the VM stops and is terminated.
	VmInitiatedShutdownBehavior *string `json:"vmInitiatedShutdownBehavior,omitempty"`

	// VmType The type of VM. You can specify a TINA type (in the `tinavW.cXrYpZ` or `tinavW.cXrY` format), or an AWS type (for example, `t2.small`, which is the default value).<br />
	// If you specify an AWS type, it is converted in the background to its corresponding TINA type, but the AWS type is still returned. If the specified or converted TINA type includes a performance flag, this performance flag is applied regardless of the value you may have provided in the `Performance` parameter. For more information, see [Instance Types](https://docs.outscale.com/en/userguide/Instance-Types.html).
	VmType *string `json:"vmType,omitempty"`

	// VmsCount The minimum number of VMs you want to create. If this number of VMs cannot be created, no VMs are created.
	VmsCount *int `json:"vmsCount,omitempty"`
}

// CreateVmsRequestSchemaPerformance The performance of the VM (`medium` \| `high` \|  `highest`). By default, `high`. This parameter is ignored if you specify a performance flag directly in the `VmType` parameter.
type CreateVmsRequestSchemaPerformance string

// CreateVmsResponseSchema defines model for CreateVmsResponseSchema.
type CreateVmsResponseSchema struct {
	// Vms Information about one or more created VMs.
	Vms *[]VmSchema `json:"vms,omitempty"`
}

// CreateVolumeRequestSchema defines model for CreateVolumeRequestSchema.
type CreateVolumeRequestSchema struct {
	// Iops The number of I/O operations per second (IOPS). This parameter must be specified only if you create an `io1` volume. The maximum number of IOPS allowed for `io1` volumes is `13000` with a maximum performance ratio of 300 IOPS per gibibyte.
	Iops *int `json:"iops,omitempty"`

	// Size The size of the volume, in gibibytes (GiB). The maximum allowed size for a volume is 14901 GiB. This parameter is required if the volume is not created from a snapshot (`SnapshotId` unspecified).
	Size *int `json:"size,omitempty"`

	// SnapshotId The ID of the snapshot from which you want to create the volume.
	SnapshotId *string `json:"snapshotId,omitempty"`

	// SubregionName The Subregion in which you want to create the volume.
	SubregionName string `json:"subregionName"`

	// Type The type of volume you want to create (`io1` \| `gp2` \ | `standard`). If not specified, a `standard` volume is created.<br />
	//  For more information about volume types, see [About Volumes > Volume Types and IOPS](https://docs.outscale.com/en/userguide/About-Volumes.html#_volume_types_and_iops).
	Type *string `json:"type,omitempty"`
}

// CreateVpnConnectionRequestSchema defines model for CreateVpnConnectionRequestSchema.
type CreateVpnConnectionRequestSchema struct {
	// ClientGatewayId The ID of the client gateway.
	ClientGatewayId string `json:"clientGatewayId"`

	// ConnectionType The type of VPN connection (only `ipsec.1` is supported).
	ConnectionType string `json:"connectionType"`

	// StaticRoutesOnly If false, the VPN connection uses dynamic routing with Border Gateway Protocol (BGP). If true, routing is controlled using static routes. For more information about how to create and delete static routes, see [CreateVpnConnectionRoute](#createvpnconnectionroute) and [DeleteVpnConnectionRoute](#deletevpnconnectionroute).
	StaticRoutesOnly *bool `json:"staticRoutesOnly,omitempty"`

	// VirtualGatewayId The ID of the virtual gateway.
	VirtualGatewayId string `json:"virtualGatewayId"`
}

// CreateVpnConnectionRouteRequestSchema defines model for CreateVpnConnectionRouteRequestSchema.
type CreateVpnConnectionRouteRequestSchema struct {
	// DestinationIpRange The network prefix of the route, in CIDR notation (for example, `10.12.0.0/16`).
	DestinationIpRange string `json:"destinationIpRange"`

	// VpnConnectionId The ID of the target VPN connection of the static route.
	VpnConnectionId string `json:"vpnConnectionId"`
}

// DeleteLoadBalancerListenersRequestSchema defines model for DeleteLoadBalancerListenersRequestSchema.
type DeleteLoadBalancerListenersRequestSchema struct {
	// LoadBalancerPorts One or more port numbers of the listeners you want to delete.
	LoadBalancerPorts []int `json:"loadBalancerPorts"`
}

// DeleteLoadBalancerListenersResponseSchema defines model for DeleteLoadBalancerListenersResponseSchema.
type DeleteLoadBalancerListenersResponseSchema struct {
	// LoadBalancer Information about the load balancer.
	LoadBalancer *LoadBalancerSchema `json:"loadBalancer,omitempty"`
}

// DeleteLoadBalancerPolicyRequestSchema defines model for DeleteLoadBalancerPolicyRequestSchema.
type DeleteLoadBalancerPolicyRequestSchema struct {
	// PolicyName The name of the policy you want to delete.
	PolicyName string `json:"policyName"`
}

// DeleteLoadBalancerPolicyResponseSchema defines model for DeleteLoadBalancerPolicyResponseSchema.
type DeleteLoadBalancerPolicyResponseSchema struct {
	// LoadBalancer Information about the load balancer.
	LoadBalancer *LoadBalancerSchema `json:"loadBalancer,omitempty"`
}

// DeleteLoadBalancerTagsRequestSchema defines model for DeleteLoadBalancerTagsRequestSchema.
type DeleteLoadBalancerTagsRequestSchema struct {
	// Tags One or more tags to delete from the load balancers.
	Tags []ResourceLoadBalancerTagSchema `json:"tags"`
}

// DeletePublicIpRequestSchema defines model for DeletePublicIpRequestSchema.
type DeletePublicIpRequestSchema struct {
	// PublicIpId The ID representing the association of the public IP with the VM or the NIC. In a Net, this parameter is required.
	PublicIpId *string `json:"publicIpId,omitempty"`
}

// DeleteRouteRequestSchema defines model for DeleteRouteRequestSchema.
type DeleteRouteRequestSchema struct {
	// DestinationIpRange The exact IP range for the route.
	DestinationIpRange string `json:"destinationIpRange"`
}

// DeleteRouteResponseSchema defines model for DeleteRouteResponseSchema.
type DeleteRouteResponseSchema struct {
	// RouteTable Information about the route table.
	RouteTable *RouteTableSchema `json:"routeTable,omitempty"`
}

// DeleteSecurityGroupRequestSchema defines model for DeleteSecurityGroupRequestSchema.
type DeleteSecurityGroupRequestSchema struct {
	// SecurityGroupName The name of the security group.
	SecurityGroupName *string `json:"securityGroupName,omitempty"`
}

// DeleteSecurityGroupRuleRequestSchema defines model for DeleteSecurityGroupRuleRequestSchema.
type DeleteSecurityGroupRuleRequestSchema struct {
	// Flow The direction of the flow: `Inbound` or `Outbound`. You can specify `Outbound` for Nets only.
	Flow string `json:"flow"`

	// FromPortRange The beginning of the port range for the TCP and UDP protocols, or an ICMP type number.
	FromPortRange *int `json:"fromPortRange,omitempty"`

	// IpProtocol The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all protocols). By default, `-1`. In a Net, this can also be an IP protocol number. For more information, see the [IANA.org website](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
	IpProtocol *string `json:"ipProtocol,omitempty"`

	// IpRange The IP range for the security group rule, in CIDR notation (for example, `10.0.0.0/16`).
	IpRange *string `json:"ipRange,omitempty"`

	// Rules One or more rules you want to delete from the security group.
	Rules *[]SecurityGroupRuleSchema `json:"rules,omitempty"`

	// SecurityGroupAccountIdToUnlink The account ID of the owner of the security group you want to delete a rule from.
	SecurityGroupAccountIdToUnlink *string `json:"securityGroupAccountIdToUnlink,omitempty"`

	// SecurityGroupNameToUnlink The ID of the source security group. If you are in the Public Cloud, you can also specify the name of the source security group.
	SecurityGroupNameToUnlink *string `json:"securityGroupNameToUnlink,omitempty"`

	// ToPortRange The end of the port range for the TCP and UDP protocols, or an ICMP code number.
	ToPortRange *int `json:"toPortRange,omitempty"`
}

// DeleteSecurityGroupRuleResponseSchema defines model for DeleteSecurityGroupRuleResponseSchema.
type DeleteSecurityGroupRuleResponseSchema struct {
	// SecurityGroup Information about the security group.
	SecurityGroup *SecurityGroupSchema `json:"securityGroup,omitempty"`
}

// DeleteTagsRequestSchema defines model for DeleteTagsRequestSchema.
type DeleteTagsRequestSchema struct {
	// Tags One or more tags to delete (if you set a tag value, only the tags matching exactly this value are deleted).
	Tags []ResourceTagSchema `json:"tags"`
}

// DeleteVmsResponseSchema defines model for DeleteVmsResponseSchema.
type DeleteVmsResponseSchema struct {
	// Vms Information about one or more terminated VMs.
	Vms *[]VmStateSchema `json:"vms,omitempty"`
}

// DeleteVpnConnectionRouteRequestSchema defines model for DeleteVpnConnectionRouteRequestSchema.
type DeleteVpnConnectionRouteRequestSchema struct {
	// DestinationIpRange The network prefix of the route to delete, in CIDR notation (for example, `10.12.0.0/16`).
	DestinationIpRange string `json:"destinationIpRange"`
}

// DhcpOptionsSetSchema Information about the DHCP options set.
type DhcpOptionsSetSchema struct {
	// Default If true, the DHCP options set is a default one. If false, it is not.
	Default *bool `json:"default,omitempty"`

	// DomainName The domain name.
	DomainName *string `json:"domainName,omitempty"`

	// DomainNameServers One or more IPs for the domain name servers.
	DomainNameServers *[]string `json:"domainNameServers,omitempty"`

	// Id The ID of the DHCP options set.
	Id *string `json:"id,omitempty"`

	// LogServers One or more IPs for the log servers.
	LogServers *[]string `json:"logServers,omitempty"`

	// NtpServers One or more IPs for the NTP servers.
	NtpServers *[]string `json:"ntpServers,omitempty"`

	// Tags One or more tags associated with the DHCP options set.
	Tags *[]ResourceTagSchema `json:"tags,omitempty"`
}

// DirectLinkInterfaceSchema Information about the DirectLink interface.
type DirectLinkInterfaceSchema struct {
	// BgpAsn The BGP (Border Gateway Protocol) ASN (Autonomous System Number) on the customer's side of the DirectLink interface. This number must be between `64512` and `65534`.
	BgpAsn int `json:"bgpAsn"`

	// BgpKey The BGP authentication key.
	BgpKey *string `json:"bgpKey,omitempty"`

	// ClientPrivateIp The IP on the customer's side of the DirectLink interface.
	ClientPrivateIp *string `json:"clientPrivateIp,omitempty"`

	// Name The name of the DirectLink interface.
	Name *string `json:"name,omitempty"`

	// NumspotPrivateIp The IP on the OUTSCALE side of the DirectLink interface.
	NumspotPrivateIp *string `json:"numspotPrivateIp,omitempty"`

	// VirtualGatewayId The ID of the target virtual gateway.
	VirtualGatewayId string `json:"virtualGatewayId"`

	// Vlan The VLAN number associated with the DirectLink interface.
	Vlan int `json:"vlan"`
}

// DirectLinkInterfacesSchema Information about the DirectLink interfaces.
type DirectLinkInterfacesSchema struct {
	// BgpAsn The BGP (Border Gateway Protocol) ASN (Autonomous System Number) on the customer's side of the DirectLink interface.
	BgpAsn *int `json:"bgpAsn,omitempty"`

	// BgpKey The BGP authentication key.
	BgpKey *string `json:"bgpKey,omitempty"`

	// ClientPrivateIp The IP on the customer's side of the DirectLink interface.
	ClientPrivateIp *string `json:"clientPrivateIp,omitempty"`

	// DirectLinkId The ID of the DirectLink.
	DirectLinkId *string `json:"directLinkId,omitempty"`

	// DirectLinkInterfaceId The ID of the DirectLink interface.
	DirectLinkInterfaceId *string `json:"directLinkInterfaceId,omitempty"`

	// DirectLinkInterfaceName The name of the DirectLink interface.
	DirectLinkInterfaceName *string `json:"directLinkInterfaceName,omitempty"`

	// InterfaceType The type of the DirectLink interface (always `private`).
	InterfaceType *string `json:"interfaceType,omitempty"`

	// Location The datacenter where the DirectLink interface is located.
	Location *string `json:"location,omitempty"`

	// Mtu The maximum transmission unit (MTU) of the DirectLink interface, in bytes (always `1500`).
	Mtu *int `json:"mtu,omitempty"`

	// OutscalePrivateIp The IP on the OUTSCALE side of the DirectLink interface.
	OutscalePrivateIp *string `json:"outscalePrivateIp,omitempty"`

	// State The state of the DirectLink interface (`pending` \| `available` \| `deleting` \| `deleted` \| `confirming` \| `rejected` \| `expired`).
	State *string `json:"state,omitempty"`

	// VirtualGatewayId The ID of the target virtual gateway.
	VirtualGatewayId *string `json:"virtualGatewayId,omitempty"`

	// Vlan The VLAN number associated with the DirectLink interface.
	Vlan *int `json:"vlan,omitempty"`
}

// DirectLinkSchema Information about the DirectLink.
type DirectLinkSchema struct {
	// Bandwidth The physical link bandwidth (either 1 Gbps or 10 Gbps).
	Bandwidth *string `json:"bandwidth,omitempty"`

	// Id The ID of the DirectLink (for example, `dxcon-xxxxxxxx`).
	Id *string `json:"id,omitempty"`

	// Location The datacenter where the DirectLink is located.
	Location *string `json:"location,omitempty"`

	// Name The name of the DirectLink.
	Name *string `json:"name,omitempty"`

	// RegionName The Region in which the DirectLink has been created.
	RegionName *string `json:"regionName,omitempty"`

	// State The state of the DirectLink.<br />
	// * `requested`: The DirectLink is requested but the request has not been validated yet.<br />
	// * `pending`: The DirectLink request has been validated. It remains in the `pending` state until you establish the physical link.<br />
	// * `available`: The physical link is established and the connection is ready to use.<br />
	//  * `deleting`: The deletion process is in progress.<br />
	// * `deleted`: The DirectLink is deleted.
	State *string `json:"state,omitempty"`
}

// FlexibleGpuCatalogSchema Information about the flexible GPU (fGPU) that is available in the public catalog.
type FlexibleGpuCatalogSchema struct {
	// Generations The generations of VMs that the fGPU is compatible with.
	Generations *[]string `json:"generations,omitempty"`

	// MaxCpu The maximum number of VM vCores that the fGPU is compatible with.
	MaxCpu *int `json:"maxCpu,omitempty"`

	// MaxRam The maximum amount of VM memory that the fGPU is compatible with.
	MaxRam *int `json:"maxRam,omitempty"`

	// ModelName The model of fGPU.
	ModelName *string `json:"modelName,omitempty"`

	// VRam The amount of video RAM (VRAM) of the fGPU.
	VRam *int `json:"vRam,omitempty"`
}

// FlexibleGpuSchema Information about the flexible GPU (fGPU).
type FlexibleGpuSchema struct {
	// DeleteOnVmDeletion If true, the fGPU is deleted when the VM is terminated.
	DeleteOnVmDeletion *bool `json:"deleteOnVmDeletion,omitempty"`

	// Generation The compatible processor generation.
	Generation *string `json:"generation,omitempty"`

	// Id The ID of the fGPU.
	Id *string `json:"id,omitempty"`

	// ModelName The model of fGPU. For more information, see [About Flexible GPUs](https://docs.outscale.com/en/userguide/About-Flexible-GPUs.html).
	ModelName *string `json:"modelName,omitempty"`

	// State The state of the fGPU (`allocated` \| `attaching` \| `attached` \| `detaching`).
	State *string `json:"state,omitempty"`

	// SubregionName The Subregion where the fGPU is located.
	SubregionName *string `json:"subregionName,omitempty"`

	// VmId The ID of the VM the fGPU is attached to, if any.
	VmId *string `json:"vmId,omitempty"`
}

// HealthCheckSchema Information about the health check configuration.
type HealthCheckSchema struct {
	// CheckInterval The number of seconds between two pings (between `5` and `600` both included).
	CheckInterval int `json:"checkInterval"`

	// HealthyThreshold The number of consecutive successful pings before considering the VM as healthy (between `2` and `10` both included).
	HealthyThreshold int `json:"healthyThreshold"`

	// Path If you use the HTTP or HTTPS protocols, the ping path.
	Path *string `json:"path,omitempty"`

	// Port The port number (between `1` and `65535`, both included).
	Port int `json:"port"`

	// Protocol The protocol for the URL of the VM (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
	Protocol string `json:"protocol"`

	// Timeout The maximum waiting time for a response before considering the VM as unhealthy, in seconds (between `2` and `60` both included).
	Timeout int `json:"timeout"`

	// UnhealthyThreshold The number of consecutive failed pings before considering the VM as unhealthy (between `2` and `10` both included).
	UnhealthyThreshold int `json:"unhealthyThreshold"`
}

// ImageSchema Information about the OMI.
type ImageSchema struct {
	// Architecture The architecture of the OMI (by default, `i386`).
	Architecture *string `json:"architecture,omitempty"`

	// BlockDeviceMappings One or more block device mappings.
	BlockDeviceMappings *[]BlockDeviceMappingImageSchema `json:"blockDeviceMappings,omitempty"`

	// CreationDate The date and time of creation of the OMI, in ISO 8601 date-time format.
	CreationDate *time.Time `json:"creationDate,omitempty"`

	// Description The description of the OMI.
	Description *string `json:"description,omitempty"`

	// Id The ID of the OMI.
	Id *string `json:"id,omitempty"`

	// Name The name of the OMI.
	Name *string `json:"name,omitempty"`

	// ProductCodes The product codes associated with the OMI.
	ProductCodes *[]string `json:"productCodes,omitempty"`

	// RootDeviceName The name of the root device.
	RootDeviceName *string `json:"rootDeviceName,omitempty"`

	// RootDeviceType The type of root device used by the OMI (always `bsu`).
	RootDeviceType *string `json:"rootDeviceType,omitempty"`

	// State The state of the OMI (`pending` \| `available` \| `failed`).
	State *string `json:"state,omitempty"`

	// StateComment Information about the change of state.
	StateComment *StateCommentSchema `json:"stateComment,omitempty"`

	// Tags One or more tags associated with the OMI.
	Tags *[]ResourceTagSchema `json:"tags,omitempty"`

	// Type The type of the OMI.
	Type *string `json:"type,omitempty"`
}

// InternetServiceSchema Information about the Internet service.
type InternetServiceSchema struct {
	// Id The ID of the Internet service.
	Id *string `json:"id,omitempty"`

	// NetId The ID of the Net attached to the Internet service.
	NetId *string `json:"netId,omitempty"`

	// State The state of the attachment of the Internet service to the Net (always `available`).
	State *string `json:"state,omitempty"`

	// Tags One or more tags associated with the Internet service.
	Tags *[]ResourceTagSchema `json:"tags,omitempty"`
}

// KeypairCreatedSchema Information about the created keypair.
type KeypairCreatedSchema struct {
	// Fingerprint The MD5 public key fingerprint as specified in section 4 of RFC 4716.
	Fingerprint *string `json:"fingerprint,omitempty"`

	// Name The name of the keypair.
	Name *string `json:"name,omitempty"`

	// PrivateKey The private key. When saving the private key in a .rsa file, replace the `\n` escape sequences with line breaks.
	PrivateKey *string `json:"privateKey,omitempty"`
}

// KeypairSchema Information about the keypair.
type KeypairSchema struct {
	// Fingerprint The MD5 public key fingerprint as specified in section 4 of RFC 4716.
	Fingerprint *string `json:"fingerprint,omitempty"`

	// Name The name of the keypair.
	Name *string `json:"name,omitempty"`
}

// LinkFlexibleGpuRequestSchema defines model for LinkFlexibleGpuRequestSchema.
type LinkFlexibleGpuRequestSchema struct {
	// VmId The ID of the VM you want to attach the fGPU to.
	VmId string `json:"vmId"`
}

// LinkInternetServiceRequestSchema defines model for LinkInternetServiceRequestSchema.
type LinkInternetServiceRequestSchema struct {
	// NetId The ID of the Net to which you want to attach the Internet service.
	NetId string `json:"netId"`
}

// LinkLoadBalancerBackendMachinesRequestSchema defines model for LinkLoadBalancerBackendMachinesRequestSchema.
type LinkLoadBalancerBackendMachinesRequestSchema struct {
	// BackendIps  One or more public IPs of back-end VMs.
	BackendIps *[]string `json:"backendIps,omitempty"`

	// BackendVmIds  One or more IDs of back-end VMs.
	BackendVmIds *[]string `json:"backendVmIds,omitempty"`
}

// LinkNicLightSchema Information about the network interface card (NIC).
type LinkNicLightSchema struct {
	// DeleteOnVmDeletion If true, the NIC is deleted when the VM is terminated.
	DeleteOnVmDeletion *bool `json:"deleteOnVmDeletion,omitempty"`

	// DeviceNumber The device index for the NIC attachment (between `1` and `7`, both included).
	DeviceNumber *int `json:"deviceNumber,omitempty"`

	// LinkNicId The ID of the NIC to attach.
	LinkNicId *string `json:"linkNicId,omitempty"`

	// State The state of the attachment (`attaching` \| `attached` \| `detaching` \| `detached`).
	State *string `json:"state,omitempty"`
}

// LinkNicRequestSchema defines model for LinkNicRequestSchema.
type LinkNicRequestSchema struct {
	// DeviceNumber The index of the VM device for the NIC attachment (between `1` and `7`, both included).
	DeviceNumber int `json:"deviceNumber"`

	// VmId The ID of the VM to which you want to attach the NIC.
	VmId string `json:"vmId"`
}

// LinkNicResponseSchema defines model for LinkNicResponseSchema.
type LinkNicResponseSchema struct {
	// Id The ID of the NIC attachment.
	Id *string `json:"id,omitempty"`
}

// LinkNicToUpdateSchema Information about the NIC attachment. If you are modifying the `DeleteOnVmDeletion` attribute, you must specify the ID of the NIC attachment.
type LinkNicToUpdateSchema struct {
	// DeleteOnVmDeletion If true, the NIC is deleted when the VM is terminated. If false, the NIC is detached from the VM.
	DeleteOnVmDeletion *bool `json:"deleteOnVmDeletion,omitempty"`

	// LinkNicId The ID of the NIC attachment.
	LinkNicId *string `json:"linkNicId,omitempty"`
}

// LinkPrivateIpsRequestSchema defines model for LinkPrivateIpsRequestSchema.
type LinkPrivateIpsRequestSchema struct {
	// AllowRelink If true, allows an IP that is already assigned to another NIC in the same Subnet to be assigned to the NIC you specified.
	AllowRelink *bool `json:"allowRelink,omitempty"`

	// PrivateIps The secondary private IP or IPs you want to assign to the NIC within the IP range of the Subnet.
	PrivateIps *[]string `json:"privateIps,omitempty"`

	// SecondaryPrivateIpCount The number of secondary private IPs to assign to the NIC.
	SecondaryPrivateIpCount *int `json:"secondaryPrivateIpCount,omitempty"`
}

// LinkPublicIpLightForVmSchema Information about the public IP associated with the NIC.
type LinkPublicIpLightForVmSchema struct {
	// PublicDnsName The name of the public DNS.
	PublicDnsName *string `json:"publicDnsName,omitempty"`

	// PublicIp The public IP associated with the NIC.
	PublicIp *string `json:"publicIp,omitempty"`

	// PublicIpAccountId The account ID of the owner of the public IP.
	PublicIpAccountId *string `json:"publicIpAccountId,omitempty"`
}

// LinkPublicIpRequestSchema defines model for LinkPublicIpRequestSchema.
type LinkPublicIpRequestSchema struct {
	// AllowRelink If true, allows the public IP to be associated with the VM or NIC that you specify even if it is already associated with another VM or NIC. If false, prevents the EIP from being associated with the VM or NIC that you specify if it is already associated with another VM or NIC. (By default, true in the public Cloud, false in a Net.)
	AllowRelink *bool `json:"allowRelink,omitempty"`

	// NicId (Net only) The ID of the NIC. This parameter is required if the VM has more than one NIC attached. Otherwise, you need to specify the `VmId` parameter instead. You cannot specify both parameters at the same time.
	NicId *string `json:"nicId,omitempty"`

	// PrivateIp (Net only) The primary or secondary private IP of the specified NIC. By default, the primary private IP.
	PrivateIp *string `json:"privateIp,omitempty"`

	// PublicIp The public IP. This parameter is required unless you use the `PublicIpId` parameter.
	PublicIp *string `json:"publicIp,omitempty"`

	// VmId The ID of the VM.<br />
	// - In the public Cloud, this parameter is required.<br />
	// - In a Net, this parameter is required if the VM has only one NIC. Otherwise, you need to specify the `NicId` parameter instead. You cannot specify both parameters at the same time.
	VmId *string `json:"vmId,omitempty"`
}

// LinkPublicIpResponseSchema defines model for LinkPublicIpResponseSchema.
type LinkPublicIpResponseSchema struct {
	// Id (Net only) The ID representing the association of the public IP with the VM or the NIC.
	Id *string `json:"id,omitempty"`
}

// LinkPublicIpSchema Information about the public IP association.
type LinkPublicIpSchema struct {
	// Id (Required in a Net) The ID representing the association of the public IP with the VM or the NIC.
	Id *string `json:"id,omitempty"`

	// PublicDnsName The name of the public DNS.
	PublicDnsName *string `json:"publicDnsName,omitempty"`

	// PublicIp The public IP associated with the NIC.
	PublicIp *string `json:"publicIp,omitempty"`

	// PublicIpAccountId The account ID of the owner of the public IP.
	PublicIpAccountId *string `json:"publicIpAccountId,omitempty"`

	// PublicIpId The allocation ID of the public IP.
	PublicIpId *string `json:"publicIpId,omitempty"`
}

// LinkRouteTableRequestSchema defines model for LinkRouteTableRequestSchema.
type LinkRouteTableRequestSchema struct {
	// SubnetId The ID of the Subnet.
	SubnetId string `json:"subnetId"`
}

// LinkRouteTableResponseSchema defines model for LinkRouteTableResponseSchema.
type LinkRouteTableResponseSchema struct {
	// Id The ID of the association between the route table and the Subnet.
	Id *string `json:"id,omitempty"`
}

// LinkVirtualGatewayRequestSchema defines model for LinkVirtualGatewayRequestSchema.
type LinkVirtualGatewayRequestSchema struct {
	// NetId The ID of the Net to which you want to attach the virtual gateway.
	NetId string `json:"netId"`
}

// LinkVirtualGatewayResponseSchema defines model for LinkVirtualGatewayResponseSchema.
type LinkVirtualGatewayResponseSchema struct {
	// NetToVirtualGatewayLink Information about the attachment.
	NetToVirtualGatewayLink *NetToVirtualGatewayLinkSchema `json:"netToVirtualGatewayLink,omitempty"`
}

// LinkVolumeRequestSchema defines model for LinkVolumeRequestSchema.
type LinkVolumeRequestSchema struct {
	// DeviceName The name of the device. For a root device, you must use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, and the second `X` is a letter between `a` and `z`).
	DeviceName string `json:"deviceName"`

	// VmId The ID of the VM you want to attach the volume to.
	VmId string `json:"vmId"`
}

// LinkedVolumeSchema Information about volume attachment.
type LinkedVolumeSchema struct {
	// DeleteOnVmDeletion If true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.
	DeleteOnVmDeletion *bool `json:"deleteOnVmDeletion,omitempty"`

	// DeviceName The name of the device.
	DeviceName *string `json:"deviceName,omitempty"`

	// State The state of the attachment of the volume (`attaching` \| `detaching` \| `attached` \| `detached`).
	State *string `json:"state,omitempty"`

	// VmId The ID of the VM.
	VmId *string `json:"vmId,omitempty"`

	// VolumeId The ID of the volume.
	VolumeId *string `json:"volumeId,omitempty"`
}

// ListenerForCreationSchema Information about the listener to create.
type ListenerForCreationSchema struct {
	// BackendPort The port on which the back-end VM is listening (between `1` and `65535`, both included).
	BackendPort int `json:"backendPort"`

	// BackendProtocol The protocol for routing traffic to back-end VMs (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
	BackendProtocol *string `json:"backendProtocol,omitempty"`

	// LoadBalancerPort The port on which the load balancer is listening (between `1` and `65535`, both included).
	LoadBalancerPort int `json:"loadBalancerPort"`

	// LoadBalancerProtocol The routing protocol (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
	LoadBalancerProtocol string `json:"loadBalancerProtocol"`
}

// ListenerRuleForCreationSchema Information about the listener rule.
type ListenerRuleForCreationSchema struct {
	// Action The type of action for the rule (always `forward`).
	Action *string `json:"action,omitempty"`

	// HostNamePattern A host-name pattern for the rule, with a maximum length of 128 characters. This host-name pattern supports maximum three wildcards, and must not contain any special characters except [-.?].
	HostNamePattern *string `json:"hostNamePattern,omitempty"`

	// ListenerRuleName A human-readable name for the listener rule.
	ListenerRuleName string `json:"listenerRuleName"`

	// PathPattern A path pattern for the rule, with a maximum length of 128 characters. This path pattern supports maximum three wildcards, and must not contain any special characters except [_-.$/~&quot;'@:+?].
	PathPattern *string `json:"pathPattern,omitempty"`

	// Priority The priority level of the listener rule, between `1` and `19999` both included. Each rule must have a unique priority level. Otherwise, an error is returned.
	Priority int `json:"priority"`
}

// ListenerRuleSchema Information about the listener rule.
type ListenerRuleSchema struct {
	// Action The type of action for the rule (always `forward`).
	Action *string `json:"action,omitempty"`

	// HostNamePattern A host-name pattern for the rule, with a maximum length of 128 characters. This host-name pattern supports maximum three wildcards, and must not contain any special characters except [-.?].
	HostNamePattern *string `json:"hostNamePattern,omitempty"`

	// Id The ID of the listener rule.
	Id *int `json:"id,omitempty"`

	// ListenerId The ID of the listener.
	ListenerId *int `json:"listenerId,omitempty"`

	// Name A human-readable name for the listener rule.
	Name *string `json:"name,omitempty"`

	// PathPattern A path pattern for the rule, with a maximum length of 128 characters. This path pattern supports maximum three wildcards, and must not contain any special characters except [_-.$/~&quot;'@:+?].
	PathPattern *string `json:"pathPattern,omitempty"`

	// Priority The priority level of the listener rule, between `1` and `19999` both included. Each rule must have a unique priority level. Otherwise, an error is returned.
	Priority *int `json:"priority,omitempty"`

	// VmIds The IDs of the backend VMs.
	VmIds *[]string `json:"vmIds,omitempty"`
}

// ListenerSchema Information about the listener.
type ListenerSchema struct {
	// BackendPort The port on which the back-end VM is listening (between `1` and `65535`, both included).
	BackendPort *int `json:"backendPort,omitempty"`

	// BackendProtocol The protocol for routing traffic to back-end VMs (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
	BackendProtocol *string `json:"backendProtocol,omitempty"`

	// LoadBalancerPort The port on which the load balancer is listening (between `1` and `65535`, both included).
	LoadBalancerPort *int `json:"loadBalancerPort,omitempty"`

	// LoadBalancerProtocol The routing protocol (`HTTP` \| `HTTPS` \| `TCP` \| `SSL`).
	LoadBalancerProtocol *string `json:"loadBalancerProtocol,omitempty"`

	// PolicyNames The names of the policies. If there are no policies enabled, the list is empty.
	PolicyNames *[]string `json:"policyNames,omitempty"`

	// ServerCertificateId The OUTSCALE Resource Name (ORN) of the server certificate. For more information, see [Resource Identifiers > OUTSCALE Resource Names (ORNs)](https://docs.outscale.com/en/userguide/Resource-Identifiers.html#_outscale_resource_names_orns).
	ServerCertificateId *string `json:"serverCertificateId,omitempty"`
}

// LoadBalancerLightSchema Information about the load balancer.
type LoadBalancerLightSchema struct {
	// LoadBalancerName The name of the load balancer to which the listener is attached.
	LoadBalancerName string `json:"loadBalancerName"`

	// LoadBalancerPort The port of load balancer on which the load balancer is listening (between `1` and `65535` both included).
	LoadBalancerPort int `json:"loadBalancerPort"`
}

// LoadBalancerSchema Information about the load balancer.
type LoadBalancerSchema struct {
	// ApplicationStickyCookiePolicies The stickiness policies defined for the load balancer.
	ApplicationStickyCookiePolicies *[]ApplicationStickyCookiePolicySchema `json:"applicationStickyCookiePolicies,omitempty"`

	// BackendIps One or more public IPs of back-end VMs.
	BackendIps *[]string `json:"backendIps,omitempty"`

	// BackendVmIds One or more IDs of back-end VMs for the load balancer.
	BackendVmIds *[]string `json:"backendVmIds,omitempty"`

	// DnsName The DNS name of the load balancer.
	DnsName *string `json:"dnsName,omitempty"`

	// HealthCheck Information about the health check configuration.
	HealthCheck *HealthCheckSchema `json:"healthCheck,omitempty"`

	// Listeners The listeners for the load balancer.
	Listeners *[]ListenerSchema `json:"listeners,omitempty"`

	// Name The name of the load balancer.
	Name *string `json:"name,omitempty"`

	// NetId The ID of the Net for the load balancer.
	NetId *string `json:"netId,omitempty"`

	// PublicIp (internet-facing only) The public IP associated with the load balancer.
	PublicIp *string `json:"publicIp,omitempty"`

	// SecuredCookies Whether secure cookies are enabled for the load balancer.
	SecuredCookies *bool `json:"securedCookies,omitempty"`

	// SecurityGroups One or more IDs of security groups for the load balancers. Valid only for load balancers in a Net.
	SecurityGroups *[]string `json:"securityGroups,omitempty"`

	// SourceSecurityGroup Information about the source security group of the load balancer, which you can use as part of your inbound rules for your registered VMs.<br />
	// To only allow traffic from load balancers, add a security group rule that specifies this source security group as the inbound source.
	SourceSecurityGroup *SourceSecurityGroupSchema `json:"sourceSecurityGroup,omitempty"`

	// StickyCookiePolicies The policies defined for the load balancer.
	StickyCookiePolicies *[]LoadBalancerStickyCookiePolicySchema `json:"stickyCookiePolicies,omitempty"`

	// Subnets The ID of the Subnet in which the load balancer was created.
	Subnets *[]string `json:"subnets,omitempty"`

	// SubregionNames The ID of the Subregion in which the load balancer was created.
	SubregionNames *[]string `json:"subregionNames,omitempty"`

	// Tags One or more tags associated with the load balancer.
	Tags *[]ResourceTagSchema `json:"tags,omitempty"`

	// Type The type of load balancer. Valid only for load balancers in a Net.<br />
	// If `LoadBalancerType` is `internet-facing`, the load balancer has a public DNS name that resolves to a public IP.<br />
	// If `LoadBalancerType` is `internal`, the load balancer has a public DNS name that resolves to a private IP.
	Type *string `json:"type,omitempty"`
}

// LoadBalancerStickyCookiePolicySchema Information about the stickiness policy.
type LoadBalancerStickyCookiePolicySchema struct {
	// CookieExpirationPeriod The time period, in seconds, after which the cookie should be considered stale.<br />
	// If `1`, the stickiness session lasts for the duration of the browser session.
	CookieExpirationPeriod *int `json:"cookieExpirationPeriod,omitempty"`

	// PolicyName The name of the stickiness policy.
	PolicyName *string `json:"policyName,omitempty"`
}

// LoadBalancerTagSchema Information about the load balancer tag.
type LoadBalancerTagSchema struct {
	// Key The key of the tag.
	Key *string `json:"key,omitempty"`

	// LoadBalancerName The name of the load balancer.
	LoadBalancerName *string `json:"loadBalancerName,omitempty"`

	// Value The value of the tag.
	Value *string `json:"value,omitempty"`
}

// LocationSchema Information about the DirectLink location.
type LocationSchema struct {
	// Code The location code, to be set as the `Location` parameter of the *CreateDirectLink* method when creating a DirectLink.
	Code *string `json:"code,omitempty"`

	// Name The name and description of the location, corresponding to a datacenter.
	Name *string `json:"name,omitempty"`
}

// MaintenanceEventSchema Information about the maintenance event.
type MaintenanceEventSchema struct {
	// Code The code of the event (`system-reboot` \| `system-maintenance`).
	Code *string `json:"code,omitempty"`

	// Description The description of the event.
	Description *string `json:"description,omitempty"`

	// NotAfter The latest scheduled end time for the event.
	NotAfter *openapi_types.Date `json:"notAfter,omitempty"`

	// NotBefore The earliest scheduled start time for the event.
	NotBefore *openapi_types.Date `json:"notBefore,omitempty"`
}

// NatServiceSchema Information about the NAT service.
type NatServiceSchema struct {
	// Id The ID of the NAT service.
	Id *string `json:"id,omitempty"`

	// NetId The ID of the Net in which the NAT service is.
	NetId *string `json:"netId,omitempty"`

	// PublicIps Information about the public IP or IPs associated with the NAT service.
	PublicIps *[]PublicIpLightSchema `json:"publicIps,omitempty"`

	// State The state of the NAT service (`pending` \| `available` \| `deleting` \| `deleted`).
	State *string `json:"state,omitempty"`

	// SubnetId The ID of the Subnet in which the NAT service is.
	SubnetId *string `json:"subnetId,omitempty"`

	// Tags One or more tags associated with the NAT service.
	Tags *[]ResourceTagSchema `json:"tags,omitempty"`
}

// NetAccessPointSchema Information about the Net access point.
type NetAccessPointSchema struct {
	// Id The ID of the Net access point.
	Id *string `json:"id,omitempty"`

	// NetId The ID of the Net with which the Net access point is associated.
	NetId *string `json:"netId,omitempty"`

	// RouteTableIds The ID of the route tables associated with the Net access point.
	RouteTableIds *[]string `json:"routeTableIds,omitempty"`

	// ServiceName The name of the service with which the Net access point is associated.
	ServiceName *string `json:"serviceName,omitempty"`

	// State The state of the Net access point (`pending` \| `available` \| `deleting` \| `deleted`).
	State *string `json:"state,omitempty"`

	// Tags One or more tags associated with the Net access point.
	Tags *[]ResourceTagSchema `json:"tags,omitempty"`
}

// NetPeeringSchema Information about the Net peering.
type NetPeeringSchema struct {
	// AccepterNet Information about the accepter Net.
	AccepterNet *AccepterNetSchema `json:"accepterNet,omitempty"`

	// Id The ID of the Net peering.
	Id *string `json:"id,omitempty"`

	// SourceNet Information about the source Net.
	SourceNet *SourceNetSchema `json:"sourceNet,omitempty"`

	// State Information about the state of the Net peering.
	State *NetPeeringStateSchema `json:"state,omitempty"`

	// Tags One or more tags associated with the Net peering.
	Tags *[]ResourceTagSchema `json:"tags,omitempty"`
}

// NetPeeringStateSchema Information about the state of the Net peering.
type NetPeeringStateSchema struct {
	// Message Additional information about the state of the Net peering.
	Message *string `json:"message,omitempty"`

	// Name The state of the Net peering (`pending-acceptance` \| `active` \| `rejected` \| `failed` \| `expired` \| `deleted`).
	Name *string `json:"name,omitempty"`
}

// NetSchema Information about the Net.
type NetSchema struct {
	// DhcpOptionsSetId The ID of the DHCP options set (or `default` if you want to associate the default one).
	DhcpOptionsSetId *string `json:"dhcpOptionsSetId,omitempty"`

	// Id The ID of the Net.
	Id *string `json:"id,omitempty"`

	// IpRange The IP range for the Net, in CIDR notation (for example, `10.0.0.0/16`).
	IpRange *string `json:"ipRange,omitempty"`

	// State The state of the Net (`pending` \| `available` \| `deleted`).
	State *string `json:"state,omitempty"`

	// Tags One or more tags associated with the Net.
	Tags *[]ResourceTagSchema `json:"tags,omitempty"`

	// Tenancy The VM tenancy in a Net.
	Tenancy *string `json:"tenancy,omitempty"`
}

// NetToVirtualGatewayLinkSchema Information about the attachment.
type NetToVirtualGatewayLinkSchema struct {
	// NetId The ID of the Net to which the virtual gateway is attached.
	NetId *string `json:"netId,omitempty"`

	// State The state of the attachment (`attaching` \| `attached` \| `detaching` \| `detached`).
	State *string `json:"state,omitempty"`
}

// NicForVmCreationSchema Information about the network interface card (NIC) when creating a virtual machine (VM).
type NicForVmCreationSchema struct {
	// DeleteOnVmDeletion If true, the NIC is deleted when the VM is terminated. You can specify this parameter only for a new NIC. To modify this value for an existing NIC, see [UpdateNic](#updatenic).
	DeleteOnVmDeletion *bool `json:"deleteOnVmDeletion,omitempty"`

	// Description The description of the NIC, if you are creating a NIC when creating the VM.
	Description *string `json:"description,omitempty"`

	// DeviceNumber The index of the VM device for the NIC attachment (between `0` and `7`, both included). This parameter is required if you create a NIC when creating the VM.
	DeviceNumber *int `json:"deviceNumber,omitempty"`

	// NicId The ID of the NIC, if you are attaching an existing NIC when creating a VM.
	NicId *string `json:"nicId,omitempty"`

	// PrivateIps One or more private IPs to assign to the NIC, if you create a NIC when creating a VM. Only one private IP can be the primary private IP.
	PrivateIps *[]PrivateIpLightSchema `json:"privateIps,omitempty"`

	// SecondaryPrivateIpCount The number of secondary private IPs, if you create a NIC when creating a VM. This parameter cannot be specified if you specified more than one private IP in the `PrivateIps` parameter.
	SecondaryPrivateIpCount *int `json:"secondaryPrivateIpCount,omitempty"`

	// SecurityGroupIds One or more IDs of security groups for the NIC, if you create a NIC when creating a VM.
	SecurityGroupIds *[]string `json:"securityGroupIds,omitempty"`

	// SubnetId The ID of the Subnet for the NIC, if you create a NIC when creating a VM. This parameter is required if you create a NIC when creating the VM.
	SubnetId *string `json:"subnetId,omitempty"`
}

// NicLightSchema Information about the network interface card (NIC).
type NicLightSchema struct {
	// AccountId The account ID of the owner of the NIC.
	AccountId *string `json:"accountId,omitempty"`

	// Description The description of the NIC.
	Description *string `json:"description,omitempty"`

	// IsSourceDestChecked (Net only) If true, the source/destination check is enabled. If false, it is disabled. This value must be false for a NAT VM to perform network address translation (NAT) in a Net.
	IsSourceDestChecked *bool `json:"isSourceDestChecked,omitempty"`

	// LinkNic Information about the network interface card (NIC).
	LinkNic *LinkNicLightSchema `json:"linkNic,omitempty"`

	// LinkPublicIp Information about the public IP associated with the NIC.
	LinkPublicIp *LinkPublicIpLightForVmSchema `json:"linkPublicIp,omitempty"`

	// MacAddress The Media Access Control (MAC) address of the NIC.
	MacAddress *string `json:"macAddress,omitempty"`

	// NetId The ID of the Net for the NIC.
	NetId *string `json:"netId,omitempty"`

	// NicId The ID of the NIC.
	NicId *string `json:"nicId,omitempty"`

	// PrivateDnsName The name of the private DNS.
	PrivateDnsName *string `json:"privateDnsName,omitempty"`

	// PrivateIps The private IP or IPs of the NIC.
	PrivateIps *[]PrivateIpLightForVmSchema `json:"privateIps,omitempty"`

	// SecurityGroups One or more IDs of security groups for the NIC.
	SecurityGroups *[]SecurityGroupLightSchema `json:"securityGroups,omitempty"`

	// State The state of the NIC (`available` \| `attaching` \| `in-use` \| `detaching`).
	State *string `json:"state,omitempty"`

	// SubnetId The ID of the Subnet for the NIC.
	SubnetId *string `json:"subnetId,omitempty"`
}

// NicSchema Information about the NIC.
type NicSchema struct {
	// AccountId The account ID of the owner of the NIC.
	AccountId *string `json:"accountId,omitempty"`

	// Description The description of the NIC.
	Description *string `json:"description,omitempty"`

	// Id The ID of the NIC.
	Id *string `json:"id,omitempty"`

	// IsSourceDestChecked (Net only) If true, the source/destination check is enabled. If false, it is disabled. This value must be false for a NAT VM to perform network address translation (NAT) in a Net.
	IsSourceDestChecked *bool `json:"isSourceDestChecked,omitempty"`

	// LinkPublicIp Information about the public IP association.
	LinkPublicIp *LinkPublicIpSchema `json:"linkPublicIp,omitempty"`

	// MacAddress The Media Access Control (MAC) address of the NIC.
	MacAddress *string `json:"macAddress,omitempty"`

	// NetId The ID of the Net for the NIC.
	NetId *string `json:"netId,omitempty"`

	// PrivateDnsName The name of the private DNS.
	PrivateDnsName *string `json:"privateDnsName,omitempty"`

	// PrivateIps The private IPs of the NIC.
	PrivateIps *[]PrivateIpSchema `json:"privateIps,omitempty"`

	// SecurityGroups One or more IDs of security groups for the NIC.
	SecurityGroups *[]SecurityGroupLightSchema `json:"securityGroups,omitempty"`

	// State The state of the NIC (`available` \| `attaching` \| `in-use` \| `detaching`).
	State *string `json:"state,omitempty"`

	// SubnetId The ID of the Subnet.
	SubnetId *string `json:"subnetId,omitempty"`

	// SubregionName The Subregion in which the NIC is located.
	SubregionName *string `json:"subregionName,omitempty"`

	// Tags One or more tags associated with the NIC.
	Tags *[]ResourceTagSchema `json:"tags,omitempty"`
}

// PermissionsOnResourceCreationSchema Information about the permissions for the resource.<br />
// Specify either the `Additions` or the `Removals` parameter.
type PermissionsOnResourceCreationSchema struct {
	// Additions Permissions for the resource.
	Additions *PermissionsOnResourceSchema `json:"additions,omitempty"`

	// Removals Permissions for the resource.
	Removals *PermissionsOnResourceSchema `json:"removals,omitempty"`
}

// PermissionsOnResourceSchema Permissions for the resource.
type PermissionsOnResourceSchema struct {
	// AccountIds One or more account IDs that the permission is associated with.
	AccountIds *[]string `json:"accountIds,omitempty"`

	// GlobalPermission A global permission for all accounts.<br />
	// (Request) Set this parameter to true to make the resource public (if the parent parameter is `Additions`) or to make the resource private (if the parent parameter is `Removals`).<br />
	// (Response) If true, the resource is public. If false, the resource is private.
	GlobalPermission *bool `json:"globalPermission,omitempty"`
}

// Phase1OptionsSchema Information about Phase 1 of the Internet Key Exchange (IKE) negotiation. When Phase 1 finishes successfully, peers proceed to Phase 2 negotiations.
type Phase1OptionsSchema struct {
	// DpdTimeoutAction The action to carry out after a Dead Peer Detection (DPD) timeout occurs.
	DpdTimeoutAction *string `json:"dpdTimeoutAction,omitempty"`

	// DpdTimeoutSeconds The maximum waiting time for a Dead Peer Detection (DPD) response before considering the peer as dead, in seconds.
	DpdTimeoutSeconds *int `json:"dpdTimeoutSeconds,omitempty"`

	// IkeVersions The Internet Key Exchange (IKE) versions allowed for the VPN tunnel.
	IkeVersions *[]string `json:"ikeVersions,omitempty"`

	// Phase1DhGroupNumbers The Diffie-Hellman (DH) group numbers allowed for the VPN tunnel for phase 1.
	Phase1DhGroupNumbers *[]int `json:"phase1DhGroupNumbers,omitempty"`

	// Phase1EncryptionAlgorithms The encryption algorithms allowed for the VPN tunnel for phase 1.
	Phase1EncryptionAlgorithms *[]string `json:"phase1EncryptionAlgorithms,omitempty"`

	// Phase1IntegrityAlgorithms The integrity algorithms allowed for the VPN tunnel for phase 1.
	Phase1IntegrityAlgorithms *[]string `json:"phase1IntegrityAlgorithms,omitempty"`

	// Phase1LifetimeSeconds The lifetime for phase 1 of the IKE negotiation process, in seconds.
	Phase1LifetimeSeconds *int `json:"phase1LifetimeSeconds,omitempty"`

	// ReplayWindowSize The number of packets in an IKE replay window.
	ReplayWindowSize *int `json:"replayWindowSize,omitempty"`

	// StartupAction The action to carry out when establishing tunnels for a VPN connection.
	StartupAction *string `json:"startupAction,omitempty"`
}

// Phase2OptionsSchema Information about Phase 2 of the Internet Key Exchange (IKE) negotiation.
type Phase2OptionsSchema struct {
	// Phase2DhGroupNumbers The Diffie-Hellman (DH) group numbers allowed for the VPN tunnel for phase 2.
	Phase2DhGroupNumbers *[]int `json:"phase2DhGroupNumbers,omitempty"`

	// Phase2EncryptionAlgorithms The encryption algorithms allowed for the VPN tunnel for phase 2.
	Phase2EncryptionAlgorithms *[]string `json:"phase2EncryptionAlgorithms,omitempty"`

	// Phase2IntegrityAlgorithms The integrity algorithms allowed for the VPN tunnel for phase 2.
	Phase2IntegrityAlgorithms *[]string `json:"phase2IntegrityAlgorithms,omitempty"`

	// Phase2LifetimeSeconds The lifetime for phase 2 of the Internet Key Exchange (IKE) negociation process, in seconds.
	Phase2LifetimeSeconds *int `json:"phase2LifetimeSeconds,omitempty"`

	// PreSharedKey The pre-shared key to establish the initial authentication between the client gateway and the virtual gateway. This key can contain any character except line breaks and double quotes (&quot;).
	PreSharedKey *string `json:"preSharedKey,omitempty"`
}

// PlacementSchema Information about the placement of the VM.
type PlacementSchema struct {
	// SubregionName The name of the Subregion. If you specify this parameter, you must not specify the `Nics` parameter.
	SubregionName *string `json:"subregionName,omitempty"`

	// Tenancy The tenancy of the VM (`default` \| `dedicated`).
	Tenancy *string `json:"tenancy,omitempty"`
}

// PrivateIpLightForVmSchema Information about the private IP of the NIC.
type PrivateIpLightForVmSchema struct {
	// IsPrimary If true, the IP is the primary private IP of the NIC.
	IsPrimary *bool `json:"isPrimary,omitempty"`

	// LinkPublicIp Information about the public IP associated with the NIC.
	LinkPublicIp *LinkPublicIpLightForVmSchema `json:"linkPublicIp,omitempty"`

	// PrivateDnsName The name of the private DNS.
	PrivateDnsName *string `json:"privateDnsName,omitempty"`

	// PrivateIp The private IP.
	PrivateIp *string `json:"privateIp,omitempty"`
}

// PrivateIpLightSchema Information about the private IP.
type PrivateIpLightSchema struct {
	// IsPrimary If true, the IP is the primary private IP of the NIC.
	IsPrimary *bool `json:"isPrimary,omitempty"`

	// PrivateIp The private IP of the NIC.
	PrivateIp *string `json:"privateIp,omitempty"`
}

// PrivateIpSchema Information about the private IP.
type PrivateIpSchema struct {
	// IsPrimary If true, the IP is the primary private IP of the NIC.
	IsPrimary *bool `json:"isPrimary,omitempty"`

	// LinkPublicIp Information about the public IP association.
	LinkPublicIp *LinkPublicIpSchema `json:"linkPublicIp,omitempty"`

	// PrivateDnsName The name of the private DNS.
	PrivateDnsName *string `json:"privateDnsName,omitempty"`

	// PrivateIp The private IP of the NIC.
	PrivateIp *string `json:"privateIp,omitempty"`
}

// ProductTypeSchema Information about the product type.
type ProductTypeSchema struct {
	// Description The description of the product type.
	Description *string `json:"description,omitempty"`

	// Id The ID of the product type.
	Id *string `json:"id,omitempty"`

	// Vendor The vendor of the product type.
	Vendor *string `json:"vendor,omitempty"`
}

// PublicIpLightSchema Information about the public IP.
type PublicIpLightSchema struct {
	// PublicIp The public IP associated with the NAT service.
	PublicIp *string `json:"publicIp,omitempty"`

	// PublicIpId The allocation ID of the public IP associated with the NAT service.
	PublicIpId *string `json:"publicIpId,omitempty"`
}

// PublicIpSchema Information about the public IP.
type PublicIpSchema struct {
	// Id The allocation ID of the public IP.
	Id *string `json:"id,omitempty"`

	// NicAccountId The account ID of the owner of the NIC.
	NicAccountId *string `json:"nicAccountId,omitempty"`

	// NicId The ID of the NIC the public IP is associated with (if any).
	NicId *string `json:"nicId,omitempty"`

	// PrivateIp The private IP associated with the public IP.
	PrivateIp *string `json:"privateIp,omitempty"`

	// PublicIp The public IP.
	PublicIp *string `json:"publicIp,omitempty"`

	// Tags One or more tags associated with the public IP.
	Tags *[]ResourceTagSchema `json:"tags,omitempty"`

	// VmId The ID of the VM the public IP is associated with (if any).
	VmId *string `json:"vmId,omitempty"`
}

// ReadAdminPasswordRequestSchema defines model for ReadAdminPasswordRequestSchema.
type ReadAdminPasswordRequestSchema struct {
	// VmId The ID of the VM.
	VmId string `json:"vmId"`
}

// ReadAdminPasswordResponseSchema defines model for ReadAdminPasswordResponseSchema.
type ReadAdminPasswordResponseSchema struct {
	// AdminPassword The password of the VM. After the first boot, returns an empty string.
	AdminPassword *string `json:"adminPassword,omitempty"`

	// VmId The ID of the VM.
	VmId *string `json:"vmId,omitempty"`
}

// ReadClientGatewaysResponseSchema defines model for ReadClientGatewaysResponseSchema.
type ReadClientGatewaysResponseSchema struct {
	// ClientGateways Information about one or more client gateways.
	ClientGateways *[]ClientGatewaySchema `json:"clientGateways,omitempty"`
}

// ReadConsoleOutputRequestSchema defines model for ReadConsoleOutputRequestSchema.
type ReadConsoleOutputRequestSchema struct {
	// VmId The ID of the VM.
	VmId string `json:"vmId"`
}

// ReadConsoleOutputResponseSchema defines model for ReadConsoleOutputResponseSchema.
type ReadConsoleOutputResponseSchema struct {
	// ConsoleOutput The Base64-encoded output of the console. If a command line tool is used, the output is decoded by the tool.
	ConsoleOutput *string `json:"consoleOutput,omitempty"`

	// VmId The ID of the VM.
	VmId *string `json:"vmId,omitempty"`
}

// ReadDhcpOptionsResponseSchema defines model for ReadDhcpOptionsResponseSchema.
type ReadDhcpOptionsResponseSchema struct {
	// DhcpOptionsSets Information about one or more DHCP options sets.
	DhcpOptionsSets *[]DhcpOptionsSetSchema `json:"dhcpOptionsSets,omitempty"`
}

// ReadDirectLinkInterfacesResponseSchema defines model for ReadDirectLinkInterfacesResponseSchema.
type ReadDirectLinkInterfacesResponseSchema struct {
	// DirectLinkInterfaces Information about one or more DirectLink interfaces.
	DirectLinkInterfaces *[]DirectLinkInterfacesSchema `json:"directLinkInterfaces,omitempty"`
}

// ReadDirectLinksResponseSchema defines model for ReadDirectLinksResponseSchema.
type ReadDirectLinksResponseSchema struct {
	// DirectLinks Information about one or more DirectLinks.
	DirectLinks *[]DirectLinkSchema `json:"directLinks,omitempty"`
}

// ReadFlexibleGpuCatalogRequestSchema defines model for ReadFlexibleGpuCatalogRequestSchema.
type ReadFlexibleGpuCatalogRequestSchema = map[string]interface{}

// ReadFlexibleGpuCatalogResponseSchema defines model for ReadFlexibleGpuCatalogResponseSchema.
type ReadFlexibleGpuCatalogResponseSchema struct {
	// FlexibleGpuCatalog Information about one or more fGPUs available in the public catalog.
	FlexibleGpuCatalog *[]FlexibleGpuCatalogSchema `json:"flexibleGpuCatalog,omitempty"`
}

// ReadFlexibleGpusResponseSchema defines model for ReadFlexibleGpusResponseSchema.
type ReadFlexibleGpusResponseSchema struct {
	// FlexibleGpus Information about one or more fGPUs.
	FlexibleGpus *[]FlexibleGpuSchema `json:"flexibleGpus,omitempty"`
}

// ReadImagesResponseSchema defines model for ReadImagesResponseSchema.
type ReadImagesResponseSchema struct {
	// Images Information about one or more OMIs.
	Images *[]ImageSchema `json:"images,omitempty"`
}

// ReadInternetServicesResponseSchema defines model for ReadInternetServicesResponseSchema.
type ReadInternetServicesResponseSchema struct {
	// InternetServices Information about one or more Internet services.
	InternetServices *[]InternetServiceSchema `json:"internetServices,omitempty"`
}

// ReadKeypairsResponseSchema defines model for ReadKeypairsResponseSchema.
type ReadKeypairsResponseSchema struct {
	// Keypairs Information about one or more keypairs.
	Keypairs *[]KeypairSchema `json:"keypairs,omitempty"`
}

// ReadListenerRulesResponseSchema defines model for ReadListenerRulesResponseSchema.
type ReadListenerRulesResponseSchema struct {
	// ListenerRules The list of the rules to describe.
	ListenerRules *[]ListenerRuleSchema `json:"listenerRules,omitempty"`
}

// ReadLoadBalancerTagsRequestSchema defines model for ReadLoadBalancerTagsRequestSchema.
type ReadLoadBalancerTagsRequestSchema struct {
	// LoadBalancerNames One or more load balancer names.
	LoadBalancerNames []string `json:"loadBalancerNames"`
}

// ReadLoadBalancerTagsResponseSchema defines model for ReadLoadBalancerTagsResponseSchema.
type ReadLoadBalancerTagsResponseSchema struct {
	// Tags Information about one or more load balancer tags.
	Tags *[]LoadBalancerTagSchema `json:"tags,omitempty"`
}

// ReadLoadBalancersResponseSchema defines model for ReadLoadBalancersResponseSchema.
type ReadLoadBalancersResponseSchema struct {
	// LoadBalancers Information about one or more load balancers.
	LoadBalancers *[]LoadBalancerSchema `json:"loadBalancers,omitempty"`
}

// ReadLocationsRequestSchema defines model for ReadLocationsRequestSchema.
type ReadLocationsRequestSchema = map[string]interface{}

// ReadLocationsResponseSchema defines model for ReadLocationsResponseSchema.
type ReadLocationsResponseSchema struct {
	// Locations Information about one or more locations.
	Locations *[]LocationSchema `json:"locations,omitempty"`
}

// ReadNatServicesResponseSchema defines model for ReadNatServicesResponseSchema.
type ReadNatServicesResponseSchema struct {
	// NatServices Information about one or more NAT services.
	NatServices *[]NatServiceSchema `json:"natServices,omitempty"`
}

// ReadNetAccessPointsResponseSchema defines model for ReadNetAccessPointsResponseSchema.
type ReadNetAccessPointsResponseSchema struct {
	// NetAccessPoints One or more Net access points.
	NetAccessPoints *[]NetAccessPointSchema `json:"netAccessPoints,omitempty"`
}

// ReadNetPeeringsResponseSchema defines model for ReadNetPeeringsResponseSchema.
type ReadNetPeeringsResponseSchema struct {
	// NetPeerings Information about one or more Net peerings.
	NetPeerings *[]NetPeeringSchema `json:"netPeerings,omitempty"`
}

// ReadNetsResponseSchema defines model for ReadNetsResponseSchema.
type ReadNetsResponseSchema struct {
	// Nets Information about the described Nets.
	Nets *[]NetSchema `json:"nets,omitempty"`
}

// ReadNicsResponseSchema defines model for ReadNicsResponseSchema.
type ReadNicsResponseSchema struct {
	// Nics Information about one or more NICs.
	Nics *[]NicSchema `json:"nics,omitempty"`
}

// ReadProductTypesResponseSchema defines model for ReadProductTypesResponseSchema.
type ReadProductTypesResponseSchema struct {
	// ProductTypes Information about one or more product types.
	ProductTypes *[]ProductTypeSchema `json:"productTypes,omitempty"`
}

// ReadPublicIpRangesRequestSchema defines model for ReadPublicIpRangesRequestSchema.
type ReadPublicIpRangesRequestSchema = map[string]interface{}

// ReadPublicIpRangesResponseSchema defines model for ReadPublicIpRangesResponseSchema.
type ReadPublicIpRangesResponseSchema struct {
	// PublicIps The list of public IPv4 addresses used in the Region, in CIDR notation.
	PublicIps *[]string `json:"publicIps,omitempty"`
}

// ReadPublicIpsResponseSchema defines model for ReadPublicIpsResponseSchema.
type ReadPublicIpsResponseSchema struct {
	// PublicIps Information about one or more public IPs.
	PublicIps *[]PublicIpSchema `json:"publicIps,omitempty"`
}

// ReadRouteTablesResponseSchema defines model for ReadRouteTablesResponseSchema.
type ReadRouteTablesResponseSchema struct {
	// RouteTables Information about one or more route tables.
	RouteTables *[]RouteTableSchema `json:"routeTables,omitempty"`
}

// ReadSecurityGroupsResponseSchema defines model for ReadSecurityGroupsResponseSchema.
type ReadSecurityGroupsResponseSchema struct {
	// SecurityGroups Information about one or more security groups.
	SecurityGroups *[]SecurityGroupSchema `json:"securityGroups,omitempty"`
}

// ReadSnapshotsResponseSchema defines model for ReadSnapshotsResponseSchema.
type ReadSnapshotsResponseSchema struct {
	// Snapshots Information about one or more snapshots and their permissions.
	Snapshots *[]SnapshotSchema `json:"snapshots,omitempty"`
}

// ReadSubnetsResponseSchema defines model for ReadSubnetsResponseSchema.
type ReadSubnetsResponseSchema struct {
	// Subnets Information about one or more Subnets.
	Subnets *[]SubnetSchema `json:"subnets,omitempty"`
}

// ReadTagsResponseSchema defines model for ReadTagsResponseSchema.
type ReadTagsResponseSchema struct {
	// Tags Information about one or more tags.
	Tags *[]TagSchema `json:"tags,omitempty"`
}

// ReadVirtualGatewaysResponseSchema defines model for ReadVirtualGatewaysResponseSchema.
type ReadVirtualGatewaysResponseSchema struct {
	// VirtualGateways Information about one or more virtual gateways.
	VirtualGateways *[]VirtualGatewaySchema `json:"virtualGateways,omitempty"`
}

// ReadVmsHealthRequestSchema defines model for ReadVmsHealthRequestSchema.
type ReadVmsHealthRequestSchema struct {
	// BackendVmIds One or more IDs of back-end VMs.
	BackendVmIds *[]string `json:"backendVmIds,omitempty"`

	// LoadBalancerName The name of the load balancer.
	LoadBalancerName string `json:"loadBalancerName"`
}

// ReadVmsHealthResponseSchema defines model for ReadVmsHealthResponseSchema.
type ReadVmsHealthResponseSchema struct {
	// BackendVmHealth Information about the health of one or more back-end VMs.
	BackendVmHealth *[]BackendVmHealthSchema `json:"backendVmHealth,omitempty"`
}

// ReadVmsResponseSchema defines model for ReadVmsResponseSchema.
type ReadVmsResponseSchema struct {
	// Vms Information about one or more VMs.
	Vms *[]VmSchema `json:"vms,omitempty"`
}

// ReadVmsStateResponseSchema defines model for ReadVmsStateResponseSchema.
type ReadVmsStateResponseSchema struct {
	// VmStates Information about one or more VM states.
	VmStates *[]VmStatesSchema `json:"vmStates,omitempty"`
}

// ReadVolumesResponseSchema defines model for ReadVolumesResponseSchema.
type ReadVolumesResponseSchema struct {
	// Volumes Information about one or more volumes.
	Volumes *[]VolumeSchema `json:"volumes,omitempty"`
}

// ReadVpnConnectionsResponseSchema defines model for ReadVpnConnectionsResponseSchema.
type ReadVpnConnectionsResponseSchema struct {
	// VpnConnections Information about one or more VPN connections.
	VpnConnections *[]VpnConnectionSchema `json:"vpnConnections,omitempty"`
}

// RebootVmsRequestSchema defines model for RebootVmsRequestSchema.
type RebootVmsRequestSchema struct {
	// VmIds One or more IDs of the VMs you want to reboot.
	VmIds []string `json:"vmIds"`
}

// RejectNetPeeringRequestSchema defines model for RejectNetPeeringRequestSchema.
type RejectNetPeeringRequestSchema struct {
	// NetPeeringId The ID of the Net peering you want to reject.
	NetPeeringId string `json:"netPeeringId"`
}

// ResourceLoadBalancerTagSchema Information about the tag.
type ResourceLoadBalancerTagSchema struct {
	// Key The key of the tag, with a minimum of 1 character.
	Key *string `json:"key,omitempty"`
}

// ResourceTagSchema Information about the tag.
type ResourceTagSchema struct {
	// Key The key of the tag, with a minimum of 1 character.
	Key string `json:"key"`

	// Value The value of the tag, between 0 and 255 characters.
	Value string `json:"value"`
}

// RouteLightSchema Information about the route.
type RouteLightSchema struct {
	// DestinationIpRange The IP range used for the destination match, in CIDR notation (for example, `10.0.0.0/24`).
	DestinationIpRange *string `json:"destinationIpRange,omitempty"`

	// RouteType The type of route (always `static`).
	RouteType *string `json:"routeType,omitempty"`

	// State The current state of the static route (`pending` \| `available` \| `deleting` \| `deleted`).
	State *string `json:"state,omitempty"`
}

// RoutePropagatingVirtualGatewaySchema Information about the route propagating virtual gateway.
type RoutePropagatingVirtualGatewaySchema struct {
	// VirtualGatewayId The ID of the virtual gateway.
	VirtualGatewayId *string `json:"virtualGatewayId,omitempty"`
}

// RouteSchema Information about the route.
type RouteSchema struct {
	// CreationMethod The method used to create the route.
	CreationMethod *string `json:"creationMethod,omitempty"`

	// DestinationIpRange The IP range used for the destination match, in CIDR notation (for example, `10.0.0.0/24`).
	DestinationIpRange *string `json:"destinationIpRange,omitempty"`

	// DestinationServiceId The ID of the OUTSCALE service.
	DestinationServiceId *string `json:"destinationServiceId,omitempty"`

	// GatewayId The ID of the Internet service or virtual gateway attached to the Net.
	GatewayId *string `json:"gatewayId,omitempty"`

	// NatServiceId The ID of a NAT service attached to the Net.
	NatServiceId *string `json:"natServiceId,omitempty"`

	// NetAccessPointId The ID of the Net access point.
	NetAccessPointId *string `json:"netAccessPointId,omitempty"`

	// NetPeeringId The ID of the Net peering.
	NetPeeringId *string `json:"netPeeringId,omitempty"`

	// NicId The ID of the NIC.
	NicId *string `json:"nicId,omitempty"`

	// State The state of a route in the route table (always `active`).
	State *string `json:"state,omitempty"`

	// VmAccountId The account ID of the owner of the VM.
	VmAccountId *string `json:"vmAccountId,omitempty"`

	// VmId The ID of a VM specified in a route in the table.
	VmId *string `json:"vmId,omitempty"`
}

// RouteTableSchema Information about the route table.
type RouteTableSchema struct {
	// Id The ID of the route table.
	Id *string `json:"id,omitempty"`

	// NetId The ID of the Net for the route table.
	NetId *string `json:"netId,omitempty"`

	// RoutePropagatingVirtualGateways Information about virtual gateways propagating routes.
	RoutePropagatingVirtualGateways *[]RoutePropagatingVirtualGatewaySchema `json:"routePropagatingVirtualGateways,omitempty"`

	// Routes One or more routes in the route table.
	Routes *[]RouteSchema `json:"routes,omitempty"`

	// Tags One or more tags associated with the route table.
	Tags *[]ResourceTagSchema `json:"tags,omitempty"`
}

// SecurityGroupLightSchema Information about the security group.
type SecurityGroupLightSchema struct {
	// SecurityGroupId The ID of the security group.
	SecurityGroupId *string `json:"securityGroupId,omitempty"`

	// SecurityGroupName The name of the security group.
	SecurityGroupName *string `json:"securityGroupName,omitempty"`
}

// SecurityGroupRuleSchema Information about the security group rule.
type SecurityGroupRuleSchema struct {
	// FromPortRange The beginning of the port range for the TCP and UDP protocols, or an ICMP type number.
	FromPortRange *int `json:"fromPortRange,omitempty"`

	// IpProtocol The IP protocol name (`tcp`, `udp`, `icmp`, or `-1` for all protocols). By default, `-1`. In a Net, this can also be an IP protocol number. For more information, see the [IANA.org website](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
	IpProtocol *string `json:"ipProtocol,omitempty"`

	// IpRanges One or more IP ranges for the security group rules, in CIDR notation (for example, `10.0.0.0/16`).
	IpRanges *[]string `json:"ipRanges,omitempty"`

	// SecurityGroupsMembers Information about one or more source or destination security groups.
	SecurityGroupsMembers *[]SecurityGroupsMemberSchema `json:"securityGroupsMembers,omitempty"`

	// ServiceIds One or more service IDs to allow traffic from a Net to access the corresponding OUTSCALE services. For more information, see [ReadNetAccessPointServices](#readnetaccesspointservices).
	ServiceIds *[]string `json:"serviceIds,omitempty"`

	// ToPortRange The end of the port range for the TCP and UDP protocols, or an ICMP code number.
	ToPortRange *int `json:"toPortRange,omitempty"`
}

// SecurityGroupSchema Information about the security group.
type SecurityGroupSchema struct {
	// AccountId The account ID of a user that has been granted permission.
	AccountId *string `json:"accountId,omitempty"`

	// Description The description of the security group.
	Description *string `json:"description,omitempty"`

	// Id The ID of the security group.
	Id *string `json:"id,omitempty"`

	// InboundRules The inbound rules associated with the security group.
	InboundRules *[]SecurityGroupRuleSchema `json:"inboundRules,omitempty"`

	// Name The name of the security group.
	Name *string `json:"name,omitempty"`

	// NetId The ID of the Net for the security group.
	NetId *string `json:"netId,omitempty"`

	// OutboundRules The outbound rules associated with the security group.
	OutboundRules *[]SecurityGroupRuleSchema `json:"outboundRules,omitempty"`

	// Tags One or more tags associated with the security group.
	Tags *[]ResourceTagSchema `json:"tags,omitempty"`
}

// SecurityGroupsMemberSchema Information about a source or destination security group.
type SecurityGroupsMemberSchema struct {
	// AccountId The account ID that owns the source or destination security group.
	AccountId *string `json:"accountId,omitempty"`

	// SecurityGroupId The ID of a source or destination security group that you want to link to the security group of the rule.
	SecurityGroupId *string `json:"securityGroupId,omitempty"`
}

// SnapshotSchema Information about the snapshot.
type SnapshotSchema struct {
	// AccountAlias The account alias of the owner of the snapshot.
	AccountAlias *string `json:"accountAlias,omitempty"`

	// AccountId The account ID of the owner of the snapshot.
	AccountId *string `json:"accountId,omitempty"`

	// CreationDate The date and time of creation of the snapshot.
	CreationDate *time.Time `json:"creationDate,omitempty"`

	// Description The description of the snapshot.
	Description *string `json:"description,omitempty"`

	// Id The ID of the snapshot.
	Id *string `json:"id,omitempty"`

	// PermissionsToCreateVolume Permissions for the resource.
	PermissionsToCreateVolume *PermissionsOnResourceSchema `json:"permissionsToCreateVolume,omitempty"`

	// Progress The progress of the snapshot, as a percentage.
	Progress *int `json:"progress,omitempty"`

	// State The state of the snapshot (`in-queue` \| `completed` \| `error`).
	State *string `json:"state,omitempty"`

	// Tags One or more tags associated with the snapshot.
	Tags *[]ResourceTagSchema `json:"tags,omitempty"`

	// VolumeId The ID of the volume used to create the snapshot.
	VolumeId *string `json:"volumeId,omitempty"`

	// VolumeSize The size of the volume used to create the snapshot, in gibibytes (GiB).
	VolumeSize *int `json:"volumeSize,omitempty"`
}

// SourceNetSchema Information about the source Net.
type SourceNetSchema struct {
	// AccountId The account ID of the owner of the source Net.
	AccountId *string `json:"accountId,omitempty"`

	// IpRange The IP range for the source Net, in CIDR notation (for example, `10.0.0.0/16`).
	IpRange *string `json:"ipRange,omitempty"`

	// NetId The ID of the source Net.
	NetId *string `json:"netId,omitempty"`
}

// SourceSecurityGroupSchema Information about the source security group of the load balancer, which you can use as part of your inbound rules for your registered VMs.<br />
// To only allow traffic from load balancers, add a security group rule that specifies this source security group as the inbound source.
type SourceSecurityGroupSchema struct {
	// SecurityGroupAccountId The account ID of the owner of the security group.
	SecurityGroupAccountId *string `json:"securityGroupAccountId,omitempty"`

	// SecurityGroupName The name of the security group.
	SecurityGroupName *string `json:"securityGroupName,omitempty"`
}

// StartVmsRequestSchema defines model for StartVmsRequestSchema.
type StartVmsRequestSchema struct {
	// VmIds One or more IDs of VMs.
	VmIds []string `json:"vmIds"`
}

// StartVmsResponseSchema defines model for StartVmsResponseSchema.
type StartVmsResponseSchema struct {
	// Vms Information about one or more started VMs.
	Vms *[]VmStateSchema `json:"vms,omitempty"`
}

// StateCommentSchema Information about the change of state.
type StateCommentSchema struct {
	// StateCode The code of the change of state.
	StateCode *string `json:"stateCode,omitempty"`

	// StateMessage A message explaining the change of state.
	StateMessage *string `json:"stateMessage,omitempty"`
}

// StopVmsRequestSchema defines model for StopVmsRequestSchema.
type StopVmsRequestSchema struct {
	// ForceStop Forces the VM to stop.
	ForceStop *bool `json:"forceStop,omitempty"`

	// VmIds One or more IDs of VMs.
	VmIds []string `json:"vmIds"`
}

// StopVmsResponseSchema defines model for StopVmsResponseSchema.
type StopVmsResponseSchema struct {
	// Vms Information about one or more stopped VMs.
	Vms *[]VmStateSchema `json:"vms,omitempty"`
}

// SubnetSchema Information about the Subnet.
type SubnetSchema struct {
	// AvailableIpsCount The number of available IPs in the Subnets.
	AvailableIpsCount *int `json:"availableIpsCount,omitempty"`

	// Id The ID of the Subnet.
	Id *string `json:"id,omitempty"`

	// IpRange The IP range in the Subnet, in CIDR notation (for example, `10.0.0.0/16`).
	IpRange *string `json:"ipRange,omitempty"`

	// MapPublicIpOnLaunch If true, a public IP is assigned to the network interface cards (NICs) created in the specified Subnet.
	MapPublicIpOnLaunch *bool `json:"mapPublicIpOnLaunch,omitempty"`

	// NetId The ID of the Net in which the Subnet is.
	NetId *string `json:"netId,omitempty"`

	// State The state of the Subnet (`pending` \| `available` \| `deleted`).
	State *string `json:"state,omitempty"`

	// SubregionName The name of the Subregion in which the Subnet is located.
	SubregionName *string `json:"subregionName,omitempty"`

	// Tags One or more tags associated with the Subnet.
	Tags *[]ResourceTagSchema `json:"tags,omitempty"`
}

// TagSchema Information about the tag.
type TagSchema struct {
	// Key The key of the tag, with a minimum of 1 character.
	Key *string `json:"key,omitempty"`

	// ResourceId The ID of the resource.
	ResourceId *string `json:"resourceId,omitempty"`

	// ResourceType The type of the resource.
	ResourceType *string `json:"resourceType,omitempty"`

	// Value The value of the tag, between 0 and 255 characters.
	Value *string `json:"value,omitempty"`
}

// UnlinkInternetServiceRequestSchema defines model for UnlinkInternetServiceRequestSchema.
type UnlinkInternetServiceRequestSchema struct {
	// NetId The ID of the Net from which you want to detach the Internet service.
	NetId string `json:"netId"`
}

// UnlinkLoadBalancerBackendMachinesRequestSchema defines model for UnlinkLoadBalancerBackendMachinesRequestSchema.
type UnlinkLoadBalancerBackendMachinesRequestSchema struct {
	// BackendIps  One or more public IPs of back-end VMs.
	BackendIps *[]string `json:"backendIps,omitempty"`

	// BackendVmIds  One or more IDs of back-end VMs.
	BackendVmIds *[]string `json:"backendVmIds,omitempty"`
}

// UnlinkPrivateIpsRequestSchema defines model for UnlinkPrivateIpsRequestSchema.
type UnlinkPrivateIpsRequestSchema struct {
	// PrivateIps One or more secondary private IPs you want to unassign from the NIC.
	PrivateIps []string `json:"privateIps"`
}

// UnlinkPublicIpRequestSchema defines model for UnlinkPublicIpRequestSchema.
type UnlinkPublicIpRequestSchema struct {
	// PublicIp The public IP. This parameter is required unless you use the `LinkPublicIpId` parameter.
	PublicIp *string `json:"publicIp,omitempty"`
}

// UnlinkVirtualGatewayRequestSchema defines model for UnlinkVirtualGatewayRequestSchema.
type UnlinkVirtualGatewayRequestSchema struct {
	// NetId The ID of the Net from which you want to detach the virtual gateway.
	NetId string `json:"netId"`
}

// UnlinkVolumeRequestSchema defines model for UnlinkVolumeRequestSchema.
type UnlinkVolumeRequestSchema struct {
	// ForceUnlink Forces the detachment of the volume in case of previous failure. Important: This action may damage your data or file systems.
	ForceUnlink *bool `json:"forceUnlink,omitempty"`
}

// UpdateDirectLinkInterfaceRequestSchema defines model for UpdateDirectLinkInterfaceRequestSchema.
type UpdateDirectLinkInterfaceRequestSchema struct {
	// Mtu The maximum transmission unit (MTU) of the DirectLink interface, in bytes (always `1500`).
	Mtu UpdateDirectLinkInterfaceRequestSchemaMtu `json:"mtu"`
}

// UpdateDirectLinkInterfaceRequestSchemaMtu The maximum transmission unit (MTU) of the DirectLink interface, in bytes (always `1500`).
type UpdateDirectLinkInterfaceRequestSchemaMtu int

// UpdateDirectLinkInterfaceResponseSchema defines model for UpdateDirectLinkInterfaceResponseSchema.
type UpdateDirectLinkInterfaceResponseSchema struct {
	// DirectLinkInterface Information about the DirectLink interfaces.
	DirectLinkInterface *DirectLinkInterfacesSchema `json:"directLinkInterface,omitempty"`
}

// UpdateFlexibleGpuRequestSchema defines model for UpdateFlexibleGpuRequestSchema.
type UpdateFlexibleGpuRequestSchema struct {
	// DeleteOnVmDeletion If true, the fGPU is deleted when the VM is terminated.
	DeleteOnVmDeletion *bool `json:"deleteOnVmDeletion,omitempty"`
}

// UpdateFlexibleGpuResponseSchema defines model for UpdateFlexibleGpuResponseSchema.
type UpdateFlexibleGpuResponseSchema struct {
	// FlexibleGpu Information about the flexible GPU (fGPU).
	FlexibleGpu *FlexibleGpuSchema `json:"flexibleGpu,omitempty"`
}

// UpdateImageRequestSchema defines model for UpdateImageRequestSchema.
type UpdateImageRequestSchema struct {
	// PermissionsToLaunch Information about the permissions for the resource.<br />
	// Specify either the `Additions` or the `Removals` parameter.
	PermissionsToLaunch PermissionsOnResourceCreationSchema `json:"permissionsToLaunch"`
}

// UpdateImageResponseSchema defines model for UpdateImageResponseSchema.
type UpdateImageResponseSchema struct {
	// Image Information about the OMI.
	Image *ImageSchema `json:"image,omitempty"`
}

// UpdateListenerRuleRequestSchema defines model for UpdateListenerRuleRequestSchema.
type UpdateListenerRuleRequestSchema struct {
	// HostPattern A host-name pattern for the rule, with a maximum length of 128 characters. This host-name pattern supports maximum three wildcards, and must not contain any special characters except [-.?].
	HostPattern *string `json:"hostPattern"`

	// PathPattern A path pattern for the rule, with a maximum length of 128 characters. This path pattern supports maximum three wildcards, and must not contain any special characters except [_-.$/~&quot;'@:+?].
	PathPattern *string `json:"pathPattern"`
}

// UpdateListenerRuleResponseSchema defines model for UpdateListenerRuleResponseSchema.
type UpdateListenerRuleResponseSchema struct {
	// ListenerRule Information about the listener rule.
	ListenerRule *ListenerRuleSchema `json:"listenerRule,omitempty"`
}

// UpdateLoadBalancerRequestSchema defines model for UpdateLoadBalancerRequestSchema.
type UpdateLoadBalancerRequestSchema struct {
	// HealthCheck Information about the health check configuration.
	HealthCheck *HealthCheckSchema `json:"healthCheck,omitempty"`

	// LoadBalancerPort The port on which the load balancer is listening (between `1` and `65535`, both included). This parameter is required if you want to update the server certificate.
	LoadBalancerPort *int `json:"loadBalancerPort,omitempty"`

	// PolicyNames The name of the policy you want to enable for the listener.
	PolicyNames *[]string `json:"policyNames,omitempty"`

	// PublicIp (internet-facing only) The public IP you want to associate with the load balancer. The former public IP of the load balancer is then disassociated. If you specify an empty string and the former public IP belonged to you, it is disassociated and replaced by a public IP owned by 3DS OUTSCALE.
	PublicIp *string `json:"publicIp,omitempty"`

	// SecuredCookies If true, secure cookies are enabled for the load balancer.
	SecuredCookies *bool `json:"securedCookies,omitempty"`

	// SecurityGroups (Net only) One or more IDs of security groups you want to assign to the load balancer. You need to specify the already assigned security groups that you want to keep along with the new ones you are assigning. If the list is empty, the default security group of the Net is assigned to the load balancer.
	SecurityGroups *[]string `json:"securityGroups,omitempty"`
}

// UpdateLoadBalancerResponseSchema defines model for UpdateLoadBalancerResponseSchema.
type UpdateLoadBalancerResponseSchema struct {
	// LoadBalancer Information about the load balancer.
	LoadBalancer *LoadBalancerSchema `json:"loadBalancer,omitempty"`
}

// UpdateNetAccessPointRequestSchema defines model for UpdateNetAccessPointRequestSchema.
type UpdateNetAccessPointRequestSchema struct {
	// AddRouteTableIds One or more IDs of route tables to associate with the specified Net access point.
	AddRouteTableIds *[]string `json:"addRouteTableIds,omitempty"`

	// RemoveRouteTableIds One or more IDs of route tables to disassociate from the specified Net access point.
	RemoveRouteTableIds *[]string `json:"removeRouteTableIds,omitempty"`
}

// UpdateNetAccessPointResponseSchema defines model for UpdateNetAccessPointResponseSchema.
type UpdateNetAccessPointResponseSchema struct {
	// NetAccessPoint Information about the Net access point.
	NetAccessPoint *NetAccessPointSchema `json:"netAccessPoint,omitempty"`
}

// UpdateNetRequestSchema defines model for UpdateNetRequestSchema.
type UpdateNetRequestSchema struct {
	// DhcpOptionsSetId The ID of the DHCP options set (or `default` if you want to associate the default one).
	DhcpOptionsSetId string `json:"dhcpOptionsSetId"`
}

// UpdateNetResponseSchema defines model for UpdateNetResponseSchema.
type UpdateNetResponseSchema struct {
	// Net Information about the Net.
	Net *NetSchema `json:"net,omitempty"`
}

// UpdateNicRequestSchema defines model for UpdateNicRequestSchema.
type UpdateNicRequestSchema struct {
	// Description A new description for the NIC.
	Description *string `json:"description,omitempty"`

	// LinkNic Information about the NIC attachment. If you are modifying the `DeleteOnVmDeletion` attribute, you must specify the ID of the NIC attachment.
	LinkNic *LinkNicToUpdateSchema `json:"linkNic,omitempty"`

	// SecurityGroupIds One or more IDs of security groups for the NIC.<br />
	// You must specify at least one group, even if you use the default security group in the Net.
	SecurityGroupIds *[]string `json:"securityGroupIds,omitempty"`
}

// UpdateNicResponseSchema defines model for UpdateNicResponseSchema.
type UpdateNicResponseSchema struct {
	// Nic Information about the NIC.
	Nic *NicSchema `json:"nic,omitempty"`
}

// UpdateRoutePropagationRequestSchema defines model for UpdateRoutePropagationRequestSchema.
type UpdateRoutePropagationRequestSchema struct {
	// Enable If true, a virtual gateway can propagate routes to a specified route table of a Net. If false, the propagation is disabled.
	Enable bool `json:"enable"`

	// VirtualGatewayId The ID of the virtual gateway.
	VirtualGatewayId string `json:"virtualGatewayId"`
}

// UpdateRoutePropagationResponseSchema defines model for UpdateRoutePropagationResponseSchema.
type UpdateRoutePropagationResponseSchema struct {
	// RouteTable Information about the route table.
	RouteTable *RouteTableSchema `json:"routeTable,omitempty"`
}

// UpdateRouteRequestSchema defines model for UpdateRouteRequestSchema.
type UpdateRouteRequestSchema struct {
	// DestinationIpRange The IP range used for the destination match, in CIDR notation (for example, `10.0.0.0/24`).
	DestinationIpRange string `json:"destinationIpRange"`

	// GatewayId The ID of an Internet service or virtual gateway attached to your Net.
	GatewayId *string `json:"gatewayId,omitempty"`

	// NatServiceId The ID of a NAT service.
	NatServiceId *string `json:"natServiceId,omitempty"`

	// NetPeeringId The ID of a Net peering.
	NetPeeringId *string `json:"netPeeringId,omitempty"`

	// NicId The ID of a network interface card (NIC).
	NicId *string `json:"nicId,omitempty"`

	// VmId The ID of a NAT VM in your Net.
	VmId *string `json:"vmId,omitempty"`
}

// UpdateRouteResponseSchema defines model for UpdateRouteResponseSchema.
type UpdateRouteResponseSchema struct {
	// RouteTable Information about the route table.
	RouteTable *RouteTableSchema `json:"routeTable,omitempty"`
}

// UpdateSubnetRequestSchema defines model for UpdateSubnetRequestSchema.
type UpdateSubnetRequestSchema struct {
	// MapPublicIpOnLaunch If true, a public IP is assigned to the network interface cards (NICs) created in the specified Subnet.
	MapPublicIpOnLaunch bool `json:"mapPublicIpOnLaunch"`
}

// UpdateSubnetResponseSchema defines model for UpdateSubnetResponseSchema.
type UpdateSubnetResponseSchema struct {
	// Subnet Information about the Subnet.
	Subnet *SubnetSchema `json:"subnet,omitempty"`
}

// UpdateVmRequestSchema defines model for UpdateVmRequestSchema.
type UpdateVmRequestSchema struct {
	// BlockDeviceMappings One or more block device mappings of the VM.
	BlockDeviceMappings *[]BlockDeviceMappingVmUpdateSchema `json:"blockDeviceMappings,omitempty"`

	// BsuOptimized This parameter is not available. It is present in our API for the sake of historical compatibility with AWS.
	BsuOptimized *bool `json:"bsuOptimized,omitempty"`

	// DeletionProtection If true, you cannot delete the VM unless you change this parameter back to false.
	DeletionProtection *bool `json:"deletionProtection,omitempty"`

	// IsSourceDestChecked (Net only) If true, the source/destination check is enabled. If false, it is disabled. This value must be false for a NAT VM to perform network address translation (NAT) in a Net.
	IsSourceDestChecked *bool `json:"isSourceDestChecked,omitempty"`

	// KeypairName The name of a keypair you want to associate with the VM.<br />
	// When you replace the keypair of a VM with another one, the metadata of the VM is modified to reflect the new public key, but the replacement is still not effective in the operating system of the VM. To complete the replacement and effectively apply the new keypair, you need to perform other actions inside the VM. For more information, see [Modifying the Keypair of an Instance](https://docs.outscale.com/en/userguide/Modifying-the-Keypair-of-an-Instance.html).
	KeypairName *string `json:"keypairName,omitempty"`

	// NestedVirtualization (dedicated tenancy only) If true, nested virtualization is enabled. If false, it is disabled.
	NestedVirtualization *bool `json:"nestedVirtualization,omitempty"`

	// Performance The performance of the VM (`medium` \| `high` \|  `highest`).
	Performance *UpdateVmRequestSchemaPerformance `json:"performance,omitempty"`

	// SecurityGroupIds One or more IDs of security groups for the VM.
	SecurityGroupIds *[]string `json:"securityGroupIds,omitempty"`

	// UserData The Base64-encoded MIME user data, limited to 500 kibibytes (KiB).
	UserData *string `json:"userData,omitempty"`

	// VmInitiatedShutdownBehavior The VM behavior when you stop it. If set to `stop`, the VM stops. If set to `restart`, the VM stops then automatically restarts. If set to `terminate`, the VM stops and is terminated.
	VmInitiatedShutdownBehavior *string `json:"vmInitiatedShutdownBehavior,omitempty"`

	// VmType The type of VM. For more information, see [Instance Types](https://docs.outscale.com/en/userguide/Instance-Types.html).
	VmType *string `json:"vmType,omitempty"`
}

// UpdateVmRequestSchemaPerformance The performance of the VM (`medium` \| `high` \|  `highest`).
type UpdateVmRequestSchemaPerformance string

// UpdateVmResponseSchema defines model for UpdateVmResponseSchema.
type UpdateVmResponseSchema struct {
	// Vm Information about the VM.
	Vm *VmSchema `json:"vm,omitempty"`
}

// UpdateVolumeRequestSchema defines model for UpdateVolumeRequestSchema.
type UpdateVolumeRequestSchema struct {
	// Iops The new number of I/O operations per second (IOPS). This parameter can be specified only if you update an `io1` volume. The maximum number of IOPS allowed for `io1` volumes is `13000` with a maximum performance ratio of 300 IOPS per gibibyte. This modification is instantaneous on a cold volume, not on a hot one.
	Iops *int `json:"iops,omitempty"`

	// Size (cold volume only) The new size of the volume, in gibibytes (GiB). This value must be equal to or greater than the current size of the volume. This modification is not instantaneous.
	Size *int `json:"size,omitempty"`

	// VolumeType (cold volume only) The new type of the volume (`standard` \| `io1` \| `gp2`). This modification is instantaneous. If you update to an `io1` volume, you must also specify the `Iops` parameter.
	VolumeType *string `json:"volumeType,omitempty"`
}

// UpdateVolumeResponseSchema defines model for UpdateVolumeResponseSchema.
type UpdateVolumeResponseSchema struct {
	// Volume Information about the volume.
	Volume *VolumeSchema `json:"volume,omitempty"`
}

// UpdateVpnConnectionRequestSchema defines model for UpdateVpnConnectionRequestSchema.
type UpdateVpnConnectionRequestSchema struct {
	// ClientGatewayId The ID of the client gateway.
	ClientGatewayId *string `json:"clientGatewayId,omitempty"`

	// VirtualGatewayId The ID of the virtual gateway.
	VirtualGatewayId *string `json:"virtualGatewayId,omitempty"`

	// VpnOptions Information about the VPN options.
	VpnOptions *VpnOptionsSchema `json:"vpnOptions,omitempty"`
}

// UpdateVpnConnectionResponseSchema defines model for UpdateVpnConnectionResponseSchema.
type UpdateVpnConnectionResponseSchema struct {
	// VpnConnection Information about a VPN connection.
	VpnConnection *VpnConnectionSchema `json:"vpnConnection,omitempty"`
}

// VgwTelemetrySchema Information about the current state of a VPN tunnel.
type VgwTelemetrySchema struct {
	// AcceptedRouteCount The number of routes accepted through BGP (Border Gateway Protocol) route exchanges.
	AcceptedRouteCount *int `json:"acceptedRouteCount,omitempty"`

	// LastStateChangeDate The date and time (UTC) of the latest state update.
	LastStateChangeDate *time.Time `json:"lastStateChangeDate,omitempty"`

	// OutsideIpAddress The IP on the OUTSCALE side of the tunnel.
	OutsideIpAddress *string `json:"outsideIpAddress,omitempty"`

	// State The state of the IPSEC tunnel (`UP` \| `DOWN`).
	State *string `json:"state,omitempty"`

	// StateDescription A description of the current state of the tunnel.
	StateDescription *string `json:"stateDescription,omitempty"`
}

// VirtualGatewaySchema Information about the virtual gateway.
type VirtualGatewaySchema struct {
	// ConnectionType The type of VPN connection supported by the virtual gateway (only `ipsec.1` is supported).
	ConnectionType *string `json:"connectionType,omitempty"`

	// Id The ID of the virtual gateway.
	Id *string `json:"id,omitempty"`

	// State The state of the virtual gateway (`pending` \| `available` \| `deleting` \| `deleted`).
	State *string `json:"state,omitempty"`

	// Tags One or more tags associated with the virtual gateway.
	Tags *[]ResourceTagSchema `json:"tags,omitempty"`
}

// VmSchema Information about the VM.
type VmSchema struct {
	// Architecture The architecture of the VM (`i386` \| `x86_64`).
	Architecture *string `json:"architecture,omitempty"`

	// BlockDeviceMappings The block device mapping of the VM.
	BlockDeviceMappings *[]BlockDeviceMappingCreatedSchema `json:"blockDeviceMappings,omitempty"`

	// BsuOptimized This parameter is not available. It is present in our API for the sake of historical compatibility with AWS.
	BsuOptimized *bool `json:"bsuOptimized,omitempty"`

	// ClientToken The idempotency token provided when launching the VM.
	ClientToken *string `json:"clientToken,omitempty"`

	// CreationDate The date and time of creation of the VM.
	CreationDate *time.Time `json:"creationDate,omitempty"`

	// DeletionProtection If true, you cannot delete the VM unless you change this parameter back to false.
	DeletionProtection *bool `json:"deletionProtection,omitempty"`

	// Hypervisor The hypervisor type of the VMs (`ovm` \| `xen`).
	Hypervisor *string `json:"hypervisor,omitempty"`

	// Id The ID of the VM.
	Id *string `json:"vmId,omitempty"`

	// ImageId The ID of the OMI used to create the VM.
	ImageId *string `json:"imageId,omitempty"`

	// InitiatedShutdownBehavior The VM behavior when you stop it. If set to `stop`, the VM stops. If set to `restart`, the VM stops then automatically restarts. If set to `terminate`, the VM stops and is deleted.
	InitiatedShutdownBehavior *string `json:"initiatedShutdownBehavior,omitempty"`

	// IsSourceDestChecked (Net only) If true, the source/destination check is enabled. If false, it is disabled. This value must be false for a NAT VM to perform network address translation (NAT) in a Net.
	IsSourceDestChecked *bool `json:"isSourceDestChecked,omitempty"`

	// KeypairName The name of the keypair used when launching the VM.
	KeypairName *string `json:"keypairName,omitempty"`

	// LaunchNumber The number for the VM when launching a group of several VMs (for example, `0`, `1`, `2`, and so on).
	LaunchNumber *int `json:"launchNumber,omitempty"`

	// NestedVirtualization If true, nested virtualization is enabled. If false, it is disabled.
	NestedVirtualization *bool `json:"nestedVirtualization,omitempty"`

	// NetId The ID of the Net in which the VM is running.
	NetId *string `json:"netId,omitempty"`

	// Nics (Net only) The network interface cards (NICs) the VMs are attached to.
	Nics *[]NicLightSchema `json:"nics,omitempty"`

	// OsFamily Indicates the operating system (OS) of the VM.
	OsFamily *string `json:"osFamily,omitempty"`

	// Performance The performance of the VM (`medium` \| `high` \|  `highest`).
	Performance *string `json:"performance,omitempty"`

	// Placement Information about the placement of the VM.
	Placement *PlacementSchema `json:"placement,omitempty"`

	// PrivateDnsName The name of the private DNS.
	PrivateDnsName *string `json:"privateDnsName,omitempty"`

	// PrivateIp The primary private IP of the VM.
	PrivateIp *string `json:"privateIp,omitempty"`

	// ProductCodes The product codes associated with the OMI used to create the VM.
	ProductCodes *[]string `json:"productCodes,omitempty"`

	// PublicDnsName The name of the public DNS.
	PublicDnsName *string `json:"publicDnsName,omitempty"`

	// PublicIp The public IP of the VM.
	PublicIp *string `json:"publicIp,omitempty"`

	// ReservationId The reservation ID of the VM.
	ReservationId *string `json:"reservationId,omitempty"`

	// RootDeviceName The name of the root device for the VM (for example, `/dev/vda1`).
	RootDeviceName *string `json:"rootDeviceName,omitempty"`

	// RootDeviceType The type of root device used by the VM (always `bsu`).
	RootDeviceType *string `json:"rootDeviceType,omitempty"`

	// SecurityGroups One or more security groups associated with the VM.
	SecurityGroups *[]SecurityGroupLightSchema `json:"securityGroups,omitempty"`

	// State The state of the VM (`pending` \| `running` \| `stopping` \| `stopped` \| `shutting-down` \| `terminated` \| `quarantine`).
	State *string `json:"state,omitempty"`

	// StateReason The reason explaining the current state of the VM.
	StateReason *string `json:"stateReason,omitempty"`

	// SubnetId The ID of the Subnet for the VM.
	SubnetId *string `json:"subnetId,omitempty"`

	// Tags One or more tags associated with the VM.
	Tags *[]ResourceTagSchema `json:"tags,omitempty"`

	// Type The type of VM. For more information, see [Instance Types](https://docs.outscale.com/en/userguide/Instance-Types.html).
	Type *string `json:"type,omitempty"`

	// UserData The Base64-encoded MIME user data.
	UserData *string `json:"userData,omitempty"`
}

// VmStateSchema Information about the state of the VM.
type VmStateSchema struct {
	// CurrentState The current state of the VM (`InService` \| `OutOfService` \| `Unknown`).
	CurrentState *string `json:"currentState,omitempty"`

	// PreviousState The previous state of the VM (`InService` \| `OutOfService` \| `Unknown`).
	PreviousState *string `json:"previousState,omitempty"`

	// VmId The ID of the VM.
	VmId *string `json:"vmId,omitempty"`
}

// VmStatesSchema Information about the states of the VMs.
type VmStatesSchema struct {
	// MaintenanceEvents One or more scheduled events associated with the VM.
	MaintenanceEvents *[]MaintenanceEventSchema `json:"maintenanceEvents,omitempty"`

	// SubregionName The name of the Subregion of the VM.
	SubregionName *string `json:"subregionName,omitempty"`

	// VmId The ID of the VM.
	VmId *string `json:"vmId,omitempty"`

	// VmState The state of the VM (`pending` \| `running` \| `stopping` \| `stopped` \| `shutting-down` \| `terminated` \| `quarantine`).
	VmState *string `json:"vmState,omitempty"`
}

// VolumeSchema Information about the volume.
type VolumeSchema struct {
	// CreationDate The date and time of creation of the volume.
	CreationDate *time.Time `json:"creationDate,omitempty"`

	// Id The ID of the volume.
	Id *string `json:"id,omitempty"`

	// Iops The number of I/O operations per second (IOPS):<br />
	// - For `io1` volumes, the number of provisioned IOPS<br />
	// - For `gp2` volumes, the baseline performance of the volume
	Iops *int `json:"iops,omitempty"`

	// Size The size of the volume, in gibibytes (GiB).
	Size *int `json:"size,omitempty"`

	// SnapshotId The snapshot from which the volume was created.
	SnapshotId *string `json:"snapshotId,omitempty"`

	// State The state of the volume (`creating` \| `available` \| `in-use` \| `updating` \| `deleting` \| `error`).
	State *string `json:"state,omitempty"`

	// SubregionName The Subregion in which the volume was created.
	SubregionName *string `json:"subregionName,omitempty"`

	// Tags One or more tags associated with the volume.
	Tags *[]ResourceTagSchema `json:"tags,omitempty"`

	// Type The type of the volume (`standard` \| `gp2` \| `io1`).
	Type *string `json:"type,omitempty"`

	// Volumes Information about your volume attachment.
	Volumes *[]LinkedVolumeSchema `json:"volumes,omitempty"`
}

// VpnConnectionSchema Information about a VPN connection.
type VpnConnectionSchema struct {
	// ClientGatewayConfiguration Example configuration for the client gateway.
	ClientGatewayConfiguration *string `json:"clientGatewayConfiguration,omitempty"`

	// ClientGatewayId The ID of the client gateway used on the client end of the connection.
	ClientGatewayId *string `json:"clientGatewayId,omitempty"`

	// ConnectionType The type of VPN connection (always `ipsec.1`).
	ConnectionType *string `json:"connectionType,omitempty"`

	// Id The ID of the VPN connection.
	Id *string `json:"id,omitempty"`

	// Routes Information about one or more static routes associated with the VPN connection, if any.
	Routes *[]RouteLightSchema `json:"routes,omitempty"`

	// State The state of the VPN connection (`pending` \| `available` \| `deleting` \| `deleted`).
	State *string `json:"state,omitempty"`

	// StaticRoutesOnly If false, the VPN connection uses dynamic routing with Border Gateway Protocol (BGP). If true, routing is controlled using static routes. For more information about how to create and delete static routes, see [CreateVpnConnectionRoute](#createvpnconnectionroute) and [DeleteVpnConnectionRoute](#deletevpnconnectionroute).
	StaticRoutesOnly *bool `json:"staticRoutesOnly,omitempty"`

	// Tags One or more tags associated with the VPN connection.
	Tags *[]ResourceTagSchema `json:"tags,omitempty"`

	// VgwTelemetries Information about the current state of one or more of the VPN tunnels.
	VgwTelemetries *[]VgwTelemetrySchema `json:"vgwTelemetries,omitempty"`

	// VirtualGatewayId The ID of the virtual gateway used on the OUTSCALE end of the connection.
	VirtualGatewayId *string `json:"virtualGatewayId,omitempty"`

	// VpnOptions Information about the VPN options.
	VpnOptions *VpnOptionsSchema `json:"vpnOptions,omitempty"`
}

// VpnOptionsSchema Information about the VPN options.
type VpnOptionsSchema struct {
	// Phase1Options Information about Phase 1 of the Internet Key Exchange (IKE) negotiation. When Phase 1 finishes successfully, peers proceed to Phase 2 negotiations.
	Phase1Options *Phase1OptionsSchema `json:"phase1Options,omitempty"`

	// Phase2Options Information about Phase 2 of the Internet Key Exchange (IKE) negotiation.
	Phase2Options *Phase2OptionsSchema `json:"phase2Options,omitempty"`

	// TunnelInsideIpRange The range of inside IPs for the tunnel. This must be a /30 CIDR block from the 169.254.254.0/24 range.
	TunnelInsideIpRange *string `json:"tunnelInsideIpRange,omitempty"`
}

// ReadClientGatewaysParams defines parameters for ReadClientGateways.
type ReadClientGatewaysParams struct {
	// BgpAsns The Border Gateway Protocol (BGP) Autonomous System Numbers (ASNs) of the connections.
	BgpAsns *[]int `form:"bgpAsns,omitempty" json:"bgpAsns,omitempty"`

	// ClientGatewayIds The IDs of the client gateways.
	ClientGatewayIds *[]string `form:"clientGatewayIds,omitempty" json:"clientGatewayIds,omitempty"`

	// ConnectionTypes The types of communication tunnels used by the client gateways (only `ipsec.1` is supported).
	ConnectionTypes *[]string `form:"connectionTypes,omitempty" json:"connectionTypes,omitempty"`

	// PublicIps The public IPv4 addresses of the client gateways.
	PublicIps *[]string `form:"publicIps,omitempty" json:"publicIps,omitempty"`

	// States The states of the client gateways (`pending` \| `available` \| `deleting` \| `deleted`).
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// TagKeys The keys of the tags associated with the client gateways.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the client gateways.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the client gateways, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`
}

// ReadDhcpOptionsParams defines parameters for ReadDhcpOptions.
type ReadDhcpOptionsParams struct {
	// Default If true, lists all default DHCP options set. If false, lists all non-default DHCP options set.
	Default *bool `form:"default,omitempty" json:"default,omitempty"`

	// DhcpOptionsSetIds The IDs of the DHCP options sets.
	DhcpOptionsSetIds *[]string `form:"dhcpOptionsSetIds,omitempty" json:"dhcpOptionsSetIds,omitempty"`

	// DomainNameServers The IPs of the domain name servers used for the DHCP options sets.
	DomainNameServers *[]string `form:"domainNameServers,omitempty" json:"domainNameServers,omitempty"`

	// DomainNames The domain names used for the DHCP options sets.
	DomainNames *[]string `form:"domainNames,omitempty" json:"domainNames,omitempty"`

	// LogServers The IPs of the log servers used for the DHCP options sets.
	LogServers *[]string `form:"logServers,omitempty" json:"logServers,omitempty"`

	// NtpServers The IPs of the Network Time Protocol (NTP) servers used for the DHCP options sets.
	NtpServers *[]string `form:"ntpServers,omitempty" json:"ntpServers,omitempty"`

	// TagKeys The keys of the tags associated with the DHCP options sets.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the DHCP options sets.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the DHCP options sets, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`
}

// ReadDirectLinkInterfacesParams defines parameters for ReadDirectLinkInterfaces.
type ReadDirectLinkInterfacesParams struct {
	// DirectLinkIds The IDs of the DirectLinks.
	DirectLinkIds *[]string `form:"directLinkIds,omitempty" json:"directLinkIds,omitempty"`

	// DirectLinkInterfaceIds The IDs of the DirectLink interfaces.
	DirectLinkInterfaceIds *[]string `form:"directLinkInterfaceIds,omitempty" json:"directLinkInterfaceIds,omitempty"`
}

// ReadDirectLinksParams defines parameters for ReadDirectLinks.
type ReadDirectLinksParams struct {
	// DirectLinkIds The IDs of the DirectLinks.
	DirectLinkIds *[]string `form:"directLinkIds,omitempty" json:"directLinkIds,omitempty"`
}

// ReadFlexibleGpusParams defines parameters for ReadFlexibleGpus.
type ReadFlexibleGpusParams struct {
	// DeleteOnVmDeletion Indicates whether the fGPU is deleted when terminating the VM.
	DeleteOnVmDeletion *bool `form:"deleteOnVmDeletion,omitempty" json:"deleteOnVmDeletion,omitempty"`

	// FlexibleGpuIds One or more IDs of fGPUs.
	FlexibleGpuIds *[]string `form:"flexibleGpuIds,omitempty" json:"flexibleGpuIds,omitempty"`

	// Generations The processor generations that the fGPUs are compatible with.
	Generations *[]string `form:"generations,omitempty" json:"generations,omitempty"`

	// ModelNames One or more models of fGPUs. For more information, see [About Flexible GPUs](https://docs.outscale.com/en/userguide/About-Flexible-GPUs.html).
	ModelNames *[]string `form:"modelNames,omitempty" json:"modelNames,omitempty"`

	// States The states of the fGPUs (`allocated` \| `attaching` \| `attached` \| `detaching`).
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// SubregionNames The Subregions where the fGPUs are located.
	SubregionNames *[]string `form:"subregionNames,omitempty" json:"subregionNames,omitempty"`

	// VmIds One or more IDs of VMs.
	VmIds *[]string `form:"vmIds,omitempty" json:"vmIds,omitempty"`
}

// ReadImagesParams defines parameters for ReadImages.
type ReadImagesParams struct {
	// AccountAliases The account aliases of the owners of the OMIs.
	AccountAliases *[]string `form:"accountAliases,omitempty" json:"accountAliases,omitempty"`

	// AccountIds The account IDs of the owners of the OMIs. By default, all the OMIs for which you have launch permissions are described.
	AccountIds *[]string `form:"accountIds,omitempty" json:"accountIds,omitempty"`

	// Architectures The architectures of the OMIs (`i386` \| `x86_64`).
	Architectures *[]string `form:"architectures,omitempty" json:"architectures,omitempty"`

	// BlockDeviceMappingDeleteOnVmDeletion Whether the volumes are deleted or not when terminating the VM.
	BlockDeviceMappingDeleteOnVmDeletion *bool `form:"blockDeviceMappingDeleteOnVmDeletion,omitempty" json:"blockDeviceMappingDeleteOnVmDeletion,omitempty"`

	// BlockDeviceMappingDeviceNames The device names for the volumes.
	BlockDeviceMappingDeviceNames *[]string `form:"blockDeviceMappingDeviceNames,omitempty" json:"blockDeviceMappingDeviceNames,omitempty"`

	// BlockDeviceMappingSnapshotIds The IDs of the snapshots used to create the volumes.
	BlockDeviceMappingSnapshotIds *[]string `form:"blockDeviceMappingSnapshotIds,omitempty" json:"blockDeviceMappingSnapshotIds,omitempty"`

	// BlockDeviceMappingVolumeSizes The sizes of the volumes, in gibibytes (GiB).
	BlockDeviceMappingVolumeSizes *[]int `form:"blockDeviceMappingVolumeSizes,omitempty" json:"blockDeviceMappingVolumeSizes,omitempty"`

	// BlockDeviceMappingVolumeTypes The types of volumes (`standard` \| `gp2` \| `io1`).
	BlockDeviceMappingVolumeTypes *[]string `form:"blockDeviceMappingVolumeTypes,omitempty" json:"blockDeviceMappingVolumeTypes,omitempty"`

	// Descriptions The descriptions of the OMIs, provided when they were created.
	Descriptions *[]string `form:"descriptions,omitempty" json:"descriptions,omitempty"`

	// FileLocations The locations of the buckets where the OMI files are stored.
	FileLocations *[]string `form:"fileLocations,omitempty" json:"fileLocations,omitempty"`

	// Hypervisors The hypervisor type of the OMI (always `xen`).
	Hypervisors *[]string `form:"hypervisors,omitempty" json:"hypervisors,omitempty"`

	// ImageIds The IDs of the OMIs.
	ImageIds *[]string `form:"imageIds,omitempty" json:"imageIds,omitempty"`

	// ImageNames The names of the OMIs, provided when they were created.
	ImageNames *[]string `form:"imageNames,omitempty" json:"imageNames,omitempty"`

	// PermissionsToLaunchAccountIds The account IDs of the users who have launch permissions for the OMIs.
	PermissionsToLaunchAccountIds *[]string `form:"permissionsToLaunchAccountIds,omitempty" json:"permissionsToLaunchAccountIds,omitempty"`

	// PermissionsToLaunchGlobalPermission If true, lists all public OMIs. If false, lists all private OMIs.
	PermissionsToLaunchGlobalPermission *bool `form:"permissionsToLaunchGlobalPermission,omitempty" json:"permissionsToLaunchGlobalPermission,omitempty"`

	// ProductCodes The product codes associated with the OMI.
	ProductCodes *[]string `form:"productCodes,omitempty" json:"productCodes,omitempty"`

	// RootDeviceNames The name of the root device. This value must be /dev/sda1.
	RootDeviceNames *[]string `form:"rootDeviceNames,omitempty" json:"rootDeviceNames,omitempty"`

	// RootDeviceTypes The types of root device used by the OMIs (always `bsu`).
	RootDeviceTypes *[]string `form:"rootDeviceTypes,omitempty" json:"rootDeviceTypes,omitempty"`

	// States The states of the OMIs (`pending` \| `available` \| `failed`).
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// TagKeys The keys of the tags associated with the OMIs.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the OMIs.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the OMIs, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// VirtualizationTypes The virtualization types (always `hvm`).
	VirtualizationTypes *[]string `form:"virtualizationTypes,omitempty" json:"virtualizationTypes,omitempty"`
}

// ReadInternetServicesParams defines parameters for ReadInternetServices.
type ReadInternetServicesParams struct {
	// InternetServiceIds The IDs of the Internet services.
	InternetServiceIds *[]string `form:"internetServiceIds,omitempty" json:"internetServiceIds,omitempty"`

	// LinkNetIds The IDs of the Nets the Internet services are attached to.
	LinkNetIds *[]string `form:"linkNetIds,omitempty" json:"linkNetIds,omitempty"`

	// LinkStates The current states of the attachments between the Internet services and the Nets (only `available`, if the Internet gateway is attached to a VPC).
	LinkStates *[]string `form:"linkStates,omitempty" json:"linkStates,omitempty"`

	// TagKeys The keys of the tags associated with the Internet services.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the Internet services.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the Internet services, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`
}

// ReadKeypairsParams defines parameters for ReadKeypairs.
type ReadKeypairsParams struct {
	// KeypairFingerprints The fingerprints of the keypairs.
	KeypairFingerprints *[]string `form:"keypairFingerprints,omitempty" json:"keypairFingerprints,omitempty"`

	// KeypairNames The names of the keypairs.
	KeypairNames *[]string `form:"keypairNames,omitempty" json:"keypairNames,omitempty"`
}

// ReadListenerRulesParams defines parameters for ReadListenerRules.
type ReadListenerRulesParams struct {
	// ListenerRuleNames The names of the listener rules.
	ListenerRuleNames *[]string `form:"listenerRuleNames,omitempty" json:"listenerRuleNames,omitempty"`
}

// ReadLoadBalancersParams defines parameters for ReadLoadBalancers.
type ReadLoadBalancersParams struct {
	// LoadBalancerNames The names of the load balancers.
	LoadBalancerNames *[]string `form:"loadBalancerNames,omitempty" json:"loadBalancerNames,omitempty"`
}

// ReadNatServicesParams defines parameters for ReadNatServices.
type ReadNatServicesParams struct {
	// NatServiceIds The IDs of the NAT services.
	NatServiceIds *[]string `form:"natServiceIds,omitempty" json:"natServiceIds,omitempty"`

	// NetIds The IDs of the Nets in which the NAT services are.
	NetIds *[]string `form:"netIds,omitempty" json:"netIds,omitempty"`

	// States The states of the NAT services (`pending` \| `available` \| `deleting` \| `deleted`).
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// SubnetIds The IDs of the Subnets in which the NAT services are.
	SubnetIds *[]string `form:"subnetIds,omitempty" json:"subnetIds,omitempty"`

	// TagKeys The keys of the tags associated with the NAT services.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the NAT services.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the NAT services, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`
}

// ReadNetAccessPointsParams defines parameters for ReadNetAccessPoints.
type ReadNetAccessPointsParams struct {
	// NetAccessPointIds The IDs of the Net access points.
	NetAccessPointIds *[]string `form:"netAccessPointIds,omitempty" json:"netAccessPointIds,omitempty"`

	// NetIds The IDs of the Nets.
	NetIds *[]string `form:"netIds,omitempty" json:"netIds,omitempty"`

	// ServiceNames The names of the services. For more information, see [ReadNetAccessPointServices](#readnetaccesspointservices).
	ServiceNames *[]string `form:"serviceNames,omitempty" json:"serviceNames,omitempty"`

	// States The states of the Net access points (`pending` \| `available` \| `deleting` \| `deleted`).
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// TagKeys The keys of the tags associated with the Net access points.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the Net access points.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the Net access points, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`
}

// ReadNetPeeringsParams defines parameters for ReadNetPeerings.
type ReadNetPeeringsParams struct {
	// AccepterNetAccountIds The account IDs of the owners of the peer Nets.
	AccepterNetAccountIds *[]string `form:"accepterNetAccountIds,omitempty" json:"accepterNetAccountIds,omitempty"`

	// AccepterNetIpRanges The IP ranges of the peer Nets, in CIDR notation (for example, `10.0.0.0/24`).
	AccepterNetIpRanges *[]string `form:"accepterNetIpRanges,omitempty" json:"accepterNetIpRanges,omitempty"`

	// AccepterNetNetIds The IDs of the peer Nets.
	AccepterNetNetIds *[]string `form:"accepterNetNetIds,omitempty" json:"accepterNetNetIds,omitempty"`

	// NetPeeringIds The IDs of the Net peerings.
	NetPeeringIds *[]string `form:"netPeeringIds,omitempty" json:"netPeeringIds,omitempty"`

	// SourceNetAccountIds The account IDs of the owners of the peer Nets.
	SourceNetAccountIds *[]string `form:"sourceNetAccountIds,omitempty" json:"sourceNetAccountIds,omitempty"`

	// SourceNetIpRanges The IP ranges of the peer Nets.
	SourceNetIpRanges *[]string `form:"sourceNetIpRanges,omitempty" json:"sourceNetIpRanges,omitempty"`

	// SourceNetNetIds The IDs of the peer Nets.
	SourceNetNetIds *[]string `form:"sourceNetNetIds,omitempty" json:"sourceNetNetIds,omitempty"`

	// StateMessages Additional information about the states of the Net peerings.
	StateMessages *[]string `form:"stateMessages,omitempty" json:"stateMessages,omitempty"`

	// StateNames The states of the Net peerings (`pending-acceptance` \| `active` \| `rejected` \| `failed` \| `expired` \| `deleted`).
	StateNames *[]string `form:"stateNames,omitempty" json:"stateNames,omitempty"`

	// TagKeys The keys of the tags associated with the Net peerings.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the Net peerings.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the Net peerings, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`
}

// ReadNetsParams defines parameters for ReadNets.
type ReadNetsParams struct {
	// DhcpOptionsSetIds The IDs of the DHCP options sets.
	DhcpOptionsSetIds *[]string `form:"dhcpOptionsSetIds,omitempty" json:"dhcpOptionsSetIds,omitempty"`

	// IpRanges The IP ranges for the Nets, in CIDR notation (for example, `10.0.0.0/16`).
	IpRanges *[]string `form:"ipRanges,omitempty" json:"ipRanges,omitempty"`

	// IsDefault If true, the Net used is the default one.
	IsDefault *bool `form:"isDefault,omitempty" json:"isDefault,omitempty"`

	// NetIds The IDs of the Nets.
	NetIds *[]string `form:"netIds,omitempty" json:"netIds,omitempty"`

	// States The states of the Nets (`pending` \| `available` \| `deleted`).
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// TagKeys The keys of the tags associated with the Nets.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the Nets.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the Nets, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`
}

// ReadNicsParams defines parameters for ReadNics.
type ReadNicsParams struct {
	// Descriptions The descriptions of the NICs.
	Descriptions *[]string `form:"descriptions,omitempty" json:"descriptions,omitempty"`

	// IsSourceDestCheck Whether the source/destination checking is enabled (true) or disabled (false).
	IsSourceDestCheck *bool `form:"isSourceDestCheck,omitempty" json:"isSourceDestCheck,omitempty"`

	// LinkNicDeleteOnVmDeletion Whether the NICs are deleted when the VMs they are attached to are terminated.
	LinkNicDeleteOnVmDeletion *bool `form:"linkNicDeleteOnVmDeletion,omitempty" json:"linkNicDeleteOnVmDeletion,omitempty"`

	// LinkNicDeviceNumbers The device numbers the NICs are attached to.
	LinkNicDeviceNumbers *[]int `form:"linkNicDeviceNumbers,omitempty" json:"linkNicDeviceNumbers,omitempty"`

	// LinkNicLinkNicIds The attachment IDs of the NICs.
	LinkNicLinkNicIds *[]string `form:"linkNicLinkNicIds,omitempty" json:"linkNicLinkNicIds,omitempty"`

	// LinkNicStates The states of the attachments.
	LinkNicStates *[]string `form:"linkNicStates,omitempty" json:"linkNicStates,omitempty"`

	// LinkNicVmAccountIds The account IDs of the owners of the VMs the NICs are attached to.
	LinkNicVmAccountIds *[]string `form:"linkNicVmAccountIds,omitempty" json:"linkNicVmAccountIds,omitempty"`

	// LinkNicVmIds The IDs of the VMs the NICs are attached to.
	LinkNicVmIds *[]string `form:"linkNicVmIds,omitempty" json:"linkNicVmIds,omitempty"`

	// LinkPublicIpAccountIds The account IDs of the owners of the public IPs associated with the NICs.
	LinkPublicIpAccountIds *[]string `form:"linkPublicIpAccountIds,omitempty" json:"linkPublicIpAccountIds,omitempty"`

	// LinkPublicIpLinkPublicIpIds The association IDs returned when the public IPs were associated with the NICs.
	LinkPublicIpLinkPublicIpIds *[]string `form:"linkPublicIpLinkPublicIpIds,omitempty" json:"linkPublicIpLinkPublicIpIds,omitempty"`

	// LinkPublicIpPublicIpIds The allocation IDs returned when the public IPs were allocated to their accounts.
	LinkPublicIpPublicIpIds *[]string `form:"linkPublicIpPublicIpIds,omitempty" json:"linkPublicIpPublicIpIds,omitempty"`

	// LinkPublicIpPublicIps The public IPs associated with the NICs.
	LinkPublicIpPublicIps *[]string `form:"linkPublicIpPublicIps,omitempty" json:"linkPublicIpPublicIps,omitempty"`

	// MacAddresses The Media Access Control (MAC) addresses of the NICs.
	MacAddresses *[]string `form:"macAddresses,omitempty" json:"macAddresses,omitempty"`

	// NetIds The IDs of the Nets where the NICs are located.
	NetIds *[]string `form:"netIds,omitempty" json:"netIds,omitempty"`

	// NicIds The IDs of the NICs.
	NicIds *[]string `form:"nicIds,omitempty" json:"nicIds,omitempty"`

	// PrivateDnsNames The private DNS names associated with the primary private IPs.
	PrivateDnsNames *[]string `form:"privateDnsNames,omitempty" json:"privateDnsNames,omitempty"`

	// PrivateIpsLinkPublicIpPublicIps The public IPs associated with the private IPs.
	PrivateIpsLinkPublicIpPublicIps *[]string `form:"privateIpsLinkPublicIpPublicIps,omitempty" json:"privateIpsLinkPublicIpPublicIps,omitempty"`

	// PrivateIpsPrimaryIp Whether the private IP is the primary IP associated with the NIC.
	PrivateIpsPrimaryIp *bool `form:"privateIpsPrimaryIp,omitempty" json:"privateIpsPrimaryIp,omitempty"`

	// PrivateIpsPrivateIps The private IPs of the NICs.
	PrivateIpsPrivateIps *[]string `form:"privateIpsPrivateIps,omitempty" json:"privateIpsPrivateIps,omitempty"`

	// SecurityGroupIds The IDs of the security groups associated with the NICs.
	SecurityGroupIds *[]string `form:"securityGroupIds,omitempty" json:"securityGroupIds,omitempty"`

	// SecurityGroupNames The names of the security groups associated with the NICs.
	SecurityGroupNames *[]string `form:"securityGroupNames,omitempty" json:"securityGroupNames,omitempty"`

	// States The states of the NICs.
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// SubnetIds The IDs of the Subnets for the NICs.
	SubnetIds *[]string `form:"subnetIds,omitempty" json:"subnetIds,omitempty"`

	// SubregionNames The Subregions where the NICs are located.
	SubregionNames *[]string `form:"subregionNames,omitempty" json:"subregionNames,omitempty"`

	// TagKeys The keys of the tags associated with the NICs.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the NICs.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the NICs, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`
}

// ReadProductTypesParams defines parameters for ReadProductTypes.
type ReadProductTypesParams struct {
	// ProductTypeIds The IDs of the product types.
	ProductTypeIds *[]string `form:"productTypeIds,omitempty" json:"productTypeIds,omitempty"`
}

// ReadPublicIpsParams defines parameters for ReadPublicIps.
type ReadPublicIpsParams struct {
	// LinkPublicIpIds The IDs representing the associations of public IPs with VMs or NICs.
	LinkPublicIpIds *[]string `form:"linkPublicIpIds,omitempty" json:"linkPublicIpIds,omitempty"`

	// NicIds The IDs of the NICs.
	NicIds *[]string `form:"nicIds,omitempty" json:"nicIds,omitempty"`

	// PrivateIps The private IPs associated with the public IPs.
	PrivateIps *[]string `form:"privateIps,omitempty" json:"privateIps,omitempty"`

	// PublicIpIds The IDs of the public IPs.
	PublicIpIds *[]string `form:"publicIpIds,omitempty" json:"publicIpIds,omitempty"`

	// PublicIps The public IPs.
	PublicIps *[]string `form:"publicIps,omitempty" json:"publicIps,omitempty"`

	// TagKeys The keys of the tags associated with the public IPs.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the public IPs.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the public IPs, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// VmIds The IDs of the VMs.
	VmIds *[]string `form:"vmIds,omitempty" json:"vmIds,omitempty"`
}

// ReadRouteTablesParams defines parameters for ReadRouteTables.
type ReadRouteTablesParams struct {
	// LinkRouteTableIds The IDs of the route tables involved in the associations.
	LinkRouteTableIds *[]string `form:"linkRouteTableIds,omitempty" json:"linkRouteTableIds,omitempty"`

	// LinkRouteTableLinkRouteTableIds The IDs of the associations between the route tables and the Subnets.
	LinkRouteTableLinkRouteTableIds *[]string `form:"linkRouteTableLinkRouteTableIds,omitempty" json:"linkRouteTableLinkRouteTableIds,omitempty"`

	// LinkRouteTableMain If true, the route tables are the main ones for their Nets.
	LinkRouteTableMain *bool `form:"linkRouteTableMain,omitempty" json:"linkRouteTableMain,omitempty"`

	// LinkSubnetIds The IDs of the Subnets involved in the associations.
	LinkSubnetIds *[]string `form:"linkSubnetIds,omitempty" json:"linkSubnetIds,omitempty"`

	// NetIds The IDs of the Nets for the route tables.
	NetIds *[]string `form:"netIds,omitempty" json:"netIds,omitempty"`

	// RouteCreationMethods The methods used to create a route.
	RouteCreationMethods *[]string `form:"routeCreationMethods,omitempty" json:"routeCreationMethods,omitempty"`

	// RouteDestinationIpRanges The IP ranges specified in routes in the tables.
	RouteDestinationIpRanges *[]string `form:"routeDestinationIpRanges,omitempty" json:"routeDestinationIpRanges,omitempty"`

	// RouteDestinationServiceIds The service IDs specified in routes in the tables.
	RouteDestinationServiceIds *[]string `form:"routeDestinationServiceIds,omitempty" json:"routeDestinationServiceIds,omitempty"`

	// RouteGatewayIds The IDs of the gateways specified in routes in the tables.
	RouteGatewayIds *[]string `form:"routeGatewayIds,omitempty" json:"routeGatewayIds,omitempty"`

	// RouteNatServiceIds The IDs of the NAT services specified in routes in the tables.
	RouteNatServiceIds *[]string `form:"routeNatServiceIds,omitempty" json:"routeNatServiceIds,omitempty"`

	// RouteNetPeeringIds The IDs of the Net peerings specified in routes in the tables.
	RouteNetPeeringIds *[]string `form:"routeNetPeeringIds,omitempty" json:"routeNetPeeringIds,omitempty"`

	// RouteStates The states of routes in the route tables (always `active`).
	RouteStates *[]string `form:"routeStates,omitempty" json:"routeStates,omitempty"`

	// RouteTableIds The IDs of the route tables.
	RouteTableIds *[]string `form:"routeTableIds,omitempty" json:"routeTableIds,omitempty"`

	// RouteVmIds The IDs of the VMs specified in routes in the tables.
	RouteVmIds *[]string `form:"routeVmIds,omitempty" json:"routeVmIds,omitempty"`

	// TagKeys The keys of the tags associated with the route tables.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the route tables.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the route tables, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`
}

// ReadSecurityGroupsParams defines parameters for ReadSecurityGroups.
type ReadSecurityGroupsParams struct {
	// Descriptions The descriptions of the security groups.
	Descriptions *[]string `form:"descriptions,omitempty" json:"descriptions,omitempty"`

	// InboundRuleAccountIds The account IDs that have been granted permissions.
	InboundRuleAccountIds *[]string `form:"inboundRuleAccountIds,omitempty" json:"inboundRuleAccountIds,omitempty"`

	// InboundRuleFromPortRanges The beginnings of the port ranges for the TCP and UDP protocols, or the ICMP type numbers.
	InboundRuleFromPortRanges *[]int `form:"inboundRuleFromPortRanges,omitempty" json:"inboundRuleFromPortRanges,omitempty"`

	// InboundRuleIpRanges The IP ranges that have been granted permissions, in CIDR notation (for example, `10.0.0.0/24`).
	InboundRuleIpRanges *[]string `form:"inboundRuleIpRanges,omitempty" json:"inboundRuleIpRanges,omitempty"`

	// InboundRuleProtocols The IP protocols for the permissions (`tcp` \| `udp` \| `icmp`, or a protocol number, or `-1` for all protocols).
	InboundRuleProtocols *[]string `form:"inboundRuleProtocols,omitempty" json:"inboundRuleProtocols,omitempty"`

	// InboundRuleSecurityGroupIds The IDs of the security groups that have been granted permissions.
	InboundRuleSecurityGroupIds *[]string `form:"inboundRuleSecurityGroupIds,omitempty" json:"inboundRuleSecurityGroupIds,omitempty"`

	// InboundRuleSecurityGroupNames The names of the security groups that have been granted permissions.
	InboundRuleSecurityGroupNames *[]string `form:"inboundRuleSecurityGroupNames,omitempty" json:"inboundRuleSecurityGroupNames,omitempty"`

	// InboundRuleToPortRanges The ends of the port ranges for the TCP and UDP protocols, or the ICMP code numbers.
	InboundRuleToPortRanges *[]int `form:"inboundRuleToPortRanges,omitempty" json:"inboundRuleToPortRanges,omitempty"`

	// NetIds The IDs of the Nets specified when the security groups were created.
	NetIds *[]string `form:"netIds,omitempty" json:"netIds,omitempty"`

	// OutboundRuleAccountIds The account IDs that have been granted permissions.
	OutboundRuleAccountIds *[]string `form:"outboundRuleAccountIds,omitempty" json:"outboundRuleAccountIds,omitempty"`

	// OutboundRuleFromPortRanges The beginnings of the port ranges for the TCP and UDP protocols, or the ICMP type numbers.
	OutboundRuleFromPortRanges *[]int `form:"outboundRuleFromPortRanges,omitempty" json:"outboundRuleFromPortRanges,omitempty"`

	// OutboundRuleIpRanges The IP ranges that have been granted permissions, in CIDR notation (for example, `10.0.0.0/24`).
	OutboundRuleIpRanges *[]string `form:"outboundRuleIpRanges,omitempty" json:"outboundRuleIpRanges,omitempty"`

	// OutboundRuleProtocols The IP protocols for the permissions (`tcp` \| `udp` \| `icmp`, or a protocol number, or `-1` for all protocols).
	OutboundRuleProtocols *[]string `form:"outboundRuleProtocols,omitempty" json:"outboundRuleProtocols,omitempty"`

	// OutboundRuleSecurityGroupIds The IDs of the security groups that have been granted permissions.
	OutboundRuleSecurityGroupIds *[]string `form:"outboundRuleSecurityGroupIds,omitempty" json:"outboundRuleSecurityGroupIds,omitempty"`

	// OutboundRuleSecurityGroupNames The names of the security groups that have been granted permissions.
	OutboundRuleSecurityGroupNames *[]string `form:"outboundRuleSecurityGroupNames,omitempty" json:"outboundRuleSecurityGroupNames,omitempty"`

	// OutboundRuleToPortRanges The ends of the port ranges for the TCP and UDP protocols, or the ICMP code numbers.
	OutboundRuleToPortRanges *[]int `form:"outboundRuleToPortRanges,omitempty" json:"outboundRuleToPortRanges,omitempty"`

	// SecurityGroupIds The IDs of the security groups.
	SecurityGroupIds *[]string `form:"securityGroupIds,omitempty" json:"securityGroupIds,omitempty"`

	// SecurityGroupNames The names of the security groups.
	SecurityGroupNames *[]string `form:"securityGroupNames,omitempty" json:"securityGroupNames,omitempty"`

	// TagKeys The keys of the tags associated with the security groups.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the security groups.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the security groups, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`
}

// ReadSnapshotsParams defines parameters for ReadSnapshots.
type ReadSnapshotsParams struct {
	// Descriptions The descriptions of the snapshots.
	Descriptions *[]string `form:"descriptions,omitempty" json:"descriptions,omitempty"`

	// FromCreationDate The beginning of the time period, in ISO 8601 date-time format (for example, `2020-06-14T00:00:00.000Z`).
	FromCreationDate *string `form:"fromCreationDate,omitempty" json:"fromCreationDate,omitempty"`

	// PermissionsToCreateVolumeGlobalPermission If true, lists all public volumes. If false, lists all private volumes.
	PermissionsToCreateVolumeGlobalPermission *bool `form:"permissionsToCreateVolumeGlobalPermission,omitempty" json:"permissionsToCreateVolumeGlobalPermission,omitempty"`

	// Progresses The progresses of the snapshots, as a percentage.
	Progresses *[]int `form:"progresses,omitempty" json:"progresses,omitempty"`

	// SnapshotIds The IDs of the snapshots.
	SnapshotIds *[]string `form:"snapshotIds,omitempty" json:"snapshotIds,omitempty"`

	// States The states of the snapshots (`in-queue` \| `completed` \| `error`).
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// TagKeys The keys of the tags associated with the snapshots.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the snapshots.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the snapshots, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// ToCreationDate The end of the time period, in ISO 8601 date-time format (for example, `2020-06-30T00:00:00.000Z`).
	ToCreationDate *string `form:"toCreationDate,omitempty" json:"toCreationDate,omitempty"`

	// VolumeIds The IDs of the volumes used to create the snapshots.
	VolumeIds *[]string `form:"volumeIds,omitempty" json:"volumeIds,omitempty"`

	// VolumeSizes The sizes of the volumes used to create the snapshots, in gibibytes (GiB).
	VolumeSizes *[]int `form:"volumeSizes,omitempty" json:"volumeSizes,omitempty"`
}

// ReadSubnetsParams defines parameters for ReadSubnets.
type ReadSubnetsParams struct {
	// AvailableIpsCounts The number of available IPs.
	AvailableIpsCounts *[]int `form:"availableIpsCounts,omitempty" json:"availableIpsCounts,omitempty"`

	// IpRanges The IP ranges in the Subnets, in CIDR notation (for example, `10.0.0.0/16`).
	IpRanges *[]string `form:"ipRanges,omitempty" json:"ipRanges,omitempty"`

	// NetIds The IDs of the Nets in which the Subnets are.
	NetIds *[]string `form:"netIds,omitempty" json:"netIds,omitempty"`

	// States The states of the Subnets (`pending` \| `available` \| `deleted`).
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// SubnetIds The IDs of the Subnets.
	SubnetIds *[]string `form:"subnetIds,omitempty" json:"subnetIds,omitempty"`

	// SubregionNames The names of the Subregions in which the Subnets are located.
	SubregionNames *[]string `form:"subregionNames,omitempty" json:"subregionNames,omitempty"`

	// TagKeys The keys of the tags associated with the Subnets.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the Subnets.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the Subnets, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`
}

// ReadTagsParams defines parameters for ReadTags.
type ReadTagsParams struct {
	// Keys The keys of the tags that are assigned to the resources. You can use this filter alongside the `Values` filter. In that case, you filter the resources corresponding to each tag, regardless of the other filter.
	Keys *[]string `form:"keys,omitempty" json:"keys,omitempty"`

	// ResourceIds The IDs of the resources with which the tags are associated.
	ResourceIds *[]string `form:"resourceIds,omitempty" json:"resourceIds,omitempty"`

	// ResourceTypes The resource type (`vm` \| `image` \| `volume` \| `snapshot` \| `public-ip` \| `security-group` \| `route-table` \| `nic` \| `net` \| `subnet` \| `net-peering` \| `net-access-point` \| `nat-service` \| `internet-service` \| `client-gateway` \| `virtual-gateway` \| `vpn-connection` \| `dhcp-options` \| `task`).
	ResourceTypes *[]string `form:"resourceTypes,omitempty" json:"resourceTypes,omitempty"`

	// Values The values of the tags that are assigned to the resources. You can use this filter alongside the `TagKeys` filter. In that case, you filter the resources corresponding to each tag, regardless of the other filter.
	Values *[]string `form:"values,omitempty" json:"values,omitempty"`
}

// ReadVirtualGatewaysParams defines parameters for ReadVirtualGateways.
type ReadVirtualGatewaysParams struct {
	// ConnectionTypes The types of the virtual gateways (only `ipsec.1` is supported).
	ConnectionTypes *[]string `form:"connectionTypes,omitempty" json:"connectionTypes,omitempty"`

	// LinkNetIds The IDs of the Nets the virtual gateways are attached to.
	LinkNetIds *[]string `form:"linkNetIds,omitempty" json:"linkNetIds,omitempty"`

	// LinkStates The current states of the attachments between the virtual gateways and the Nets (`attaching` \| `attached` \| `detaching` \| `detached`).
	LinkStates *[]string `form:"linkStates,omitempty" json:"linkStates,omitempty"`

	// States The states of the virtual gateways (`pending` \| `available` \| `deleting` \| `deleted`).
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// TagKeys The keys of the tags associated with the virtual gateways.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the virtual gateways.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the virtual gateways, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// VirtualGatewayIds The IDs of the virtual gateways.
	VirtualGatewayIds *[]string `form:"virtualGatewayIds,omitempty" json:"virtualGatewayIds,omitempty"`
}

// ReadVmsParams defines parameters for ReadVms.
type ReadVmsParams struct {
	// TagKeys The keys of the tags associated with the VMs.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the VMs.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the VMs, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// VmIds One or more IDs of VMs.
	VmIds *[]string `form:"vmIds,omitempty" json:"vmIds,omitempty"`
}

// ReadVmsStateParams defines parameters for ReadVmsState.
type ReadVmsStateParams struct {
	// MaintenanceEventCodes The code for the scheduled event (`system-reboot` \| `system-maintenance`).
	MaintenanceEventCodes *[]string `form:"maintenanceEventCodes,omitempty" json:"maintenanceEventCodes,omitempty"`

	// MaintenanceEventDescriptions The description of the scheduled event.
	MaintenanceEventDescriptions *[]string `form:"maintenanceEventDescriptions,omitempty" json:"maintenanceEventDescriptions,omitempty"`

	// MaintenanceEventsNotAfter The latest time the event can end.
	MaintenanceEventsNotAfter *[]openapi_types.Date `form:"maintenanceEventsNotAfter,omitempty" json:"maintenanceEventsNotAfter,omitempty"`

	// MaintenanceEventsNotBefore The earliest time the event can start.
	MaintenanceEventsNotBefore *[]openapi_types.Date `form:"maintenanceEventsNotBefore,omitempty" json:"maintenanceEventsNotBefore,omitempty"`

	// SubregionNames The names of the Subregions of the VMs.
	SubregionNames *[]string `form:"subregionNames,omitempty" json:"subregionNames,omitempty"`

	// VmIds One or more IDs of VMs.
	VmIds *[]string `form:"vmIds,omitempty" json:"vmIds,omitempty"`

	// VmStates The states of the VMs (`pending` \| `running` \| `stopping` \| `stopped` \| `shutting-down` \| `terminated` \| `quarantine`).
	VmStates *[]string `form:"vmStates,omitempty" json:"vmStates,omitempty"`
}

// ReadVolumesParams defines parameters for ReadVolumes.
type ReadVolumesParams struct {
	// CreationDates The dates and times of creation of the volumes, in ISO 8601 date-time format (for example, `2020-06-30T00:00:00.000Z`).
	CreationDates *[]time.Time `form:"creationDates,omitempty" json:"creationDates,omitempty"`

	// LinkVolumeDeleteOnVmDeletion Whether the volumes are deleted or not when terminating the VMs.
	LinkVolumeDeleteOnVmDeletion *bool `form:"linkVolumeDeleteOnVmDeletion,omitempty" json:"linkVolumeDeleteOnVmDeletion,omitempty"`

	// LinkVolumeDeviceNames The VM device names.
	LinkVolumeDeviceNames *[]string `form:"linkVolumeDeviceNames,omitempty" json:"linkVolumeDeviceNames,omitempty"`

	// LinkVolumeLinkDates The dates and times of creation of the volumes, in ISO 8601 date-time format (for example, `2020-06-30T00:00:00.000Z`).
	LinkVolumeLinkDates *[]time.Time `form:"linkVolumeLinkDates,omitempty" json:"linkVolumeLinkDates,omitempty"`

	// LinkVolumeLinkStates The attachment states of the volumes (`attaching` \| `detaching` \| `attached` \| `detached`).
	LinkVolumeLinkStates *[]string `form:"linkVolumeLinkStates,omitempty" json:"linkVolumeLinkStates,omitempty"`

	// LinkVolumeVmIds One or more IDs of VMs.
	LinkVolumeVmIds *[]string `form:"linkVolumeVmIds,omitempty" json:"linkVolumeVmIds,omitempty"`

	// SnapshotIds The snapshots from which the volumes were created.
	SnapshotIds *[]string `form:"snapshotIds,omitempty" json:"snapshotIds,omitempty"`

	// SubregionNames The names of the Subregions in which the volumes were created.
	SubregionNames *[]string `form:"subregionNames,omitempty" json:"subregionNames,omitempty"`

	// TagKeys The keys of the tags associated with the volumes.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the volumes.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the volumes, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// VolumeIds The IDs of the volumes.
	VolumeIds *[]string `form:"volumeIds,omitempty" json:"volumeIds,omitempty"`

	// VolumeSizes The sizes of the volumes, in gibibytes (GiB).
	VolumeSizes *[]int `form:"volumeSizes,omitempty" json:"volumeSizes,omitempty"`

	// VolumeStates The states of the volumes (`creating` \| `available` \| `in-use` \| `updating` \| `deleting` \| `error`).
	VolumeStates *[]string `form:"volumeStates,omitempty" json:"volumeStates,omitempty"`

	// VolumeTypes The types of the volumes (`standard` \| `gp2` \| `io1`).
	VolumeTypes *[]string `form:"volumeTypes,omitempty" json:"volumeTypes,omitempty"`
}

// ReadVpnConnectionsParams defines parameters for ReadVpnConnections.
type ReadVpnConnectionsParams struct {
	// BgpAsns The Border Gateway Protocol (BGP) Autonomous System Numbers (ASNs) of the connections.
	BgpAsns *[]int `form:"bgpAsns,omitempty" json:"bgpAsns,omitempty"`

	// ClientGatewayIds The IDs of the client gateways.
	ClientGatewayIds *[]string `form:"clientGatewayIds,omitempty" json:"clientGatewayIds,omitempty"`

	// ConnectionTypes The types of the VPN connections (only `ipsec.1` is supported).
	ConnectionTypes *[]string `form:"connectionTypes,omitempty" json:"connectionTypes,omitempty"`

	// RouteDestinationIpRanges The destination IP ranges.
	RouteDestinationIpRanges *[]string `form:"routeDestinationIpRanges,omitempty" json:"routeDestinationIpRanges,omitempty"`

	// States The states of the VPN connections (`pending` \| `available` \| `deleting` \| `deleted`).
	States *[]string `form:"states,omitempty" json:"states,omitempty"`

	// StaticRoutesOnly If false, the VPN connection uses dynamic routing with Border Gateway Protocol (BGP). If true, routing is controlled using static routes. For more information about how to create and delete static routes, see [CreateVpnConnectionRoute](#createvpnconnectionroute) and [DeleteVpnConnectionRoute](#deletevpnconnectionroute).
	StaticRoutesOnly *bool `form:"staticRoutesOnly,omitempty" json:"staticRoutesOnly,omitempty"`

	// TagKeys The keys of the tags associated with the VPN connections.
	TagKeys *[]string `form:"tagKeys,omitempty" json:"tagKeys,omitempty"`

	// TagValues The values of the tags associated with the VPN connections.
	TagValues *[]string `form:"tagValues,omitempty" json:"tagValues,omitempty"`

	// Tags The key/value combination of the tags associated with the VPN connections, in the following format: &quot;Filters&quot;:{&quot;Tags&quot;:[&quot;TAGKEY=TAGVALUE&quot;]}.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// VirtualGatewayIds The IDs of the virtual gateways.
	VirtualGatewayIds *[]string `form:"virtualGatewayIds,omitempty" json:"virtualGatewayIds,omitempty"`

	// VpnConnectionIds The IDs of the VPN connections.
	VpnConnectionIds *[]string `form:"vpnConnectionIds,omitempty" json:"vpnConnectionIds,omitempty"`
}

// AcceptNetPeeringJSONRequestBody defines body for AcceptNetPeering for application/json ContentType.
type AcceptNetPeeringJSONRequestBody = AcceptNetPeeringRequestSchema

// ReadAdminPasswordJSONRequestBody defines body for ReadAdminPassword for application/json ContentType.
type ReadAdminPasswordJSONRequestBody = ReadAdminPasswordRequestSchema

// CreateClientGatewayJSONRequestBody defines body for CreateClientGateway for application/json ContentType.
type CreateClientGatewayJSONRequestBody = CreateClientGatewayRequestSchema

// ReadConsoleOutputJSONRequestBody defines body for ReadConsoleOutput for application/json ContentType.
type ReadConsoleOutputJSONRequestBody = ReadConsoleOutputRequestSchema

// CreateDhcpOptionsJSONRequestBody defines body for CreateDhcpOptions for application/json ContentType.
type CreateDhcpOptionsJSONRequestBody = CreateDhcpOptionsRequestSchema

// CreateDirectLinkInterfaceJSONRequestBody defines body for CreateDirectLinkInterface for application/json ContentType.
type CreateDirectLinkInterfaceJSONRequestBody = CreateDirectLinkInterfaceRequestSchema

// UpdateDirectLinkInterfaceJSONRequestBody defines body for UpdateDirectLinkInterface for application/json ContentType.
type UpdateDirectLinkInterfaceJSONRequestBody = UpdateDirectLinkInterfaceRequestSchema

// CreateDirectLinkJSONRequestBody defines body for CreateDirectLink for application/json ContentType.
type CreateDirectLinkJSONRequestBody = CreateDirectLinkRequestSchema

// ReadFlexibleGpuCatalogJSONRequestBody defines body for ReadFlexibleGpuCatalog for application/json ContentType.
type ReadFlexibleGpuCatalogJSONRequestBody = ReadFlexibleGpuCatalogRequestSchema

// CreateFlexibleGpuJSONRequestBody defines body for CreateFlexibleGpu for application/json ContentType.
type CreateFlexibleGpuJSONRequestBody = CreateFlexibleGpuRequestSchema

// UpdateFlexibleGpuJSONRequestBody defines body for UpdateFlexibleGpu for application/json ContentType.
type UpdateFlexibleGpuJSONRequestBody = UpdateFlexibleGpuRequestSchema

// LinkFlexibleGpuJSONRequestBody defines body for LinkFlexibleGpu for application/json ContentType.
type LinkFlexibleGpuJSONRequestBody = LinkFlexibleGpuRequestSchema

// CreateImageJSONRequestBody defines body for CreateImage for application/json ContentType.
type CreateImageJSONRequestBody = CreateImageRequestSchema

// UpdateImageJSONRequestBody defines body for UpdateImage for application/json ContentType.
type UpdateImageJSONRequestBody = UpdateImageRequestSchema

// CreateInternetServiceJSONRequestBody defines body for CreateInternetService for application/json ContentType.
type CreateInternetServiceJSONRequestBody = CreateInternetServiceRequestSchema

// LinkInternetServiceJSONRequestBody defines body for LinkInternetService for application/json ContentType.
type LinkInternetServiceJSONRequestBody = LinkInternetServiceRequestSchema

// UnlinkInternetServiceJSONRequestBody defines body for UnlinkInternetService for application/json ContentType.
type UnlinkInternetServiceJSONRequestBody = UnlinkInternetServiceRequestSchema

// CreateKeypairJSONRequestBody defines body for CreateKeypair for application/json ContentType.
type CreateKeypairJSONRequestBody = CreateKeypairRequestSchema

// CreateListenerRuleJSONRequestBody defines body for CreateListenerRule for application/json ContentType.
type CreateListenerRuleJSONRequestBody = CreateListenerRuleRequestSchema

// UpdateListenerRuleJSONRequestBody defines body for UpdateListenerRule for application/json ContentType.
type UpdateListenerRuleJSONRequestBody = UpdateListenerRuleRequestSchema

// LinkLoadBalancerBackendMachinesJSONRequestBody defines body for LinkLoadBalancerBackendMachines for application/json ContentType.
type LinkLoadBalancerBackendMachinesJSONRequestBody = LinkLoadBalancerBackendMachinesRequestSchema

// UnlinkLoadBalancerBackendMachinesJSONRequestBody defines body for UnlinkLoadBalancerBackendMachines for application/json ContentType.
type UnlinkLoadBalancerBackendMachinesJSONRequestBody = UnlinkLoadBalancerBackendMachinesRequestSchema

// CreateLoadBalancerListenersJSONRequestBody defines body for CreateLoadBalancerListeners for application/json ContentType.
type CreateLoadBalancerListenersJSONRequestBody = CreateLoadBalancerListenersRequestSchema

// DeleteLoadBalancerListenersJSONRequestBody defines body for DeleteLoadBalancerListeners for application/json ContentType.
type DeleteLoadBalancerListenersJSONRequestBody = DeleteLoadBalancerListenersRequestSchema

// CreateLoadBalancerPolicyJSONRequestBody defines body for CreateLoadBalancerPolicy for application/json ContentType.
type CreateLoadBalancerPolicyJSONRequestBody = CreateLoadBalancerPolicyRequestSchema

// DeleteLoadBalancerPolicyJSONRequestBody defines body for DeleteLoadBalancerPolicy for application/json ContentType.
type DeleteLoadBalancerPolicyJSONRequestBody = DeleteLoadBalancerPolicyRequestSchema

// ReadLoadBalancerTagsJSONRequestBody defines body for ReadLoadBalancerTags for application/json ContentType.
type ReadLoadBalancerTagsJSONRequestBody = ReadLoadBalancerTagsRequestSchema

// CreateLoadBalancerTagsJSONRequestBody defines body for CreateLoadBalancerTags for application/json ContentType.
type CreateLoadBalancerTagsJSONRequestBody = CreateLoadBalancerTagsRequestSchema

// DeleteLoadBalancerTagsJSONRequestBody defines body for DeleteLoadBalancerTags for application/json ContentType.
type DeleteLoadBalancerTagsJSONRequestBody = DeleteLoadBalancerTagsRequestSchema

// CreateLoadBalancerJSONRequestBody defines body for CreateLoadBalancer for application/json ContentType.
type CreateLoadBalancerJSONRequestBody = CreateLoadBalancerRequestSchema

// UpdateLoadBalancerJSONRequestBody defines body for UpdateLoadBalancer for application/json ContentType.
type UpdateLoadBalancerJSONRequestBody = UpdateLoadBalancerRequestSchema

// ReadLocationsJSONRequestBody defines body for ReadLocations for application/json ContentType.
type ReadLocationsJSONRequestBody = ReadLocationsRequestSchema

// CreateNatServiceJSONRequestBody defines body for CreateNatService for application/json ContentType.
type CreateNatServiceJSONRequestBody = CreateNatServiceRequestSchema

// CreateNetAccessPointJSONRequestBody defines body for CreateNetAccessPoint for application/json ContentType.
type CreateNetAccessPointJSONRequestBody = CreateNetAccessPointRequestSchema

// UpdateNetAccessPointJSONRequestBody defines body for UpdateNetAccessPoint for application/json ContentType.
type UpdateNetAccessPointJSONRequestBody = UpdateNetAccessPointRequestSchema

// CreateNetPeeringJSONRequestBody defines body for CreateNetPeering for application/json ContentType.
type CreateNetPeeringJSONRequestBody = CreateNetPeeringRequestSchema

// CreateNetJSONRequestBody defines body for CreateNet for application/json ContentType.
type CreateNetJSONRequestBody = CreateNetRequestSchema

// UpdateNetJSONRequestBody defines body for UpdateNet for application/json ContentType.
type UpdateNetJSONRequestBody = UpdateNetRequestSchema

// CreateNicJSONRequestBody defines body for CreateNic for application/json ContentType.
type CreateNicJSONRequestBody = CreateNicRequestSchema

// UpdateNicJSONRequestBody defines body for UpdateNic for application/json ContentType.
type UpdateNicJSONRequestBody = UpdateNicRequestSchema

// LinkNicJSONRequestBody defines body for LinkNic for application/json ContentType.
type LinkNicJSONRequestBody = LinkNicRequestSchema

// LinkPrivateIpsJSONRequestBody defines body for LinkPrivateIps for application/json ContentType.
type LinkPrivateIpsJSONRequestBody = LinkPrivateIpsRequestSchema

// UnlinkPrivateIpsJSONRequestBody defines body for UnlinkPrivateIps for application/json ContentType.
type UnlinkPrivateIpsJSONRequestBody = UnlinkPrivateIpsRequestSchema

// ReadPublicIpRangesJSONRequestBody defines body for ReadPublicIpRanges for application/json ContentType.
type ReadPublicIpRangesJSONRequestBody = ReadPublicIpRangesRequestSchema

// CreatePublicIpJSONRequestBody defines body for CreatePublicIp for application/json ContentType.
type CreatePublicIpJSONRequestBody = CreatePublicIpRequestSchema

// DeletePublicIpJSONRequestBody defines body for DeletePublicIp for application/json ContentType.
type DeletePublicIpJSONRequestBody = DeletePublicIpRequestSchema

// LinkPublicIpJSONRequestBody defines body for LinkPublicIp for application/json ContentType.
type LinkPublicIpJSONRequestBody = LinkPublicIpRequestSchema

// UnlinkPublicIpJSONRequestBody defines body for UnlinkPublicIp for application/json ContentType.
type UnlinkPublicIpJSONRequestBody = UnlinkPublicIpRequestSchema

// RebootVmsJSONRequestBody defines body for RebootVms for application/json ContentType.
type RebootVmsJSONRequestBody = RebootVmsRequestSchema

// RejectNetPeeringJSONRequestBody defines body for RejectNetPeering for application/json ContentType.
type RejectNetPeeringJSONRequestBody = RejectNetPeeringRequestSchema

// UpdateRoutePropagationJSONRequestBody defines body for UpdateRoutePropagation for application/json ContentType.
type UpdateRoutePropagationJSONRequestBody = UpdateRoutePropagationRequestSchema

// CreateRouteTableJSONRequestBody defines body for CreateRouteTable for application/json ContentType.
type CreateRouteTableJSONRequestBody = CreateRouteTableRequestSchema

// LinkRouteTableJSONRequestBody defines body for LinkRouteTable for application/json ContentType.
type LinkRouteTableJSONRequestBody = LinkRouteTableRequestSchema

// CreateRouteJSONRequestBody defines body for CreateRoute for application/json ContentType.
type CreateRouteJSONRequestBody = CreateRouteRequestSchema

// DeleteRouteJSONRequestBody defines body for DeleteRoute for application/json ContentType.
type DeleteRouteJSONRequestBody = DeleteRouteRequestSchema

// UpdateRouteJSONRequestBody defines body for UpdateRoute for application/json ContentType.
type UpdateRouteJSONRequestBody = UpdateRouteRequestSchema

// CreateSecurityGroupRuleJSONRequestBody defines body for CreateSecurityGroupRule for application/json ContentType.
type CreateSecurityGroupRuleJSONRequestBody = CreateSecurityGroupRuleRequestSchema

// DeleteSecurityGroupRuleJSONRequestBody defines body for DeleteSecurityGroupRule for application/json ContentType.
type DeleteSecurityGroupRuleJSONRequestBody = DeleteSecurityGroupRuleRequestSchema

// CreateSecurityGroupJSONRequestBody defines body for CreateSecurityGroup for application/json ContentType.
type CreateSecurityGroupJSONRequestBody = CreateSecurityGroupRequestSchema

// DeleteSecurityGroupJSONRequestBody defines body for DeleteSecurityGroup for application/json ContentType.
type DeleteSecurityGroupJSONRequestBody = DeleteSecurityGroupRequestSchema

// CreateSnapshotJSONRequestBody defines body for CreateSnapshot for application/json ContentType.
type CreateSnapshotJSONRequestBody = CreateSnapshotRequestSchema

// StartVmsJSONRequestBody defines body for StartVms for application/json ContentType.
type StartVmsJSONRequestBody = StartVmsRequestSchema

// StopVmsJSONRequestBody defines body for StopVms for application/json ContentType.
type StopVmsJSONRequestBody = StopVmsRequestSchema

// CreateSubnetJSONRequestBody defines body for CreateSubnet for application/json ContentType.
type CreateSubnetJSONRequestBody = CreateSubnetRequestSchema

// UpdateSubnetJSONRequestBody defines body for UpdateSubnet for application/json ContentType.
type UpdateSubnetJSONRequestBody = UpdateSubnetRequestSchema

// CreateTagsJSONRequestBody defines body for CreateTags for application/json ContentType.
type CreateTagsJSONRequestBody = CreateTagsRequestSchema

// DeleteTagsJSONRequestBody defines body for DeleteTags for application/json ContentType.
type DeleteTagsJSONRequestBody = DeleteTagsRequestSchema

// CreateVirtualGatewayJSONRequestBody defines body for CreateVirtualGateway for application/json ContentType.
type CreateVirtualGatewayJSONRequestBody = CreateVirtualGatewayRequestSchema

// LinkVirtualGatewayJSONRequestBody defines body for LinkVirtualGateway for application/json ContentType.
type LinkVirtualGatewayJSONRequestBody = LinkVirtualGatewayRequestSchema

// UnlinkVirtualGatewayJSONRequestBody defines body for UnlinkVirtualGateway for application/json ContentType.
type UnlinkVirtualGatewayJSONRequestBody = UnlinkVirtualGatewayRequestSchema

// CreateVmsJSONRequestBody defines body for CreateVms for application/json ContentType.
type CreateVmsJSONRequestBody = CreateVmsRequestSchema

// UpdateVmJSONRequestBody defines body for UpdateVm for application/json ContentType.
type UpdateVmJSONRequestBody = UpdateVmRequestSchema

// ReadVmsHealthJSONRequestBody defines body for ReadVmsHealth for application/json ContentType.
type ReadVmsHealthJSONRequestBody = ReadVmsHealthRequestSchema

// CreateVolumeJSONRequestBody defines body for CreateVolume for application/json ContentType.
type CreateVolumeJSONRequestBody = CreateVolumeRequestSchema

// UpdateVolumeJSONRequestBody defines body for UpdateVolume for application/json ContentType.
type UpdateVolumeJSONRequestBody = UpdateVolumeRequestSchema

// LinkVolumeJSONRequestBody defines body for LinkVolume for application/json ContentType.
type LinkVolumeJSONRequestBody = LinkVolumeRequestSchema

// UnlinkVolumeJSONRequestBody defines body for UnlinkVolume for application/json ContentType.
type UnlinkVolumeJSONRequestBody = UnlinkVolumeRequestSchema

// CreateVpnConnectionRouteJSONRequestBody defines body for CreateVpnConnectionRoute for application/json ContentType.
type CreateVpnConnectionRouteJSONRequestBody = CreateVpnConnectionRouteRequestSchema

// DeleteVpnConnectionRouteJSONRequestBody defines body for DeleteVpnConnectionRoute for application/json ContentType.
type DeleteVpnConnectionRouteJSONRequestBody = DeleteVpnConnectionRouteRequestSchema

// CreateVpnConnectionJSONRequestBody defines body for CreateVpnConnection for application/json ContentType.
type CreateVpnConnectionJSONRequestBody = CreateVpnConnectionRequestSchema

// UpdateVpnConnectionJSONRequestBody defines body for UpdateVpnConnection for application/json ContentType.
type UpdateVpnConnectionJSONRequestBody = UpdateVpnConnectionRequestSchema

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// AcceptNetPeeringWithBody request with any body
	AcceptNetPeeringWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AcceptNetPeering(ctx context.Context, body AcceptNetPeeringJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadAdminPasswordWithBody request with any body
	ReadAdminPasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReadAdminPassword(ctx context.Context, body ReadAdminPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadAdminPasswordById request
	ReadAdminPasswordById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadClientGateways request
	ReadClientGateways(ctx context.Context, params *ReadClientGatewaysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateClientGatewayWithBody request with any body
	CreateClientGatewayWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateClientGateway(ctx context.Context, body CreateClientGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteClientGateway request
	DeleteClientGateway(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadClientGatewaysById request
	ReadClientGatewaysById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadConsoleOutputWithBody request with any body
	ReadConsoleOutputWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReadConsoleOutput(ctx context.Context, body ReadConsoleOutputJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadConsoleOutputById request
	ReadConsoleOutputById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadDhcpOptions request
	ReadDhcpOptions(ctx context.Context, params *ReadDhcpOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDhcpOptionsWithBody request with any body
	CreateDhcpOptionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDhcpOptions(ctx context.Context, body CreateDhcpOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDhcpOptions request
	DeleteDhcpOptions(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadDhcpOptionsById request
	ReadDhcpOptionsById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadDirectLinkInterfaces request
	ReadDirectLinkInterfaces(ctx context.Context, params *ReadDirectLinkInterfacesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDirectLinkInterfaceWithBody request with any body
	CreateDirectLinkInterfaceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDirectLinkInterface(ctx context.Context, body CreateDirectLinkInterfaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDirectLinkInterface request
	DeleteDirectLinkInterface(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadDirectLinkInterfacesById request
	ReadDirectLinkInterfacesById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDirectLinkInterfaceWithBody request with any body
	UpdateDirectLinkInterfaceWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDirectLinkInterface(ctx context.Context, id string, body UpdateDirectLinkInterfaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadDirectLinks request
	ReadDirectLinks(ctx context.Context, params *ReadDirectLinksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDirectLinkWithBody request with any body
	CreateDirectLinkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDirectLink(ctx context.Context, body CreateDirectLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDirectLink request
	DeleteDirectLink(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadDirectLinksById request
	ReadDirectLinksById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadFlexibleGpuCatalogWithBody request with any body
	ReadFlexibleGpuCatalogWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReadFlexibleGpuCatalog(ctx context.Context, body ReadFlexibleGpuCatalogJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadFlexibleGpuCatalogById request
	ReadFlexibleGpuCatalogById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadFlexibleGpus request
	ReadFlexibleGpus(ctx context.Context, params *ReadFlexibleGpusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFlexibleGpuWithBody request with any body
	CreateFlexibleGpuWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFlexibleGpu(ctx context.Context, body CreateFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFlexibleGpu request
	DeleteFlexibleGpu(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadFlexibleGpusById request
	ReadFlexibleGpusById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateFlexibleGpuWithBody request with any body
	UpdateFlexibleGpuWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateFlexibleGpu(ctx context.Context, id string, body UpdateFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkFlexibleGpuWithBody request with any body
	LinkFlexibleGpuWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkFlexibleGpu(ctx context.Context, id string, body LinkFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkFlexibleGpu request
	UnlinkFlexibleGpu(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadImages request
	ReadImages(ctx context.Context, params *ReadImagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateImageWithBody request with any body
	CreateImageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateImage(ctx context.Context, body CreateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteImage request
	DeleteImage(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadImagesById request
	ReadImagesById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateImageWithBody request with any body
	UpdateImageWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateImage(ctx context.Context, id string, body UpdateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadInternetServices request
	ReadInternetServices(ctx context.Context, params *ReadInternetServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateInternetServiceWithBody request with any body
	CreateInternetServiceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateInternetService(ctx context.Context, body CreateInternetServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteInternetService request
	DeleteInternetService(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadInternetServicesById request
	ReadInternetServicesById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkInternetServiceWithBody request with any body
	LinkInternetServiceWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkInternetService(ctx context.Context, id string, body LinkInternetServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkInternetServiceWithBody request with any body
	UnlinkInternetServiceWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnlinkInternetService(ctx context.Context, id string, body UnlinkInternetServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadKeypairs request
	ReadKeypairs(ctx context.Context, params *ReadKeypairsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateKeypairWithBody request with any body
	CreateKeypairWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateKeypair(ctx context.Context, body CreateKeypairJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteKeypair request
	DeleteKeypair(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadKeypairsById request
	ReadKeypairsById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadListenerRules request
	ReadListenerRules(ctx context.Context, params *ReadListenerRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateListenerRuleWithBody request with any body
	CreateListenerRuleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateListenerRule(ctx context.Context, body CreateListenerRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteListenerRule request
	DeleteListenerRule(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadListenerRulesById request
	ReadListenerRulesById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateListenerRuleWithBody request with any body
	UpdateListenerRuleWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateListenerRule(ctx context.Context, id string, body UpdateListenerRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkLoadBalancerBackendMachinesWithBody request with any body
	LinkLoadBalancerBackendMachinesWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkLoadBalancerBackendMachines(ctx context.Context, id string, body LinkLoadBalancerBackendMachinesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkLoadBalancerBackendMachinesWithBody request with any body
	UnlinkLoadBalancerBackendMachinesWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnlinkLoadBalancerBackendMachines(ctx context.Context, id string, body UnlinkLoadBalancerBackendMachinesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLoadBalancerListenersWithBody request with any body
	CreateLoadBalancerListenersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLoadBalancerListeners(ctx context.Context, body CreateLoadBalancerListenersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLoadBalancerListenersWithBody request with any body
	DeleteLoadBalancerListenersWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteLoadBalancerListeners(ctx context.Context, id string, body DeleteLoadBalancerListenersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLoadBalancerPolicyWithBody request with any body
	CreateLoadBalancerPolicyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLoadBalancerPolicy(ctx context.Context, body CreateLoadBalancerPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLoadBalancerPolicyWithBody request with any body
	DeleteLoadBalancerPolicyWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteLoadBalancerPolicy(ctx context.Context, id string, body DeleteLoadBalancerPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadLoadBalancerTagsWithBody request with any body
	ReadLoadBalancerTagsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReadLoadBalancerTags(ctx context.Context, body ReadLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLoadBalancerTagsWithBody request with any body
	CreateLoadBalancerTagsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLoadBalancerTags(ctx context.Context, body CreateLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLoadBalancerTagsWithBody request with any body
	DeleteLoadBalancerTagsWithBody(ctx context.Context, id []interface{}, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteLoadBalancerTags(ctx context.Context, id []interface{}, body DeleteLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadLoadBalancerTagsById request
	ReadLoadBalancerTagsById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadLoadBalancers request
	ReadLoadBalancers(ctx context.Context, params *ReadLoadBalancersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLoadBalancerWithBody request with any body
	CreateLoadBalancerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLoadBalancer(ctx context.Context, body CreateLoadBalancerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLoadBalancer request
	DeleteLoadBalancer(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadLoadBalancersById request
	ReadLoadBalancersById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateLoadBalancerWithBody request with any body
	UpdateLoadBalancerWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateLoadBalancer(ctx context.Context, id string, body UpdateLoadBalancerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadLocationsWithBody request with any body
	ReadLocationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReadLocations(ctx context.Context, body ReadLocationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadLocationsById request
	ReadLocationsById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadNatServices request
	ReadNatServices(ctx context.Context, params *ReadNatServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNatServiceWithBody request with any body
	CreateNatServiceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNatService(ctx context.Context, body CreateNatServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNatService request
	DeleteNatService(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadNatServicesById request
	ReadNatServicesById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadNetAccessPoints request
	ReadNetAccessPoints(ctx context.Context, params *ReadNetAccessPointsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNetAccessPointWithBody request with any body
	CreateNetAccessPointWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNetAccessPoint(ctx context.Context, body CreateNetAccessPointJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNetAccessPoint request
	DeleteNetAccessPoint(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadNetAccessPointsById request
	ReadNetAccessPointsById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateNetAccessPointWithBody request with any body
	UpdateNetAccessPointWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateNetAccessPoint(ctx context.Context, id string, body UpdateNetAccessPointJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadNetPeerings request
	ReadNetPeerings(ctx context.Context, params *ReadNetPeeringsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNetPeeringWithBody request with any body
	CreateNetPeeringWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNetPeering(ctx context.Context, body CreateNetPeeringJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNetPeering request
	DeleteNetPeering(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadNetPeeringsById request
	ReadNetPeeringsById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadNets request
	ReadNets(ctx context.Context, params *ReadNetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNetWithBody request with any body
	CreateNetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNet(ctx context.Context, body CreateNetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNet request
	DeleteNet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadNetsById request
	ReadNetsById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateNetWithBody request with any body
	UpdateNetWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateNet(ctx context.Context, id string, body UpdateNetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadNics request
	ReadNics(ctx context.Context, params *ReadNicsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNicWithBody request with any body
	CreateNicWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNic(ctx context.Context, body CreateNicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNic request
	DeleteNic(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadNicsById request
	ReadNicsById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateNicWithBody request with any body
	UpdateNicWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateNic(ctx context.Context, id string, body UpdateNicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkNicWithBody request with any body
	LinkNicWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkNic(ctx context.Context, id string, body LinkNicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkNic request
	UnlinkNic(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkPrivateIpsWithBody request with any body
	LinkPrivateIpsWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkPrivateIps(ctx context.Context, id string, body LinkPrivateIpsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkPrivateIpsWithBody request with any body
	UnlinkPrivateIpsWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnlinkPrivateIps(ctx context.Context, id string, body UnlinkPrivateIpsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadProductTypes request
	ReadProductTypes(ctx context.Context, params *ReadProductTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadProductTypesById request
	ReadProductTypesById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadPublicIpRangesWithBody request with any body
	ReadPublicIpRangesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReadPublicIpRanges(ctx context.Context, body ReadPublicIpRangesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadPublicIpRangesById request
	ReadPublicIpRangesById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadPublicIps request
	ReadPublicIps(ctx context.Context, params *ReadPublicIpsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePublicIpWithBody request with any body
	CreatePublicIpWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePublicIp(ctx context.Context, body CreatePublicIpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePublicIpWithBody request with any body
	DeletePublicIpWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeletePublicIp(ctx context.Context, id string, body DeletePublicIpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadPublicIpsById request
	ReadPublicIpsById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkPublicIpWithBody request with any body
	LinkPublicIpWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkPublicIp(ctx context.Context, id string, body LinkPublicIpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkPublicIpWithBody request with any body
	UnlinkPublicIpWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnlinkPublicIp(ctx context.Context, id string, body UnlinkPublicIpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RebootVmsWithBody request with any body
	RebootVmsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RebootVms(ctx context.Context, body RebootVmsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RejectNetPeeringWithBody request with any body
	RejectNetPeeringWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RejectNetPeering(ctx context.Context, body RejectNetPeeringJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRoutePropagationWithBody request with any body
	UpdateRoutePropagationWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRoutePropagation(ctx context.Context, id string, body UpdateRoutePropagationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadRouteTables request
	ReadRouteTables(ctx context.Context, params *ReadRouteTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRouteTableWithBody request with any body
	CreateRouteTableWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRouteTable(ctx context.Context, body CreateRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRouteTable request
	DeleteRouteTable(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadRouteTablesById request
	ReadRouteTablesById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkRouteTableWithBody request with any body
	LinkRouteTableWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkRouteTable(ctx context.Context, id string, body LinkRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkRouteTable request
	UnlinkRouteTable(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRouteWithBody request with any body
	CreateRouteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRoute(ctx context.Context, body CreateRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRouteWithBody request with any body
	DeleteRouteWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteRoute(ctx context.Context, id string, body DeleteRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRouteWithBody request with any body
	UpdateRouteWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRoute(ctx context.Context, id string, body UpdateRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSecurityGroupRuleWithBody request with any body
	CreateSecurityGroupRuleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSecurityGroupRule(ctx context.Context, body CreateSecurityGroupRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSecurityGroupRuleWithBody request with any body
	DeleteSecurityGroupRuleWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteSecurityGroupRule(ctx context.Context, id string, body DeleteSecurityGroupRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadSecurityGroups request
	ReadSecurityGroups(ctx context.Context, params *ReadSecurityGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSecurityGroupWithBody request with any body
	CreateSecurityGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSecurityGroup(ctx context.Context, body CreateSecurityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSecurityGroupWithBody request with any body
	DeleteSecurityGroupWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteSecurityGroup(ctx context.Context, id string, body DeleteSecurityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadSecurityGroupsById request
	ReadSecurityGroupsById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadSnapshots request
	ReadSnapshots(ctx context.Context, params *ReadSnapshotsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSnapshotWithBody request with any body
	CreateSnapshotWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSnapshot(ctx context.Context, body CreateSnapshotJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSnapshot request
	DeleteSnapshot(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadSnapshotsById request
	ReadSnapshotsById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartVmsWithBody request with any body
	StartVmsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StartVms(ctx context.Context, body StartVmsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StopVmsWithBody request with any body
	StopVmsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StopVms(ctx context.Context, body StopVmsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadSubnets request
	ReadSubnets(ctx context.Context, params *ReadSubnetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSubnetWithBody request with any body
	CreateSubnetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSubnet(ctx context.Context, body CreateSubnetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSubnet request
	DeleteSubnet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadSubnetsById request
	ReadSubnetsById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSubnetWithBody request with any body
	UpdateSubnetWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSubnet(ctx context.Context, id string, body UpdateSubnetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadTags request
	ReadTags(ctx context.Context, params *ReadTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTagsWithBody request with any body
	CreateTagsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTags(ctx context.Context, body CreateTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTagsWithBody request with any body
	DeleteTagsWithBody(ctx context.Context, id []interface{}, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteTags(ctx context.Context, id []interface{}, body DeleteTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadTagsById request
	ReadTagsById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVirtualGateways request
	ReadVirtualGateways(ctx context.Context, params *ReadVirtualGatewaysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVirtualGatewayWithBody request with any body
	CreateVirtualGatewayWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVirtualGateway(ctx context.Context, body CreateVirtualGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVirtualGateway request
	DeleteVirtualGateway(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVirtualGatewaysById request
	ReadVirtualGatewaysById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkVirtualGatewayWithBody request with any body
	LinkVirtualGatewayWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkVirtualGateway(ctx context.Context, id string, body LinkVirtualGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkVirtualGatewayWithBody request with any body
	UnlinkVirtualGatewayWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnlinkVirtualGateway(ctx context.Context, id string, body UnlinkVirtualGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVms request
	ReadVms(ctx context.Context, params *ReadVmsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVmsWithBody request with any body
	CreateVmsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVms(ctx context.Context, body CreateVmsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVms request
	DeleteVms(ctx context.Context, id []interface{}, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVmsById request
	ReadVmsById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVmWithBody request with any body
	UpdateVmWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVm(ctx context.Context, id string, body UpdateVmJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVmsHealthWithBody request with any body
	ReadVmsHealthWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReadVmsHealth(ctx context.Context, body ReadVmsHealthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVmsHealthById request
	ReadVmsHealthById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVmsState request
	ReadVmsState(ctx context.Context, params *ReadVmsStateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVmsStateById request
	ReadVmsStateById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVolumes request
	ReadVolumes(ctx context.Context, params *ReadVolumesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVolumeWithBody request with any body
	CreateVolumeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVolume(ctx context.Context, body CreateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVolume request
	DeleteVolume(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVolumesById request
	ReadVolumesById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVolumeWithBody request with any body
	UpdateVolumeWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVolume(ctx context.Context, id string, body UpdateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkVolumeWithBody request with any body
	LinkVolumeWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkVolume(ctx context.Context, id string, body LinkVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkVolumeWithBody request with any body
	UnlinkVolumeWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnlinkVolume(ctx context.Context, id string, body UnlinkVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVpnConnectionRouteWithBody request with any body
	CreateVpnConnectionRouteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVpnConnectionRoute(ctx context.Context, body CreateVpnConnectionRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVpnConnectionRouteWithBody request with any body
	DeleteVpnConnectionRouteWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteVpnConnectionRoute(ctx context.Context, id string, body DeleteVpnConnectionRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVpnConnections request
	ReadVpnConnections(ctx context.Context, params *ReadVpnConnectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVpnConnectionWithBody request with any body
	CreateVpnConnectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVpnConnection(ctx context.Context, body CreateVpnConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVpnConnection request
	DeleteVpnConnection(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadVpnConnectionsById request
	ReadVpnConnectionsById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVpnConnectionWithBody request with any body
	UpdateVpnConnectionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVpnConnection(ctx context.Context, id string, body UpdateVpnConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) AcceptNetPeeringWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcceptNetPeeringRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AcceptNetPeering(ctx context.Context, body AcceptNetPeeringJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcceptNetPeeringRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadAdminPasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadAdminPasswordRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadAdminPassword(ctx context.Context, body ReadAdminPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadAdminPasswordRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadAdminPasswordById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadAdminPasswordByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadClientGateways(ctx context.Context, params *ReadClientGatewaysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadClientGatewaysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClientGatewayWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientGatewayRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClientGateway(ctx context.Context, body CreateClientGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientGatewayRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteClientGateway(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClientGatewayRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadClientGatewaysById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadClientGatewaysByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadConsoleOutputWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadConsoleOutputRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadConsoleOutput(ctx context.Context, body ReadConsoleOutputJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadConsoleOutputRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadConsoleOutputById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadConsoleOutputByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadDhcpOptions(ctx context.Context, params *ReadDhcpOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadDhcpOptionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDhcpOptionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDhcpOptionsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDhcpOptions(ctx context.Context, body CreateDhcpOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDhcpOptionsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDhcpOptions(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDhcpOptionsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadDhcpOptionsById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadDhcpOptionsByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadDirectLinkInterfaces(ctx context.Context, params *ReadDirectLinkInterfacesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadDirectLinkInterfacesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDirectLinkInterfaceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDirectLinkInterfaceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDirectLinkInterface(ctx context.Context, body CreateDirectLinkInterfaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDirectLinkInterfaceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDirectLinkInterface(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDirectLinkInterfaceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadDirectLinkInterfacesById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadDirectLinkInterfacesByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDirectLinkInterfaceWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDirectLinkInterfaceRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDirectLinkInterface(ctx context.Context, id string, body UpdateDirectLinkInterfaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDirectLinkInterfaceRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadDirectLinks(ctx context.Context, params *ReadDirectLinksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadDirectLinksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDirectLinkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDirectLinkRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDirectLink(ctx context.Context, body CreateDirectLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDirectLinkRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDirectLink(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDirectLinkRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadDirectLinksById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadDirectLinksByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadFlexibleGpuCatalogWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadFlexibleGpuCatalogRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadFlexibleGpuCatalog(ctx context.Context, body ReadFlexibleGpuCatalogJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadFlexibleGpuCatalogRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadFlexibleGpuCatalogById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadFlexibleGpuCatalogByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadFlexibleGpus(ctx context.Context, params *ReadFlexibleGpusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadFlexibleGpusRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFlexibleGpuWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFlexibleGpuRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFlexibleGpu(ctx context.Context, body CreateFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFlexibleGpuRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFlexibleGpu(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFlexibleGpuRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadFlexibleGpusById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadFlexibleGpusByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFlexibleGpuWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFlexibleGpuRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFlexibleGpu(ctx context.Context, id string, body UpdateFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFlexibleGpuRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkFlexibleGpuWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkFlexibleGpuRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkFlexibleGpu(ctx context.Context, id string, body LinkFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkFlexibleGpuRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkFlexibleGpu(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkFlexibleGpuRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadImages(ctx context.Context, params *ReadImagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadImagesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateImageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateImageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateImage(ctx context.Context, body CreateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateImageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteImage(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteImageRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadImagesById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadImagesByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateImageWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateImageRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateImage(ctx context.Context, id string, body UpdateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateImageRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadInternetServices(ctx context.Context, params *ReadInternetServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadInternetServicesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateInternetServiceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateInternetServiceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateInternetService(ctx context.Context, body CreateInternetServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateInternetServiceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteInternetService(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteInternetServiceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadInternetServicesById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadInternetServicesByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkInternetServiceWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkInternetServiceRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkInternetService(ctx context.Context, id string, body LinkInternetServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkInternetServiceRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkInternetServiceWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkInternetServiceRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkInternetService(ctx context.Context, id string, body UnlinkInternetServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkInternetServiceRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadKeypairs(ctx context.Context, params *ReadKeypairsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadKeypairsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKeypairWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeypairRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKeypair(ctx context.Context, body CreateKeypairJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeypairRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteKeypair(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteKeypairRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadKeypairsById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadKeypairsByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadListenerRules(ctx context.Context, params *ReadListenerRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadListenerRulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateListenerRuleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateListenerRuleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateListenerRule(ctx context.Context, body CreateListenerRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateListenerRuleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteListenerRule(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteListenerRuleRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadListenerRulesById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadListenerRulesByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateListenerRuleWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateListenerRuleRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateListenerRule(ctx context.Context, id string, body UpdateListenerRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateListenerRuleRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkLoadBalancerBackendMachinesWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkLoadBalancerBackendMachinesRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkLoadBalancerBackendMachines(ctx context.Context, id string, body LinkLoadBalancerBackendMachinesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkLoadBalancerBackendMachinesRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkLoadBalancerBackendMachinesWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkLoadBalancerBackendMachinesRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkLoadBalancerBackendMachines(ctx context.Context, id string, body UnlinkLoadBalancerBackendMachinesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkLoadBalancerBackendMachinesRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLoadBalancerListenersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLoadBalancerListenersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLoadBalancerListeners(ctx context.Context, body CreateLoadBalancerListenersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLoadBalancerListenersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLoadBalancerListenersWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLoadBalancerListenersRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLoadBalancerListeners(ctx context.Context, id string, body DeleteLoadBalancerListenersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLoadBalancerListenersRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLoadBalancerPolicyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLoadBalancerPolicyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLoadBalancerPolicy(ctx context.Context, body CreateLoadBalancerPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLoadBalancerPolicyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLoadBalancerPolicyWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLoadBalancerPolicyRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLoadBalancerPolicy(ctx context.Context, id string, body DeleteLoadBalancerPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLoadBalancerPolicyRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadLoadBalancerTagsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadLoadBalancerTagsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadLoadBalancerTags(ctx context.Context, body ReadLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadLoadBalancerTagsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLoadBalancerTagsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLoadBalancerTagsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLoadBalancerTags(ctx context.Context, body CreateLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLoadBalancerTagsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLoadBalancerTagsWithBody(ctx context.Context, id []interface{}, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLoadBalancerTagsRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLoadBalancerTags(ctx context.Context, id []interface{}, body DeleteLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLoadBalancerTagsRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadLoadBalancerTagsById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadLoadBalancerTagsByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadLoadBalancers(ctx context.Context, params *ReadLoadBalancersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadLoadBalancersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLoadBalancerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLoadBalancerRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLoadBalancer(ctx context.Context, body CreateLoadBalancerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLoadBalancerRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLoadBalancer(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLoadBalancerRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadLoadBalancersById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadLoadBalancersByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLoadBalancerWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLoadBalancerRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLoadBalancer(ctx context.Context, id string, body UpdateLoadBalancerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLoadBalancerRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadLocationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadLocationsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadLocations(ctx context.Context, body ReadLocationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadLocationsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadLocationsById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadLocationsByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadNatServices(ctx context.Context, params *ReadNatServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadNatServicesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNatServiceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNatServiceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNatService(ctx context.Context, body CreateNatServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNatServiceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNatService(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNatServiceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadNatServicesById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadNatServicesByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadNetAccessPoints(ctx context.Context, params *ReadNetAccessPointsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadNetAccessPointsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNetAccessPointWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNetAccessPointRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNetAccessPoint(ctx context.Context, body CreateNetAccessPointJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNetAccessPointRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNetAccessPoint(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNetAccessPointRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadNetAccessPointsById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadNetAccessPointsByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNetAccessPointWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNetAccessPointRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNetAccessPoint(ctx context.Context, id string, body UpdateNetAccessPointJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNetAccessPointRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadNetPeerings(ctx context.Context, params *ReadNetPeeringsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadNetPeeringsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNetPeeringWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNetPeeringRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNetPeering(ctx context.Context, body CreateNetPeeringJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNetPeeringRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNetPeering(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNetPeeringRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadNetPeeringsById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadNetPeeringsByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadNets(ctx context.Context, params *ReadNetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadNetsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNetRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNet(ctx context.Context, body CreateNetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNetRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNetRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadNetsById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadNetsByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNetWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNetRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNet(ctx context.Context, id string, body UpdateNetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNetRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadNics(ctx context.Context, params *ReadNicsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadNicsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNicWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNicRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNic(ctx context.Context, body CreateNicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNicRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNic(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNicRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadNicsById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadNicsByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNicWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNicRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNic(ctx context.Context, id string, body UpdateNicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNicRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkNicWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkNicRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkNic(ctx context.Context, id string, body LinkNicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkNicRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkNic(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkNicRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkPrivateIpsWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkPrivateIpsRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkPrivateIps(ctx context.Context, id string, body LinkPrivateIpsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkPrivateIpsRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkPrivateIpsWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkPrivateIpsRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkPrivateIps(ctx context.Context, id string, body UnlinkPrivateIpsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkPrivateIpsRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadProductTypes(ctx context.Context, params *ReadProductTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadProductTypesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadProductTypesById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadProductTypesByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadPublicIpRangesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadPublicIpRangesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadPublicIpRanges(ctx context.Context, body ReadPublicIpRangesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadPublicIpRangesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadPublicIpRangesById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadPublicIpRangesByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadPublicIps(ctx context.Context, params *ReadPublicIpsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadPublicIpsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePublicIpWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePublicIpRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePublicIp(ctx context.Context, body CreatePublicIpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePublicIpRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePublicIpWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePublicIpRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePublicIp(ctx context.Context, id string, body DeletePublicIpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePublicIpRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadPublicIpsById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadPublicIpsByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkPublicIpWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkPublicIpRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkPublicIp(ctx context.Context, id string, body LinkPublicIpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkPublicIpRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkPublicIpWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkPublicIpRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkPublicIp(ctx context.Context, id string, body UnlinkPublicIpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkPublicIpRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RebootVmsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRebootVmsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RebootVms(ctx context.Context, body RebootVmsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRebootVmsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RejectNetPeeringWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRejectNetPeeringRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RejectNetPeering(ctx context.Context, body RejectNetPeeringJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRejectNetPeeringRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRoutePropagationWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRoutePropagationRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRoutePropagation(ctx context.Context, id string, body UpdateRoutePropagationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRoutePropagationRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadRouteTables(ctx context.Context, params *ReadRouteTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadRouteTablesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRouteTableWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRouteTableRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRouteTable(ctx context.Context, body CreateRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRouteTableRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRouteTable(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRouteTableRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadRouteTablesById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadRouteTablesByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkRouteTableWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkRouteTableRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkRouteTable(ctx context.Context, id string, body LinkRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkRouteTableRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkRouteTable(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkRouteTableRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRouteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRouteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRoute(ctx context.Context, body CreateRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRouteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRouteWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRouteRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRoute(ctx context.Context, id string, body DeleteRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRouteRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRouteWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRouteRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRoute(ctx context.Context, id string, body UpdateRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRouteRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSecurityGroupRuleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSecurityGroupRuleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSecurityGroupRule(ctx context.Context, body CreateSecurityGroupRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSecurityGroupRuleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSecurityGroupRuleWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSecurityGroupRuleRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSecurityGroupRule(ctx context.Context, id string, body DeleteSecurityGroupRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSecurityGroupRuleRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadSecurityGroups(ctx context.Context, params *ReadSecurityGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadSecurityGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSecurityGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSecurityGroupRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSecurityGroup(ctx context.Context, body CreateSecurityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSecurityGroupRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSecurityGroupWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSecurityGroupRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSecurityGroup(ctx context.Context, id string, body DeleteSecurityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSecurityGroupRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadSecurityGroupsById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadSecurityGroupsByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadSnapshots(ctx context.Context, params *ReadSnapshotsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadSnapshotsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSnapshotWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSnapshotRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSnapshot(ctx context.Context, body CreateSnapshotJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSnapshotRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSnapshot(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSnapshotRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadSnapshotsById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadSnapshotsByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartVmsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartVmsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartVms(ctx context.Context, body StartVmsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartVmsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopVmsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopVmsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopVms(ctx context.Context, body StopVmsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopVmsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadSubnets(ctx context.Context, params *ReadSubnetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadSubnetsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSubnetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSubnetRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSubnet(ctx context.Context, body CreateSubnetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSubnetRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSubnet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSubnetRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadSubnetsById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadSubnetsByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSubnetWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSubnetRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSubnet(ctx context.Context, id string, body UpdateSubnetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSubnetRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadTags(ctx context.Context, params *ReadTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadTagsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTagsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTagsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTags(ctx context.Context, body CreateTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTagsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTagsWithBody(ctx context.Context, id []interface{}, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTagsRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTags(ctx context.Context, id []interface{}, body DeleteTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTagsRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadTagsById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadTagsByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVirtualGateways(ctx context.Context, params *ReadVirtualGatewaysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVirtualGatewaysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVirtualGatewayWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVirtualGatewayRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVirtualGateway(ctx context.Context, body CreateVirtualGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVirtualGatewayRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVirtualGateway(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVirtualGatewayRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVirtualGatewaysById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVirtualGatewaysByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkVirtualGatewayWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkVirtualGatewayRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkVirtualGateway(ctx context.Context, id string, body LinkVirtualGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkVirtualGatewayRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkVirtualGatewayWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkVirtualGatewayRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkVirtualGateway(ctx context.Context, id string, body UnlinkVirtualGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkVirtualGatewayRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVms(ctx context.Context, params *ReadVmsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVmsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVmsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVmsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVms(ctx context.Context, body CreateVmsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVmsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVms(ctx context.Context, id []interface{}, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVmsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVmsById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVmsByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVmWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVmRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVm(ctx context.Context, id string, body UpdateVmJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVmRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVmsHealthWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVmsHealthRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVmsHealth(ctx context.Context, body ReadVmsHealthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVmsHealthRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVmsHealthById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVmsHealthByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVmsState(ctx context.Context, params *ReadVmsStateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVmsStateRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVmsStateById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVmsStateByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVolumes(ctx context.Context, params *ReadVolumesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVolumesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVolumeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVolumeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVolume(ctx context.Context, body CreateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVolumeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVolume(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVolumeRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVolumesById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVolumesByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVolumeWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVolumeRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVolume(ctx context.Context, id string, body UpdateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVolumeRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkVolumeWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkVolumeRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkVolume(ctx context.Context, id string, body LinkVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkVolumeRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkVolumeWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkVolumeRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkVolume(ctx context.Context, id string, body UnlinkVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkVolumeRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVpnConnectionRouteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVpnConnectionRouteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVpnConnectionRoute(ctx context.Context, body CreateVpnConnectionRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVpnConnectionRouteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVpnConnectionRouteWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVpnConnectionRouteRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVpnConnectionRoute(ctx context.Context, id string, body DeleteVpnConnectionRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVpnConnectionRouteRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVpnConnections(ctx context.Context, params *ReadVpnConnectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVpnConnectionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVpnConnectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVpnConnectionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVpnConnection(ctx context.Context, body CreateVpnConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVpnConnectionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVpnConnection(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVpnConnectionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadVpnConnectionsById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadVpnConnectionsByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVpnConnectionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVpnConnectionRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVpnConnection(ctx context.Context, id string, body UpdateVpnConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVpnConnectionRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewAcceptNetPeeringRequest calls the generic AcceptNetPeering builder with application/json body
func NewAcceptNetPeeringRequest(server string, body AcceptNetPeeringJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAcceptNetPeeringRequestWithBody(server, "application/json", bodyReader)
}

// NewAcceptNetPeeringRequestWithBody generates requests for AcceptNetPeering with any type of body
func NewAcceptNetPeeringRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/acceptNetPeering")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadAdminPasswordRequest calls the generic ReadAdminPassword builder with application/json body
func NewReadAdminPasswordRequest(server string, body ReadAdminPasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReadAdminPasswordRequestWithBody(server, "application/json", bodyReader)
}

// NewReadAdminPasswordRequestWithBody generates requests for ReadAdminPassword with any type of body
func NewReadAdminPasswordRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/adminPasswords")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadAdminPasswordByIdRequest generates requests for ReadAdminPasswordById
func NewReadAdminPasswordByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/adminPasswords/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadClientGatewaysRequest generates requests for ReadClientGateways
func NewReadClientGatewaysRequest(server string, params *ReadClientGatewaysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clientGateways")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BgpAsns != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bgpAsns", runtime.ParamLocationQuery, *params.BgpAsns); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClientGatewayIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "clientGatewayIds", runtime.ParamLocationQuery, *params.ClientGatewayIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ConnectionTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "connectionTypes", runtime.ParamLocationQuery, *params.ConnectionTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PublicIps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "publicIps", runtime.ParamLocationQuery, *params.PublicIps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateClientGatewayRequest calls the generic CreateClientGateway builder with application/json body
func NewCreateClientGatewayRequest(server string, body CreateClientGatewayJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateClientGatewayRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateClientGatewayRequestWithBody generates requests for CreateClientGateway with any type of body
func NewCreateClientGatewayRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clientGateways")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteClientGatewayRequest generates requests for DeleteClientGateway
func NewDeleteClientGatewayRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clientGateways/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadClientGatewaysByIdRequest generates requests for ReadClientGatewaysById
func NewReadClientGatewaysByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clientGateways/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadConsoleOutputRequest calls the generic ReadConsoleOutput builder with application/json body
func NewReadConsoleOutputRequest(server string, body ReadConsoleOutputJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReadConsoleOutputRequestWithBody(server, "application/json", bodyReader)
}

// NewReadConsoleOutputRequestWithBody generates requests for ReadConsoleOutput with any type of body
func NewReadConsoleOutputRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/consoleOutputs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadConsoleOutputByIdRequest generates requests for ReadConsoleOutputById
func NewReadConsoleOutputByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/consoleOutputs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadDhcpOptionsRequest generates requests for ReadDhcpOptions
func NewReadDhcpOptionsRequest(server string, params *ReadDhcpOptionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dhcpOptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Default != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "default", runtime.ParamLocationQuery, *params.Default); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DhcpOptionsSetIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dhcpOptionsSetIds", runtime.ParamLocationQuery, *params.DhcpOptionsSetIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DomainNameServers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domainNameServers", runtime.ParamLocationQuery, *params.DomainNameServers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DomainNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domainNames", runtime.ParamLocationQuery, *params.DomainNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LogServers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "logServers", runtime.ParamLocationQuery, *params.LogServers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NtpServers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ntpServers", runtime.ParamLocationQuery, *params.NtpServers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDhcpOptionsRequest calls the generic CreateDhcpOptions builder with application/json body
func NewCreateDhcpOptionsRequest(server string, body CreateDhcpOptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDhcpOptionsRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDhcpOptionsRequestWithBody generates requests for CreateDhcpOptions with any type of body
func NewCreateDhcpOptionsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dhcpOptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDhcpOptionsRequest generates requests for DeleteDhcpOptions
func NewDeleteDhcpOptionsRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dhcpOptions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadDhcpOptionsByIdRequest generates requests for ReadDhcpOptionsById
func NewReadDhcpOptionsByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dhcpOptions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadDirectLinkInterfacesRequest generates requests for ReadDirectLinkInterfaces
func NewReadDirectLinkInterfacesRequest(server string, params *ReadDirectLinkInterfacesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/directLinkInterfaces")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DirectLinkIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "directLinkIds", runtime.ParamLocationQuery, *params.DirectLinkIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DirectLinkInterfaceIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "directLinkInterfaceIds", runtime.ParamLocationQuery, *params.DirectLinkInterfaceIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDirectLinkInterfaceRequest calls the generic CreateDirectLinkInterface builder with application/json body
func NewCreateDirectLinkInterfaceRequest(server string, body CreateDirectLinkInterfaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDirectLinkInterfaceRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDirectLinkInterfaceRequestWithBody generates requests for CreateDirectLinkInterface with any type of body
func NewCreateDirectLinkInterfaceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/directLinkInterfaces")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDirectLinkInterfaceRequest generates requests for DeleteDirectLinkInterface
func NewDeleteDirectLinkInterfaceRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/directLinkInterfaces/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadDirectLinkInterfacesByIdRequest generates requests for ReadDirectLinkInterfacesById
func NewReadDirectLinkInterfacesByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/directLinkInterfaces/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDirectLinkInterfaceRequest calls the generic UpdateDirectLinkInterface builder with application/json body
func NewUpdateDirectLinkInterfaceRequest(server string, id string, body UpdateDirectLinkInterfaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDirectLinkInterfaceRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateDirectLinkInterfaceRequestWithBody generates requests for UpdateDirectLinkInterface with any type of body
func NewUpdateDirectLinkInterfaceRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/directLinkInterfaces/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadDirectLinksRequest generates requests for ReadDirectLinks
func NewReadDirectLinksRequest(server string, params *ReadDirectLinksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/directLinks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DirectLinkIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "directLinkIds", runtime.ParamLocationQuery, *params.DirectLinkIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDirectLinkRequest calls the generic CreateDirectLink builder with application/json body
func NewCreateDirectLinkRequest(server string, body CreateDirectLinkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDirectLinkRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDirectLinkRequestWithBody generates requests for CreateDirectLink with any type of body
func NewCreateDirectLinkRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/directLinks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDirectLinkRequest generates requests for DeleteDirectLink
func NewDeleteDirectLinkRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/directLinks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadDirectLinksByIdRequest generates requests for ReadDirectLinksById
func NewReadDirectLinksByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/directLinks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadFlexibleGpuCatalogRequest calls the generic ReadFlexibleGpuCatalog builder with application/json body
func NewReadFlexibleGpuCatalogRequest(server string, body ReadFlexibleGpuCatalogJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReadFlexibleGpuCatalogRequestWithBody(server, "application/json", bodyReader)
}

// NewReadFlexibleGpuCatalogRequestWithBody generates requests for ReadFlexibleGpuCatalog with any type of body
func NewReadFlexibleGpuCatalogRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flexibleGpuCatalogs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadFlexibleGpuCatalogByIdRequest generates requests for ReadFlexibleGpuCatalogById
func NewReadFlexibleGpuCatalogByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flexibleGpuCatalogs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadFlexibleGpusRequest generates requests for ReadFlexibleGpus
func NewReadFlexibleGpusRequest(server string, params *ReadFlexibleGpusParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flexibleGpus")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DeleteOnVmDeletion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleteOnVmDeletion", runtime.ParamLocationQuery, *params.DeleteOnVmDeletion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FlexibleGpuIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "flexibleGpuIds", runtime.ParamLocationQuery, *params.FlexibleGpuIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Generations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "generations", runtime.ParamLocationQuery, *params.Generations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModelNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modelNames", runtime.ParamLocationQuery, *params.ModelNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubregionNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subregionNames", runtime.ParamLocationQuery, *params.SubregionNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VmIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vmIds", runtime.ParamLocationQuery, *params.VmIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFlexibleGpuRequest calls the generic CreateFlexibleGpu builder with application/json body
func NewCreateFlexibleGpuRequest(server string, body CreateFlexibleGpuJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFlexibleGpuRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateFlexibleGpuRequestWithBody generates requests for CreateFlexibleGpu with any type of body
func NewCreateFlexibleGpuRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flexibleGpus")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFlexibleGpuRequest generates requests for DeleteFlexibleGpu
func NewDeleteFlexibleGpuRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flexibleGpus/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadFlexibleGpusByIdRequest generates requests for ReadFlexibleGpusById
func NewReadFlexibleGpusByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flexibleGpus/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateFlexibleGpuRequest calls the generic UpdateFlexibleGpu builder with application/json body
func NewUpdateFlexibleGpuRequest(server string, id string, body UpdateFlexibleGpuJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateFlexibleGpuRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateFlexibleGpuRequestWithBody generates requests for UpdateFlexibleGpu with any type of body
func NewUpdateFlexibleGpuRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flexibleGpus/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLinkFlexibleGpuRequest calls the generic LinkFlexibleGpu builder with application/json body
func NewLinkFlexibleGpuRequest(server string, id string, body LinkFlexibleGpuJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkFlexibleGpuRequestWithBody(server, id, "application/json", bodyReader)
}

// NewLinkFlexibleGpuRequestWithBody generates requests for LinkFlexibleGpu with any type of body
func NewLinkFlexibleGpuRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flexibleGpus/%s/link", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnlinkFlexibleGpuRequest generates requests for UnlinkFlexibleGpu
func NewUnlinkFlexibleGpuRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flexibleGpus/%s/unlink", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadImagesRequest generates requests for ReadImages
func NewReadImagesRequest(server string, params *ReadImagesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/images")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AccountAliases != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accountAliases", runtime.ParamLocationQuery, *params.AccountAliases); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AccountIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accountIds", runtime.ParamLocationQuery, *params.AccountIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Architectures != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "architectures", runtime.ParamLocationQuery, *params.Architectures); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BlockDeviceMappingDeleteOnVmDeletion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blockDeviceMappingDeleteOnVmDeletion", runtime.ParamLocationQuery, *params.BlockDeviceMappingDeleteOnVmDeletion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BlockDeviceMappingDeviceNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blockDeviceMappingDeviceNames", runtime.ParamLocationQuery, *params.BlockDeviceMappingDeviceNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BlockDeviceMappingSnapshotIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blockDeviceMappingSnapshotIds", runtime.ParamLocationQuery, *params.BlockDeviceMappingSnapshotIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BlockDeviceMappingVolumeSizes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blockDeviceMappingVolumeSizes", runtime.ParamLocationQuery, *params.BlockDeviceMappingVolumeSizes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BlockDeviceMappingVolumeTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blockDeviceMappingVolumeTypes", runtime.ParamLocationQuery, *params.BlockDeviceMappingVolumeTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Descriptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "descriptions", runtime.ParamLocationQuery, *params.Descriptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FileLocations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fileLocations", runtime.ParamLocationQuery, *params.FileLocations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Hypervisors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hypervisors", runtime.ParamLocationQuery, *params.Hypervisors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageIds", runtime.ParamLocationQuery, *params.ImageIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageNames", runtime.ParamLocationQuery, *params.ImageNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PermissionsToLaunchAccountIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "permissionsToLaunchAccountIds", runtime.ParamLocationQuery, *params.PermissionsToLaunchAccountIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PermissionsToLaunchGlobalPermission != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "permissionsToLaunchGlobalPermission", runtime.ParamLocationQuery, *params.PermissionsToLaunchGlobalPermission); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProductCodes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "productCodes", runtime.ParamLocationQuery, *params.ProductCodes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RootDeviceNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rootDeviceNames", runtime.ParamLocationQuery, *params.RootDeviceNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RootDeviceTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rootDeviceTypes", runtime.ParamLocationQuery, *params.RootDeviceTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VirtualizationTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "virtualizationTypes", runtime.ParamLocationQuery, *params.VirtualizationTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateImageRequest calls the generic CreateImage builder with application/json body
func NewCreateImageRequest(server string, body CreateImageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateImageRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateImageRequestWithBody generates requests for CreateImage with any type of body
func NewCreateImageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/images")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteImageRequest generates requests for DeleteImage
func NewDeleteImageRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/images/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadImagesByIdRequest generates requests for ReadImagesById
func NewReadImagesByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/images/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateImageRequest calls the generic UpdateImage builder with application/json body
func NewUpdateImageRequest(server string, id string, body UpdateImageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateImageRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateImageRequestWithBody generates requests for UpdateImage with any type of body
func NewUpdateImageRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/images/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadInternetServicesRequest generates requests for ReadInternetServices
func NewReadInternetServicesRequest(server string, params *ReadInternetServicesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internetServices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.InternetServiceIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "internetServiceIds", runtime.ParamLocationQuery, *params.InternetServiceIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkNetIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkNetIds", runtime.ParamLocationQuery, *params.LinkNetIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkStates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkStates", runtime.ParamLocationQuery, *params.LinkStates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateInternetServiceRequest calls the generic CreateInternetService builder with application/json body
func NewCreateInternetServiceRequest(server string, body CreateInternetServiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateInternetServiceRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateInternetServiceRequestWithBody generates requests for CreateInternetService with any type of body
func NewCreateInternetServiceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internetServices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteInternetServiceRequest generates requests for DeleteInternetService
func NewDeleteInternetServiceRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internetServices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadInternetServicesByIdRequest generates requests for ReadInternetServicesById
func NewReadInternetServicesByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internetServices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLinkInternetServiceRequest calls the generic LinkInternetService builder with application/json body
func NewLinkInternetServiceRequest(server string, id string, body LinkInternetServiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkInternetServiceRequestWithBody(server, id, "application/json", bodyReader)
}

// NewLinkInternetServiceRequestWithBody generates requests for LinkInternetService with any type of body
func NewLinkInternetServiceRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internetServices/%s/link", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnlinkInternetServiceRequest calls the generic UnlinkInternetService builder with application/json body
func NewUnlinkInternetServiceRequest(server string, id string, body UnlinkInternetServiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnlinkInternetServiceRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUnlinkInternetServiceRequestWithBody generates requests for UnlinkInternetService with any type of body
func NewUnlinkInternetServiceRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internetServices/%s/unlink", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadKeypairsRequest generates requests for ReadKeypairs
func NewReadKeypairsRequest(server string, params *ReadKeypairsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keypairs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.KeypairFingerprints != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keypairFingerprints", runtime.ParamLocationQuery, *params.KeypairFingerprints); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.KeypairNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keypairNames", runtime.ParamLocationQuery, *params.KeypairNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateKeypairRequest calls the generic CreateKeypair builder with application/json body
func NewCreateKeypairRequest(server string, body CreateKeypairJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateKeypairRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateKeypairRequestWithBody generates requests for CreateKeypair with any type of body
func NewCreateKeypairRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keypairs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteKeypairRequest generates requests for DeleteKeypair
func NewDeleteKeypairRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keypairs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadKeypairsByIdRequest generates requests for ReadKeypairsById
func NewReadKeypairsByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keypairs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadListenerRulesRequest generates requests for ReadListenerRules
func NewReadListenerRulesRequest(server string, params *ReadListenerRulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/listenerRules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ListenerRuleNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "listenerRuleNames", runtime.ParamLocationQuery, *params.ListenerRuleNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateListenerRuleRequest calls the generic CreateListenerRule builder with application/json body
func NewCreateListenerRuleRequest(server string, body CreateListenerRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateListenerRuleRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateListenerRuleRequestWithBody generates requests for CreateListenerRule with any type of body
func NewCreateListenerRuleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/listenerRules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteListenerRuleRequest generates requests for DeleteListenerRule
func NewDeleteListenerRuleRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/listenerRules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadListenerRulesByIdRequest generates requests for ReadListenerRulesById
func NewReadListenerRulesByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/listenerRules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateListenerRuleRequest calls the generic UpdateListenerRule builder with application/json body
func NewUpdateListenerRuleRequest(server string, id string, body UpdateListenerRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateListenerRuleRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateListenerRuleRequestWithBody generates requests for UpdateListenerRule with any type of body
func NewUpdateListenerRuleRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/listenerRules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLinkLoadBalancerBackendMachinesRequest calls the generic LinkLoadBalancerBackendMachines builder with application/json body
func NewLinkLoadBalancerBackendMachinesRequest(server string, id string, body LinkLoadBalancerBackendMachinesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkLoadBalancerBackendMachinesRequestWithBody(server, id, "application/json", bodyReader)
}

// NewLinkLoadBalancerBackendMachinesRequestWithBody generates requests for LinkLoadBalancerBackendMachines with any type of body
func NewLinkLoadBalancerBackendMachinesRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/loadBalancerBackendMachines/%s/link", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnlinkLoadBalancerBackendMachinesRequest calls the generic UnlinkLoadBalancerBackendMachines builder with application/json body
func NewUnlinkLoadBalancerBackendMachinesRequest(server string, id string, body UnlinkLoadBalancerBackendMachinesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnlinkLoadBalancerBackendMachinesRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUnlinkLoadBalancerBackendMachinesRequestWithBody generates requests for UnlinkLoadBalancerBackendMachines with any type of body
func NewUnlinkLoadBalancerBackendMachinesRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/loadBalancerBackendMachines/%s/unlink", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateLoadBalancerListenersRequest calls the generic CreateLoadBalancerListeners builder with application/json body
func NewCreateLoadBalancerListenersRequest(server string, body CreateLoadBalancerListenersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLoadBalancerListenersRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateLoadBalancerListenersRequestWithBody generates requests for CreateLoadBalancerListeners with any type of body
func NewCreateLoadBalancerListenersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/loadBalancerListeners")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLoadBalancerListenersRequest calls the generic DeleteLoadBalancerListeners builder with application/json body
func NewDeleteLoadBalancerListenersRequest(server string, id string, body DeleteLoadBalancerListenersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteLoadBalancerListenersRequestWithBody(server, id, "application/json", bodyReader)
}

// NewDeleteLoadBalancerListenersRequestWithBody generates requests for DeleteLoadBalancerListeners with any type of body
func NewDeleteLoadBalancerListenersRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/loadBalancerListeners/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateLoadBalancerPolicyRequest calls the generic CreateLoadBalancerPolicy builder with application/json body
func NewCreateLoadBalancerPolicyRequest(server string, body CreateLoadBalancerPolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLoadBalancerPolicyRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateLoadBalancerPolicyRequestWithBody generates requests for CreateLoadBalancerPolicy with any type of body
func NewCreateLoadBalancerPolicyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/loadBalancerPolicies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLoadBalancerPolicyRequest calls the generic DeleteLoadBalancerPolicy builder with application/json body
func NewDeleteLoadBalancerPolicyRequest(server string, id string, body DeleteLoadBalancerPolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteLoadBalancerPolicyRequestWithBody(server, id, "application/json", bodyReader)
}

// NewDeleteLoadBalancerPolicyRequestWithBody generates requests for DeleteLoadBalancerPolicy with any type of body
func NewDeleteLoadBalancerPolicyRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/loadBalancerPolicies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadLoadBalancerTagsRequest calls the generic ReadLoadBalancerTags builder with application/json body
func NewReadLoadBalancerTagsRequest(server string, body ReadLoadBalancerTagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReadLoadBalancerTagsRequestWithBody(server, "application/json", bodyReader)
}

// NewReadLoadBalancerTagsRequestWithBody generates requests for ReadLoadBalancerTags with any type of body
func NewReadLoadBalancerTagsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/loadBalancerTags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateLoadBalancerTagsRequest calls the generic CreateLoadBalancerTags builder with application/json body
func NewCreateLoadBalancerTagsRequest(server string, body CreateLoadBalancerTagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLoadBalancerTagsRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateLoadBalancerTagsRequestWithBody generates requests for CreateLoadBalancerTags with any type of body
func NewCreateLoadBalancerTagsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/loadBalancerTags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLoadBalancerTagsRequest calls the generic DeleteLoadBalancerTags builder with application/json body
func NewDeleteLoadBalancerTagsRequest(server string, id []interface{}, body DeleteLoadBalancerTagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteLoadBalancerTagsRequestWithBody(server, id, "application/json", bodyReader)
}

// NewDeleteLoadBalancerTagsRequestWithBody generates requests for DeleteLoadBalancerTags with any type of body
func NewDeleteLoadBalancerTagsRequestWithBody(server string, id []interface{}, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/loadBalancerTags/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadLoadBalancerTagsByIdRequest generates requests for ReadLoadBalancerTagsById
func NewReadLoadBalancerTagsByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/loadBalancerTags/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadLoadBalancersRequest generates requests for ReadLoadBalancers
func NewReadLoadBalancersRequest(server string, params *ReadLoadBalancersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/loadBalancers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LoadBalancerNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "loadBalancerNames", runtime.ParamLocationQuery, *params.LoadBalancerNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateLoadBalancerRequest calls the generic CreateLoadBalancer builder with application/json body
func NewCreateLoadBalancerRequest(server string, body CreateLoadBalancerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLoadBalancerRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateLoadBalancerRequestWithBody generates requests for CreateLoadBalancer with any type of body
func NewCreateLoadBalancerRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/loadBalancers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLoadBalancerRequest generates requests for DeleteLoadBalancer
func NewDeleteLoadBalancerRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/loadBalancers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadLoadBalancersByIdRequest generates requests for ReadLoadBalancersById
func NewReadLoadBalancersByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/loadBalancers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateLoadBalancerRequest calls the generic UpdateLoadBalancer builder with application/json body
func NewUpdateLoadBalancerRequest(server string, id string, body UpdateLoadBalancerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateLoadBalancerRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateLoadBalancerRequestWithBody generates requests for UpdateLoadBalancer with any type of body
func NewUpdateLoadBalancerRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/loadBalancers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadLocationsRequest calls the generic ReadLocations builder with application/json body
func NewReadLocationsRequest(server string, body ReadLocationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReadLocationsRequestWithBody(server, "application/json", bodyReader)
}

// NewReadLocationsRequestWithBody generates requests for ReadLocations with any type of body
func NewReadLocationsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/locations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadLocationsByIdRequest generates requests for ReadLocationsById
func NewReadLocationsByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/locations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadNatServicesRequest generates requests for ReadNatServices
func NewReadNatServicesRequest(server string, params *ReadNatServicesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/natServices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NatServiceIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "natServiceIds", runtime.ParamLocationQuery, *params.NatServiceIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NetIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "netIds", runtime.ParamLocationQuery, *params.NetIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubnetIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subnetIds", runtime.ParamLocationQuery, *params.SubnetIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNatServiceRequest calls the generic CreateNatService builder with application/json body
func NewCreateNatServiceRequest(server string, body CreateNatServiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNatServiceRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateNatServiceRequestWithBody generates requests for CreateNatService with any type of body
func NewCreateNatServiceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/natServices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteNatServiceRequest generates requests for DeleteNatService
func NewDeleteNatServiceRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/natServices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadNatServicesByIdRequest generates requests for ReadNatServicesById
func NewReadNatServicesByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/natServices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadNetAccessPointsRequest generates requests for ReadNetAccessPoints
func NewReadNetAccessPointsRequest(server string, params *ReadNetAccessPointsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/netAccessPoints")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NetAccessPointIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "netAccessPointIds", runtime.ParamLocationQuery, *params.NetAccessPointIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NetIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "netIds", runtime.ParamLocationQuery, *params.NetIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ServiceNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "serviceNames", runtime.ParamLocationQuery, *params.ServiceNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNetAccessPointRequest calls the generic CreateNetAccessPoint builder with application/json body
func NewCreateNetAccessPointRequest(server string, body CreateNetAccessPointJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNetAccessPointRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateNetAccessPointRequestWithBody generates requests for CreateNetAccessPoint with any type of body
func NewCreateNetAccessPointRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/netAccessPoints")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteNetAccessPointRequest generates requests for DeleteNetAccessPoint
func NewDeleteNetAccessPointRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/netAccessPoints/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadNetAccessPointsByIdRequest generates requests for ReadNetAccessPointsById
func NewReadNetAccessPointsByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/netAccessPoints/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateNetAccessPointRequest calls the generic UpdateNetAccessPoint builder with application/json body
func NewUpdateNetAccessPointRequest(server string, id string, body UpdateNetAccessPointJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateNetAccessPointRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateNetAccessPointRequestWithBody generates requests for UpdateNetAccessPoint with any type of body
func NewUpdateNetAccessPointRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/netAccessPoints/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadNetPeeringsRequest generates requests for ReadNetPeerings
func NewReadNetPeeringsRequest(server string, params *ReadNetPeeringsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/netPeerings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AccepterNetAccountIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accepterNetAccountIds", runtime.ParamLocationQuery, *params.AccepterNetAccountIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AccepterNetIpRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accepterNetIpRanges", runtime.ParamLocationQuery, *params.AccepterNetIpRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AccepterNetNetIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accepterNetNetIds", runtime.ParamLocationQuery, *params.AccepterNetNetIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NetPeeringIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "netPeeringIds", runtime.ParamLocationQuery, *params.NetPeeringIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SourceNetAccountIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sourceNetAccountIds", runtime.ParamLocationQuery, *params.SourceNetAccountIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SourceNetIpRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sourceNetIpRanges", runtime.ParamLocationQuery, *params.SourceNetIpRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SourceNetNetIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sourceNetNetIds", runtime.ParamLocationQuery, *params.SourceNetNetIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StateMessages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stateMessages", runtime.ParamLocationQuery, *params.StateMessages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StateNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stateNames", runtime.ParamLocationQuery, *params.StateNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNetPeeringRequest calls the generic CreateNetPeering builder with application/json body
func NewCreateNetPeeringRequest(server string, body CreateNetPeeringJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNetPeeringRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateNetPeeringRequestWithBody generates requests for CreateNetPeering with any type of body
func NewCreateNetPeeringRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/netPeerings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteNetPeeringRequest generates requests for DeleteNetPeering
func NewDeleteNetPeeringRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/netPeerings/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadNetPeeringsByIdRequest generates requests for ReadNetPeeringsById
func NewReadNetPeeringsByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/netPeerings/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadNetsRequest generates requests for ReadNets
func NewReadNetsRequest(server string, params *ReadNetsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/nets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DhcpOptionsSetIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dhcpOptionsSetIds", runtime.ParamLocationQuery, *params.DhcpOptionsSetIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IpRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ipRanges", runtime.ParamLocationQuery, *params.IpRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsDefault != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isDefault", runtime.ParamLocationQuery, *params.IsDefault); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NetIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "netIds", runtime.ParamLocationQuery, *params.NetIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNetRequest calls the generic CreateNet builder with application/json body
func NewCreateNetRequest(server string, body CreateNetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNetRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateNetRequestWithBody generates requests for CreateNet with any type of body
func NewCreateNetRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/nets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteNetRequest generates requests for DeleteNet
func NewDeleteNetRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/nets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadNetsByIdRequest generates requests for ReadNetsById
func NewReadNetsByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/nets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateNetRequest calls the generic UpdateNet builder with application/json body
func NewUpdateNetRequest(server string, id string, body UpdateNetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateNetRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateNetRequestWithBody generates requests for UpdateNet with any type of body
func NewUpdateNetRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/nets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadNicsRequest generates requests for ReadNics
func NewReadNicsRequest(server string, params *ReadNicsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/nics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Descriptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "descriptions", runtime.ParamLocationQuery, *params.Descriptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsSourceDestCheck != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isSourceDestCheck", runtime.ParamLocationQuery, *params.IsSourceDestCheck); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkNicDeleteOnVmDeletion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkNicDeleteOnVmDeletion", runtime.ParamLocationQuery, *params.LinkNicDeleteOnVmDeletion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkNicDeviceNumbers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkNicDeviceNumbers", runtime.ParamLocationQuery, *params.LinkNicDeviceNumbers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkNicLinkNicIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkNicLinkNicIds", runtime.ParamLocationQuery, *params.LinkNicLinkNicIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkNicStates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkNicStates", runtime.ParamLocationQuery, *params.LinkNicStates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkNicVmAccountIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkNicVmAccountIds", runtime.ParamLocationQuery, *params.LinkNicVmAccountIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkNicVmIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkNicVmIds", runtime.ParamLocationQuery, *params.LinkNicVmIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkPublicIpAccountIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkPublicIpAccountIds", runtime.ParamLocationQuery, *params.LinkPublicIpAccountIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkPublicIpLinkPublicIpIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkPublicIpLinkPublicIpIds", runtime.ParamLocationQuery, *params.LinkPublicIpLinkPublicIpIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkPublicIpPublicIpIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkPublicIpPublicIpIds", runtime.ParamLocationQuery, *params.LinkPublicIpPublicIpIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkPublicIpPublicIps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkPublicIpPublicIps", runtime.ParamLocationQuery, *params.LinkPublicIpPublicIps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MacAddresses != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "macAddresses", runtime.ParamLocationQuery, *params.MacAddresses); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NetIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "netIds", runtime.ParamLocationQuery, *params.NetIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicIds", runtime.ParamLocationQuery, *params.NicIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrivateDnsNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "privateDnsNames", runtime.ParamLocationQuery, *params.PrivateDnsNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrivateIpsLinkPublicIpPublicIps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "privateIpsLinkPublicIpPublicIps", runtime.ParamLocationQuery, *params.PrivateIpsLinkPublicIpPublicIps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrivateIpsPrimaryIp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "privateIpsPrimaryIp", runtime.ParamLocationQuery, *params.PrivateIpsPrimaryIp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrivateIpsPrivateIps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "privateIpsPrivateIps", runtime.ParamLocationQuery, *params.PrivateIpsPrivateIps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SecurityGroupIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "securityGroupIds", runtime.ParamLocationQuery, *params.SecurityGroupIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SecurityGroupNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "securityGroupNames", runtime.ParamLocationQuery, *params.SecurityGroupNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubnetIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subnetIds", runtime.ParamLocationQuery, *params.SubnetIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubregionNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subregionNames", runtime.ParamLocationQuery, *params.SubregionNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNicRequest calls the generic CreateNic builder with application/json body
func NewCreateNicRequest(server string, body CreateNicJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNicRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateNicRequestWithBody generates requests for CreateNic with any type of body
func NewCreateNicRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/nics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteNicRequest generates requests for DeleteNic
func NewDeleteNicRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/nics/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadNicsByIdRequest generates requests for ReadNicsById
func NewReadNicsByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/nics/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateNicRequest calls the generic UpdateNic builder with application/json body
func NewUpdateNicRequest(server string, id string, body UpdateNicJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateNicRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateNicRequestWithBody generates requests for UpdateNic with any type of body
func NewUpdateNicRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/nics/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLinkNicRequest calls the generic LinkNic builder with application/json body
func NewLinkNicRequest(server string, id string, body LinkNicJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkNicRequestWithBody(server, id, "application/json", bodyReader)
}

// NewLinkNicRequestWithBody generates requests for LinkNic with any type of body
func NewLinkNicRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/nics/%s/link", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnlinkNicRequest generates requests for UnlinkNic
func NewUnlinkNicRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/nics/%s/unlink", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLinkPrivateIpsRequest calls the generic LinkPrivateIps builder with application/json body
func NewLinkPrivateIpsRequest(server string, id string, body LinkPrivateIpsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkPrivateIpsRequestWithBody(server, id, "application/json", bodyReader)
}

// NewLinkPrivateIpsRequestWithBody generates requests for LinkPrivateIps with any type of body
func NewLinkPrivateIpsRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/privateIps/%s/link", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnlinkPrivateIpsRequest calls the generic UnlinkPrivateIps builder with application/json body
func NewUnlinkPrivateIpsRequest(server string, id string, body UnlinkPrivateIpsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnlinkPrivateIpsRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUnlinkPrivateIpsRequestWithBody generates requests for UnlinkPrivateIps with any type of body
func NewUnlinkPrivateIpsRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/privateIps/%s/unlink", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadProductTypesRequest generates requests for ReadProductTypes
func NewReadProductTypesRequest(server string, params *ReadProductTypesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/productTypes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProductTypeIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "productTypeIds", runtime.ParamLocationQuery, *params.ProductTypeIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadProductTypesByIdRequest generates requests for ReadProductTypesById
func NewReadProductTypesByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/productTypes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadPublicIpRangesRequest calls the generic ReadPublicIpRanges builder with application/json body
func NewReadPublicIpRangesRequest(server string, body ReadPublicIpRangesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReadPublicIpRangesRequestWithBody(server, "application/json", bodyReader)
}

// NewReadPublicIpRangesRequestWithBody generates requests for ReadPublicIpRanges with any type of body
func NewReadPublicIpRangesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/publicIpRanges")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadPublicIpRangesByIdRequest generates requests for ReadPublicIpRangesById
func NewReadPublicIpRangesByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/publicIpRanges/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadPublicIpsRequest generates requests for ReadPublicIps
func NewReadPublicIpsRequest(server string, params *ReadPublicIpsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/publicIps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LinkPublicIpIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkPublicIpIds", runtime.ParamLocationQuery, *params.LinkPublicIpIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NicIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nicIds", runtime.ParamLocationQuery, *params.NicIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrivateIps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "privateIps", runtime.ParamLocationQuery, *params.PrivateIps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PublicIpIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "publicIpIds", runtime.ParamLocationQuery, *params.PublicIpIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PublicIps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "publicIps", runtime.ParamLocationQuery, *params.PublicIps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VmIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vmIds", runtime.ParamLocationQuery, *params.VmIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePublicIpRequest calls the generic CreatePublicIp builder with application/json body
func NewCreatePublicIpRequest(server string, body CreatePublicIpJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePublicIpRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePublicIpRequestWithBody generates requests for CreatePublicIp with any type of body
func NewCreatePublicIpRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/publicIps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePublicIpRequest calls the generic DeletePublicIp builder with application/json body
func NewDeletePublicIpRequest(server string, id string, body DeletePublicIpJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeletePublicIpRequestWithBody(server, id, "application/json", bodyReader)
}

// NewDeletePublicIpRequestWithBody generates requests for DeletePublicIp with any type of body
func NewDeletePublicIpRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/publicIps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadPublicIpsByIdRequest generates requests for ReadPublicIpsById
func NewReadPublicIpsByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/publicIps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLinkPublicIpRequest calls the generic LinkPublicIp builder with application/json body
func NewLinkPublicIpRequest(server string, id string, body LinkPublicIpJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkPublicIpRequestWithBody(server, id, "application/json", bodyReader)
}

// NewLinkPublicIpRequestWithBody generates requests for LinkPublicIp with any type of body
func NewLinkPublicIpRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/publicIps/%s/link", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnlinkPublicIpRequest calls the generic UnlinkPublicIp builder with application/json body
func NewUnlinkPublicIpRequest(server string, id string, body UnlinkPublicIpJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnlinkPublicIpRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUnlinkPublicIpRequestWithBody generates requests for UnlinkPublicIp with any type of body
func NewUnlinkPublicIpRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/publicIps/%s/unlink", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRebootVmsRequest calls the generic RebootVms builder with application/json body
func NewRebootVmsRequest(server string, body RebootVmsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRebootVmsRequestWithBody(server, "application/json", bodyReader)
}

// NewRebootVmsRequestWithBody generates requests for RebootVms with any type of body
func NewRebootVmsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rebootVms")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRejectNetPeeringRequest calls the generic RejectNetPeering builder with application/json body
func NewRejectNetPeeringRequest(server string, body RejectNetPeeringJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRejectNetPeeringRequestWithBody(server, "application/json", bodyReader)
}

// NewRejectNetPeeringRequestWithBody generates requests for RejectNetPeering with any type of body
func NewRejectNetPeeringRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rejectNetPeering")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateRoutePropagationRequest calls the generic UpdateRoutePropagation builder with application/json body
func NewUpdateRoutePropagationRequest(server string, id string, body UpdateRoutePropagationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRoutePropagationRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateRoutePropagationRequestWithBody generates requests for UpdateRoutePropagation with any type of body
func NewUpdateRoutePropagationRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/routePropagations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadRouteTablesRequest generates requests for ReadRouteTables
func NewReadRouteTablesRequest(server string, params *ReadRouteTablesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/routeTables")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LinkRouteTableIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkRouteTableIds", runtime.ParamLocationQuery, *params.LinkRouteTableIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkRouteTableLinkRouteTableIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkRouteTableLinkRouteTableIds", runtime.ParamLocationQuery, *params.LinkRouteTableLinkRouteTableIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkRouteTableMain != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkRouteTableMain", runtime.ParamLocationQuery, *params.LinkRouteTableMain); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkSubnetIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkSubnetIds", runtime.ParamLocationQuery, *params.LinkSubnetIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NetIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "netIds", runtime.ParamLocationQuery, *params.NetIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RouteCreationMethods != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "routeCreationMethods", runtime.ParamLocationQuery, *params.RouteCreationMethods); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RouteDestinationIpRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "routeDestinationIpRanges", runtime.ParamLocationQuery, *params.RouteDestinationIpRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RouteDestinationServiceIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "routeDestinationServiceIds", runtime.ParamLocationQuery, *params.RouteDestinationServiceIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RouteGatewayIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "routeGatewayIds", runtime.ParamLocationQuery, *params.RouteGatewayIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RouteNatServiceIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "routeNatServiceIds", runtime.ParamLocationQuery, *params.RouteNatServiceIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RouteNetPeeringIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "routeNetPeeringIds", runtime.ParamLocationQuery, *params.RouteNetPeeringIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RouteStates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "routeStates", runtime.ParamLocationQuery, *params.RouteStates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RouteTableIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "routeTableIds", runtime.ParamLocationQuery, *params.RouteTableIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RouteVmIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "routeVmIds", runtime.ParamLocationQuery, *params.RouteVmIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRouteTableRequest calls the generic CreateRouteTable builder with application/json body
func NewCreateRouteTableRequest(server string, body CreateRouteTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRouteTableRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateRouteTableRequestWithBody generates requests for CreateRouteTable with any type of body
func NewCreateRouteTableRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/routeTables")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRouteTableRequest generates requests for DeleteRouteTable
func NewDeleteRouteTableRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/routeTables/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadRouteTablesByIdRequest generates requests for ReadRouteTablesById
func NewReadRouteTablesByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/routeTables/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLinkRouteTableRequest calls the generic LinkRouteTable builder with application/json body
func NewLinkRouteTableRequest(server string, id string, body LinkRouteTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkRouteTableRequestWithBody(server, id, "application/json", bodyReader)
}

// NewLinkRouteTableRequestWithBody generates requests for LinkRouteTable with any type of body
func NewLinkRouteTableRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/routeTables/%s/link", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnlinkRouteTableRequest generates requests for UnlinkRouteTable
func NewUnlinkRouteTableRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/routeTables/%s/unlink", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRouteRequest calls the generic CreateRoute builder with application/json body
func NewCreateRouteRequest(server string, body CreateRouteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRouteRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateRouteRequestWithBody generates requests for CreateRoute with any type of body
func NewCreateRouteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/routes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRouteRequest calls the generic DeleteRoute builder with application/json body
func NewDeleteRouteRequest(server string, id string, body DeleteRouteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteRouteRequestWithBody(server, id, "application/json", bodyReader)
}

// NewDeleteRouteRequestWithBody generates requests for DeleteRoute with any type of body
func NewDeleteRouteRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/routes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateRouteRequest calls the generic UpdateRoute builder with application/json body
func NewUpdateRouteRequest(server string, id string, body UpdateRouteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRouteRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateRouteRequestWithBody generates requests for UpdateRoute with any type of body
func NewUpdateRouteRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/routes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateSecurityGroupRuleRequest calls the generic CreateSecurityGroupRule builder with application/json body
func NewCreateSecurityGroupRuleRequest(server string, body CreateSecurityGroupRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSecurityGroupRuleRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateSecurityGroupRuleRequestWithBody generates requests for CreateSecurityGroupRule with any type of body
func NewCreateSecurityGroupRuleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/securityGroupRules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSecurityGroupRuleRequest calls the generic DeleteSecurityGroupRule builder with application/json body
func NewDeleteSecurityGroupRuleRequest(server string, id string, body DeleteSecurityGroupRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteSecurityGroupRuleRequestWithBody(server, id, "application/json", bodyReader)
}

// NewDeleteSecurityGroupRuleRequestWithBody generates requests for DeleteSecurityGroupRule with any type of body
func NewDeleteSecurityGroupRuleRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/securityGroupRules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadSecurityGroupsRequest generates requests for ReadSecurityGroups
func NewReadSecurityGroupsRequest(server string, params *ReadSecurityGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/securityGroups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Descriptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "descriptions", runtime.ParamLocationQuery, *params.Descriptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InboundRuleAccountIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inboundRuleAccountIds", runtime.ParamLocationQuery, *params.InboundRuleAccountIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InboundRuleFromPortRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inboundRuleFromPortRanges", runtime.ParamLocationQuery, *params.InboundRuleFromPortRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InboundRuleIpRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inboundRuleIpRanges", runtime.ParamLocationQuery, *params.InboundRuleIpRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InboundRuleProtocols != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inboundRuleProtocols", runtime.ParamLocationQuery, *params.InboundRuleProtocols); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InboundRuleSecurityGroupIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inboundRuleSecurityGroupIds", runtime.ParamLocationQuery, *params.InboundRuleSecurityGroupIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InboundRuleSecurityGroupNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inboundRuleSecurityGroupNames", runtime.ParamLocationQuery, *params.InboundRuleSecurityGroupNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InboundRuleToPortRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inboundRuleToPortRanges", runtime.ParamLocationQuery, *params.InboundRuleToPortRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NetIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "netIds", runtime.ParamLocationQuery, *params.NetIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OutboundRuleAccountIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outboundRuleAccountIds", runtime.ParamLocationQuery, *params.OutboundRuleAccountIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OutboundRuleFromPortRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outboundRuleFromPortRanges", runtime.ParamLocationQuery, *params.OutboundRuleFromPortRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OutboundRuleIpRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outboundRuleIpRanges", runtime.ParamLocationQuery, *params.OutboundRuleIpRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OutboundRuleProtocols != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outboundRuleProtocols", runtime.ParamLocationQuery, *params.OutboundRuleProtocols); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OutboundRuleSecurityGroupIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outboundRuleSecurityGroupIds", runtime.ParamLocationQuery, *params.OutboundRuleSecurityGroupIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OutboundRuleSecurityGroupNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outboundRuleSecurityGroupNames", runtime.ParamLocationQuery, *params.OutboundRuleSecurityGroupNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OutboundRuleToPortRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outboundRuleToPortRanges", runtime.ParamLocationQuery, *params.OutboundRuleToPortRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SecurityGroupIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "securityGroupIds", runtime.ParamLocationQuery, *params.SecurityGroupIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SecurityGroupNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "securityGroupNames", runtime.ParamLocationQuery, *params.SecurityGroupNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSecurityGroupRequest calls the generic CreateSecurityGroup builder with application/json body
func NewCreateSecurityGroupRequest(server string, body CreateSecurityGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSecurityGroupRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateSecurityGroupRequestWithBody generates requests for CreateSecurityGroup with any type of body
func NewCreateSecurityGroupRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/securityGroups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSecurityGroupRequest calls the generic DeleteSecurityGroup builder with application/json body
func NewDeleteSecurityGroupRequest(server string, id string, body DeleteSecurityGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteSecurityGroupRequestWithBody(server, id, "application/json", bodyReader)
}

// NewDeleteSecurityGroupRequestWithBody generates requests for DeleteSecurityGroup with any type of body
func NewDeleteSecurityGroupRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/securityGroups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadSecurityGroupsByIdRequest generates requests for ReadSecurityGroupsById
func NewReadSecurityGroupsByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/securityGroups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadSnapshotsRequest generates requests for ReadSnapshots
func NewReadSnapshotsRequest(server string, params *ReadSnapshotsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/snapshots")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Descriptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "descriptions", runtime.ParamLocationQuery, *params.Descriptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FromCreationDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fromCreationDate", runtime.ParamLocationQuery, *params.FromCreationDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PermissionsToCreateVolumeGlobalPermission != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "permissionsToCreateVolumeGlobalPermission", runtime.ParamLocationQuery, *params.PermissionsToCreateVolumeGlobalPermission); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Progresses != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "progresses", runtime.ParamLocationQuery, *params.Progresses); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SnapshotIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "snapshotIds", runtime.ParamLocationQuery, *params.SnapshotIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToCreationDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "toCreationDate", runtime.ParamLocationQuery, *params.ToCreationDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VolumeIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "volumeIds", runtime.ParamLocationQuery, *params.VolumeIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VolumeSizes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "volumeSizes", runtime.ParamLocationQuery, *params.VolumeSizes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSnapshotRequest calls the generic CreateSnapshot builder with application/json body
func NewCreateSnapshotRequest(server string, body CreateSnapshotJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSnapshotRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateSnapshotRequestWithBody generates requests for CreateSnapshot with any type of body
func NewCreateSnapshotRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/snapshots")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSnapshotRequest generates requests for DeleteSnapshot
func NewDeleteSnapshotRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/snapshots/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadSnapshotsByIdRequest generates requests for ReadSnapshotsById
func NewReadSnapshotsByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/snapshots/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartVmsRequest calls the generic StartVms builder with application/json body
func NewStartVmsRequest(server string, body StartVmsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartVmsRequestWithBody(server, "application/json", bodyReader)
}

// NewStartVmsRequestWithBody generates requests for StartVms with any type of body
func NewStartVmsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/startVms")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStopVmsRequest calls the generic StopVms builder with application/json body
func NewStopVmsRequest(server string, body StopVmsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStopVmsRequestWithBody(server, "application/json", bodyReader)
}

// NewStopVmsRequestWithBody generates requests for StopVms with any type of body
func NewStopVmsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stopVms")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadSubnetsRequest generates requests for ReadSubnets
func NewReadSubnetsRequest(server string, params *ReadSubnetsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/subnets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AvailableIpsCounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "availableIpsCounts", runtime.ParamLocationQuery, *params.AvailableIpsCounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IpRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ipRanges", runtime.ParamLocationQuery, *params.IpRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NetIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "netIds", runtime.ParamLocationQuery, *params.NetIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubnetIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subnetIds", runtime.ParamLocationQuery, *params.SubnetIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubregionNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subregionNames", runtime.ParamLocationQuery, *params.SubregionNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSubnetRequest calls the generic CreateSubnet builder with application/json body
func NewCreateSubnetRequest(server string, body CreateSubnetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSubnetRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateSubnetRequestWithBody generates requests for CreateSubnet with any type of body
func NewCreateSubnetRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/subnets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSubnetRequest generates requests for DeleteSubnet
func NewDeleteSubnetRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/subnets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadSubnetsByIdRequest generates requests for ReadSubnetsById
func NewReadSubnetsByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/subnets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSubnetRequest calls the generic UpdateSubnet builder with application/json body
func NewUpdateSubnetRequest(server string, id string, body UpdateSubnetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSubnetRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateSubnetRequestWithBody generates requests for UpdateSubnet with any type of body
func NewUpdateSubnetRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/subnets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadTagsRequest generates requests for ReadTags
func NewReadTagsRequest(server string, params *ReadTagsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Keys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keys", runtime.ParamLocationQuery, *params.Keys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResourceIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resourceIds", runtime.ParamLocationQuery, *params.ResourceIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResourceTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resourceTypes", runtime.ParamLocationQuery, *params.ResourceTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Values != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "values", runtime.ParamLocationQuery, *params.Values); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTagsRequest calls the generic CreateTags builder with application/json body
func NewCreateTagsRequest(server string, body CreateTagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTagsRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateTagsRequestWithBody generates requests for CreateTags with any type of body
func NewCreateTagsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTagsRequest calls the generic DeleteTags builder with application/json body
func NewDeleteTagsRequest(server string, id []interface{}, body DeleteTagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteTagsRequestWithBody(server, id, "application/json", bodyReader)
}

// NewDeleteTagsRequestWithBody generates requests for DeleteTags with any type of body
func NewDeleteTagsRequestWithBody(server string, id []interface{}, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadTagsByIdRequest generates requests for ReadTagsById
func NewReadTagsByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadVirtualGatewaysRequest generates requests for ReadVirtualGateways
func NewReadVirtualGatewaysRequest(server string, params *ReadVirtualGatewaysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/virtualGateways")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ConnectionTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "connectionTypes", runtime.ParamLocationQuery, *params.ConnectionTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkNetIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkNetIds", runtime.ParamLocationQuery, *params.LinkNetIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkStates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkStates", runtime.ParamLocationQuery, *params.LinkStates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VirtualGatewayIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "virtualGatewayIds", runtime.ParamLocationQuery, *params.VirtualGatewayIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVirtualGatewayRequest calls the generic CreateVirtualGateway builder with application/json body
func NewCreateVirtualGatewayRequest(server string, body CreateVirtualGatewayJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVirtualGatewayRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateVirtualGatewayRequestWithBody generates requests for CreateVirtualGateway with any type of body
func NewCreateVirtualGatewayRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/virtualGateways")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVirtualGatewayRequest generates requests for DeleteVirtualGateway
func NewDeleteVirtualGatewayRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/virtualGateways/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadVirtualGatewaysByIdRequest generates requests for ReadVirtualGatewaysById
func NewReadVirtualGatewaysByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/virtualGateways/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLinkVirtualGatewayRequest calls the generic LinkVirtualGateway builder with application/json body
func NewLinkVirtualGatewayRequest(server string, id string, body LinkVirtualGatewayJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkVirtualGatewayRequestWithBody(server, id, "application/json", bodyReader)
}

// NewLinkVirtualGatewayRequestWithBody generates requests for LinkVirtualGateway with any type of body
func NewLinkVirtualGatewayRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/virtualGateways/%s/link", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnlinkVirtualGatewayRequest calls the generic UnlinkVirtualGateway builder with application/json body
func NewUnlinkVirtualGatewayRequest(server string, id string, body UnlinkVirtualGatewayJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnlinkVirtualGatewayRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUnlinkVirtualGatewayRequestWithBody generates requests for UnlinkVirtualGateway with any type of body
func NewUnlinkVirtualGatewayRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/virtualGateways/%s/unlink", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadVmsRequest generates requests for ReadVms
func NewReadVmsRequest(server string, params *ReadVmsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vms")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VmIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vmIds", runtime.ParamLocationQuery, *params.VmIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVmsRequest calls the generic CreateVms builder with application/json body
func NewCreateVmsRequest(server string, body CreateVmsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVmsRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateVmsRequestWithBody generates requests for CreateVms with any type of body
func NewCreateVmsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vms")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVmsRequest generates requests for DeleteVms
func NewDeleteVmsRequest(server string, id []interface{}) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vms/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadVmsByIdRequest generates requests for ReadVmsById
func NewReadVmsByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vms/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVmRequest calls the generic UpdateVm builder with application/json body
func NewUpdateVmRequest(server string, id string, body UpdateVmJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVmRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateVmRequestWithBody generates requests for UpdateVm with any type of body
func NewUpdateVmRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vms/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadVmsHealthRequest calls the generic ReadVmsHealth builder with application/json body
func NewReadVmsHealthRequest(server string, body ReadVmsHealthJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReadVmsHealthRequestWithBody(server, "application/json", bodyReader)
}

// NewReadVmsHealthRequestWithBody generates requests for ReadVmsHealth with any type of body
func NewReadVmsHealthRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vmsHealths")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadVmsHealthByIdRequest generates requests for ReadVmsHealthById
func NewReadVmsHealthByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vmsHealths/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadVmsStateRequest generates requests for ReadVmsState
func NewReadVmsStateRequest(server string, params *ReadVmsStateParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vmsStates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MaintenanceEventCodes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maintenanceEventCodes", runtime.ParamLocationQuery, *params.MaintenanceEventCodes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaintenanceEventDescriptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maintenanceEventDescriptions", runtime.ParamLocationQuery, *params.MaintenanceEventDescriptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaintenanceEventsNotAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maintenanceEventsNotAfter", runtime.ParamLocationQuery, *params.MaintenanceEventsNotAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaintenanceEventsNotBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maintenanceEventsNotBefore", runtime.ParamLocationQuery, *params.MaintenanceEventsNotBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubregionNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subregionNames", runtime.ParamLocationQuery, *params.SubregionNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VmIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vmIds", runtime.ParamLocationQuery, *params.VmIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VmStates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vmStates", runtime.ParamLocationQuery, *params.VmStates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadVmsStateByIdRequest generates requests for ReadVmsStateById
func NewReadVmsStateByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vmsStates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadVolumesRequest generates requests for ReadVolumes
func NewReadVolumesRequest(server string, params *ReadVolumesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volumes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreationDates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "creationDates", runtime.ParamLocationQuery, *params.CreationDates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkVolumeDeleteOnVmDeletion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkVolumeDeleteOnVmDeletion", runtime.ParamLocationQuery, *params.LinkVolumeDeleteOnVmDeletion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkVolumeDeviceNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkVolumeDeviceNames", runtime.ParamLocationQuery, *params.LinkVolumeDeviceNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkVolumeLinkDates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkVolumeLinkDates", runtime.ParamLocationQuery, *params.LinkVolumeLinkDates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkVolumeLinkStates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkVolumeLinkStates", runtime.ParamLocationQuery, *params.LinkVolumeLinkStates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkVolumeVmIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkVolumeVmIds", runtime.ParamLocationQuery, *params.LinkVolumeVmIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SnapshotIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "snapshotIds", runtime.ParamLocationQuery, *params.SnapshotIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubregionNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subregionNames", runtime.ParamLocationQuery, *params.SubregionNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VolumeIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "volumeIds", runtime.ParamLocationQuery, *params.VolumeIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VolumeSizes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "volumeSizes", runtime.ParamLocationQuery, *params.VolumeSizes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VolumeStates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "volumeStates", runtime.ParamLocationQuery, *params.VolumeStates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VolumeTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "volumeTypes", runtime.ParamLocationQuery, *params.VolumeTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVolumeRequest calls the generic CreateVolume builder with application/json body
func NewCreateVolumeRequest(server string, body CreateVolumeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVolumeRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateVolumeRequestWithBody generates requests for CreateVolume with any type of body
func NewCreateVolumeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volumes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVolumeRequest generates requests for DeleteVolume
func NewDeleteVolumeRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volumes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadVolumesByIdRequest generates requests for ReadVolumesById
func NewReadVolumesByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volumes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVolumeRequest calls the generic UpdateVolume builder with application/json body
func NewUpdateVolumeRequest(server string, id string, body UpdateVolumeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVolumeRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateVolumeRequestWithBody generates requests for UpdateVolume with any type of body
func NewUpdateVolumeRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volumes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLinkVolumeRequest calls the generic LinkVolume builder with application/json body
func NewLinkVolumeRequest(server string, id string, body LinkVolumeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkVolumeRequestWithBody(server, id, "application/json", bodyReader)
}

// NewLinkVolumeRequestWithBody generates requests for LinkVolume with any type of body
func NewLinkVolumeRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volumes/%s/link", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnlinkVolumeRequest calls the generic UnlinkVolume builder with application/json body
func NewUnlinkVolumeRequest(server string, id string, body UnlinkVolumeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnlinkVolumeRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUnlinkVolumeRequestWithBody generates requests for UnlinkVolume with any type of body
func NewUnlinkVolumeRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volumes/%s/unlink", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateVpnConnectionRouteRequest calls the generic CreateVpnConnectionRoute builder with application/json body
func NewCreateVpnConnectionRouteRequest(server string, body CreateVpnConnectionRouteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVpnConnectionRouteRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateVpnConnectionRouteRequestWithBody generates requests for CreateVpnConnectionRoute with any type of body
func NewCreateVpnConnectionRouteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vpnConnectionRoutes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVpnConnectionRouteRequest calls the generic DeleteVpnConnectionRoute builder with application/json body
func NewDeleteVpnConnectionRouteRequest(server string, id string, body DeleteVpnConnectionRouteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteVpnConnectionRouteRequestWithBody(server, id, "application/json", bodyReader)
}

// NewDeleteVpnConnectionRouteRequestWithBody generates requests for DeleteVpnConnectionRoute with any type of body
func NewDeleteVpnConnectionRouteRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vpnConnectionRoutes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadVpnConnectionsRequest generates requests for ReadVpnConnections
func NewReadVpnConnectionsRequest(server string, params *ReadVpnConnectionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vpnConnections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BgpAsns != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bgpAsns", runtime.ParamLocationQuery, *params.BgpAsns); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClientGatewayIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "clientGatewayIds", runtime.ParamLocationQuery, *params.ClientGatewayIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ConnectionTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "connectionTypes", runtime.ParamLocationQuery, *params.ConnectionTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RouteDestinationIpRanges != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "routeDestinationIpRanges", runtime.ParamLocationQuery, *params.RouteDestinationIpRanges); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.States != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "states", runtime.ParamLocationQuery, *params.States); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StaticRoutesOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "staticRoutesOnly", runtime.ParamLocationQuery, *params.StaticRoutesOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagKeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagKeys", runtime.ParamLocationQuery, *params.TagKeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagValues != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tagValues", runtime.ParamLocationQuery, *params.TagValues); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VirtualGatewayIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "virtualGatewayIds", runtime.ParamLocationQuery, *params.VirtualGatewayIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VpnConnectionIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vpnConnectionIds", runtime.ParamLocationQuery, *params.VpnConnectionIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVpnConnectionRequest calls the generic CreateVpnConnection builder with application/json body
func NewCreateVpnConnectionRequest(server string, body CreateVpnConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVpnConnectionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateVpnConnectionRequestWithBody generates requests for CreateVpnConnection with any type of body
func NewCreateVpnConnectionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vpnConnections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVpnConnectionRequest generates requests for DeleteVpnConnection
func NewDeleteVpnConnectionRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vpnConnections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadVpnConnectionsByIdRequest generates requests for ReadVpnConnectionsById
func NewReadVpnConnectionsByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vpnConnections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVpnConnectionRequest calls the generic UpdateVpnConnection builder with application/json body
func NewUpdateVpnConnectionRequest(server string, id string, body UpdateVpnConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVpnConnectionRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateVpnConnectionRequestWithBody generates requests for UpdateVpnConnection with any type of body
func NewUpdateVpnConnectionRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vpnConnections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// AcceptNetPeeringWithBodyWithResponse request with any body
	AcceptNetPeeringWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AcceptNetPeeringResponse, error)

	AcceptNetPeeringWithResponse(ctx context.Context, body AcceptNetPeeringJSONRequestBody, reqEditors ...RequestEditorFn) (*AcceptNetPeeringResponse, error)

	// ReadAdminPasswordWithBodyWithResponse request with any body
	ReadAdminPasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReadAdminPasswordResponse, error)

	ReadAdminPasswordWithResponse(ctx context.Context, body ReadAdminPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*ReadAdminPasswordResponse, error)

	// ReadAdminPasswordByIdWithResponse request
	ReadAdminPasswordByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadAdminPasswordByIdResponse, error)

	// ReadClientGatewaysWithResponse request
	ReadClientGatewaysWithResponse(ctx context.Context, params *ReadClientGatewaysParams, reqEditors ...RequestEditorFn) (*ReadClientGatewaysResponse, error)

	// CreateClientGatewayWithBodyWithResponse request with any body
	CreateClientGatewayWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientGatewayResponse, error)

	CreateClientGatewayWithResponse(ctx context.Context, body CreateClientGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientGatewayResponse, error)

	// DeleteClientGatewayWithResponse request
	DeleteClientGatewayWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteClientGatewayResponse, error)

	// ReadClientGatewaysByIdWithResponse request
	ReadClientGatewaysByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadClientGatewaysByIdResponse, error)

	// ReadConsoleOutputWithBodyWithResponse request with any body
	ReadConsoleOutputWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReadConsoleOutputResponse, error)

	ReadConsoleOutputWithResponse(ctx context.Context, body ReadConsoleOutputJSONRequestBody, reqEditors ...RequestEditorFn) (*ReadConsoleOutputResponse, error)

	// ReadConsoleOutputByIdWithResponse request
	ReadConsoleOutputByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadConsoleOutputByIdResponse, error)

	// ReadDhcpOptionsWithResponse request
	ReadDhcpOptionsWithResponse(ctx context.Context, params *ReadDhcpOptionsParams, reqEditors ...RequestEditorFn) (*ReadDhcpOptionsResponse, error)

	// CreateDhcpOptionsWithBodyWithResponse request with any body
	CreateDhcpOptionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDhcpOptionsResponse, error)

	CreateDhcpOptionsWithResponse(ctx context.Context, body CreateDhcpOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDhcpOptionsResponse, error)

	// DeleteDhcpOptionsWithResponse request
	DeleteDhcpOptionsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteDhcpOptionsResponse, error)

	// ReadDhcpOptionsByIdWithResponse request
	ReadDhcpOptionsByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadDhcpOptionsByIdResponse, error)

	// ReadDirectLinkInterfacesWithResponse request
	ReadDirectLinkInterfacesWithResponse(ctx context.Context, params *ReadDirectLinkInterfacesParams, reqEditors ...RequestEditorFn) (*ReadDirectLinkInterfacesResponse, error)

	// CreateDirectLinkInterfaceWithBodyWithResponse request with any body
	CreateDirectLinkInterfaceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDirectLinkInterfaceResponse, error)

	CreateDirectLinkInterfaceWithResponse(ctx context.Context, body CreateDirectLinkInterfaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDirectLinkInterfaceResponse, error)

	// DeleteDirectLinkInterfaceWithResponse request
	DeleteDirectLinkInterfaceWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteDirectLinkInterfaceResponse, error)

	// ReadDirectLinkInterfacesByIdWithResponse request
	ReadDirectLinkInterfacesByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadDirectLinkInterfacesByIdResponse, error)

	// UpdateDirectLinkInterfaceWithBodyWithResponse request with any body
	UpdateDirectLinkInterfaceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDirectLinkInterfaceResponse, error)

	UpdateDirectLinkInterfaceWithResponse(ctx context.Context, id string, body UpdateDirectLinkInterfaceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDirectLinkInterfaceResponse, error)

	// ReadDirectLinksWithResponse request
	ReadDirectLinksWithResponse(ctx context.Context, params *ReadDirectLinksParams, reqEditors ...RequestEditorFn) (*ReadDirectLinksResponse, error)

	// CreateDirectLinkWithBodyWithResponse request with any body
	CreateDirectLinkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDirectLinkResponse, error)

	CreateDirectLinkWithResponse(ctx context.Context, body CreateDirectLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDirectLinkResponse, error)

	// DeleteDirectLinkWithResponse request
	DeleteDirectLinkWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteDirectLinkResponse, error)

	// ReadDirectLinksByIdWithResponse request
	ReadDirectLinksByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadDirectLinksByIdResponse, error)

	// ReadFlexibleGpuCatalogWithBodyWithResponse request with any body
	ReadFlexibleGpuCatalogWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReadFlexibleGpuCatalogResponse, error)

	ReadFlexibleGpuCatalogWithResponse(ctx context.Context, body ReadFlexibleGpuCatalogJSONRequestBody, reqEditors ...RequestEditorFn) (*ReadFlexibleGpuCatalogResponse, error)

	// ReadFlexibleGpuCatalogByIdWithResponse request
	ReadFlexibleGpuCatalogByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadFlexibleGpuCatalogByIdResponse, error)

	// ReadFlexibleGpusWithResponse request
	ReadFlexibleGpusWithResponse(ctx context.Context, params *ReadFlexibleGpusParams, reqEditors ...RequestEditorFn) (*ReadFlexibleGpusResponse, error)

	// CreateFlexibleGpuWithBodyWithResponse request with any body
	CreateFlexibleGpuWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFlexibleGpuResponse, error)

	CreateFlexibleGpuWithResponse(ctx context.Context, body CreateFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFlexibleGpuResponse, error)

	// DeleteFlexibleGpuWithResponse request
	DeleteFlexibleGpuWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteFlexibleGpuResponse, error)

	// ReadFlexibleGpusByIdWithResponse request
	ReadFlexibleGpusByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadFlexibleGpusByIdResponse, error)

	// UpdateFlexibleGpuWithBodyWithResponse request with any body
	UpdateFlexibleGpuWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFlexibleGpuResponse, error)

	UpdateFlexibleGpuWithResponse(ctx context.Context, id string, body UpdateFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFlexibleGpuResponse, error)

	// LinkFlexibleGpuWithBodyWithResponse request with any body
	LinkFlexibleGpuWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkFlexibleGpuResponse, error)

	LinkFlexibleGpuWithResponse(ctx context.Context, id string, body LinkFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkFlexibleGpuResponse, error)

	// UnlinkFlexibleGpuWithResponse request
	UnlinkFlexibleGpuWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*UnlinkFlexibleGpuResponse, error)

	// ReadImagesWithResponse request
	ReadImagesWithResponse(ctx context.Context, params *ReadImagesParams, reqEditors ...RequestEditorFn) (*ReadImagesResponse, error)

	// CreateImageWithBodyWithResponse request with any body
	CreateImageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateImageResponse, error)

	CreateImageWithResponse(ctx context.Context, body CreateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateImageResponse, error)

	// DeleteImageWithResponse request
	DeleteImageWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteImageResponse, error)

	// ReadImagesByIdWithResponse request
	ReadImagesByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadImagesByIdResponse, error)

	// UpdateImageWithBodyWithResponse request with any body
	UpdateImageWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateImageResponse, error)

	UpdateImageWithResponse(ctx context.Context, id string, body UpdateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateImageResponse, error)

	// ReadInternetServicesWithResponse request
	ReadInternetServicesWithResponse(ctx context.Context, params *ReadInternetServicesParams, reqEditors ...RequestEditorFn) (*ReadInternetServicesResponse, error)

	// CreateInternetServiceWithBodyWithResponse request with any body
	CreateInternetServiceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateInternetServiceResponse, error)

	CreateInternetServiceWithResponse(ctx context.Context, body CreateInternetServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateInternetServiceResponse, error)

	// DeleteInternetServiceWithResponse request
	DeleteInternetServiceWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteInternetServiceResponse, error)

	// ReadInternetServicesByIdWithResponse request
	ReadInternetServicesByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadInternetServicesByIdResponse, error)

	// LinkInternetServiceWithBodyWithResponse request with any body
	LinkInternetServiceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkInternetServiceResponse, error)

	LinkInternetServiceWithResponse(ctx context.Context, id string, body LinkInternetServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkInternetServiceResponse, error)

	// UnlinkInternetServiceWithBodyWithResponse request with any body
	UnlinkInternetServiceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkInternetServiceResponse, error)

	UnlinkInternetServiceWithResponse(ctx context.Context, id string, body UnlinkInternetServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkInternetServiceResponse, error)

	// ReadKeypairsWithResponse request
	ReadKeypairsWithResponse(ctx context.Context, params *ReadKeypairsParams, reqEditors ...RequestEditorFn) (*ReadKeypairsResponse, error)

	// CreateKeypairWithBodyWithResponse request with any body
	CreateKeypairWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeypairResponse, error)

	CreateKeypairWithResponse(ctx context.Context, body CreateKeypairJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeypairResponse, error)

	// DeleteKeypairWithResponse request
	DeleteKeypairWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteKeypairResponse, error)

	// ReadKeypairsByIdWithResponse request
	ReadKeypairsByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadKeypairsByIdResponse, error)

	// ReadListenerRulesWithResponse request
	ReadListenerRulesWithResponse(ctx context.Context, params *ReadListenerRulesParams, reqEditors ...RequestEditorFn) (*ReadListenerRulesResponse, error)

	// CreateListenerRuleWithBodyWithResponse request with any body
	CreateListenerRuleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateListenerRuleResponse, error)

	CreateListenerRuleWithResponse(ctx context.Context, body CreateListenerRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateListenerRuleResponse, error)

	// DeleteListenerRuleWithResponse request
	DeleteListenerRuleWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteListenerRuleResponse, error)

	// ReadListenerRulesByIdWithResponse request
	ReadListenerRulesByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadListenerRulesByIdResponse, error)

	// UpdateListenerRuleWithBodyWithResponse request with any body
	UpdateListenerRuleWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateListenerRuleResponse, error)

	UpdateListenerRuleWithResponse(ctx context.Context, id string, body UpdateListenerRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateListenerRuleResponse, error)

	// LinkLoadBalancerBackendMachinesWithBodyWithResponse request with any body
	LinkLoadBalancerBackendMachinesWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkLoadBalancerBackendMachinesResponse, error)

	LinkLoadBalancerBackendMachinesWithResponse(ctx context.Context, id string, body LinkLoadBalancerBackendMachinesJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkLoadBalancerBackendMachinesResponse, error)

	// UnlinkLoadBalancerBackendMachinesWithBodyWithResponse request with any body
	UnlinkLoadBalancerBackendMachinesWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkLoadBalancerBackendMachinesResponse, error)

	UnlinkLoadBalancerBackendMachinesWithResponse(ctx context.Context, id string, body UnlinkLoadBalancerBackendMachinesJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkLoadBalancerBackendMachinesResponse, error)

	// CreateLoadBalancerListenersWithBodyWithResponse request with any body
	CreateLoadBalancerListenersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLoadBalancerListenersResponse, error)

	CreateLoadBalancerListenersWithResponse(ctx context.Context, body CreateLoadBalancerListenersJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLoadBalancerListenersResponse, error)

	// DeleteLoadBalancerListenersWithBodyWithResponse request with any body
	DeleteLoadBalancerListenersWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerListenersResponse, error)

	DeleteLoadBalancerListenersWithResponse(ctx context.Context, id string, body DeleteLoadBalancerListenersJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerListenersResponse, error)

	// CreateLoadBalancerPolicyWithBodyWithResponse request with any body
	CreateLoadBalancerPolicyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLoadBalancerPolicyResponse, error)

	CreateLoadBalancerPolicyWithResponse(ctx context.Context, body CreateLoadBalancerPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLoadBalancerPolicyResponse, error)

	// DeleteLoadBalancerPolicyWithBodyWithResponse request with any body
	DeleteLoadBalancerPolicyWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerPolicyResponse, error)

	DeleteLoadBalancerPolicyWithResponse(ctx context.Context, id string, body DeleteLoadBalancerPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerPolicyResponse, error)

	// ReadLoadBalancerTagsWithBodyWithResponse request with any body
	ReadLoadBalancerTagsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReadLoadBalancerTagsResponse, error)

	ReadLoadBalancerTagsWithResponse(ctx context.Context, body ReadLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReadLoadBalancerTagsResponse, error)

	// CreateLoadBalancerTagsWithBodyWithResponse request with any body
	CreateLoadBalancerTagsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLoadBalancerTagsResponse, error)

	CreateLoadBalancerTagsWithResponse(ctx context.Context, body CreateLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLoadBalancerTagsResponse, error)

	// DeleteLoadBalancerTagsWithBodyWithResponse request with any body
	DeleteLoadBalancerTagsWithBodyWithResponse(ctx context.Context, id []interface{}, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerTagsResponse, error)

	DeleteLoadBalancerTagsWithResponse(ctx context.Context, id []interface{}, body DeleteLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerTagsResponse, error)

	// ReadLoadBalancerTagsByIdWithResponse request
	ReadLoadBalancerTagsByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadLoadBalancerTagsByIdResponse, error)

	// ReadLoadBalancersWithResponse request
	ReadLoadBalancersWithResponse(ctx context.Context, params *ReadLoadBalancersParams, reqEditors ...RequestEditorFn) (*ReadLoadBalancersResponse, error)

	// CreateLoadBalancerWithBodyWithResponse request with any body
	CreateLoadBalancerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLoadBalancerResponse, error)

	CreateLoadBalancerWithResponse(ctx context.Context, body CreateLoadBalancerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLoadBalancerResponse, error)

	// DeleteLoadBalancerWithResponse request
	DeleteLoadBalancerWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerResponse, error)

	// ReadLoadBalancersByIdWithResponse request
	ReadLoadBalancersByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadLoadBalancersByIdResponse, error)

	// UpdateLoadBalancerWithBodyWithResponse request with any body
	UpdateLoadBalancerWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLoadBalancerResponse, error)

	UpdateLoadBalancerWithResponse(ctx context.Context, id string, body UpdateLoadBalancerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLoadBalancerResponse, error)

	// ReadLocationsWithBodyWithResponse request with any body
	ReadLocationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReadLocationsResponse, error)

	ReadLocationsWithResponse(ctx context.Context, body ReadLocationsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReadLocationsResponse, error)

	// ReadLocationsByIdWithResponse request
	ReadLocationsByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadLocationsByIdResponse, error)

	// ReadNatServicesWithResponse request
	ReadNatServicesWithResponse(ctx context.Context, params *ReadNatServicesParams, reqEditors ...RequestEditorFn) (*ReadNatServicesResponse, error)

	// CreateNatServiceWithBodyWithResponse request with any body
	CreateNatServiceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNatServiceResponse, error)

	CreateNatServiceWithResponse(ctx context.Context, body CreateNatServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNatServiceResponse, error)

	// DeleteNatServiceWithResponse request
	DeleteNatServiceWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteNatServiceResponse, error)

	// ReadNatServicesByIdWithResponse request
	ReadNatServicesByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadNatServicesByIdResponse, error)

	// ReadNetAccessPointsWithResponse request
	ReadNetAccessPointsWithResponse(ctx context.Context, params *ReadNetAccessPointsParams, reqEditors ...RequestEditorFn) (*ReadNetAccessPointsResponse, error)

	// CreateNetAccessPointWithBodyWithResponse request with any body
	CreateNetAccessPointWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNetAccessPointResponse, error)

	CreateNetAccessPointWithResponse(ctx context.Context, body CreateNetAccessPointJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNetAccessPointResponse, error)

	// DeleteNetAccessPointWithResponse request
	DeleteNetAccessPointWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteNetAccessPointResponse, error)

	// ReadNetAccessPointsByIdWithResponse request
	ReadNetAccessPointsByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadNetAccessPointsByIdResponse, error)

	// UpdateNetAccessPointWithBodyWithResponse request with any body
	UpdateNetAccessPointWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNetAccessPointResponse, error)

	UpdateNetAccessPointWithResponse(ctx context.Context, id string, body UpdateNetAccessPointJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNetAccessPointResponse, error)

	// ReadNetPeeringsWithResponse request
	ReadNetPeeringsWithResponse(ctx context.Context, params *ReadNetPeeringsParams, reqEditors ...RequestEditorFn) (*ReadNetPeeringsResponse, error)

	// CreateNetPeeringWithBodyWithResponse request with any body
	CreateNetPeeringWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNetPeeringResponse, error)

	CreateNetPeeringWithResponse(ctx context.Context, body CreateNetPeeringJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNetPeeringResponse, error)

	// DeleteNetPeeringWithResponse request
	DeleteNetPeeringWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteNetPeeringResponse, error)

	// ReadNetPeeringsByIdWithResponse request
	ReadNetPeeringsByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadNetPeeringsByIdResponse, error)

	// ReadNetsWithResponse request
	ReadNetsWithResponse(ctx context.Context, params *ReadNetsParams, reqEditors ...RequestEditorFn) (*ReadNetsResponse, error)

	// CreateNetWithBodyWithResponse request with any body
	CreateNetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNetResponse, error)

	CreateNetWithResponse(ctx context.Context, body CreateNetJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNetResponse, error)

	// DeleteNetWithResponse request
	DeleteNetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteNetResponse, error)

	// ReadNetsByIdWithResponse request
	ReadNetsByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadNetsByIdResponse, error)

	// UpdateNetWithBodyWithResponse request with any body
	UpdateNetWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNetResponse, error)

	UpdateNetWithResponse(ctx context.Context, id string, body UpdateNetJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNetResponse, error)

	// ReadNicsWithResponse request
	ReadNicsWithResponse(ctx context.Context, params *ReadNicsParams, reqEditors ...RequestEditorFn) (*ReadNicsResponse, error)

	// CreateNicWithBodyWithResponse request with any body
	CreateNicWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNicResponse, error)

	CreateNicWithResponse(ctx context.Context, body CreateNicJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNicResponse, error)

	// DeleteNicWithResponse request
	DeleteNicWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteNicResponse, error)

	// ReadNicsByIdWithResponse request
	ReadNicsByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadNicsByIdResponse, error)

	// UpdateNicWithBodyWithResponse request with any body
	UpdateNicWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNicResponse, error)

	UpdateNicWithResponse(ctx context.Context, id string, body UpdateNicJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNicResponse, error)

	// LinkNicWithBodyWithResponse request with any body
	LinkNicWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkNicResponse, error)

	LinkNicWithResponse(ctx context.Context, id string, body LinkNicJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkNicResponse, error)

	// UnlinkNicWithResponse request
	UnlinkNicWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*UnlinkNicResponse, error)

	// LinkPrivateIpsWithBodyWithResponse request with any body
	LinkPrivateIpsWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkPrivateIpsResponse, error)

	LinkPrivateIpsWithResponse(ctx context.Context, id string, body LinkPrivateIpsJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkPrivateIpsResponse, error)

	// UnlinkPrivateIpsWithBodyWithResponse request with any body
	UnlinkPrivateIpsWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkPrivateIpsResponse, error)

	UnlinkPrivateIpsWithResponse(ctx context.Context, id string, body UnlinkPrivateIpsJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkPrivateIpsResponse, error)

	// ReadProductTypesWithResponse request
	ReadProductTypesWithResponse(ctx context.Context, params *ReadProductTypesParams, reqEditors ...RequestEditorFn) (*ReadProductTypesResponse, error)

	// ReadProductTypesByIdWithResponse request
	ReadProductTypesByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadProductTypesByIdResponse, error)

	// ReadPublicIpRangesWithBodyWithResponse request with any body
	ReadPublicIpRangesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReadPublicIpRangesResponse, error)

	ReadPublicIpRangesWithResponse(ctx context.Context, body ReadPublicIpRangesJSONRequestBody, reqEditors ...RequestEditorFn) (*ReadPublicIpRangesResponse, error)

	// ReadPublicIpRangesByIdWithResponse request
	ReadPublicIpRangesByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadPublicIpRangesByIdResponse, error)

	// ReadPublicIpsWithResponse request
	ReadPublicIpsWithResponse(ctx context.Context, params *ReadPublicIpsParams, reqEditors ...RequestEditorFn) (*ReadPublicIpsResponse, error)

	// CreatePublicIpWithBodyWithResponse request with any body
	CreatePublicIpWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePublicIpResponse, error)

	CreatePublicIpWithResponse(ctx context.Context, body CreatePublicIpJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePublicIpResponse, error)

	// DeletePublicIpWithBodyWithResponse request with any body
	DeletePublicIpWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeletePublicIpResponse, error)

	DeletePublicIpWithResponse(ctx context.Context, id string, body DeletePublicIpJSONRequestBody, reqEditors ...RequestEditorFn) (*DeletePublicIpResponse, error)

	// ReadPublicIpsByIdWithResponse request
	ReadPublicIpsByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadPublicIpsByIdResponse, error)

	// LinkPublicIpWithBodyWithResponse request with any body
	LinkPublicIpWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkPublicIpResponse, error)

	LinkPublicIpWithResponse(ctx context.Context, id string, body LinkPublicIpJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkPublicIpResponse, error)

	// UnlinkPublicIpWithBodyWithResponse request with any body
	UnlinkPublicIpWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkPublicIpResponse, error)

	UnlinkPublicIpWithResponse(ctx context.Context, id string, body UnlinkPublicIpJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkPublicIpResponse, error)

	// RebootVmsWithBodyWithResponse request with any body
	RebootVmsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RebootVmsResponse, error)

	RebootVmsWithResponse(ctx context.Context, body RebootVmsJSONRequestBody, reqEditors ...RequestEditorFn) (*RebootVmsResponse, error)

	// RejectNetPeeringWithBodyWithResponse request with any body
	RejectNetPeeringWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RejectNetPeeringResponse, error)

	RejectNetPeeringWithResponse(ctx context.Context, body RejectNetPeeringJSONRequestBody, reqEditors ...RequestEditorFn) (*RejectNetPeeringResponse, error)

	// UpdateRoutePropagationWithBodyWithResponse request with any body
	UpdateRoutePropagationWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRoutePropagationResponse, error)

	UpdateRoutePropagationWithResponse(ctx context.Context, id string, body UpdateRoutePropagationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRoutePropagationResponse, error)

	// ReadRouteTablesWithResponse request
	ReadRouteTablesWithResponse(ctx context.Context, params *ReadRouteTablesParams, reqEditors ...RequestEditorFn) (*ReadRouteTablesResponse, error)

	// CreateRouteTableWithBodyWithResponse request with any body
	CreateRouteTableWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRouteTableResponse, error)

	CreateRouteTableWithResponse(ctx context.Context, body CreateRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRouteTableResponse, error)

	// DeleteRouteTableWithResponse request
	DeleteRouteTableWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteRouteTableResponse, error)

	// ReadRouteTablesByIdWithResponse request
	ReadRouteTablesByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadRouteTablesByIdResponse, error)

	// LinkRouteTableWithBodyWithResponse request with any body
	LinkRouteTableWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkRouteTableResponse, error)

	LinkRouteTableWithResponse(ctx context.Context, id string, body LinkRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkRouteTableResponse, error)

	// UnlinkRouteTableWithResponse request
	UnlinkRouteTableWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*UnlinkRouteTableResponse, error)

	// CreateRouteWithBodyWithResponse request with any body
	CreateRouteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRouteResponse, error)

	CreateRouteWithResponse(ctx context.Context, body CreateRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRouteResponse, error)

	// DeleteRouteWithBodyWithResponse request with any body
	DeleteRouteWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteRouteResponse, error)

	DeleteRouteWithResponse(ctx context.Context, id string, body DeleteRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteRouteResponse, error)

	// UpdateRouteWithBodyWithResponse request with any body
	UpdateRouteWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRouteResponse, error)

	UpdateRouteWithResponse(ctx context.Context, id string, body UpdateRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRouteResponse, error)

	// CreateSecurityGroupRuleWithBodyWithResponse request with any body
	CreateSecurityGroupRuleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSecurityGroupRuleResponse, error)

	CreateSecurityGroupRuleWithResponse(ctx context.Context, body CreateSecurityGroupRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSecurityGroupRuleResponse, error)

	// DeleteSecurityGroupRuleWithBodyWithResponse request with any body
	DeleteSecurityGroupRuleWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteSecurityGroupRuleResponse, error)

	DeleteSecurityGroupRuleWithResponse(ctx context.Context, id string, body DeleteSecurityGroupRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteSecurityGroupRuleResponse, error)

	// ReadSecurityGroupsWithResponse request
	ReadSecurityGroupsWithResponse(ctx context.Context, params *ReadSecurityGroupsParams, reqEditors ...RequestEditorFn) (*ReadSecurityGroupsResponse, error)

	// CreateSecurityGroupWithBodyWithResponse request with any body
	CreateSecurityGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSecurityGroupResponse, error)

	CreateSecurityGroupWithResponse(ctx context.Context, body CreateSecurityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSecurityGroupResponse, error)

	// DeleteSecurityGroupWithBodyWithResponse request with any body
	DeleteSecurityGroupWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteSecurityGroupResponse, error)

	DeleteSecurityGroupWithResponse(ctx context.Context, id string, body DeleteSecurityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteSecurityGroupResponse, error)

	// ReadSecurityGroupsByIdWithResponse request
	ReadSecurityGroupsByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadSecurityGroupsByIdResponse, error)

	// ReadSnapshotsWithResponse request
	ReadSnapshotsWithResponse(ctx context.Context, params *ReadSnapshotsParams, reqEditors ...RequestEditorFn) (*ReadSnapshotsResponse, error)

	// CreateSnapshotWithBodyWithResponse request with any body
	CreateSnapshotWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSnapshotResponse, error)

	CreateSnapshotWithResponse(ctx context.Context, body CreateSnapshotJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSnapshotResponse, error)

	// DeleteSnapshotWithResponse request
	DeleteSnapshotWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSnapshotResponse, error)

	// ReadSnapshotsByIdWithResponse request
	ReadSnapshotsByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadSnapshotsByIdResponse, error)

	// StartVmsWithBodyWithResponse request with any body
	StartVmsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartVmsResponse, error)

	StartVmsWithResponse(ctx context.Context, body StartVmsJSONRequestBody, reqEditors ...RequestEditorFn) (*StartVmsResponse, error)

	// StopVmsWithBodyWithResponse request with any body
	StopVmsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StopVmsResponse, error)

	StopVmsWithResponse(ctx context.Context, body StopVmsJSONRequestBody, reqEditors ...RequestEditorFn) (*StopVmsResponse, error)

	// ReadSubnetsWithResponse request
	ReadSubnetsWithResponse(ctx context.Context, params *ReadSubnetsParams, reqEditors ...RequestEditorFn) (*ReadSubnetsResponse, error)

	// CreateSubnetWithBodyWithResponse request with any body
	CreateSubnetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSubnetResponse, error)

	CreateSubnetWithResponse(ctx context.Context, body CreateSubnetJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSubnetResponse, error)

	// DeleteSubnetWithResponse request
	DeleteSubnetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSubnetResponse, error)

	// ReadSubnetsByIdWithResponse request
	ReadSubnetsByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadSubnetsByIdResponse, error)

	// UpdateSubnetWithBodyWithResponse request with any body
	UpdateSubnetWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSubnetResponse, error)

	UpdateSubnetWithResponse(ctx context.Context, id string, body UpdateSubnetJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSubnetResponse, error)

	// ReadTagsWithResponse request
	ReadTagsWithResponse(ctx context.Context, params *ReadTagsParams, reqEditors ...RequestEditorFn) (*ReadTagsResponse, error)

	// CreateTagsWithBodyWithResponse request with any body
	CreateTagsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTagsResponse, error)

	CreateTagsWithResponse(ctx context.Context, body CreateTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTagsResponse, error)

	// DeleteTagsWithBodyWithResponse request with any body
	DeleteTagsWithBodyWithResponse(ctx context.Context, id []interface{}, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteTagsResponse, error)

	DeleteTagsWithResponse(ctx context.Context, id []interface{}, body DeleteTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteTagsResponse, error)

	// ReadTagsByIdWithResponse request
	ReadTagsByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadTagsByIdResponse, error)

	// ReadVirtualGatewaysWithResponse request
	ReadVirtualGatewaysWithResponse(ctx context.Context, params *ReadVirtualGatewaysParams, reqEditors ...RequestEditorFn) (*ReadVirtualGatewaysResponse, error)

	// CreateVirtualGatewayWithBodyWithResponse request with any body
	CreateVirtualGatewayWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVirtualGatewayResponse, error)

	CreateVirtualGatewayWithResponse(ctx context.Context, body CreateVirtualGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVirtualGatewayResponse, error)

	// DeleteVirtualGatewayWithResponse request
	DeleteVirtualGatewayWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteVirtualGatewayResponse, error)

	// ReadVirtualGatewaysByIdWithResponse request
	ReadVirtualGatewaysByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadVirtualGatewaysByIdResponse, error)

	// LinkVirtualGatewayWithBodyWithResponse request with any body
	LinkVirtualGatewayWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkVirtualGatewayResponse, error)

	LinkVirtualGatewayWithResponse(ctx context.Context, id string, body LinkVirtualGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkVirtualGatewayResponse, error)

	// UnlinkVirtualGatewayWithBodyWithResponse request with any body
	UnlinkVirtualGatewayWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkVirtualGatewayResponse, error)

	UnlinkVirtualGatewayWithResponse(ctx context.Context, id string, body UnlinkVirtualGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkVirtualGatewayResponse, error)

	// ReadVmsWithResponse request
	ReadVmsWithResponse(ctx context.Context, params *ReadVmsParams, reqEditors ...RequestEditorFn) (*ReadVmsResponse, error)

	// CreateVmsWithBodyWithResponse request with any body
	CreateVmsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVmsResponse, error)

	CreateVmsWithResponse(ctx context.Context, body CreateVmsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVmsResponse, error)

	// DeleteVmsWithResponse request
	DeleteVmsWithResponse(ctx context.Context, id []interface{}, reqEditors ...RequestEditorFn) (*DeleteVmsResponse, error)

	// ReadVmsByIdWithResponse request
	ReadVmsByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadVmsByIdResponse, error)

	// UpdateVmWithBodyWithResponse request with any body
	UpdateVmWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVmResponse, error)

	UpdateVmWithResponse(ctx context.Context, id string, body UpdateVmJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVmResponse, error)

	// ReadVmsHealthWithBodyWithResponse request with any body
	ReadVmsHealthWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReadVmsHealthResponse, error)

	ReadVmsHealthWithResponse(ctx context.Context, body ReadVmsHealthJSONRequestBody, reqEditors ...RequestEditorFn) (*ReadVmsHealthResponse, error)

	// ReadVmsHealthByIdWithResponse request
	ReadVmsHealthByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadVmsHealthByIdResponse, error)

	// ReadVmsStateWithResponse request
	ReadVmsStateWithResponse(ctx context.Context, params *ReadVmsStateParams, reqEditors ...RequestEditorFn) (*ReadVmsStateResponse, error)

	// ReadVmsStateByIdWithResponse request
	ReadVmsStateByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadVmsStateByIdResponse, error)

	// ReadVolumesWithResponse request
	ReadVolumesWithResponse(ctx context.Context, params *ReadVolumesParams, reqEditors ...RequestEditorFn) (*ReadVolumesResponse, error)

	// CreateVolumeWithBodyWithResponse request with any body
	CreateVolumeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVolumeResponse, error)

	CreateVolumeWithResponse(ctx context.Context, body CreateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVolumeResponse, error)

	// DeleteVolumeWithResponse request
	DeleteVolumeWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteVolumeResponse, error)

	// ReadVolumesByIdWithResponse request
	ReadVolumesByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadVolumesByIdResponse, error)

	// UpdateVolumeWithBodyWithResponse request with any body
	UpdateVolumeWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVolumeResponse, error)

	UpdateVolumeWithResponse(ctx context.Context, id string, body UpdateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVolumeResponse, error)

	// LinkVolumeWithBodyWithResponse request with any body
	LinkVolumeWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkVolumeResponse, error)

	LinkVolumeWithResponse(ctx context.Context, id string, body LinkVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkVolumeResponse, error)

	// UnlinkVolumeWithBodyWithResponse request with any body
	UnlinkVolumeWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkVolumeResponse, error)

	UnlinkVolumeWithResponse(ctx context.Context, id string, body UnlinkVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkVolumeResponse, error)

	// CreateVpnConnectionRouteWithBodyWithResponse request with any body
	CreateVpnConnectionRouteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVpnConnectionRouteResponse, error)

	CreateVpnConnectionRouteWithResponse(ctx context.Context, body CreateVpnConnectionRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVpnConnectionRouteResponse, error)

	// DeleteVpnConnectionRouteWithBodyWithResponse request with any body
	DeleteVpnConnectionRouteWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteVpnConnectionRouteResponse, error)

	DeleteVpnConnectionRouteWithResponse(ctx context.Context, id string, body DeleteVpnConnectionRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteVpnConnectionRouteResponse, error)

	// ReadVpnConnectionsWithResponse request
	ReadVpnConnectionsWithResponse(ctx context.Context, params *ReadVpnConnectionsParams, reqEditors ...RequestEditorFn) (*ReadVpnConnectionsResponse, error)

	// CreateVpnConnectionWithBodyWithResponse request with any body
	CreateVpnConnectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVpnConnectionResponse, error)

	CreateVpnConnectionWithResponse(ctx context.Context, body CreateVpnConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVpnConnectionResponse, error)

	// DeleteVpnConnectionWithResponse request
	DeleteVpnConnectionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteVpnConnectionResponse, error)

	// ReadVpnConnectionsByIdWithResponse request
	ReadVpnConnectionsByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadVpnConnectionsByIdResponse, error)

	// UpdateVpnConnectionWithBodyWithResponse request with any body
	UpdateVpnConnectionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVpnConnectionResponse, error)

	UpdateVpnConnectionWithResponse(ctx context.Context, id string, body UpdateVpnConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVpnConnectionResponse, error)
}

type AcceptNetPeeringResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AcceptNetPeeringResponseSchema
}

// Status returns HTTPResponse.Status
func (r AcceptNetPeeringResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AcceptNetPeeringResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadAdminPasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReadAdminPasswordResponseSchema
}

// Status returns HTTPResponse.Status
func (r ReadAdminPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadAdminPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadAdminPasswordByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReadAdminPasswordResponseSchema
}

// Status returns HTTPResponse.Status
func (r ReadAdminPasswordByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadAdminPasswordByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadClientGatewaysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReadClientGatewaysResponseSchema
}

// Status returns HTTPResponse.Status
func (r ReadClientGatewaysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadClientGatewaysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClientGatewayResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClientGatewaySchema
}

// Status returns HTTPResponse.Status
func (r CreateClientGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClientGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClientGatewayResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteClientGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClientGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadClientGatewaysByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClientGatewaySchema
}

// Status returns HTTPResponse.Status
func (r ReadClientGatewaysByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadClientGatewaysByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadConsoleOutputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReadConsoleOutputResponseSchema
}

// Status returns HTTPResponse.Status
func (r ReadConsoleOutputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadConsoleOutputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadConsoleOutputByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReadConsoleOutputResponseSchema
}

// Status returns HTTPResponse.Status
func (r ReadConsoleOutputByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadConsoleOutputByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadDhcpOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReadDhcpOptionsResponseSchema
}

// Status returns HTTPResponse.Status
func (r ReadDhcpOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadDhcpOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDhcpOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DhcpOptionsSetSchema
}

// Status returns HTTPResponse.Status
func (r CreateDhcpOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDhcpOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDhcpOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteDhcpOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDhcpOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadDhcpOptionsByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DhcpOptionsSetSchema
}

// Status returns HTTPResponse.Status
func (r ReadDhcpOptionsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadDhcpOptionsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadDirectLinkInterfacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReadDirectLinkInterfacesResponseSchema
}

// Status returns HTTPResponse.Status
func (r ReadDirectLinkInterfacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadDirectLinkInterfacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDirectLinkInterfaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DirectLinkInterfacesSchema
}

// Status returns HTTPResponse.Status
func (r CreateDirectLinkInterfaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDirectLinkInterfaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDirectLinkInterfaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteDirectLinkInterfaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDirectLinkInterfaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadDirectLinkInterfacesByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DirectLinkInterfacesSchema
}

// Status returns HTTPResponse.Status
func (r ReadDirectLinkInterfacesByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadDirectLinkInterfacesByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDirectLinkInterfaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateDirectLinkInterfaceResponseSchema
}

// Status returns HTTPResponse.Status
func (r UpdateDirectLinkInterfaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDirectLinkInterfaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadDirectLinksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReadDirectLinksResponseSchema
}

// Status returns HTTPResponse.Status
func (r ReadDirectLinksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadDirectLinksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDirectLinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DirectLinkSchema
}

// Status returns HTTPResponse.Status
func (r CreateDirectLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDirectLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDirectLinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteDirectLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDirectLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadDirectLinksByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DirectLinkSchema
}

// Status returns HTTPResponse.Status
func (r ReadDirectLinksByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadDirectLinksByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadFlexibleGpuCatalogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReadFlexibleGpuCatalogResponseSchema
}

// Status returns HTTPResponse.Status
func (r ReadFlexibleGpuCatalogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadFlexibleGpuCatalogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadFlexibleGpuCatalogByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FlexibleGpuCatalogSchema
}

// Status returns HTTPResponse.Status
func (r ReadFlexibleGpuCatalogByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadFlexibleGpuCatalogByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadFlexibleGpusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReadFlexibleGpusResponseSchema
}

// Status returns HTTPResponse.Status
func (r ReadFlexibleGpusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadFlexibleGpusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFlexibleGpuResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FlexibleGpuSchema
}

// Status returns HTTPResponse.Status
func (r CreateFlexibleGpuResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFlexibleGpuResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFlexibleGpuResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteFlexibleGpuResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFlexibleGpuResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadFlexibleGpusByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FlexibleGpuSchema
}

// Status returns HTTPResponse.Status
func (r ReadFlexibleGpusByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadFlexibleGpusByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateFlexibleGpuResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateFlexibleGpuResponseSchema
}

// Status returns HTTPResponse.Status
func (r UpdateFlexibleGpuResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFlexibleGpuResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkFlexibleGpuResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LinkFlexibleGpuResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkFlexibleGpuResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkFlexibleGpuResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UnlinkFlexibleGpuResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkFlexibleGpuResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadImagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReadImagesResponseSchema
}

// Status returns HTTPResponse.Status
func (r ReadImagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadImagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ImageSchema
}

// Status returns HTTPResponse.Status
func (r CreateImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadImagesByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ImageSchema
}

// Status returns HTTPResponse.Status
func (r ReadImagesByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadImagesByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateImageResponseSchema
}

// Status returns HTTPResponse.Status
func (r UpdateImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadInternetServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReadInternetServicesResponseSchema
}

// Status returns HTTPResponse.Status
func (r ReadInternetServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadInternetServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateInternetServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InternetServiceSchema
}

// Status returns HTTPResponse.Status
func (r CreateInternetServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateInternetServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteInternetServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteInternetServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteInternetServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadInternetServicesByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InternetServiceSchema
}

// Status returns HTTPResponse.Status
func (r ReadInternetServicesByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadInternetServicesByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkInternetServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LinkInternetServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkInternetServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkInternetServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UnlinkInternetServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkInternetServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadKeypairsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReadKeypairsResponseSchema
}

// Status returns HTTPResponse.Status
func (r ReadKeypairsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadKeypairsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateKeypairResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeypairCreatedSchema
}

// Status returns HTTPResponse.Status
func (r CreateKeypairResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateKeypairResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteKeypairResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteKeypairResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteKeypairResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadKeypairsByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeypairSchema
}

// Status returns HTTPResponse.Status
func (r ReadKeypairsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadKeypairsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadListenerRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReadListenerRulesResponseSchema
}

// Status returns HTTPResponse.Status
func (r ReadListenerRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadListenerRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateListenerRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListenerRuleSchema
}

// Status returns HTTPResponse.Status
func (r CreateListenerRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateListenerRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteListenerRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteListenerRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteListenerRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadListenerRulesByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListenerRuleSchema
}

// Status returns HTTPResponse.Status
func (r ReadListenerRulesByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadListenerRulesByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateListenerRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateListenerRuleResponseSchema
}

// Status returns HTTPResponse.Status
func (r UpdateListenerRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateListenerRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkLoadBalancerBackendMachinesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LinkLoadBalancerBackendMachinesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkLoadBalancerBackendMachinesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkLoadBalancerBackendMachinesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UnlinkLoadBalancerBackendMachinesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkLoadBalancerBackendMachinesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLoadBalancerListenersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoadBalancerSchema
}

// Status returns HTTPResponse.Status
func (r CreateLoadBalancerListenersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLoadBalancerListenersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLoadBalancerListenersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *DeleteLoadBalancerListenersResponseSchema
}

// Status returns HTTPResponse.Status
func (r DeleteLoadBalancerListenersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLoadBalancerListenersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLoadBalancerPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoadBalancerSchema
}

// Status returns HTTPResponse.Status
func (r CreateLoadBalancerPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLoadBalancerPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLoadBalancerPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *DeleteLoadBalancerPolicyResponseSchema
}

// Status returns HTTPResponse.Status
func (r DeleteLoadBalancerPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLoadBalancerPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadLoadBalancerTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReadLoadBalancerTagsResponseSchema
}

// Status returns HTTPResponse.Status
func (r ReadLoadBalancerTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadLoadBalancerTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLoadBalancerTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateLoadBalancerTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLoadBalancerTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLoadBalancerTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteLoadBalancerTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLoadBalancerTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadLoadBalancerTagsByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoadBalancerTagSchema
}

// Status returns HTTPResponse.Status
func (r ReadLoadBalancerTagsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadLoadBalancerTagsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadLoadBalancersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReadLoadBalancersResponseSchema
}

// Status returns HTTPResponse.Status
func (r ReadLoadBalancersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadLoadBalancersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLoadBalancerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoadBalancerSchema
}

// Status returns HTTPResponse.Status
func (r CreateLoadBalancerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLoadBalancerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLoadBalancerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteLoadBalancerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLoadBalancerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadLoadBalancersByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoadBalancerSchema
}

// Status returns HTTPResponse.Status
func (r ReadLoadBalancersByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadLoadBalancersByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateLoadBalancerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateLoadBalancerResponseSchema
}

// Status returns HTTPResponse.Status
func (r UpdateLoadBalancerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateLoadBalancerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadLocationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReadLocationsResponseSchema
}

// Status returns HTTPResponse.Status
func (r ReadLocationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadLocationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadLocationsByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LocationSchema
}

// Status returns HTTPResponse.Status
func (r ReadLocationsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadLocationsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadNatServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReadNatServicesResponseSchema
}

// Status returns HTTPResponse.Status
func (r ReadNatServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadNatServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNatServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NatServiceSchema
}

// Status returns HTTPResponse.Status
func (r CreateNatServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNatServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNatServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteNatServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNatServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadNatServicesByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NatServiceSchema
}

// Status returns HTTPResponse.Status
func (r ReadNatServicesByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadNatServicesByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadNetAccessPointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReadNetAccessPointsResponseSchema
}

// Status returns HTTPResponse.Status
func (r ReadNetAccessPointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadNetAccessPointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNetAccessPointResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NetAccessPointSchema
}

// Status returns HTTPResponse.Status
func (r CreateNetAccessPointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNetAccessPointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNetAccessPointResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteNetAccessPointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNetAccessPointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadNetAccessPointsByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NetAccessPointSchema
}

// Status returns HTTPResponse.Status
func (r ReadNetAccessPointsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadNetAccessPointsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateNetAccessPointResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateNetAccessPointResponseSchema
}

// Status returns HTTPResponse.Status
func (r UpdateNetAccessPointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateNetAccessPointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadNetPeeringsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReadNetPeeringsResponseSchema
}

// Status returns HTTPResponse.Status
func (r ReadNetPeeringsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadNetPeeringsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNetPeeringResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NetPeeringSchema
}

// Status returns HTTPResponse.Status
func (r CreateNetPeeringResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNetPeeringResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNetPeeringResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteNetPeeringResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNetPeeringResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadNetPeeringsByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NetPeeringSchema
}

// Status returns HTTPResponse.Status
func (r ReadNetPeeringsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadNetPeeringsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadNetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReadNetsResponseSchema
}

// Status returns HTTPResponse.Status
func (r ReadNetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadNetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NetSchema
}

// Status returns HTTPResponse.Status
func (r CreateNetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteNetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadNetsByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NetSchema
}

// Status returns HTTPResponse.Status
func (r ReadNetsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadNetsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateNetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateNetResponseSchema
}

// Status returns HTTPResponse.Status
func (r UpdateNetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateNetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadNicsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReadNicsResponseSchema
}

// Status returns HTTPResponse.Status
func (r ReadNicsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadNicsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NicSchema
}

// Status returns HTTPResponse.Status
func (r CreateNicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteNicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadNicsByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NicSchema
}

// Status returns HTTPResponse.Status
func (r ReadNicsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadNicsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateNicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateNicResponseSchema
}

// Status returns HTTPResponse.Status
func (r UpdateNicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateNicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkNicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LinkNicResponseSchema
}

// Status returns HTTPResponse.Status
func (r LinkNicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkNicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkNicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UnlinkNicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkNicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkPrivateIpsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LinkPrivateIpsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkPrivateIpsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkPrivateIpsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UnlinkPrivateIpsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkPrivateIpsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadProductTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReadProductTypesResponseSchema
}

// Status returns HTTPResponse.Status
func (r ReadProductTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadProductTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadProductTypesByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProductTypeSchema
}

// Status returns HTTPResponse.Status
func (r ReadProductTypesByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadProductTypesByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadPublicIpRangesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReadPublicIpRangesResponseSchema
}

// Status returns HTTPResponse.Status
func (r ReadPublicIpRangesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadPublicIpRangesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadPublicIpRangesByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReadPublicIpRangesResponseSchema
}

// Status returns HTTPResponse.Status
func (r ReadPublicIpRangesByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadPublicIpRangesByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadPublicIpsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReadPublicIpsResponseSchema
}

// Status returns HTTPResponse.Status
func (r ReadPublicIpsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadPublicIpsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePublicIpResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PublicIpSchema
}

// Status returns HTTPResponse.Status
func (r CreatePublicIpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePublicIpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePublicIpResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeletePublicIpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePublicIpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadPublicIpsByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PublicIpSchema
}

// Status returns HTTPResponse.Status
func (r ReadPublicIpsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadPublicIpsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkPublicIpResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LinkPublicIpResponseSchema
}

// Status returns HTTPResponse.Status
func (r LinkPublicIpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkPublicIpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkPublicIpResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UnlinkPublicIpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkPublicIpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RebootVmsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RebootVmsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RebootVmsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RejectNetPeeringResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RejectNetPeeringResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RejectNetPeeringResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRoutePropagationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateRoutePropagationResponseSchema
}

// Status returns HTTPResponse.Status
func (r UpdateRoutePropagationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRoutePropagationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadRouteTablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReadRouteTablesResponseSchema
}

// Status returns HTTPResponse.Status
func (r ReadRouteTablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadRouteTablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRouteTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RouteTableSchema
}

// Status returns HTTPResponse.Status
func (r CreateRouteTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRouteTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRouteTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteRouteTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRouteTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadRouteTablesByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RouteTableSchema
}

// Status returns HTTPResponse.Status
func (r ReadRouteTablesByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadRouteTablesByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkRouteTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LinkRouteTableResponseSchema
}

// Status returns HTTPResponse.Status
func (r LinkRouteTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkRouteTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkRouteTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UnlinkRouteTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkRouteTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRouteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RouteTableSchema
}

// Status returns HTTPResponse.Status
func (r CreateRouteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRouteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRouteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *DeleteRouteResponseSchema
}

// Status returns HTTPResponse.Status
func (r DeleteRouteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRouteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRouteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateRouteResponseSchema
}

// Status returns HTTPResponse.Status
func (r UpdateRouteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRouteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSecurityGroupRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SecurityGroupSchema
}

// Status returns HTTPResponse.Status
func (r CreateSecurityGroupRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSecurityGroupRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSecurityGroupRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *DeleteSecurityGroupRuleResponseSchema
}

// Status returns HTTPResponse.Status
func (r DeleteSecurityGroupRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSecurityGroupRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadSecurityGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReadSecurityGroupsResponseSchema
}

// Status returns HTTPResponse.Status
func (r ReadSecurityGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadSecurityGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSecurityGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SecurityGroupSchema
}

// Status returns HTTPResponse.Status
func (r CreateSecurityGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSecurityGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSecurityGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSecurityGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSecurityGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadSecurityGroupsByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SecurityGroupSchema
}

// Status returns HTTPResponse.Status
func (r ReadSecurityGroupsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadSecurityGroupsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadSnapshotsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReadSnapshotsResponseSchema
}

// Status returns HTTPResponse.Status
func (r ReadSnapshotsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadSnapshotsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSnapshotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SnapshotSchema
}

// Status returns HTTPResponse.Status
func (r CreateSnapshotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSnapshotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSnapshotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSnapshotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSnapshotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadSnapshotsByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SnapshotSchema
}

// Status returns HTTPResponse.Status
func (r ReadSnapshotsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadSnapshotsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartVmsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StartVmsResponseSchema
}

// Status returns HTTPResponse.Status
func (r StartVmsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartVmsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StopVmsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StopVmsResponseSchema
}

// Status returns HTTPResponse.Status
func (r StopVmsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StopVmsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadSubnetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReadSubnetsResponseSchema
}

// Status returns HTTPResponse.Status
func (r ReadSubnetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadSubnetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSubnetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SubnetSchema
}

// Status returns HTTPResponse.Status
func (r CreateSubnetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSubnetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSubnetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSubnetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSubnetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadSubnetsByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SubnetSchema
}

// Status returns HTTPResponse.Status
func (r ReadSubnetsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadSubnetsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSubnetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateSubnetResponseSchema
}

// Status returns HTTPResponse.Status
func (r UpdateSubnetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSubnetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReadTagsResponseSchema
}

// Status returns HTTPResponse.Status
func (r ReadTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadTagsByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TagSchema
}

// Status returns HTTPResponse.Status
func (r ReadTagsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadTagsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVirtualGatewaysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReadVirtualGatewaysResponseSchema
}

// Status returns HTTPResponse.Status
func (r ReadVirtualGatewaysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVirtualGatewaysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVirtualGatewayResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VirtualGatewaySchema
}

// Status returns HTTPResponse.Status
func (r CreateVirtualGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVirtualGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVirtualGatewayResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteVirtualGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVirtualGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVirtualGatewaysByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VirtualGatewaySchema
}

// Status returns HTTPResponse.Status
func (r ReadVirtualGatewaysByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVirtualGatewaysByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkVirtualGatewayResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LinkVirtualGatewayResponseSchema
}

// Status returns HTTPResponse.Status
func (r LinkVirtualGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkVirtualGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkVirtualGatewayResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UnlinkVirtualGatewayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkVirtualGatewayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVmsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReadVmsResponseSchema
}

// Status returns HTTPResponse.Status
func (r ReadVmsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVmsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVmsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateVmsResponseSchema
}

// Status returns HTTPResponse.Status
func (r CreateVmsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVmsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVmsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *DeleteVmsResponseSchema
}

// Status returns HTTPResponse.Status
func (r DeleteVmsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVmsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVmsByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VmSchema
}

// Status returns HTTPResponse.Status
func (r ReadVmsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVmsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVmResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateVmResponseSchema
}

// Status returns HTTPResponse.Status
func (r UpdateVmResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVmResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVmsHealthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReadVmsHealthResponseSchema
}

// Status returns HTTPResponse.Status
func (r ReadVmsHealthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVmsHealthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVmsHealthByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BackendVmHealthSchema
}

// Status returns HTTPResponse.Status
func (r ReadVmsHealthByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVmsHealthByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVmsStateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReadVmsStateResponseSchema
}

// Status returns HTTPResponse.Status
func (r ReadVmsStateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVmsStateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVmsStateByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VmStatesSchema
}

// Status returns HTTPResponse.Status
func (r ReadVmsStateByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVmsStateByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVolumesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReadVolumesResponseSchema
}

// Status returns HTTPResponse.Status
func (r ReadVolumesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVolumesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVolumeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VolumeSchema
}

// Status returns HTTPResponse.Status
func (r CreateVolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVolumeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteVolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVolumesByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VolumeSchema
}

// Status returns HTTPResponse.Status
func (r ReadVolumesByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVolumesByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVolumeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateVolumeResponseSchema
}

// Status returns HTTPResponse.Status
func (r UpdateVolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkVolumeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LinkVolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkVolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkVolumeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UnlinkVolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkVolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVpnConnectionRouteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateVpnConnectionRouteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVpnConnectionRouteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVpnConnectionRouteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteVpnConnectionRouteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVpnConnectionRouteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVpnConnectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReadVpnConnectionsResponseSchema
}

// Status returns HTTPResponse.Status
func (r ReadVpnConnectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVpnConnectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVpnConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VpnConnectionSchema
}

// Status returns HTTPResponse.Status
func (r CreateVpnConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVpnConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVpnConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteVpnConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVpnConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadVpnConnectionsByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VpnConnectionSchema
}

// Status returns HTTPResponse.Status
func (r ReadVpnConnectionsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadVpnConnectionsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVpnConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateVpnConnectionResponseSchema
}

// Status returns HTTPResponse.Status
func (r UpdateVpnConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVpnConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// AcceptNetPeeringWithBodyWithResponse request with arbitrary body returning *AcceptNetPeeringResponse
func (c *ClientWithResponses) AcceptNetPeeringWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AcceptNetPeeringResponse, error) {
	rsp, err := c.AcceptNetPeeringWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcceptNetPeeringResponse(rsp)
}

func (c *ClientWithResponses) AcceptNetPeeringWithResponse(ctx context.Context, body AcceptNetPeeringJSONRequestBody, reqEditors ...RequestEditorFn) (*AcceptNetPeeringResponse, error) {
	rsp, err := c.AcceptNetPeering(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcceptNetPeeringResponse(rsp)
}

// ReadAdminPasswordWithBodyWithResponse request with arbitrary body returning *ReadAdminPasswordResponse
func (c *ClientWithResponses) ReadAdminPasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReadAdminPasswordResponse, error) {
	rsp, err := c.ReadAdminPasswordWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadAdminPasswordResponse(rsp)
}

func (c *ClientWithResponses) ReadAdminPasswordWithResponse(ctx context.Context, body ReadAdminPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*ReadAdminPasswordResponse, error) {
	rsp, err := c.ReadAdminPassword(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadAdminPasswordResponse(rsp)
}

// ReadAdminPasswordByIdWithResponse request returning *ReadAdminPasswordByIdResponse
func (c *ClientWithResponses) ReadAdminPasswordByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadAdminPasswordByIdResponse, error) {
	rsp, err := c.ReadAdminPasswordById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadAdminPasswordByIdResponse(rsp)
}

// ReadClientGatewaysWithResponse request returning *ReadClientGatewaysResponse
func (c *ClientWithResponses) ReadClientGatewaysWithResponse(ctx context.Context, params *ReadClientGatewaysParams, reqEditors ...RequestEditorFn) (*ReadClientGatewaysResponse, error) {
	rsp, err := c.ReadClientGateways(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadClientGatewaysResponse(rsp)
}

// CreateClientGatewayWithBodyWithResponse request with arbitrary body returning *CreateClientGatewayResponse
func (c *ClientWithResponses) CreateClientGatewayWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientGatewayResponse, error) {
	rsp, err := c.CreateClientGatewayWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientGatewayResponse(rsp)
}

func (c *ClientWithResponses) CreateClientGatewayWithResponse(ctx context.Context, body CreateClientGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientGatewayResponse, error) {
	rsp, err := c.CreateClientGateway(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientGatewayResponse(rsp)
}

// DeleteClientGatewayWithResponse request returning *DeleteClientGatewayResponse
func (c *ClientWithResponses) DeleteClientGatewayWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteClientGatewayResponse, error) {
	rsp, err := c.DeleteClientGateway(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClientGatewayResponse(rsp)
}

// ReadClientGatewaysByIdWithResponse request returning *ReadClientGatewaysByIdResponse
func (c *ClientWithResponses) ReadClientGatewaysByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadClientGatewaysByIdResponse, error) {
	rsp, err := c.ReadClientGatewaysById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadClientGatewaysByIdResponse(rsp)
}

// ReadConsoleOutputWithBodyWithResponse request with arbitrary body returning *ReadConsoleOutputResponse
func (c *ClientWithResponses) ReadConsoleOutputWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReadConsoleOutputResponse, error) {
	rsp, err := c.ReadConsoleOutputWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadConsoleOutputResponse(rsp)
}

func (c *ClientWithResponses) ReadConsoleOutputWithResponse(ctx context.Context, body ReadConsoleOutputJSONRequestBody, reqEditors ...RequestEditorFn) (*ReadConsoleOutputResponse, error) {
	rsp, err := c.ReadConsoleOutput(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadConsoleOutputResponse(rsp)
}

// ReadConsoleOutputByIdWithResponse request returning *ReadConsoleOutputByIdResponse
func (c *ClientWithResponses) ReadConsoleOutputByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadConsoleOutputByIdResponse, error) {
	rsp, err := c.ReadConsoleOutputById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadConsoleOutputByIdResponse(rsp)
}

// ReadDhcpOptionsWithResponse request returning *ReadDhcpOptionsResponse
func (c *ClientWithResponses) ReadDhcpOptionsWithResponse(ctx context.Context, params *ReadDhcpOptionsParams, reqEditors ...RequestEditorFn) (*ReadDhcpOptionsResponse, error) {
	rsp, err := c.ReadDhcpOptions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadDhcpOptionsResponse(rsp)
}

// CreateDhcpOptionsWithBodyWithResponse request with arbitrary body returning *CreateDhcpOptionsResponse
func (c *ClientWithResponses) CreateDhcpOptionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDhcpOptionsResponse, error) {
	rsp, err := c.CreateDhcpOptionsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDhcpOptionsResponse(rsp)
}

func (c *ClientWithResponses) CreateDhcpOptionsWithResponse(ctx context.Context, body CreateDhcpOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDhcpOptionsResponse, error) {
	rsp, err := c.CreateDhcpOptions(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDhcpOptionsResponse(rsp)
}

// DeleteDhcpOptionsWithResponse request returning *DeleteDhcpOptionsResponse
func (c *ClientWithResponses) DeleteDhcpOptionsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteDhcpOptionsResponse, error) {
	rsp, err := c.DeleteDhcpOptions(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDhcpOptionsResponse(rsp)
}

// ReadDhcpOptionsByIdWithResponse request returning *ReadDhcpOptionsByIdResponse
func (c *ClientWithResponses) ReadDhcpOptionsByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadDhcpOptionsByIdResponse, error) {
	rsp, err := c.ReadDhcpOptionsById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadDhcpOptionsByIdResponse(rsp)
}

// ReadDirectLinkInterfacesWithResponse request returning *ReadDirectLinkInterfacesResponse
func (c *ClientWithResponses) ReadDirectLinkInterfacesWithResponse(ctx context.Context, params *ReadDirectLinkInterfacesParams, reqEditors ...RequestEditorFn) (*ReadDirectLinkInterfacesResponse, error) {
	rsp, err := c.ReadDirectLinkInterfaces(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadDirectLinkInterfacesResponse(rsp)
}

// CreateDirectLinkInterfaceWithBodyWithResponse request with arbitrary body returning *CreateDirectLinkInterfaceResponse
func (c *ClientWithResponses) CreateDirectLinkInterfaceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDirectLinkInterfaceResponse, error) {
	rsp, err := c.CreateDirectLinkInterfaceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDirectLinkInterfaceResponse(rsp)
}

func (c *ClientWithResponses) CreateDirectLinkInterfaceWithResponse(ctx context.Context, body CreateDirectLinkInterfaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDirectLinkInterfaceResponse, error) {
	rsp, err := c.CreateDirectLinkInterface(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDirectLinkInterfaceResponse(rsp)
}

// DeleteDirectLinkInterfaceWithResponse request returning *DeleteDirectLinkInterfaceResponse
func (c *ClientWithResponses) DeleteDirectLinkInterfaceWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteDirectLinkInterfaceResponse, error) {
	rsp, err := c.DeleteDirectLinkInterface(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDirectLinkInterfaceResponse(rsp)
}

// ReadDirectLinkInterfacesByIdWithResponse request returning *ReadDirectLinkInterfacesByIdResponse
func (c *ClientWithResponses) ReadDirectLinkInterfacesByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadDirectLinkInterfacesByIdResponse, error) {
	rsp, err := c.ReadDirectLinkInterfacesById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadDirectLinkInterfacesByIdResponse(rsp)
}

// UpdateDirectLinkInterfaceWithBodyWithResponse request with arbitrary body returning *UpdateDirectLinkInterfaceResponse
func (c *ClientWithResponses) UpdateDirectLinkInterfaceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDirectLinkInterfaceResponse, error) {
	rsp, err := c.UpdateDirectLinkInterfaceWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDirectLinkInterfaceResponse(rsp)
}

func (c *ClientWithResponses) UpdateDirectLinkInterfaceWithResponse(ctx context.Context, id string, body UpdateDirectLinkInterfaceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDirectLinkInterfaceResponse, error) {
	rsp, err := c.UpdateDirectLinkInterface(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDirectLinkInterfaceResponse(rsp)
}

// ReadDirectLinksWithResponse request returning *ReadDirectLinksResponse
func (c *ClientWithResponses) ReadDirectLinksWithResponse(ctx context.Context, params *ReadDirectLinksParams, reqEditors ...RequestEditorFn) (*ReadDirectLinksResponse, error) {
	rsp, err := c.ReadDirectLinks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadDirectLinksResponse(rsp)
}

// CreateDirectLinkWithBodyWithResponse request with arbitrary body returning *CreateDirectLinkResponse
func (c *ClientWithResponses) CreateDirectLinkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDirectLinkResponse, error) {
	rsp, err := c.CreateDirectLinkWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDirectLinkResponse(rsp)
}

func (c *ClientWithResponses) CreateDirectLinkWithResponse(ctx context.Context, body CreateDirectLinkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDirectLinkResponse, error) {
	rsp, err := c.CreateDirectLink(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDirectLinkResponse(rsp)
}

// DeleteDirectLinkWithResponse request returning *DeleteDirectLinkResponse
func (c *ClientWithResponses) DeleteDirectLinkWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteDirectLinkResponse, error) {
	rsp, err := c.DeleteDirectLink(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDirectLinkResponse(rsp)
}

// ReadDirectLinksByIdWithResponse request returning *ReadDirectLinksByIdResponse
func (c *ClientWithResponses) ReadDirectLinksByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadDirectLinksByIdResponse, error) {
	rsp, err := c.ReadDirectLinksById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadDirectLinksByIdResponse(rsp)
}

// ReadFlexibleGpuCatalogWithBodyWithResponse request with arbitrary body returning *ReadFlexibleGpuCatalogResponse
func (c *ClientWithResponses) ReadFlexibleGpuCatalogWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReadFlexibleGpuCatalogResponse, error) {
	rsp, err := c.ReadFlexibleGpuCatalogWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadFlexibleGpuCatalogResponse(rsp)
}

func (c *ClientWithResponses) ReadFlexibleGpuCatalogWithResponse(ctx context.Context, body ReadFlexibleGpuCatalogJSONRequestBody, reqEditors ...RequestEditorFn) (*ReadFlexibleGpuCatalogResponse, error) {
	rsp, err := c.ReadFlexibleGpuCatalog(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadFlexibleGpuCatalogResponse(rsp)
}

// ReadFlexibleGpuCatalogByIdWithResponse request returning *ReadFlexibleGpuCatalogByIdResponse
func (c *ClientWithResponses) ReadFlexibleGpuCatalogByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadFlexibleGpuCatalogByIdResponse, error) {
	rsp, err := c.ReadFlexibleGpuCatalogById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadFlexibleGpuCatalogByIdResponse(rsp)
}

// ReadFlexibleGpusWithResponse request returning *ReadFlexibleGpusResponse
func (c *ClientWithResponses) ReadFlexibleGpusWithResponse(ctx context.Context, params *ReadFlexibleGpusParams, reqEditors ...RequestEditorFn) (*ReadFlexibleGpusResponse, error) {
	rsp, err := c.ReadFlexibleGpus(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadFlexibleGpusResponse(rsp)
}

// CreateFlexibleGpuWithBodyWithResponse request with arbitrary body returning *CreateFlexibleGpuResponse
func (c *ClientWithResponses) CreateFlexibleGpuWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFlexibleGpuResponse, error) {
	rsp, err := c.CreateFlexibleGpuWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFlexibleGpuResponse(rsp)
}

func (c *ClientWithResponses) CreateFlexibleGpuWithResponse(ctx context.Context, body CreateFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFlexibleGpuResponse, error) {
	rsp, err := c.CreateFlexibleGpu(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFlexibleGpuResponse(rsp)
}

// DeleteFlexibleGpuWithResponse request returning *DeleteFlexibleGpuResponse
func (c *ClientWithResponses) DeleteFlexibleGpuWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteFlexibleGpuResponse, error) {
	rsp, err := c.DeleteFlexibleGpu(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFlexibleGpuResponse(rsp)
}

// ReadFlexibleGpusByIdWithResponse request returning *ReadFlexibleGpusByIdResponse
func (c *ClientWithResponses) ReadFlexibleGpusByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadFlexibleGpusByIdResponse, error) {
	rsp, err := c.ReadFlexibleGpusById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadFlexibleGpusByIdResponse(rsp)
}

// UpdateFlexibleGpuWithBodyWithResponse request with arbitrary body returning *UpdateFlexibleGpuResponse
func (c *ClientWithResponses) UpdateFlexibleGpuWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFlexibleGpuResponse, error) {
	rsp, err := c.UpdateFlexibleGpuWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFlexibleGpuResponse(rsp)
}

func (c *ClientWithResponses) UpdateFlexibleGpuWithResponse(ctx context.Context, id string, body UpdateFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFlexibleGpuResponse, error) {
	rsp, err := c.UpdateFlexibleGpu(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFlexibleGpuResponse(rsp)
}

// LinkFlexibleGpuWithBodyWithResponse request with arbitrary body returning *LinkFlexibleGpuResponse
func (c *ClientWithResponses) LinkFlexibleGpuWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkFlexibleGpuResponse, error) {
	rsp, err := c.LinkFlexibleGpuWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkFlexibleGpuResponse(rsp)
}

func (c *ClientWithResponses) LinkFlexibleGpuWithResponse(ctx context.Context, id string, body LinkFlexibleGpuJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkFlexibleGpuResponse, error) {
	rsp, err := c.LinkFlexibleGpu(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkFlexibleGpuResponse(rsp)
}

// UnlinkFlexibleGpuWithResponse request returning *UnlinkFlexibleGpuResponse
func (c *ClientWithResponses) UnlinkFlexibleGpuWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*UnlinkFlexibleGpuResponse, error) {
	rsp, err := c.UnlinkFlexibleGpu(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkFlexibleGpuResponse(rsp)
}

// ReadImagesWithResponse request returning *ReadImagesResponse
func (c *ClientWithResponses) ReadImagesWithResponse(ctx context.Context, params *ReadImagesParams, reqEditors ...RequestEditorFn) (*ReadImagesResponse, error) {
	rsp, err := c.ReadImages(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadImagesResponse(rsp)
}

// CreateImageWithBodyWithResponse request with arbitrary body returning *CreateImageResponse
func (c *ClientWithResponses) CreateImageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateImageResponse, error) {
	rsp, err := c.CreateImageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateImageResponse(rsp)
}

func (c *ClientWithResponses) CreateImageWithResponse(ctx context.Context, body CreateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateImageResponse, error) {
	rsp, err := c.CreateImage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateImageResponse(rsp)
}

// DeleteImageWithResponse request returning *DeleteImageResponse
func (c *ClientWithResponses) DeleteImageWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteImageResponse, error) {
	rsp, err := c.DeleteImage(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteImageResponse(rsp)
}

// ReadImagesByIdWithResponse request returning *ReadImagesByIdResponse
func (c *ClientWithResponses) ReadImagesByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadImagesByIdResponse, error) {
	rsp, err := c.ReadImagesById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadImagesByIdResponse(rsp)
}

// UpdateImageWithBodyWithResponse request with arbitrary body returning *UpdateImageResponse
func (c *ClientWithResponses) UpdateImageWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateImageResponse, error) {
	rsp, err := c.UpdateImageWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateImageResponse(rsp)
}

func (c *ClientWithResponses) UpdateImageWithResponse(ctx context.Context, id string, body UpdateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateImageResponse, error) {
	rsp, err := c.UpdateImage(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateImageResponse(rsp)
}

// ReadInternetServicesWithResponse request returning *ReadInternetServicesResponse
func (c *ClientWithResponses) ReadInternetServicesWithResponse(ctx context.Context, params *ReadInternetServicesParams, reqEditors ...RequestEditorFn) (*ReadInternetServicesResponse, error) {
	rsp, err := c.ReadInternetServices(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadInternetServicesResponse(rsp)
}

// CreateInternetServiceWithBodyWithResponse request with arbitrary body returning *CreateInternetServiceResponse
func (c *ClientWithResponses) CreateInternetServiceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateInternetServiceResponse, error) {
	rsp, err := c.CreateInternetServiceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateInternetServiceResponse(rsp)
}

func (c *ClientWithResponses) CreateInternetServiceWithResponse(ctx context.Context, body CreateInternetServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateInternetServiceResponse, error) {
	rsp, err := c.CreateInternetService(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateInternetServiceResponse(rsp)
}

// DeleteInternetServiceWithResponse request returning *DeleteInternetServiceResponse
func (c *ClientWithResponses) DeleteInternetServiceWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteInternetServiceResponse, error) {
	rsp, err := c.DeleteInternetService(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInternetServiceResponse(rsp)
}

// ReadInternetServicesByIdWithResponse request returning *ReadInternetServicesByIdResponse
func (c *ClientWithResponses) ReadInternetServicesByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadInternetServicesByIdResponse, error) {
	rsp, err := c.ReadInternetServicesById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadInternetServicesByIdResponse(rsp)
}

// LinkInternetServiceWithBodyWithResponse request with arbitrary body returning *LinkInternetServiceResponse
func (c *ClientWithResponses) LinkInternetServiceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkInternetServiceResponse, error) {
	rsp, err := c.LinkInternetServiceWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkInternetServiceResponse(rsp)
}

func (c *ClientWithResponses) LinkInternetServiceWithResponse(ctx context.Context, id string, body LinkInternetServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkInternetServiceResponse, error) {
	rsp, err := c.LinkInternetService(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkInternetServiceResponse(rsp)
}

// UnlinkInternetServiceWithBodyWithResponse request with arbitrary body returning *UnlinkInternetServiceResponse
func (c *ClientWithResponses) UnlinkInternetServiceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkInternetServiceResponse, error) {
	rsp, err := c.UnlinkInternetServiceWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkInternetServiceResponse(rsp)
}

func (c *ClientWithResponses) UnlinkInternetServiceWithResponse(ctx context.Context, id string, body UnlinkInternetServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkInternetServiceResponse, error) {
	rsp, err := c.UnlinkInternetService(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkInternetServiceResponse(rsp)
}

// ReadKeypairsWithResponse request returning *ReadKeypairsResponse
func (c *ClientWithResponses) ReadKeypairsWithResponse(ctx context.Context, params *ReadKeypairsParams, reqEditors ...RequestEditorFn) (*ReadKeypairsResponse, error) {
	rsp, err := c.ReadKeypairs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadKeypairsResponse(rsp)
}

// CreateKeypairWithBodyWithResponse request with arbitrary body returning *CreateKeypairResponse
func (c *ClientWithResponses) CreateKeypairWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateKeypairResponse, error) {
	rsp, err := c.CreateKeypairWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeypairResponse(rsp)
}

func (c *ClientWithResponses) CreateKeypairWithResponse(ctx context.Context, body CreateKeypairJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateKeypairResponse, error) {
	rsp, err := c.CreateKeypair(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeypairResponse(rsp)
}

// DeleteKeypairWithResponse request returning *DeleteKeypairResponse
func (c *ClientWithResponses) DeleteKeypairWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteKeypairResponse, error) {
	rsp, err := c.DeleteKeypair(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteKeypairResponse(rsp)
}

// ReadKeypairsByIdWithResponse request returning *ReadKeypairsByIdResponse
func (c *ClientWithResponses) ReadKeypairsByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadKeypairsByIdResponse, error) {
	rsp, err := c.ReadKeypairsById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadKeypairsByIdResponse(rsp)
}

// ReadListenerRulesWithResponse request returning *ReadListenerRulesResponse
func (c *ClientWithResponses) ReadListenerRulesWithResponse(ctx context.Context, params *ReadListenerRulesParams, reqEditors ...RequestEditorFn) (*ReadListenerRulesResponse, error) {
	rsp, err := c.ReadListenerRules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadListenerRulesResponse(rsp)
}

// CreateListenerRuleWithBodyWithResponse request with arbitrary body returning *CreateListenerRuleResponse
func (c *ClientWithResponses) CreateListenerRuleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateListenerRuleResponse, error) {
	rsp, err := c.CreateListenerRuleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateListenerRuleResponse(rsp)
}

func (c *ClientWithResponses) CreateListenerRuleWithResponse(ctx context.Context, body CreateListenerRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateListenerRuleResponse, error) {
	rsp, err := c.CreateListenerRule(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateListenerRuleResponse(rsp)
}

// DeleteListenerRuleWithResponse request returning *DeleteListenerRuleResponse
func (c *ClientWithResponses) DeleteListenerRuleWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteListenerRuleResponse, error) {
	rsp, err := c.DeleteListenerRule(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteListenerRuleResponse(rsp)
}

// ReadListenerRulesByIdWithResponse request returning *ReadListenerRulesByIdResponse
func (c *ClientWithResponses) ReadListenerRulesByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadListenerRulesByIdResponse, error) {
	rsp, err := c.ReadListenerRulesById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadListenerRulesByIdResponse(rsp)
}

// UpdateListenerRuleWithBodyWithResponse request with arbitrary body returning *UpdateListenerRuleResponse
func (c *ClientWithResponses) UpdateListenerRuleWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateListenerRuleResponse, error) {
	rsp, err := c.UpdateListenerRuleWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateListenerRuleResponse(rsp)
}

func (c *ClientWithResponses) UpdateListenerRuleWithResponse(ctx context.Context, id string, body UpdateListenerRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateListenerRuleResponse, error) {
	rsp, err := c.UpdateListenerRule(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateListenerRuleResponse(rsp)
}

// LinkLoadBalancerBackendMachinesWithBodyWithResponse request with arbitrary body returning *LinkLoadBalancerBackendMachinesResponse
func (c *ClientWithResponses) LinkLoadBalancerBackendMachinesWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkLoadBalancerBackendMachinesResponse, error) {
	rsp, err := c.LinkLoadBalancerBackendMachinesWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkLoadBalancerBackendMachinesResponse(rsp)
}

func (c *ClientWithResponses) LinkLoadBalancerBackendMachinesWithResponse(ctx context.Context, id string, body LinkLoadBalancerBackendMachinesJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkLoadBalancerBackendMachinesResponse, error) {
	rsp, err := c.LinkLoadBalancerBackendMachines(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkLoadBalancerBackendMachinesResponse(rsp)
}

// UnlinkLoadBalancerBackendMachinesWithBodyWithResponse request with arbitrary body returning *UnlinkLoadBalancerBackendMachinesResponse
func (c *ClientWithResponses) UnlinkLoadBalancerBackendMachinesWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkLoadBalancerBackendMachinesResponse, error) {
	rsp, err := c.UnlinkLoadBalancerBackendMachinesWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkLoadBalancerBackendMachinesResponse(rsp)
}

func (c *ClientWithResponses) UnlinkLoadBalancerBackendMachinesWithResponse(ctx context.Context, id string, body UnlinkLoadBalancerBackendMachinesJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkLoadBalancerBackendMachinesResponse, error) {
	rsp, err := c.UnlinkLoadBalancerBackendMachines(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkLoadBalancerBackendMachinesResponse(rsp)
}

// CreateLoadBalancerListenersWithBodyWithResponse request with arbitrary body returning *CreateLoadBalancerListenersResponse
func (c *ClientWithResponses) CreateLoadBalancerListenersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLoadBalancerListenersResponse, error) {
	rsp, err := c.CreateLoadBalancerListenersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLoadBalancerListenersResponse(rsp)
}

func (c *ClientWithResponses) CreateLoadBalancerListenersWithResponse(ctx context.Context, body CreateLoadBalancerListenersJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLoadBalancerListenersResponse, error) {
	rsp, err := c.CreateLoadBalancerListeners(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLoadBalancerListenersResponse(rsp)
}

// DeleteLoadBalancerListenersWithBodyWithResponse request with arbitrary body returning *DeleteLoadBalancerListenersResponse
func (c *ClientWithResponses) DeleteLoadBalancerListenersWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerListenersResponse, error) {
	rsp, err := c.DeleteLoadBalancerListenersWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLoadBalancerListenersResponse(rsp)
}

func (c *ClientWithResponses) DeleteLoadBalancerListenersWithResponse(ctx context.Context, id string, body DeleteLoadBalancerListenersJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerListenersResponse, error) {
	rsp, err := c.DeleteLoadBalancerListeners(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLoadBalancerListenersResponse(rsp)
}

// CreateLoadBalancerPolicyWithBodyWithResponse request with arbitrary body returning *CreateLoadBalancerPolicyResponse
func (c *ClientWithResponses) CreateLoadBalancerPolicyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLoadBalancerPolicyResponse, error) {
	rsp, err := c.CreateLoadBalancerPolicyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLoadBalancerPolicyResponse(rsp)
}

func (c *ClientWithResponses) CreateLoadBalancerPolicyWithResponse(ctx context.Context, body CreateLoadBalancerPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLoadBalancerPolicyResponse, error) {
	rsp, err := c.CreateLoadBalancerPolicy(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLoadBalancerPolicyResponse(rsp)
}

// DeleteLoadBalancerPolicyWithBodyWithResponse request with arbitrary body returning *DeleteLoadBalancerPolicyResponse
func (c *ClientWithResponses) DeleteLoadBalancerPolicyWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerPolicyResponse, error) {
	rsp, err := c.DeleteLoadBalancerPolicyWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLoadBalancerPolicyResponse(rsp)
}

func (c *ClientWithResponses) DeleteLoadBalancerPolicyWithResponse(ctx context.Context, id string, body DeleteLoadBalancerPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerPolicyResponse, error) {
	rsp, err := c.DeleteLoadBalancerPolicy(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLoadBalancerPolicyResponse(rsp)
}

// ReadLoadBalancerTagsWithBodyWithResponse request with arbitrary body returning *ReadLoadBalancerTagsResponse
func (c *ClientWithResponses) ReadLoadBalancerTagsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReadLoadBalancerTagsResponse, error) {
	rsp, err := c.ReadLoadBalancerTagsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadLoadBalancerTagsResponse(rsp)
}

func (c *ClientWithResponses) ReadLoadBalancerTagsWithResponse(ctx context.Context, body ReadLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReadLoadBalancerTagsResponse, error) {
	rsp, err := c.ReadLoadBalancerTags(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadLoadBalancerTagsResponse(rsp)
}

// CreateLoadBalancerTagsWithBodyWithResponse request with arbitrary body returning *CreateLoadBalancerTagsResponse
func (c *ClientWithResponses) CreateLoadBalancerTagsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLoadBalancerTagsResponse, error) {
	rsp, err := c.CreateLoadBalancerTagsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLoadBalancerTagsResponse(rsp)
}

func (c *ClientWithResponses) CreateLoadBalancerTagsWithResponse(ctx context.Context, body CreateLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLoadBalancerTagsResponse, error) {
	rsp, err := c.CreateLoadBalancerTags(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLoadBalancerTagsResponse(rsp)
}

// DeleteLoadBalancerTagsWithBodyWithResponse request with arbitrary body returning *DeleteLoadBalancerTagsResponse
func (c *ClientWithResponses) DeleteLoadBalancerTagsWithBodyWithResponse(ctx context.Context, id []interface{}, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerTagsResponse, error) {
	rsp, err := c.DeleteLoadBalancerTagsWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLoadBalancerTagsResponse(rsp)
}

func (c *ClientWithResponses) DeleteLoadBalancerTagsWithResponse(ctx context.Context, id []interface{}, body DeleteLoadBalancerTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerTagsResponse, error) {
	rsp, err := c.DeleteLoadBalancerTags(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLoadBalancerTagsResponse(rsp)
}

// ReadLoadBalancerTagsByIdWithResponse request returning *ReadLoadBalancerTagsByIdResponse
func (c *ClientWithResponses) ReadLoadBalancerTagsByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadLoadBalancerTagsByIdResponse, error) {
	rsp, err := c.ReadLoadBalancerTagsById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadLoadBalancerTagsByIdResponse(rsp)
}

// ReadLoadBalancersWithResponse request returning *ReadLoadBalancersResponse
func (c *ClientWithResponses) ReadLoadBalancersWithResponse(ctx context.Context, params *ReadLoadBalancersParams, reqEditors ...RequestEditorFn) (*ReadLoadBalancersResponse, error) {
	rsp, err := c.ReadLoadBalancers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadLoadBalancersResponse(rsp)
}

// CreateLoadBalancerWithBodyWithResponse request with arbitrary body returning *CreateLoadBalancerResponse
func (c *ClientWithResponses) CreateLoadBalancerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLoadBalancerResponse, error) {
	rsp, err := c.CreateLoadBalancerWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLoadBalancerResponse(rsp)
}

func (c *ClientWithResponses) CreateLoadBalancerWithResponse(ctx context.Context, body CreateLoadBalancerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLoadBalancerResponse, error) {
	rsp, err := c.CreateLoadBalancer(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLoadBalancerResponse(rsp)
}

// DeleteLoadBalancerWithResponse request returning *DeleteLoadBalancerResponse
func (c *ClientWithResponses) DeleteLoadBalancerWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteLoadBalancerResponse, error) {
	rsp, err := c.DeleteLoadBalancer(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLoadBalancerResponse(rsp)
}

// ReadLoadBalancersByIdWithResponse request returning *ReadLoadBalancersByIdResponse
func (c *ClientWithResponses) ReadLoadBalancersByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadLoadBalancersByIdResponse, error) {
	rsp, err := c.ReadLoadBalancersById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadLoadBalancersByIdResponse(rsp)
}

// UpdateLoadBalancerWithBodyWithResponse request with arbitrary body returning *UpdateLoadBalancerResponse
func (c *ClientWithResponses) UpdateLoadBalancerWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLoadBalancerResponse, error) {
	rsp, err := c.UpdateLoadBalancerWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLoadBalancerResponse(rsp)
}

func (c *ClientWithResponses) UpdateLoadBalancerWithResponse(ctx context.Context, id string, body UpdateLoadBalancerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLoadBalancerResponse, error) {
	rsp, err := c.UpdateLoadBalancer(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLoadBalancerResponse(rsp)
}

// ReadLocationsWithBodyWithResponse request with arbitrary body returning *ReadLocationsResponse
func (c *ClientWithResponses) ReadLocationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReadLocationsResponse, error) {
	rsp, err := c.ReadLocationsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadLocationsResponse(rsp)
}

func (c *ClientWithResponses) ReadLocationsWithResponse(ctx context.Context, body ReadLocationsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReadLocationsResponse, error) {
	rsp, err := c.ReadLocations(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadLocationsResponse(rsp)
}

// ReadLocationsByIdWithResponse request returning *ReadLocationsByIdResponse
func (c *ClientWithResponses) ReadLocationsByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadLocationsByIdResponse, error) {
	rsp, err := c.ReadLocationsById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadLocationsByIdResponse(rsp)
}

// ReadNatServicesWithResponse request returning *ReadNatServicesResponse
func (c *ClientWithResponses) ReadNatServicesWithResponse(ctx context.Context, params *ReadNatServicesParams, reqEditors ...RequestEditorFn) (*ReadNatServicesResponse, error) {
	rsp, err := c.ReadNatServices(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadNatServicesResponse(rsp)
}

// CreateNatServiceWithBodyWithResponse request with arbitrary body returning *CreateNatServiceResponse
func (c *ClientWithResponses) CreateNatServiceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNatServiceResponse, error) {
	rsp, err := c.CreateNatServiceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNatServiceResponse(rsp)
}

func (c *ClientWithResponses) CreateNatServiceWithResponse(ctx context.Context, body CreateNatServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNatServiceResponse, error) {
	rsp, err := c.CreateNatService(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNatServiceResponse(rsp)
}

// DeleteNatServiceWithResponse request returning *DeleteNatServiceResponse
func (c *ClientWithResponses) DeleteNatServiceWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteNatServiceResponse, error) {
	rsp, err := c.DeleteNatService(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNatServiceResponse(rsp)
}

// ReadNatServicesByIdWithResponse request returning *ReadNatServicesByIdResponse
func (c *ClientWithResponses) ReadNatServicesByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadNatServicesByIdResponse, error) {
	rsp, err := c.ReadNatServicesById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadNatServicesByIdResponse(rsp)
}

// ReadNetAccessPointsWithResponse request returning *ReadNetAccessPointsResponse
func (c *ClientWithResponses) ReadNetAccessPointsWithResponse(ctx context.Context, params *ReadNetAccessPointsParams, reqEditors ...RequestEditorFn) (*ReadNetAccessPointsResponse, error) {
	rsp, err := c.ReadNetAccessPoints(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadNetAccessPointsResponse(rsp)
}

// CreateNetAccessPointWithBodyWithResponse request with arbitrary body returning *CreateNetAccessPointResponse
func (c *ClientWithResponses) CreateNetAccessPointWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNetAccessPointResponse, error) {
	rsp, err := c.CreateNetAccessPointWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNetAccessPointResponse(rsp)
}

func (c *ClientWithResponses) CreateNetAccessPointWithResponse(ctx context.Context, body CreateNetAccessPointJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNetAccessPointResponse, error) {
	rsp, err := c.CreateNetAccessPoint(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNetAccessPointResponse(rsp)
}

// DeleteNetAccessPointWithResponse request returning *DeleteNetAccessPointResponse
func (c *ClientWithResponses) DeleteNetAccessPointWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteNetAccessPointResponse, error) {
	rsp, err := c.DeleteNetAccessPoint(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNetAccessPointResponse(rsp)
}

// ReadNetAccessPointsByIdWithResponse request returning *ReadNetAccessPointsByIdResponse
func (c *ClientWithResponses) ReadNetAccessPointsByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadNetAccessPointsByIdResponse, error) {
	rsp, err := c.ReadNetAccessPointsById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadNetAccessPointsByIdResponse(rsp)
}

// UpdateNetAccessPointWithBodyWithResponse request with arbitrary body returning *UpdateNetAccessPointResponse
func (c *ClientWithResponses) UpdateNetAccessPointWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNetAccessPointResponse, error) {
	rsp, err := c.UpdateNetAccessPointWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNetAccessPointResponse(rsp)
}

func (c *ClientWithResponses) UpdateNetAccessPointWithResponse(ctx context.Context, id string, body UpdateNetAccessPointJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNetAccessPointResponse, error) {
	rsp, err := c.UpdateNetAccessPoint(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNetAccessPointResponse(rsp)
}

// ReadNetPeeringsWithResponse request returning *ReadNetPeeringsResponse
func (c *ClientWithResponses) ReadNetPeeringsWithResponse(ctx context.Context, params *ReadNetPeeringsParams, reqEditors ...RequestEditorFn) (*ReadNetPeeringsResponse, error) {
	rsp, err := c.ReadNetPeerings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadNetPeeringsResponse(rsp)
}

// CreateNetPeeringWithBodyWithResponse request with arbitrary body returning *CreateNetPeeringResponse
func (c *ClientWithResponses) CreateNetPeeringWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNetPeeringResponse, error) {
	rsp, err := c.CreateNetPeeringWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNetPeeringResponse(rsp)
}

func (c *ClientWithResponses) CreateNetPeeringWithResponse(ctx context.Context, body CreateNetPeeringJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNetPeeringResponse, error) {
	rsp, err := c.CreateNetPeering(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNetPeeringResponse(rsp)
}

// DeleteNetPeeringWithResponse request returning *DeleteNetPeeringResponse
func (c *ClientWithResponses) DeleteNetPeeringWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteNetPeeringResponse, error) {
	rsp, err := c.DeleteNetPeering(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNetPeeringResponse(rsp)
}

// ReadNetPeeringsByIdWithResponse request returning *ReadNetPeeringsByIdResponse
func (c *ClientWithResponses) ReadNetPeeringsByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadNetPeeringsByIdResponse, error) {
	rsp, err := c.ReadNetPeeringsById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadNetPeeringsByIdResponse(rsp)
}

// ReadNetsWithResponse request returning *ReadNetsResponse
func (c *ClientWithResponses) ReadNetsWithResponse(ctx context.Context, params *ReadNetsParams, reqEditors ...RequestEditorFn) (*ReadNetsResponse, error) {
	rsp, err := c.ReadNets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadNetsResponse(rsp)
}

// CreateNetWithBodyWithResponse request with arbitrary body returning *CreateNetResponse
func (c *ClientWithResponses) CreateNetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNetResponse, error) {
	rsp, err := c.CreateNetWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNetResponse(rsp)
}

func (c *ClientWithResponses) CreateNetWithResponse(ctx context.Context, body CreateNetJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNetResponse, error) {
	rsp, err := c.CreateNet(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNetResponse(rsp)
}

// DeleteNetWithResponse request returning *DeleteNetResponse
func (c *ClientWithResponses) DeleteNetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteNetResponse, error) {
	rsp, err := c.DeleteNet(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNetResponse(rsp)
}

// ReadNetsByIdWithResponse request returning *ReadNetsByIdResponse
func (c *ClientWithResponses) ReadNetsByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadNetsByIdResponse, error) {
	rsp, err := c.ReadNetsById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadNetsByIdResponse(rsp)
}

// UpdateNetWithBodyWithResponse request with arbitrary body returning *UpdateNetResponse
func (c *ClientWithResponses) UpdateNetWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNetResponse, error) {
	rsp, err := c.UpdateNetWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNetResponse(rsp)
}

func (c *ClientWithResponses) UpdateNetWithResponse(ctx context.Context, id string, body UpdateNetJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNetResponse, error) {
	rsp, err := c.UpdateNet(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNetResponse(rsp)
}

// ReadNicsWithResponse request returning *ReadNicsResponse
func (c *ClientWithResponses) ReadNicsWithResponse(ctx context.Context, params *ReadNicsParams, reqEditors ...RequestEditorFn) (*ReadNicsResponse, error) {
	rsp, err := c.ReadNics(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadNicsResponse(rsp)
}

// CreateNicWithBodyWithResponse request with arbitrary body returning *CreateNicResponse
func (c *ClientWithResponses) CreateNicWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNicResponse, error) {
	rsp, err := c.CreateNicWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNicResponse(rsp)
}

func (c *ClientWithResponses) CreateNicWithResponse(ctx context.Context, body CreateNicJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNicResponse, error) {
	rsp, err := c.CreateNic(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNicResponse(rsp)
}

// DeleteNicWithResponse request returning *DeleteNicResponse
func (c *ClientWithResponses) DeleteNicWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteNicResponse, error) {
	rsp, err := c.DeleteNic(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNicResponse(rsp)
}

// ReadNicsByIdWithResponse request returning *ReadNicsByIdResponse
func (c *ClientWithResponses) ReadNicsByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadNicsByIdResponse, error) {
	rsp, err := c.ReadNicsById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadNicsByIdResponse(rsp)
}

// UpdateNicWithBodyWithResponse request with arbitrary body returning *UpdateNicResponse
func (c *ClientWithResponses) UpdateNicWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNicResponse, error) {
	rsp, err := c.UpdateNicWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNicResponse(rsp)
}

func (c *ClientWithResponses) UpdateNicWithResponse(ctx context.Context, id string, body UpdateNicJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNicResponse, error) {
	rsp, err := c.UpdateNic(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNicResponse(rsp)
}

// LinkNicWithBodyWithResponse request with arbitrary body returning *LinkNicResponse
func (c *ClientWithResponses) LinkNicWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkNicResponse, error) {
	rsp, err := c.LinkNicWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkNicResponse(rsp)
}

func (c *ClientWithResponses) LinkNicWithResponse(ctx context.Context, id string, body LinkNicJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkNicResponse, error) {
	rsp, err := c.LinkNic(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkNicResponse(rsp)
}

// UnlinkNicWithResponse request returning *UnlinkNicResponse
func (c *ClientWithResponses) UnlinkNicWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*UnlinkNicResponse, error) {
	rsp, err := c.UnlinkNic(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkNicResponse(rsp)
}

// LinkPrivateIpsWithBodyWithResponse request with arbitrary body returning *LinkPrivateIpsResponse
func (c *ClientWithResponses) LinkPrivateIpsWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkPrivateIpsResponse, error) {
	rsp, err := c.LinkPrivateIpsWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkPrivateIpsResponse(rsp)
}

func (c *ClientWithResponses) LinkPrivateIpsWithResponse(ctx context.Context, id string, body LinkPrivateIpsJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkPrivateIpsResponse, error) {
	rsp, err := c.LinkPrivateIps(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkPrivateIpsResponse(rsp)
}

// UnlinkPrivateIpsWithBodyWithResponse request with arbitrary body returning *UnlinkPrivateIpsResponse
func (c *ClientWithResponses) UnlinkPrivateIpsWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkPrivateIpsResponse, error) {
	rsp, err := c.UnlinkPrivateIpsWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkPrivateIpsResponse(rsp)
}

func (c *ClientWithResponses) UnlinkPrivateIpsWithResponse(ctx context.Context, id string, body UnlinkPrivateIpsJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkPrivateIpsResponse, error) {
	rsp, err := c.UnlinkPrivateIps(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkPrivateIpsResponse(rsp)
}

// ReadProductTypesWithResponse request returning *ReadProductTypesResponse
func (c *ClientWithResponses) ReadProductTypesWithResponse(ctx context.Context, params *ReadProductTypesParams, reqEditors ...RequestEditorFn) (*ReadProductTypesResponse, error) {
	rsp, err := c.ReadProductTypes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadProductTypesResponse(rsp)
}

// ReadProductTypesByIdWithResponse request returning *ReadProductTypesByIdResponse
func (c *ClientWithResponses) ReadProductTypesByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadProductTypesByIdResponse, error) {
	rsp, err := c.ReadProductTypesById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadProductTypesByIdResponse(rsp)
}

// ReadPublicIpRangesWithBodyWithResponse request with arbitrary body returning *ReadPublicIpRangesResponse
func (c *ClientWithResponses) ReadPublicIpRangesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReadPublicIpRangesResponse, error) {
	rsp, err := c.ReadPublicIpRangesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadPublicIpRangesResponse(rsp)
}

func (c *ClientWithResponses) ReadPublicIpRangesWithResponse(ctx context.Context, body ReadPublicIpRangesJSONRequestBody, reqEditors ...RequestEditorFn) (*ReadPublicIpRangesResponse, error) {
	rsp, err := c.ReadPublicIpRanges(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadPublicIpRangesResponse(rsp)
}

// ReadPublicIpRangesByIdWithResponse request returning *ReadPublicIpRangesByIdResponse
func (c *ClientWithResponses) ReadPublicIpRangesByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadPublicIpRangesByIdResponse, error) {
	rsp, err := c.ReadPublicIpRangesById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadPublicIpRangesByIdResponse(rsp)
}

// ReadPublicIpsWithResponse request returning *ReadPublicIpsResponse
func (c *ClientWithResponses) ReadPublicIpsWithResponse(ctx context.Context, params *ReadPublicIpsParams, reqEditors ...RequestEditorFn) (*ReadPublicIpsResponse, error) {
	rsp, err := c.ReadPublicIps(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadPublicIpsResponse(rsp)
}

// CreatePublicIpWithBodyWithResponse request with arbitrary body returning *CreatePublicIpResponse
func (c *ClientWithResponses) CreatePublicIpWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePublicIpResponse, error) {
	rsp, err := c.CreatePublicIpWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePublicIpResponse(rsp)
}

func (c *ClientWithResponses) CreatePublicIpWithResponse(ctx context.Context, body CreatePublicIpJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePublicIpResponse, error) {
	rsp, err := c.CreatePublicIp(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePublicIpResponse(rsp)
}

// DeletePublicIpWithBodyWithResponse request with arbitrary body returning *DeletePublicIpResponse
func (c *ClientWithResponses) DeletePublicIpWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeletePublicIpResponse, error) {
	rsp, err := c.DeletePublicIpWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePublicIpResponse(rsp)
}

func (c *ClientWithResponses) DeletePublicIpWithResponse(ctx context.Context, id string, body DeletePublicIpJSONRequestBody, reqEditors ...RequestEditorFn) (*DeletePublicIpResponse, error) {
	rsp, err := c.DeletePublicIp(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePublicIpResponse(rsp)
}

// ReadPublicIpsByIdWithResponse request returning *ReadPublicIpsByIdResponse
func (c *ClientWithResponses) ReadPublicIpsByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadPublicIpsByIdResponse, error) {
	rsp, err := c.ReadPublicIpsById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadPublicIpsByIdResponse(rsp)
}

// LinkPublicIpWithBodyWithResponse request with arbitrary body returning *LinkPublicIpResponse
func (c *ClientWithResponses) LinkPublicIpWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkPublicIpResponse, error) {
	rsp, err := c.LinkPublicIpWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkPublicIpResponse(rsp)
}

func (c *ClientWithResponses) LinkPublicIpWithResponse(ctx context.Context, id string, body LinkPublicIpJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkPublicIpResponse, error) {
	rsp, err := c.LinkPublicIp(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkPublicIpResponse(rsp)
}

// UnlinkPublicIpWithBodyWithResponse request with arbitrary body returning *UnlinkPublicIpResponse
func (c *ClientWithResponses) UnlinkPublicIpWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkPublicIpResponse, error) {
	rsp, err := c.UnlinkPublicIpWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkPublicIpResponse(rsp)
}

func (c *ClientWithResponses) UnlinkPublicIpWithResponse(ctx context.Context, id string, body UnlinkPublicIpJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkPublicIpResponse, error) {
	rsp, err := c.UnlinkPublicIp(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkPublicIpResponse(rsp)
}

// RebootVmsWithBodyWithResponse request with arbitrary body returning *RebootVmsResponse
func (c *ClientWithResponses) RebootVmsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RebootVmsResponse, error) {
	rsp, err := c.RebootVmsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRebootVmsResponse(rsp)
}

func (c *ClientWithResponses) RebootVmsWithResponse(ctx context.Context, body RebootVmsJSONRequestBody, reqEditors ...RequestEditorFn) (*RebootVmsResponse, error) {
	rsp, err := c.RebootVms(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRebootVmsResponse(rsp)
}

// RejectNetPeeringWithBodyWithResponse request with arbitrary body returning *RejectNetPeeringResponse
func (c *ClientWithResponses) RejectNetPeeringWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RejectNetPeeringResponse, error) {
	rsp, err := c.RejectNetPeeringWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRejectNetPeeringResponse(rsp)
}

func (c *ClientWithResponses) RejectNetPeeringWithResponse(ctx context.Context, body RejectNetPeeringJSONRequestBody, reqEditors ...RequestEditorFn) (*RejectNetPeeringResponse, error) {
	rsp, err := c.RejectNetPeering(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRejectNetPeeringResponse(rsp)
}

// UpdateRoutePropagationWithBodyWithResponse request with arbitrary body returning *UpdateRoutePropagationResponse
func (c *ClientWithResponses) UpdateRoutePropagationWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRoutePropagationResponse, error) {
	rsp, err := c.UpdateRoutePropagationWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRoutePropagationResponse(rsp)
}

func (c *ClientWithResponses) UpdateRoutePropagationWithResponse(ctx context.Context, id string, body UpdateRoutePropagationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRoutePropagationResponse, error) {
	rsp, err := c.UpdateRoutePropagation(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRoutePropagationResponse(rsp)
}

// ReadRouteTablesWithResponse request returning *ReadRouteTablesResponse
func (c *ClientWithResponses) ReadRouteTablesWithResponse(ctx context.Context, params *ReadRouteTablesParams, reqEditors ...RequestEditorFn) (*ReadRouteTablesResponse, error) {
	rsp, err := c.ReadRouteTables(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadRouteTablesResponse(rsp)
}

// CreateRouteTableWithBodyWithResponse request with arbitrary body returning *CreateRouteTableResponse
func (c *ClientWithResponses) CreateRouteTableWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRouteTableResponse, error) {
	rsp, err := c.CreateRouteTableWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRouteTableResponse(rsp)
}

func (c *ClientWithResponses) CreateRouteTableWithResponse(ctx context.Context, body CreateRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRouteTableResponse, error) {
	rsp, err := c.CreateRouteTable(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRouteTableResponse(rsp)
}

// DeleteRouteTableWithResponse request returning *DeleteRouteTableResponse
func (c *ClientWithResponses) DeleteRouteTableWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteRouteTableResponse, error) {
	rsp, err := c.DeleteRouteTable(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRouteTableResponse(rsp)
}

// ReadRouteTablesByIdWithResponse request returning *ReadRouteTablesByIdResponse
func (c *ClientWithResponses) ReadRouteTablesByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadRouteTablesByIdResponse, error) {
	rsp, err := c.ReadRouteTablesById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadRouteTablesByIdResponse(rsp)
}

// LinkRouteTableWithBodyWithResponse request with arbitrary body returning *LinkRouteTableResponse
func (c *ClientWithResponses) LinkRouteTableWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkRouteTableResponse, error) {
	rsp, err := c.LinkRouteTableWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkRouteTableResponse(rsp)
}

func (c *ClientWithResponses) LinkRouteTableWithResponse(ctx context.Context, id string, body LinkRouteTableJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkRouteTableResponse, error) {
	rsp, err := c.LinkRouteTable(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkRouteTableResponse(rsp)
}

// UnlinkRouteTableWithResponse request returning *UnlinkRouteTableResponse
func (c *ClientWithResponses) UnlinkRouteTableWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*UnlinkRouteTableResponse, error) {
	rsp, err := c.UnlinkRouteTable(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkRouteTableResponse(rsp)
}

// CreateRouteWithBodyWithResponse request with arbitrary body returning *CreateRouteResponse
func (c *ClientWithResponses) CreateRouteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRouteResponse, error) {
	rsp, err := c.CreateRouteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRouteResponse(rsp)
}

func (c *ClientWithResponses) CreateRouteWithResponse(ctx context.Context, body CreateRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRouteResponse, error) {
	rsp, err := c.CreateRoute(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRouteResponse(rsp)
}

// DeleteRouteWithBodyWithResponse request with arbitrary body returning *DeleteRouteResponse
func (c *ClientWithResponses) DeleteRouteWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteRouteResponse, error) {
	rsp, err := c.DeleteRouteWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRouteResponse(rsp)
}

func (c *ClientWithResponses) DeleteRouteWithResponse(ctx context.Context, id string, body DeleteRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteRouteResponse, error) {
	rsp, err := c.DeleteRoute(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRouteResponse(rsp)
}

// UpdateRouteWithBodyWithResponse request with arbitrary body returning *UpdateRouteResponse
func (c *ClientWithResponses) UpdateRouteWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRouteResponse, error) {
	rsp, err := c.UpdateRouteWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRouteResponse(rsp)
}

func (c *ClientWithResponses) UpdateRouteWithResponse(ctx context.Context, id string, body UpdateRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRouteResponse, error) {
	rsp, err := c.UpdateRoute(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRouteResponse(rsp)
}

// CreateSecurityGroupRuleWithBodyWithResponse request with arbitrary body returning *CreateSecurityGroupRuleResponse
func (c *ClientWithResponses) CreateSecurityGroupRuleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSecurityGroupRuleResponse, error) {
	rsp, err := c.CreateSecurityGroupRuleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSecurityGroupRuleResponse(rsp)
}

func (c *ClientWithResponses) CreateSecurityGroupRuleWithResponse(ctx context.Context, body CreateSecurityGroupRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSecurityGroupRuleResponse, error) {
	rsp, err := c.CreateSecurityGroupRule(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSecurityGroupRuleResponse(rsp)
}

// DeleteSecurityGroupRuleWithBodyWithResponse request with arbitrary body returning *DeleteSecurityGroupRuleResponse
func (c *ClientWithResponses) DeleteSecurityGroupRuleWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteSecurityGroupRuleResponse, error) {
	rsp, err := c.DeleteSecurityGroupRuleWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSecurityGroupRuleResponse(rsp)
}

func (c *ClientWithResponses) DeleteSecurityGroupRuleWithResponse(ctx context.Context, id string, body DeleteSecurityGroupRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteSecurityGroupRuleResponse, error) {
	rsp, err := c.DeleteSecurityGroupRule(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSecurityGroupRuleResponse(rsp)
}

// ReadSecurityGroupsWithResponse request returning *ReadSecurityGroupsResponse
func (c *ClientWithResponses) ReadSecurityGroupsWithResponse(ctx context.Context, params *ReadSecurityGroupsParams, reqEditors ...RequestEditorFn) (*ReadSecurityGroupsResponse, error) {
	rsp, err := c.ReadSecurityGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadSecurityGroupsResponse(rsp)
}

// CreateSecurityGroupWithBodyWithResponse request with arbitrary body returning *CreateSecurityGroupResponse
func (c *ClientWithResponses) CreateSecurityGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSecurityGroupResponse, error) {
	rsp, err := c.CreateSecurityGroupWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSecurityGroupResponse(rsp)
}

func (c *ClientWithResponses) CreateSecurityGroupWithResponse(ctx context.Context, body CreateSecurityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSecurityGroupResponse, error) {
	rsp, err := c.CreateSecurityGroup(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSecurityGroupResponse(rsp)
}

// DeleteSecurityGroupWithBodyWithResponse request with arbitrary body returning *DeleteSecurityGroupResponse
func (c *ClientWithResponses) DeleteSecurityGroupWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteSecurityGroupResponse, error) {
	rsp, err := c.DeleteSecurityGroupWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSecurityGroupResponse(rsp)
}

func (c *ClientWithResponses) DeleteSecurityGroupWithResponse(ctx context.Context, id string, body DeleteSecurityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteSecurityGroupResponse, error) {
	rsp, err := c.DeleteSecurityGroup(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSecurityGroupResponse(rsp)
}

// ReadSecurityGroupsByIdWithResponse request returning *ReadSecurityGroupsByIdResponse
func (c *ClientWithResponses) ReadSecurityGroupsByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadSecurityGroupsByIdResponse, error) {
	rsp, err := c.ReadSecurityGroupsById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadSecurityGroupsByIdResponse(rsp)
}

// ReadSnapshotsWithResponse request returning *ReadSnapshotsResponse
func (c *ClientWithResponses) ReadSnapshotsWithResponse(ctx context.Context, params *ReadSnapshotsParams, reqEditors ...RequestEditorFn) (*ReadSnapshotsResponse, error) {
	rsp, err := c.ReadSnapshots(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadSnapshotsResponse(rsp)
}

// CreateSnapshotWithBodyWithResponse request with arbitrary body returning *CreateSnapshotResponse
func (c *ClientWithResponses) CreateSnapshotWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSnapshotResponse, error) {
	rsp, err := c.CreateSnapshotWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSnapshotResponse(rsp)
}

func (c *ClientWithResponses) CreateSnapshotWithResponse(ctx context.Context, body CreateSnapshotJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSnapshotResponse, error) {
	rsp, err := c.CreateSnapshot(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSnapshotResponse(rsp)
}

// DeleteSnapshotWithResponse request returning *DeleteSnapshotResponse
func (c *ClientWithResponses) DeleteSnapshotWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSnapshotResponse, error) {
	rsp, err := c.DeleteSnapshot(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSnapshotResponse(rsp)
}

// ReadSnapshotsByIdWithResponse request returning *ReadSnapshotsByIdResponse
func (c *ClientWithResponses) ReadSnapshotsByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadSnapshotsByIdResponse, error) {
	rsp, err := c.ReadSnapshotsById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadSnapshotsByIdResponse(rsp)
}

// StartVmsWithBodyWithResponse request with arbitrary body returning *StartVmsResponse
func (c *ClientWithResponses) StartVmsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartVmsResponse, error) {
	rsp, err := c.StartVmsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartVmsResponse(rsp)
}

func (c *ClientWithResponses) StartVmsWithResponse(ctx context.Context, body StartVmsJSONRequestBody, reqEditors ...RequestEditorFn) (*StartVmsResponse, error) {
	rsp, err := c.StartVms(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartVmsResponse(rsp)
}

// StopVmsWithBodyWithResponse request with arbitrary body returning *StopVmsResponse
func (c *ClientWithResponses) StopVmsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StopVmsResponse, error) {
	rsp, err := c.StopVmsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopVmsResponse(rsp)
}

func (c *ClientWithResponses) StopVmsWithResponse(ctx context.Context, body StopVmsJSONRequestBody, reqEditors ...RequestEditorFn) (*StopVmsResponse, error) {
	rsp, err := c.StopVms(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopVmsResponse(rsp)
}

// ReadSubnetsWithResponse request returning *ReadSubnetsResponse
func (c *ClientWithResponses) ReadSubnetsWithResponse(ctx context.Context, params *ReadSubnetsParams, reqEditors ...RequestEditorFn) (*ReadSubnetsResponse, error) {
	rsp, err := c.ReadSubnets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadSubnetsResponse(rsp)
}

// CreateSubnetWithBodyWithResponse request with arbitrary body returning *CreateSubnetResponse
func (c *ClientWithResponses) CreateSubnetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSubnetResponse, error) {
	rsp, err := c.CreateSubnetWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSubnetResponse(rsp)
}

func (c *ClientWithResponses) CreateSubnetWithResponse(ctx context.Context, body CreateSubnetJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSubnetResponse, error) {
	rsp, err := c.CreateSubnet(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSubnetResponse(rsp)
}

// DeleteSubnetWithResponse request returning *DeleteSubnetResponse
func (c *ClientWithResponses) DeleteSubnetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSubnetResponse, error) {
	rsp, err := c.DeleteSubnet(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSubnetResponse(rsp)
}

// ReadSubnetsByIdWithResponse request returning *ReadSubnetsByIdResponse
func (c *ClientWithResponses) ReadSubnetsByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadSubnetsByIdResponse, error) {
	rsp, err := c.ReadSubnetsById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadSubnetsByIdResponse(rsp)
}

// UpdateSubnetWithBodyWithResponse request with arbitrary body returning *UpdateSubnetResponse
func (c *ClientWithResponses) UpdateSubnetWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSubnetResponse, error) {
	rsp, err := c.UpdateSubnetWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSubnetResponse(rsp)
}

func (c *ClientWithResponses) UpdateSubnetWithResponse(ctx context.Context, id string, body UpdateSubnetJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSubnetResponse, error) {
	rsp, err := c.UpdateSubnet(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSubnetResponse(rsp)
}

// ReadTagsWithResponse request returning *ReadTagsResponse
func (c *ClientWithResponses) ReadTagsWithResponse(ctx context.Context, params *ReadTagsParams, reqEditors ...RequestEditorFn) (*ReadTagsResponse, error) {
	rsp, err := c.ReadTags(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadTagsResponse(rsp)
}

// CreateTagsWithBodyWithResponse request with arbitrary body returning *CreateTagsResponse
func (c *ClientWithResponses) CreateTagsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTagsResponse, error) {
	rsp, err := c.CreateTagsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTagsResponse(rsp)
}

func (c *ClientWithResponses) CreateTagsWithResponse(ctx context.Context, body CreateTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTagsResponse, error) {
	rsp, err := c.CreateTags(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTagsResponse(rsp)
}

// DeleteTagsWithBodyWithResponse request with arbitrary body returning *DeleteTagsResponse
func (c *ClientWithResponses) DeleteTagsWithBodyWithResponse(ctx context.Context, id []interface{}, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteTagsResponse, error) {
	rsp, err := c.DeleteTagsWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTagsResponse(rsp)
}

func (c *ClientWithResponses) DeleteTagsWithResponse(ctx context.Context, id []interface{}, body DeleteTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteTagsResponse, error) {
	rsp, err := c.DeleteTags(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTagsResponse(rsp)
}

// ReadTagsByIdWithResponse request returning *ReadTagsByIdResponse
func (c *ClientWithResponses) ReadTagsByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadTagsByIdResponse, error) {
	rsp, err := c.ReadTagsById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadTagsByIdResponse(rsp)
}

// ReadVirtualGatewaysWithResponse request returning *ReadVirtualGatewaysResponse
func (c *ClientWithResponses) ReadVirtualGatewaysWithResponse(ctx context.Context, params *ReadVirtualGatewaysParams, reqEditors ...RequestEditorFn) (*ReadVirtualGatewaysResponse, error) {
	rsp, err := c.ReadVirtualGateways(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVirtualGatewaysResponse(rsp)
}

// CreateVirtualGatewayWithBodyWithResponse request with arbitrary body returning *CreateVirtualGatewayResponse
func (c *ClientWithResponses) CreateVirtualGatewayWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVirtualGatewayResponse, error) {
	rsp, err := c.CreateVirtualGatewayWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVirtualGatewayResponse(rsp)
}

func (c *ClientWithResponses) CreateVirtualGatewayWithResponse(ctx context.Context, body CreateVirtualGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVirtualGatewayResponse, error) {
	rsp, err := c.CreateVirtualGateway(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVirtualGatewayResponse(rsp)
}

// DeleteVirtualGatewayWithResponse request returning *DeleteVirtualGatewayResponse
func (c *ClientWithResponses) DeleteVirtualGatewayWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteVirtualGatewayResponse, error) {
	rsp, err := c.DeleteVirtualGateway(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVirtualGatewayResponse(rsp)
}

// ReadVirtualGatewaysByIdWithResponse request returning *ReadVirtualGatewaysByIdResponse
func (c *ClientWithResponses) ReadVirtualGatewaysByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadVirtualGatewaysByIdResponse, error) {
	rsp, err := c.ReadVirtualGatewaysById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVirtualGatewaysByIdResponse(rsp)
}

// LinkVirtualGatewayWithBodyWithResponse request with arbitrary body returning *LinkVirtualGatewayResponse
func (c *ClientWithResponses) LinkVirtualGatewayWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkVirtualGatewayResponse, error) {
	rsp, err := c.LinkVirtualGatewayWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkVirtualGatewayResponse(rsp)
}

func (c *ClientWithResponses) LinkVirtualGatewayWithResponse(ctx context.Context, id string, body LinkVirtualGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkVirtualGatewayResponse, error) {
	rsp, err := c.LinkVirtualGateway(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkVirtualGatewayResponse(rsp)
}

// UnlinkVirtualGatewayWithBodyWithResponse request with arbitrary body returning *UnlinkVirtualGatewayResponse
func (c *ClientWithResponses) UnlinkVirtualGatewayWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkVirtualGatewayResponse, error) {
	rsp, err := c.UnlinkVirtualGatewayWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkVirtualGatewayResponse(rsp)
}

func (c *ClientWithResponses) UnlinkVirtualGatewayWithResponse(ctx context.Context, id string, body UnlinkVirtualGatewayJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkVirtualGatewayResponse, error) {
	rsp, err := c.UnlinkVirtualGateway(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkVirtualGatewayResponse(rsp)
}

// ReadVmsWithResponse request returning *ReadVmsResponse
func (c *ClientWithResponses) ReadVmsWithResponse(ctx context.Context, params *ReadVmsParams, reqEditors ...RequestEditorFn) (*ReadVmsResponse, error) {
	rsp, err := c.ReadVms(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVmsResponse(rsp)
}

// CreateVmsWithBodyWithResponse request with arbitrary body returning *CreateVmsResponse
func (c *ClientWithResponses) CreateVmsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVmsResponse, error) {
	rsp, err := c.CreateVmsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVmsResponse(rsp)
}

func (c *ClientWithResponses) CreateVmsWithResponse(ctx context.Context, body CreateVmsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVmsResponse, error) {
	rsp, err := c.CreateVms(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVmsResponse(rsp)
}

// DeleteVmsWithResponse request returning *DeleteVmsResponse
func (c *ClientWithResponses) DeleteVmsWithResponse(ctx context.Context, id []interface{}, reqEditors ...RequestEditorFn) (*DeleteVmsResponse, error) {
	rsp, err := c.DeleteVms(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVmsResponse(rsp)
}

// ReadVmsByIdWithResponse request returning *ReadVmsByIdResponse
func (c *ClientWithResponses) ReadVmsByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadVmsByIdResponse, error) {
	rsp, err := c.ReadVmsById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVmsByIdResponse(rsp)
}

// UpdateVmWithBodyWithResponse request with arbitrary body returning *UpdateVmResponse
func (c *ClientWithResponses) UpdateVmWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVmResponse, error) {
	rsp, err := c.UpdateVmWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVmResponse(rsp)
}

func (c *ClientWithResponses) UpdateVmWithResponse(ctx context.Context, id string, body UpdateVmJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVmResponse, error) {
	rsp, err := c.UpdateVm(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVmResponse(rsp)
}

// ReadVmsHealthWithBodyWithResponse request with arbitrary body returning *ReadVmsHealthResponse
func (c *ClientWithResponses) ReadVmsHealthWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReadVmsHealthResponse, error) {
	rsp, err := c.ReadVmsHealthWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVmsHealthResponse(rsp)
}

func (c *ClientWithResponses) ReadVmsHealthWithResponse(ctx context.Context, body ReadVmsHealthJSONRequestBody, reqEditors ...RequestEditorFn) (*ReadVmsHealthResponse, error) {
	rsp, err := c.ReadVmsHealth(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVmsHealthResponse(rsp)
}

// ReadVmsHealthByIdWithResponse request returning *ReadVmsHealthByIdResponse
func (c *ClientWithResponses) ReadVmsHealthByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadVmsHealthByIdResponse, error) {
	rsp, err := c.ReadVmsHealthById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVmsHealthByIdResponse(rsp)
}

// ReadVmsStateWithResponse request returning *ReadVmsStateResponse
func (c *ClientWithResponses) ReadVmsStateWithResponse(ctx context.Context, params *ReadVmsStateParams, reqEditors ...RequestEditorFn) (*ReadVmsStateResponse, error) {
	rsp, err := c.ReadVmsState(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVmsStateResponse(rsp)
}

// ReadVmsStateByIdWithResponse request returning *ReadVmsStateByIdResponse
func (c *ClientWithResponses) ReadVmsStateByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadVmsStateByIdResponse, error) {
	rsp, err := c.ReadVmsStateById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVmsStateByIdResponse(rsp)
}

// ReadVolumesWithResponse request returning *ReadVolumesResponse
func (c *ClientWithResponses) ReadVolumesWithResponse(ctx context.Context, params *ReadVolumesParams, reqEditors ...RequestEditorFn) (*ReadVolumesResponse, error) {
	rsp, err := c.ReadVolumes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVolumesResponse(rsp)
}

// CreateVolumeWithBodyWithResponse request with arbitrary body returning *CreateVolumeResponse
func (c *ClientWithResponses) CreateVolumeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVolumeResponse, error) {
	rsp, err := c.CreateVolumeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVolumeResponse(rsp)
}

func (c *ClientWithResponses) CreateVolumeWithResponse(ctx context.Context, body CreateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVolumeResponse, error) {
	rsp, err := c.CreateVolume(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVolumeResponse(rsp)
}

// DeleteVolumeWithResponse request returning *DeleteVolumeResponse
func (c *ClientWithResponses) DeleteVolumeWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteVolumeResponse, error) {
	rsp, err := c.DeleteVolume(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVolumeResponse(rsp)
}

// ReadVolumesByIdWithResponse request returning *ReadVolumesByIdResponse
func (c *ClientWithResponses) ReadVolumesByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadVolumesByIdResponse, error) {
	rsp, err := c.ReadVolumesById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVolumesByIdResponse(rsp)
}

// UpdateVolumeWithBodyWithResponse request with arbitrary body returning *UpdateVolumeResponse
func (c *ClientWithResponses) UpdateVolumeWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVolumeResponse, error) {
	rsp, err := c.UpdateVolumeWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVolumeResponse(rsp)
}

func (c *ClientWithResponses) UpdateVolumeWithResponse(ctx context.Context, id string, body UpdateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVolumeResponse, error) {
	rsp, err := c.UpdateVolume(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVolumeResponse(rsp)
}

// LinkVolumeWithBodyWithResponse request with arbitrary body returning *LinkVolumeResponse
func (c *ClientWithResponses) LinkVolumeWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkVolumeResponse, error) {
	rsp, err := c.LinkVolumeWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkVolumeResponse(rsp)
}

func (c *ClientWithResponses) LinkVolumeWithResponse(ctx context.Context, id string, body LinkVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkVolumeResponse, error) {
	rsp, err := c.LinkVolume(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkVolumeResponse(rsp)
}

// UnlinkVolumeWithBodyWithResponse request with arbitrary body returning *UnlinkVolumeResponse
func (c *ClientWithResponses) UnlinkVolumeWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnlinkVolumeResponse, error) {
	rsp, err := c.UnlinkVolumeWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkVolumeResponse(rsp)
}

func (c *ClientWithResponses) UnlinkVolumeWithResponse(ctx context.Context, id string, body UnlinkVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*UnlinkVolumeResponse, error) {
	rsp, err := c.UnlinkVolume(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkVolumeResponse(rsp)
}

// CreateVpnConnectionRouteWithBodyWithResponse request with arbitrary body returning *CreateVpnConnectionRouteResponse
func (c *ClientWithResponses) CreateVpnConnectionRouteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVpnConnectionRouteResponse, error) {
	rsp, err := c.CreateVpnConnectionRouteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVpnConnectionRouteResponse(rsp)
}

func (c *ClientWithResponses) CreateVpnConnectionRouteWithResponse(ctx context.Context, body CreateVpnConnectionRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVpnConnectionRouteResponse, error) {
	rsp, err := c.CreateVpnConnectionRoute(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVpnConnectionRouteResponse(rsp)
}

// DeleteVpnConnectionRouteWithBodyWithResponse request with arbitrary body returning *DeleteVpnConnectionRouteResponse
func (c *ClientWithResponses) DeleteVpnConnectionRouteWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteVpnConnectionRouteResponse, error) {
	rsp, err := c.DeleteVpnConnectionRouteWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVpnConnectionRouteResponse(rsp)
}

func (c *ClientWithResponses) DeleteVpnConnectionRouteWithResponse(ctx context.Context, id string, body DeleteVpnConnectionRouteJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteVpnConnectionRouteResponse, error) {
	rsp, err := c.DeleteVpnConnectionRoute(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVpnConnectionRouteResponse(rsp)
}

// ReadVpnConnectionsWithResponse request returning *ReadVpnConnectionsResponse
func (c *ClientWithResponses) ReadVpnConnectionsWithResponse(ctx context.Context, params *ReadVpnConnectionsParams, reqEditors ...RequestEditorFn) (*ReadVpnConnectionsResponse, error) {
	rsp, err := c.ReadVpnConnections(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVpnConnectionsResponse(rsp)
}

// CreateVpnConnectionWithBodyWithResponse request with arbitrary body returning *CreateVpnConnectionResponse
func (c *ClientWithResponses) CreateVpnConnectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVpnConnectionResponse, error) {
	rsp, err := c.CreateVpnConnectionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVpnConnectionResponse(rsp)
}

func (c *ClientWithResponses) CreateVpnConnectionWithResponse(ctx context.Context, body CreateVpnConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVpnConnectionResponse, error) {
	rsp, err := c.CreateVpnConnection(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVpnConnectionResponse(rsp)
}

// DeleteVpnConnectionWithResponse request returning *DeleteVpnConnectionResponse
func (c *ClientWithResponses) DeleteVpnConnectionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteVpnConnectionResponse, error) {
	rsp, err := c.DeleteVpnConnection(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVpnConnectionResponse(rsp)
}

// ReadVpnConnectionsByIdWithResponse request returning *ReadVpnConnectionsByIdResponse
func (c *ClientWithResponses) ReadVpnConnectionsByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReadVpnConnectionsByIdResponse, error) {
	rsp, err := c.ReadVpnConnectionsById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadVpnConnectionsByIdResponse(rsp)
}

// UpdateVpnConnectionWithBodyWithResponse request with arbitrary body returning *UpdateVpnConnectionResponse
func (c *ClientWithResponses) UpdateVpnConnectionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVpnConnectionResponse, error) {
	rsp, err := c.UpdateVpnConnectionWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVpnConnectionResponse(rsp)
}

func (c *ClientWithResponses) UpdateVpnConnectionWithResponse(ctx context.Context, id string, body UpdateVpnConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVpnConnectionResponse, error) {
	rsp, err := c.UpdateVpnConnection(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVpnConnectionResponse(rsp)
}

// ParseAcceptNetPeeringResponse parses an HTTP response from a AcceptNetPeeringWithResponse call
func ParseAcceptNetPeeringResponse(rsp *http.Response) (*AcceptNetPeeringResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AcceptNetPeeringResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AcceptNetPeeringResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReadAdminPasswordResponse parses an HTTP response from a ReadAdminPasswordWithResponse call
func ParseReadAdminPasswordResponse(rsp *http.Response) (*ReadAdminPasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadAdminPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadAdminPasswordResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReadAdminPasswordByIdResponse parses an HTTP response from a ReadAdminPasswordByIdWithResponse call
func ParseReadAdminPasswordByIdResponse(rsp *http.Response) (*ReadAdminPasswordByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadAdminPasswordByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadAdminPasswordResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReadClientGatewaysResponse parses an HTTP response from a ReadClientGatewaysWithResponse call
func ParseReadClientGatewaysResponse(rsp *http.Response) (*ReadClientGatewaysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadClientGatewaysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadClientGatewaysResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateClientGatewayResponse parses an HTTP response from a CreateClientGatewayWithResponse call
func ParseCreateClientGatewayResponse(rsp *http.Response) (*CreateClientGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateClientGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClientGatewaySchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteClientGatewayResponse parses an HTTP response from a DeleteClientGatewayWithResponse call
func ParseDeleteClientGatewayResponse(rsp *http.Response) (*DeleteClientGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClientGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReadClientGatewaysByIdResponse parses an HTTP response from a ReadClientGatewaysByIdWithResponse call
func ParseReadClientGatewaysByIdResponse(rsp *http.Response) (*ReadClientGatewaysByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadClientGatewaysByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClientGatewaySchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReadConsoleOutputResponse parses an HTTP response from a ReadConsoleOutputWithResponse call
func ParseReadConsoleOutputResponse(rsp *http.Response) (*ReadConsoleOutputResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadConsoleOutputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadConsoleOutputResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReadConsoleOutputByIdResponse parses an HTTP response from a ReadConsoleOutputByIdWithResponse call
func ParseReadConsoleOutputByIdResponse(rsp *http.Response) (*ReadConsoleOutputByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadConsoleOutputByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadConsoleOutputResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReadDhcpOptionsResponse parses an HTTP response from a ReadDhcpOptionsWithResponse call
func ParseReadDhcpOptionsResponse(rsp *http.Response) (*ReadDhcpOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadDhcpOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadDhcpOptionsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateDhcpOptionsResponse parses an HTTP response from a CreateDhcpOptionsWithResponse call
func ParseCreateDhcpOptionsResponse(rsp *http.Response) (*CreateDhcpOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDhcpOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DhcpOptionsSetSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteDhcpOptionsResponse parses an HTTP response from a DeleteDhcpOptionsWithResponse call
func ParseDeleteDhcpOptionsResponse(rsp *http.Response) (*DeleteDhcpOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDhcpOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReadDhcpOptionsByIdResponse parses an HTTP response from a ReadDhcpOptionsByIdWithResponse call
func ParseReadDhcpOptionsByIdResponse(rsp *http.Response) (*ReadDhcpOptionsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadDhcpOptionsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DhcpOptionsSetSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReadDirectLinkInterfacesResponse parses an HTTP response from a ReadDirectLinkInterfacesWithResponse call
func ParseReadDirectLinkInterfacesResponse(rsp *http.Response) (*ReadDirectLinkInterfacesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadDirectLinkInterfacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadDirectLinkInterfacesResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateDirectLinkInterfaceResponse parses an HTTP response from a CreateDirectLinkInterfaceWithResponse call
func ParseCreateDirectLinkInterfaceResponse(rsp *http.Response) (*CreateDirectLinkInterfaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDirectLinkInterfaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DirectLinkInterfacesSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteDirectLinkInterfaceResponse parses an HTTP response from a DeleteDirectLinkInterfaceWithResponse call
func ParseDeleteDirectLinkInterfaceResponse(rsp *http.Response) (*DeleteDirectLinkInterfaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDirectLinkInterfaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReadDirectLinkInterfacesByIdResponse parses an HTTP response from a ReadDirectLinkInterfacesByIdWithResponse call
func ParseReadDirectLinkInterfacesByIdResponse(rsp *http.Response) (*ReadDirectLinkInterfacesByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadDirectLinkInterfacesByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DirectLinkInterfacesSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateDirectLinkInterfaceResponse parses an HTTP response from a UpdateDirectLinkInterfaceWithResponse call
func ParseUpdateDirectLinkInterfaceResponse(rsp *http.Response) (*UpdateDirectLinkInterfaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDirectLinkInterfaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateDirectLinkInterfaceResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReadDirectLinksResponse parses an HTTP response from a ReadDirectLinksWithResponse call
func ParseReadDirectLinksResponse(rsp *http.Response) (*ReadDirectLinksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadDirectLinksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadDirectLinksResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateDirectLinkResponse parses an HTTP response from a CreateDirectLinkWithResponse call
func ParseCreateDirectLinkResponse(rsp *http.Response) (*CreateDirectLinkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDirectLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DirectLinkSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteDirectLinkResponse parses an HTTP response from a DeleteDirectLinkWithResponse call
func ParseDeleteDirectLinkResponse(rsp *http.Response) (*DeleteDirectLinkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDirectLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReadDirectLinksByIdResponse parses an HTTP response from a ReadDirectLinksByIdWithResponse call
func ParseReadDirectLinksByIdResponse(rsp *http.Response) (*ReadDirectLinksByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadDirectLinksByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DirectLinkSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReadFlexibleGpuCatalogResponse parses an HTTP response from a ReadFlexibleGpuCatalogWithResponse call
func ParseReadFlexibleGpuCatalogResponse(rsp *http.Response) (*ReadFlexibleGpuCatalogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadFlexibleGpuCatalogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadFlexibleGpuCatalogResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReadFlexibleGpuCatalogByIdResponse parses an HTTP response from a ReadFlexibleGpuCatalogByIdWithResponse call
func ParseReadFlexibleGpuCatalogByIdResponse(rsp *http.Response) (*ReadFlexibleGpuCatalogByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadFlexibleGpuCatalogByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FlexibleGpuCatalogSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReadFlexibleGpusResponse parses an HTTP response from a ReadFlexibleGpusWithResponse call
func ParseReadFlexibleGpusResponse(rsp *http.Response) (*ReadFlexibleGpusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadFlexibleGpusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadFlexibleGpusResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateFlexibleGpuResponse parses an HTTP response from a CreateFlexibleGpuWithResponse call
func ParseCreateFlexibleGpuResponse(rsp *http.Response) (*CreateFlexibleGpuResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFlexibleGpuResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FlexibleGpuSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteFlexibleGpuResponse parses an HTTP response from a DeleteFlexibleGpuWithResponse call
func ParseDeleteFlexibleGpuResponse(rsp *http.Response) (*DeleteFlexibleGpuResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFlexibleGpuResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReadFlexibleGpusByIdResponse parses an HTTP response from a ReadFlexibleGpusByIdWithResponse call
func ParseReadFlexibleGpusByIdResponse(rsp *http.Response) (*ReadFlexibleGpusByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadFlexibleGpusByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FlexibleGpuSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateFlexibleGpuResponse parses an HTTP response from a UpdateFlexibleGpuWithResponse call
func ParseUpdateFlexibleGpuResponse(rsp *http.Response) (*UpdateFlexibleGpuResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateFlexibleGpuResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateFlexibleGpuResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLinkFlexibleGpuResponse parses an HTTP response from a LinkFlexibleGpuWithResponse call
func ParseLinkFlexibleGpuResponse(rsp *http.Response) (*LinkFlexibleGpuResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkFlexibleGpuResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUnlinkFlexibleGpuResponse parses an HTTP response from a UnlinkFlexibleGpuWithResponse call
func ParseUnlinkFlexibleGpuResponse(rsp *http.Response) (*UnlinkFlexibleGpuResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkFlexibleGpuResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReadImagesResponse parses an HTTP response from a ReadImagesWithResponse call
func ParseReadImagesResponse(rsp *http.Response) (*ReadImagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadImagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadImagesResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateImageResponse parses an HTTP response from a CreateImageWithResponse call
func ParseCreateImageResponse(rsp *http.Response) (*CreateImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ImageSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteImageResponse parses an HTTP response from a DeleteImageWithResponse call
func ParseDeleteImageResponse(rsp *http.Response) (*DeleteImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReadImagesByIdResponse parses an HTTP response from a ReadImagesByIdWithResponse call
func ParseReadImagesByIdResponse(rsp *http.Response) (*ReadImagesByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadImagesByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ImageSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateImageResponse parses an HTTP response from a UpdateImageWithResponse call
func ParseUpdateImageResponse(rsp *http.Response) (*UpdateImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateImageResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReadInternetServicesResponse parses an HTTP response from a ReadInternetServicesWithResponse call
func ParseReadInternetServicesResponse(rsp *http.Response) (*ReadInternetServicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadInternetServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadInternetServicesResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateInternetServiceResponse parses an HTTP response from a CreateInternetServiceWithResponse call
func ParseCreateInternetServiceResponse(rsp *http.Response) (*CreateInternetServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateInternetServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InternetServiceSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteInternetServiceResponse parses an HTTP response from a DeleteInternetServiceWithResponse call
func ParseDeleteInternetServiceResponse(rsp *http.Response) (*DeleteInternetServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteInternetServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReadInternetServicesByIdResponse parses an HTTP response from a ReadInternetServicesByIdWithResponse call
func ParseReadInternetServicesByIdResponse(rsp *http.Response) (*ReadInternetServicesByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadInternetServicesByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InternetServiceSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLinkInternetServiceResponse parses an HTTP response from a LinkInternetServiceWithResponse call
func ParseLinkInternetServiceResponse(rsp *http.Response) (*LinkInternetServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkInternetServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUnlinkInternetServiceResponse parses an HTTP response from a UnlinkInternetServiceWithResponse call
func ParseUnlinkInternetServiceResponse(rsp *http.Response) (*UnlinkInternetServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkInternetServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReadKeypairsResponse parses an HTTP response from a ReadKeypairsWithResponse call
func ParseReadKeypairsResponse(rsp *http.Response) (*ReadKeypairsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadKeypairsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadKeypairsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateKeypairResponse parses an HTTP response from a CreateKeypairWithResponse call
func ParseCreateKeypairResponse(rsp *http.Response) (*CreateKeypairResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateKeypairResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeypairCreatedSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteKeypairResponse parses an HTTP response from a DeleteKeypairWithResponse call
func ParseDeleteKeypairResponse(rsp *http.Response) (*DeleteKeypairResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteKeypairResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReadKeypairsByIdResponse parses an HTTP response from a ReadKeypairsByIdWithResponse call
func ParseReadKeypairsByIdResponse(rsp *http.Response) (*ReadKeypairsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadKeypairsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeypairSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReadListenerRulesResponse parses an HTTP response from a ReadListenerRulesWithResponse call
func ParseReadListenerRulesResponse(rsp *http.Response) (*ReadListenerRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadListenerRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadListenerRulesResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateListenerRuleResponse parses an HTTP response from a CreateListenerRuleWithResponse call
func ParseCreateListenerRuleResponse(rsp *http.Response) (*CreateListenerRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateListenerRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListenerRuleSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteListenerRuleResponse parses an HTTP response from a DeleteListenerRuleWithResponse call
func ParseDeleteListenerRuleResponse(rsp *http.Response) (*DeleteListenerRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteListenerRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReadListenerRulesByIdResponse parses an HTTP response from a ReadListenerRulesByIdWithResponse call
func ParseReadListenerRulesByIdResponse(rsp *http.Response) (*ReadListenerRulesByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadListenerRulesByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListenerRuleSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateListenerRuleResponse parses an HTTP response from a UpdateListenerRuleWithResponse call
func ParseUpdateListenerRuleResponse(rsp *http.Response) (*UpdateListenerRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateListenerRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateListenerRuleResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLinkLoadBalancerBackendMachinesResponse parses an HTTP response from a LinkLoadBalancerBackendMachinesWithResponse call
func ParseLinkLoadBalancerBackendMachinesResponse(rsp *http.Response) (*LinkLoadBalancerBackendMachinesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkLoadBalancerBackendMachinesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUnlinkLoadBalancerBackendMachinesResponse parses an HTTP response from a UnlinkLoadBalancerBackendMachinesWithResponse call
func ParseUnlinkLoadBalancerBackendMachinesResponse(rsp *http.Response) (*UnlinkLoadBalancerBackendMachinesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkLoadBalancerBackendMachinesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateLoadBalancerListenersResponse parses an HTTP response from a CreateLoadBalancerListenersWithResponse call
func ParseCreateLoadBalancerListenersResponse(rsp *http.Response) (*CreateLoadBalancerListenersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLoadBalancerListenersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoadBalancerSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteLoadBalancerListenersResponse parses an HTTP response from a DeleteLoadBalancerListenersWithResponse call
func ParseDeleteLoadBalancerListenersResponse(rsp *http.Response) (*DeleteLoadBalancerListenersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLoadBalancerListenersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest DeleteLoadBalancerListenersResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	}

	return response, nil
}

// ParseCreateLoadBalancerPolicyResponse parses an HTTP response from a CreateLoadBalancerPolicyWithResponse call
func ParseCreateLoadBalancerPolicyResponse(rsp *http.Response) (*CreateLoadBalancerPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLoadBalancerPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoadBalancerSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteLoadBalancerPolicyResponse parses an HTTP response from a DeleteLoadBalancerPolicyWithResponse call
func ParseDeleteLoadBalancerPolicyResponse(rsp *http.Response) (*DeleteLoadBalancerPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLoadBalancerPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest DeleteLoadBalancerPolicyResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	}

	return response, nil
}

// ParseReadLoadBalancerTagsResponse parses an HTTP response from a ReadLoadBalancerTagsWithResponse call
func ParseReadLoadBalancerTagsResponse(rsp *http.Response) (*ReadLoadBalancerTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadLoadBalancerTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadLoadBalancerTagsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateLoadBalancerTagsResponse parses an HTTP response from a CreateLoadBalancerTagsWithResponse call
func ParseCreateLoadBalancerTagsResponse(rsp *http.Response) (*CreateLoadBalancerTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLoadBalancerTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteLoadBalancerTagsResponse parses an HTTP response from a DeleteLoadBalancerTagsWithResponse call
func ParseDeleteLoadBalancerTagsResponse(rsp *http.Response) (*DeleteLoadBalancerTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLoadBalancerTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReadLoadBalancerTagsByIdResponse parses an HTTP response from a ReadLoadBalancerTagsByIdWithResponse call
func ParseReadLoadBalancerTagsByIdResponse(rsp *http.Response) (*ReadLoadBalancerTagsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadLoadBalancerTagsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoadBalancerTagSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReadLoadBalancersResponse parses an HTTP response from a ReadLoadBalancersWithResponse call
func ParseReadLoadBalancersResponse(rsp *http.Response) (*ReadLoadBalancersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadLoadBalancersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadLoadBalancersResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateLoadBalancerResponse parses an HTTP response from a CreateLoadBalancerWithResponse call
func ParseCreateLoadBalancerResponse(rsp *http.Response) (*CreateLoadBalancerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLoadBalancerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoadBalancerSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteLoadBalancerResponse parses an HTTP response from a DeleteLoadBalancerWithResponse call
func ParseDeleteLoadBalancerResponse(rsp *http.Response) (*DeleteLoadBalancerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLoadBalancerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReadLoadBalancersByIdResponse parses an HTTP response from a ReadLoadBalancersByIdWithResponse call
func ParseReadLoadBalancersByIdResponse(rsp *http.Response) (*ReadLoadBalancersByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadLoadBalancersByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoadBalancerSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateLoadBalancerResponse parses an HTTP response from a UpdateLoadBalancerWithResponse call
func ParseUpdateLoadBalancerResponse(rsp *http.Response) (*UpdateLoadBalancerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateLoadBalancerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateLoadBalancerResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReadLocationsResponse parses an HTTP response from a ReadLocationsWithResponse call
func ParseReadLocationsResponse(rsp *http.Response) (*ReadLocationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadLocationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadLocationsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReadLocationsByIdResponse parses an HTTP response from a ReadLocationsByIdWithResponse call
func ParseReadLocationsByIdResponse(rsp *http.Response) (*ReadLocationsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadLocationsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LocationSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReadNatServicesResponse parses an HTTP response from a ReadNatServicesWithResponse call
func ParseReadNatServicesResponse(rsp *http.Response) (*ReadNatServicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadNatServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadNatServicesResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateNatServiceResponse parses an HTTP response from a CreateNatServiceWithResponse call
func ParseCreateNatServiceResponse(rsp *http.Response) (*CreateNatServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNatServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NatServiceSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteNatServiceResponse parses an HTTP response from a DeleteNatServiceWithResponse call
func ParseDeleteNatServiceResponse(rsp *http.Response) (*DeleteNatServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNatServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReadNatServicesByIdResponse parses an HTTP response from a ReadNatServicesByIdWithResponse call
func ParseReadNatServicesByIdResponse(rsp *http.Response) (*ReadNatServicesByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadNatServicesByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NatServiceSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReadNetAccessPointsResponse parses an HTTP response from a ReadNetAccessPointsWithResponse call
func ParseReadNetAccessPointsResponse(rsp *http.Response) (*ReadNetAccessPointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadNetAccessPointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadNetAccessPointsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateNetAccessPointResponse parses an HTTP response from a CreateNetAccessPointWithResponse call
func ParseCreateNetAccessPointResponse(rsp *http.Response) (*CreateNetAccessPointResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNetAccessPointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NetAccessPointSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteNetAccessPointResponse parses an HTTP response from a DeleteNetAccessPointWithResponse call
func ParseDeleteNetAccessPointResponse(rsp *http.Response) (*DeleteNetAccessPointResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNetAccessPointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReadNetAccessPointsByIdResponse parses an HTTP response from a ReadNetAccessPointsByIdWithResponse call
func ParseReadNetAccessPointsByIdResponse(rsp *http.Response) (*ReadNetAccessPointsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadNetAccessPointsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NetAccessPointSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateNetAccessPointResponse parses an HTTP response from a UpdateNetAccessPointWithResponse call
func ParseUpdateNetAccessPointResponse(rsp *http.Response) (*UpdateNetAccessPointResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateNetAccessPointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateNetAccessPointResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReadNetPeeringsResponse parses an HTTP response from a ReadNetPeeringsWithResponse call
func ParseReadNetPeeringsResponse(rsp *http.Response) (*ReadNetPeeringsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadNetPeeringsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadNetPeeringsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateNetPeeringResponse parses an HTTP response from a CreateNetPeeringWithResponse call
func ParseCreateNetPeeringResponse(rsp *http.Response) (*CreateNetPeeringResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNetPeeringResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NetPeeringSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteNetPeeringResponse parses an HTTP response from a DeleteNetPeeringWithResponse call
func ParseDeleteNetPeeringResponse(rsp *http.Response) (*DeleteNetPeeringResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNetPeeringResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReadNetPeeringsByIdResponse parses an HTTP response from a ReadNetPeeringsByIdWithResponse call
func ParseReadNetPeeringsByIdResponse(rsp *http.Response) (*ReadNetPeeringsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadNetPeeringsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NetPeeringSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReadNetsResponse parses an HTTP response from a ReadNetsWithResponse call
func ParseReadNetsResponse(rsp *http.Response) (*ReadNetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadNetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadNetsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateNetResponse parses an HTTP response from a CreateNetWithResponse call
func ParseCreateNetResponse(rsp *http.Response) (*CreateNetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NetSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteNetResponse parses an HTTP response from a DeleteNetWithResponse call
func ParseDeleteNetResponse(rsp *http.Response) (*DeleteNetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReadNetsByIdResponse parses an HTTP response from a ReadNetsByIdWithResponse call
func ParseReadNetsByIdResponse(rsp *http.Response) (*ReadNetsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadNetsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NetSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateNetResponse parses an HTTP response from a UpdateNetWithResponse call
func ParseUpdateNetResponse(rsp *http.Response) (*UpdateNetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateNetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateNetResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReadNicsResponse parses an HTTP response from a ReadNicsWithResponse call
func ParseReadNicsResponse(rsp *http.Response) (*ReadNicsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadNicsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadNicsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateNicResponse parses an HTTP response from a CreateNicWithResponse call
func ParseCreateNicResponse(rsp *http.Response) (*CreateNicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NicSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteNicResponse parses an HTTP response from a DeleteNicWithResponse call
func ParseDeleteNicResponse(rsp *http.Response) (*DeleteNicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReadNicsByIdResponse parses an HTTP response from a ReadNicsByIdWithResponse call
func ParseReadNicsByIdResponse(rsp *http.Response) (*ReadNicsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadNicsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NicSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateNicResponse parses an HTTP response from a UpdateNicWithResponse call
func ParseUpdateNicResponse(rsp *http.Response) (*UpdateNicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateNicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateNicResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLinkNicResponse parses an HTTP response from a LinkNicWithResponse call
func ParseLinkNicResponse(rsp *http.Response) (*LinkNicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkNicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinkNicResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUnlinkNicResponse parses an HTTP response from a UnlinkNicWithResponse call
func ParseUnlinkNicResponse(rsp *http.Response) (*UnlinkNicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkNicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseLinkPrivateIpsResponse parses an HTTP response from a LinkPrivateIpsWithResponse call
func ParseLinkPrivateIpsResponse(rsp *http.Response) (*LinkPrivateIpsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkPrivateIpsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUnlinkPrivateIpsResponse parses an HTTP response from a UnlinkPrivateIpsWithResponse call
func ParseUnlinkPrivateIpsResponse(rsp *http.Response) (*UnlinkPrivateIpsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkPrivateIpsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReadProductTypesResponse parses an HTTP response from a ReadProductTypesWithResponse call
func ParseReadProductTypesResponse(rsp *http.Response) (*ReadProductTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadProductTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadProductTypesResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReadProductTypesByIdResponse parses an HTTP response from a ReadProductTypesByIdWithResponse call
func ParseReadProductTypesByIdResponse(rsp *http.Response) (*ReadProductTypesByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadProductTypesByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProductTypeSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReadPublicIpRangesResponse parses an HTTP response from a ReadPublicIpRangesWithResponse call
func ParseReadPublicIpRangesResponse(rsp *http.Response) (*ReadPublicIpRangesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadPublicIpRangesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadPublicIpRangesResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReadPublicIpRangesByIdResponse parses an HTTP response from a ReadPublicIpRangesByIdWithResponse call
func ParseReadPublicIpRangesByIdResponse(rsp *http.Response) (*ReadPublicIpRangesByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadPublicIpRangesByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadPublicIpRangesResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReadPublicIpsResponse parses an HTTP response from a ReadPublicIpsWithResponse call
func ParseReadPublicIpsResponse(rsp *http.Response) (*ReadPublicIpsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadPublicIpsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadPublicIpsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreatePublicIpResponse parses an HTTP response from a CreatePublicIpWithResponse call
func ParseCreatePublicIpResponse(rsp *http.Response) (*CreatePublicIpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePublicIpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PublicIpSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeletePublicIpResponse parses an HTTP response from a DeletePublicIpWithResponse call
func ParseDeletePublicIpResponse(rsp *http.Response) (*DeletePublicIpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePublicIpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReadPublicIpsByIdResponse parses an HTTP response from a ReadPublicIpsByIdWithResponse call
func ParseReadPublicIpsByIdResponse(rsp *http.Response) (*ReadPublicIpsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadPublicIpsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PublicIpSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLinkPublicIpResponse parses an HTTP response from a LinkPublicIpWithResponse call
func ParseLinkPublicIpResponse(rsp *http.Response) (*LinkPublicIpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkPublicIpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinkPublicIpResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUnlinkPublicIpResponse parses an HTTP response from a UnlinkPublicIpWithResponse call
func ParseUnlinkPublicIpResponse(rsp *http.Response) (*UnlinkPublicIpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkPublicIpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRebootVmsResponse parses an HTTP response from a RebootVmsWithResponse call
func ParseRebootVmsResponse(rsp *http.Response) (*RebootVmsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RebootVmsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRejectNetPeeringResponse parses an HTTP response from a RejectNetPeeringWithResponse call
func ParseRejectNetPeeringResponse(rsp *http.Response) (*RejectNetPeeringResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RejectNetPeeringResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateRoutePropagationResponse parses an HTTP response from a UpdateRoutePropagationWithResponse call
func ParseUpdateRoutePropagationResponse(rsp *http.Response) (*UpdateRoutePropagationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRoutePropagationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateRoutePropagationResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReadRouteTablesResponse parses an HTTP response from a ReadRouteTablesWithResponse call
func ParseReadRouteTablesResponse(rsp *http.Response) (*ReadRouteTablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadRouteTablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadRouteTablesResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateRouteTableResponse parses an HTTP response from a CreateRouteTableWithResponse call
func ParseCreateRouteTableResponse(rsp *http.Response) (*CreateRouteTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRouteTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RouteTableSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteRouteTableResponse parses an HTTP response from a DeleteRouteTableWithResponse call
func ParseDeleteRouteTableResponse(rsp *http.Response) (*DeleteRouteTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRouteTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReadRouteTablesByIdResponse parses an HTTP response from a ReadRouteTablesByIdWithResponse call
func ParseReadRouteTablesByIdResponse(rsp *http.Response) (*ReadRouteTablesByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadRouteTablesByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RouteTableSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLinkRouteTableResponse parses an HTTP response from a LinkRouteTableWithResponse call
func ParseLinkRouteTableResponse(rsp *http.Response) (*LinkRouteTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkRouteTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinkRouteTableResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUnlinkRouteTableResponse parses an HTTP response from a UnlinkRouteTableWithResponse call
func ParseUnlinkRouteTableResponse(rsp *http.Response) (*UnlinkRouteTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkRouteTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateRouteResponse parses an HTTP response from a CreateRouteWithResponse call
func ParseCreateRouteResponse(rsp *http.Response) (*CreateRouteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRouteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RouteTableSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteRouteResponse parses an HTTP response from a DeleteRouteWithResponse call
func ParseDeleteRouteResponse(rsp *http.Response) (*DeleteRouteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRouteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest DeleteRouteResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	}

	return response, nil
}

// ParseUpdateRouteResponse parses an HTTP response from a UpdateRouteWithResponse call
func ParseUpdateRouteResponse(rsp *http.Response) (*UpdateRouteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRouteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateRouteResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateSecurityGroupRuleResponse parses an HTTP response from a CreateSecurityGroupRuleWithResponse call
func ParseCreateSecurityGroupRuleResponse(rsp *http.Response) (*CreateSecurityGroupRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSecurityGroupRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SecurityGroupSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteSecurityGroupRuleResponse parses an HTTP response from a DeleteSecurityGroupRuleWithResponse call
func ParseDeleteSecurityGroupRuleResponse(rsp *http.Response) (*DeleteSecurityGroupRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSecurityGroupRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest DeleteSecurityGroupRuleResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	}

	return response, nil
}

// ParseReadSecurityGroupsResponse parses an HTTP response from a ReadSecurityGroupsWithResponse call
func ParseReadSecurityGroupsResponse(rsp *http.Response) (*ReadSecurityGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadSecurityGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadSecurityGroupsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateSecurityGroupResponse parses an HTTP response from a CreateSecurityGroupWithResponse call
func ParseCreateSecurityGroupResponse(rsp *http.Response) (*CreateSecurityGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSecurityGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SecurityGroupSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteSecurityGroupResponse parses an HTTP response from a DeleteSecurityGroupWithResponse call
func ParseDeleteSecurityGroupResponse(rsp *http.Response) (*DeleteSecurityGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSecurityGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReadSecurityGroupsByIdResponse parses an HTTP response from a ReadSecurityGroupsByIdWithResponse call
func ParseReadSecurityGroupsByIdResponse(rsp *http.Response) (*ReadSecurityGroupsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadSecurityGroupsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SecurityGroupSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReadSnapshotsResponse parses an HTTP response from a ReadSnapshotsWithResponse call
func ParseReadSnapshotsResponse(rsp *http.Response) (*ReadSnapshotsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadSnapshotsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadSnapshotsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateSnapshotResponse parses an HTTP response from a CreateSnapshotWithResponse call
func ParseCreateSnapshotResponse(rsp *http.Response) (*CreateSnapshotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSnapshotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SnapshotSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteSnapshotResponse parses an HTTP response from a DeleteSnapshotWithResponse call
func ParseDeleteSnapshotResponse(rsp *http.Response) (*DeleteSnapshotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSnapshotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReadSnapshotsByIdResponse parses an HTTP response from a ReadSnapshotsByIdWithResponse call
func ParseReadSnapshotsByIdResponse(rsp *http.Response) (*ReadSnapshotsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadSnapshotsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SnapshotSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStartVmsResponse parses an HTTP response from a StartVmsWithResponse call
func ParseStartVmsResponse(rsp *http.Response) (*StartVmsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartVmsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StartVmsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStopVmsResponse parses an HTTP response from a StopVmsWithResponse call
func ParseStopVmsResponse(rsp *http.Response) (*StopVmsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StopVmsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StopVmsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReadSubnetsResponse parses an HTTP response from a ReadSubnetsWithResponse call
func ParseReadSubnetsResponse(rsp *http.Response) (*ReadSubnetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadSubnetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadSubnetsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateSubnetResponse parses an HTTP response from a CreateSubnetWithResponse call
func ParseCreateSubnetResponse(rsp *http.Response) (*CreateSubnetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSubnetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SubnetSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteSubnetResponse parses an HTTP response from a DeleteSubnetWithResponse call
func ParseDeleteSubnetResponse(rsp *http.Response) (*DeleteSubnetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSubnetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReadSubnetsByIdResponse parses an HTTP response from a ReadSubnetsByIdWithResponse call
func ParseReadSubnetsByIdResponse(rsp *http.Response) (*ReadSubnetsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadSubnetsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SubnetSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateSubnetResponse parses an HTTP response from a UpdateSubnetWithResponse call
func ParseUpdateSubnetResponse(rsp *http.Response) (*UpdateSubnetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSubnetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateSubnetResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReadTagsResponse parses an HTTP response from a ReadTagsWithResponse call
func ParseReadTagsResponse(rsp *http.Response) (*ReadTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadTagsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateTagsResponse parses an HTTP response from a CreateTagsWithResponse call
func ParseCreateTagsResponse(rsp *http.Response) (*CreateTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteTagsResponse parses an HTTP response from a DeleteTagsWithResponse call
func ParseDeleteTagsResponse(rsp *http.Response) (*DeleteTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReadTagsByIdResponse parses an HTTP response from a ReadTagsByIdWithResponse call
func ParseReadTagsByIdResponse(rsp *http.Response) (*ReadTagsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadTagsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TagSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReadVirtualGatewaysResponse parses an HTTP response from a ReadVirtualGatewaysWithResponse call
func ParseReadVirtualGatewaysResponse(rsp *http.Response) (*ReadVirtualGatewaysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVirtualGatewaysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVirtualGatewaysResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateVirtualGatewayResponse parses an HTTP response from a CreateVirtualGatewayWithResponse call
func ParseCreateVirtualGatewayResponse(rsp *http.Response) (*CreateVirtualGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVirtualGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VirtualGatewaySchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteVirtualGatewayResponse parses an HTTP response from a DeleteVirtualGatewayWithResponse call
func ParseDeleteVirtualGatewayResponse(rsp *http.Response) (*DeleteVirtualGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVirtualGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReadVirtualGatewaysByIdResponse parses an HTTP response from a ReadVirtualGatewaysByIdWithResponse call
func ParseReadVirtualGatewaysByIdResponse(rsp *http.Response) (*ReadVirtualGatewaysByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVirtualGatewaysByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VirtualGatewaySchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLinkVirtualGatewayResponse parses an HTTP response from a LinkVirtualGatewayWithResponse call
func ParseLinkVirtualGatewayResponse(rsp *http.Response) (*LinkVirtualGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkVirtualGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinkVirtualGatewayResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUnlinkVirtualGatewayResponse parses an HTTP response from a UnlinkVirtualGatewayWithResponse call
func ParseUnlinkVirtualGatewayResponse(rsp *http.Response) (*UnlinkVirtualGatewayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkVirtualGatewayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReadVmsResponse parses an HTTP response from a ReadVmsWithResponse call
func ParseReadVmsResponse(rsp *http.Response) (*ReadVmsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVmsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVmsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateVmsResponse parses an HTTP response from a CreateVmsWithResponse call
func ParseCreateVmsResponse(rsp *http.Response) (*CreateVmsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVmsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateVmsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteVmsResponse parses an HTTP response from a DeleteVmsWithResponse call
func ParseDeleteVmsResponse(rsp *http.Response) (*DeleteVmsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVmsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest DeleteVmsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	}

	return response, nil
}

// ParseReadVmsByIdResponse parses an HTTP response from a ReadVmsByIdWithResponse call
func ParseReadVmsByIdResponse(rsp *http.Response) (*ReadVmsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVmsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VmSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateVmResponse parses an HTTP response from a UpdateVmWithResponse call
func ParseUpdateVmResponse(rsp *http.Response) (*UpdateVmResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVmResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateVmResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReadVmsHealthResponse parses an HTTP response from a ReadVmsHealthWithResponse call
func ParseReadVmsHealthResponse(rsp *http.Response) (*ReadVmsHealthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVmsHealthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVmsHealthResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReadVmsHealthByIdResponse parses an HTTP response from a ReadVmsHealthByIdWithResponse call
func ParseReadVmsHealthByIdResponse(rsp *http.Response) (*ReadVmsHealthByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVmsHealthByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BackendVmHealthSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReadVmsStateResponse parses an HTTP response from a ReadVmsStateWithResponse call
func ParseReadVmsStateResponse(rsp *http.Response) (*ReadVmsStateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVmsStateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVmsStateResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReadVmsStateByIdResponse parses an HTTP response from a ReadVmsStateByIdWithResponse call
func ParseReadVmsStateByIdResponse(rsp *http.Response) (*ReadVmsStateByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVmsStateByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VmStatesSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReadVolumesResponse parses an HTTP response from a ReadVolumesWithResponse call
func ParseReadVolumesResponse(rsp *http.Response) (*ReadVolumesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVolumesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVolumesResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateVolumeResponse parses an HTTP response from a CreateVolumeWithResponse call
func ParseCreateVolumeResponse(rsp *http.Response) (*CreateVolumeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VolumeSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteVolumeResponse parses an HTTP response from a DeleteVolumeWithResponse call
func ParseDeleteVolumeResponse(rsp *http.Response) (*DeleteVolumeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReadVolumesByIdResponse parses an HTTP response from a ReadVolumesByIdWithResponse call
func ParseReadVolumesByIdResponse(rsp *http.Response) (*ReadVolumesByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVolumesByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VolumeSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateVolumeResponse parses an HTTP response from a UpdateVolumeWithResponse call
func ParseUpdateVolumeResponse(rsp *http.Response) (*UpdateVolumeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateVolumeResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLinkVolumeResponse parses an HTTP response from a LinkVolumeWithResponse call
func ParseLinkVolumeResponse(rsp *http.Response) (*LinkVolumeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkVolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUnlinkVolumeResponse parses an HTTP response from a UnlinkVolumeWithResponse call
func ParseUnlinkVolumeResponse(rsp *http.Response) (*UnlinkVolumeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkVolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateVpnConnectionRouteResponse parses an HTTP response from a CreateVpnConnectionRouteWithResponse call
func ParseCreateVpnConnectionRouteResponse(rsp *http.Response) (*CreateVpnConnectionRouteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVpnConnectionRouteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteVpnConnectionRouteResponse parses an HTTP response from a DeleteVpnConnectionRouteWithResponse call
func ParseDeleteVpnConnectionRouteResponse(rsp *http.Response) (*DeleteVpnConnectionRouteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVpnConnectionRouteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReadVpnConnectionsResponse parses an HTTP response from a ReadVpnConnectionsWithResponse call
func ParseReadVpnConnectionsResponse(rsp *http.Response) (*ReadVpnConnectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVpnConnectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadVpnConnectionsResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateVpnConnectionResponse parses an HTTP response from a CreateVpnConnectionWithResponse call
func ParseCreateVpnConnectionResponse(rsp *http.Response) (*CreateVpnConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVpnConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VpnConnectionSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteVpnConnectionResponse parses an HTTP response from a DeleteVpnConnectionWithResponse call
func ParseDeleteVpnConnectionResponse(rsp *http.Response) (*DeleteVpnConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVpnConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReadVpnConnectionsByIdResponse parses an HTTP response from a ReadVpnConnectionsByIdWithResponse call
func ParseReadVpnConnectionsByIdResponse(rsp *http.Response) (*ReadVpnConnectionsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadVpnConnectionsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VpnConnectionSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateVpnConnectionResponse parses an HTTP response from a UpdateVpnConnectionWithResponse call
func ParseUpdateVpnConnectionResponse(rsp *http.Response) (*UpdateVpnConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVpnConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateVpnConnectionResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
