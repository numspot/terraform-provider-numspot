// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_vm

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"gitlab.numspot.cloud/cloud/terraform-provider-numspot/internal/provider/tags"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func VmResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"architecture": schema.StringAttribute{
				Computed:            true,
				Description:         "The architecture of the VM (`i386` \\| `x86_64`).",
				MarkdownDescription: "The architecture of the VM (`i386` \\| `x86_64`).",
			},
			"block_device_mappings": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"bsu": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"delete_on_vm_deletion": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "By default or if set to true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.",
									MarkdownDescription: "By default or if set to true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.",
									Default:             booldefault.StaticBool(true),
								},
								"iops": schema.Int64Attribute{
									Optional:            true,
									Computed:            true,
									Description:         "The number of I/O operations per second (IOPS). This parameter must be specified only if you create an `io1` volume. The maximum number of IOPS allowed for `io1` volumes is `13000` with a maximum performance ratio of 300 IOPS per gibibyte.",
									MarkdownDescription: "The number of I/O operations per second (IOPS). This parameter must be specified only if you create an `io1` volume. The maximum number of IOPS allowed for `io1` volumes is `13000` with a maximum performance ratio of 300 IOPS per gibibyte.",
								},
								"link_date": schema.StringAttribute{
									Computed:            true,
									Description:         "The date and time of attachment of the volume to the VM, in ISO 8601 date-time format.",
									MarkdownDescription: "The date and time of attachment of the volume to the VM, in ISO 8601 date-time format.",
								},
								"snapshot_id": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "The ID of the snapshot used to create the volume.",
									MarkdownDescription: "The ID of the snapshot used to create the volume.",
								},
								"state": schema.StringAttribute{
									Computed:            true,
									Description:         "The state of the volume.",
									MarkdownDescription: "The state of the volume.",
								},
								"volume_id": schema.StringAttribute{
									Computed:            true,
									Description:         "The ID of the volume.",
									MarkdownDescription: "The ID of the volume.",
								},
								"volume_size": schema.Int64Attribute{
									Optional:            true,
									Computed:            true,
									Description:         "The size of the volume, in gibibytes (GiB).<br />\nIf you specify a snapshot ID, the volume size must be at least equal to the snapshot size.<br />\nIf you specify a snapshot ID but no volume size, the volume is created with a size similar to the snapshot one.",
									MarkdownDescription: "The size of the volume, in gibibytes (GiB).<br />\nIf you specify a snapshot ID, the volume size must be at least equal to the snapshot size.<br />\nIf you specify a snapshot ID but no volume size, the volume is created with a size similar to the snapshot one.",
								},
								"volume_type": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "The type of the volume (`standard` \\| `io1` \\| `gp2`). If not specified in the request, a `standard` volume is created.<br />\n For more information about volume types, see [About Volumes > Volume Types and IOPS](https://docs.outscale.com/en/userguide/About-Volumes.html#_volume_types_and_iops).",
									MarkdownDescription: "The type of the volume (`standard` \\| `io1` \\| `gp2`). If not specified in the request, a `standard` volume is created.<br />\n For more information about volume types, see [About Volumes > Volume Types and IOPS](https://docs.outscale.com/en/userguide/About-Volumes.html#_volume_types_and_iops).",
								},
							},
							CustomType: BsuType{
								ObjectType: types.ObjectType{
									AttrTypes: BsuValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Computed:            true,
							Description:         "Information about the BSU volume to create.",
							MarkdownDescription: "Information about the BSU volume to create.",
						},
						"device_name": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "The device name for the volume. For a root device, you must use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, and the second `X` is a letter between `a` and `z`).",
							MarkdownDescription: "The device name for the volume. For a root device, you must use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, and the second `X` is a letter between `a` and `z`).",
						},
						"no_device": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Removes the device which is included in the block device mapping of the OMI.",
							MarkdownDescription: "Removes the device which is included in the block device mapping of the OMI.",
						},
						"virtual_device_name": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "The name of the virtual device (`ephemeralN`).",
							MarkdownDescription: "The name of the virtual device (`ephemeralN`).",
						},
					},
					CustomType: BlockDeviceMappingsType{
						ObjectType: types.ObjectType{
							AttrTypes: BlockDeviceMappingsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "One or more block device mappings.",
				MarkdownDescription: "One or more block device mappings.",
			},
			"boot_on_creation": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "By default or if true, the VM is started on creation. If false, the VM is stopped on creation.",
				MarkdownDescription: "By default or if true, the VM is started on creation. If false, the VM is stopped on creation.",
				Default:             booldefault.StaticBool(true),
			},
			"bsu_optimized": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "This parameter is not available. It is present in our API for the sake of historical compatibility with AWS.",
				MarkdownDescription: "This parameter is not available. It is present in our API for the sake of historical compatibility with AWS.",
			},
			"client_token": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "A unique identifier which enables you to manage the idempotency.",
				MarkdownDescription: "A unique identifier which enables you to manage the idempotency.",
			},
			"creation_date": schema.StringAttribute{
				Computed:            true,
				Description:         "The date and time of creation of the VM.",
				MarkdownDescription: "The date and time of creation of the VM.",
			},
			"deletion_protection": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "If true, you cannot delete the VM unless you change this parameter back to false.",
				MarkdownDescription: "If true, you cannot delete the VM unless you change this parameter back to false.",
			},
			"hypervisor": schema.StringAttribute{
				Computed:            true,
				Description:         "The hypervisor type of the VMs (`ovm` \\| `xen`).",
				MarkdownDescription: "The hypervisor type of the VMs (`ovm` \\| `xen`).",
			},
			"id": schema.StringAttribute{
				Computed:            true,
				Description:         "The ID of the VM.",
				MarkdownDescription: "The ID of the VM.",
			},
			"image_id": schema.StringAttribute{
				Required:            true,
				Description:         "The ID of the OMI used to create the VM. You can find the list of OMIs by calling the [ReadImages](#readimages) method.",
				MarkdownDescription: "The ID of the OMI used to create the VM. You can find the list of OMIs by calling the [ReadImages](#readimages) method.",
			},
			"initiated_shutdown_behavior": schema.StringAttribute{
				Computed:            true,
				Description:         "The VM behavior when you stop it. If set to `stop`, the VM stops. If set to `restart`, the VM stops then automatically restarts. If set to `terminate`, the VM stops and is deleted.",
				MarkdownDescription: "The VM behavior when you stop it. If set to `stop`, the VM stops. If set to `restart`, the VM stops then automatically restarts. If set to `terminate`, the VM stops and is deleted.",
			},
			"is_source_dest_checked": schema.BoolAttribute{
				Computed:            true,
				Description:         "(Net only) If true, the source/destination check is enabled. If false, it is disabled. This value must be false for a NAT VM to perform network address translation (NAT) in a Net.",
				MarkdownDescription: "(Net only) If true, the source/destination check is enabled. If false, it is disabled. This value must be false for a NAT VM to perform network address translation (NAT) in a Net.",
			},
			"keypair_name": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The name of the keypair.",
				MarkdownDescription: "The name of the keypair.",
			},
			"launch_number": schema.Int64Attribute{
				Computed:            true,
				Description:         "The number for the VM when launching a group of several VMs (for example, `0`, `1`, `2`, and so on).",
				MarkdownDescription: "The number for the VM when launching a group of several VMs (for example, `0`, `1`, `2`, and so on).",
			},
			"nested_virtualization": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "(dedicated tenancy only) If true, nested virtualization is enabled. If false, it is disabled.",
				MarkdownDescription: "(dedicated tenancy only) If true, nested virtualization is enabled. If false, it is disabled.",
				Default:             booldefault.StaticBool(false),
			},
			"net_id": schema.StringAttribute{
				Computed:            true,
				Description:         "The ID of the Net in which the VM is running.",
				MarkdownDescription: "The ID of the Net in which the VM is running.",
			},
			"nics": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"delete_on_vm_deletion": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "If true, the NIC is deleted when the VM is terminated. You can specify this parameter only for a new NIC. To modify this value for an existing NIC, see [UpdateNic](#updatenic).",
							MarkdownDescription: "If true, the NIC is deleted when the VM is terminated. You can specify this parameter only for a new NIC. To modify this value for an existing NIC, see [UpdateNic](#updatenic).",
						},
						"description": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "The description of the NIC, if you are creating a NIC when creating the VM.",
							MarkdownDescription: "The description of the NIC, if you are creating a NIC when creating the VM.",
						},
						"device_number": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "The index of the VM device for the NIC attachment (between `0` and `7`, both included). This parameter is required if you create a NIC when creating the VM.",
							MarkdownDescription: "The index of the VM device for the NIC attachment (between `0` and `7`, both included). This parameter is required if you create a NIC when creating the VM.",
						},
						"is_source_dest_checked": schema.BoolAttribute{
							Computed:            true,
							Description:         "(Net only) If true, the source/destination check is enabled. If false, it is disabled. This value must be false for a NAT VM to perform network address translation (NAT) in a Net.",
							MarkdownDescription: "(Net only) If true, the source/destination check is enabled. If false, it is disabled. This value must be false for a NAT VM to perform network address translation (NAT) in a Net.",
						},
						"link_nic": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"delete_on_vm_deletion": schema.BoolAttribute{
									Computed:            true,
									Description:         "If true, the NIC is deleted when the VM is terminated.",
									MarkdownDescription: "If true, the NIC is deleted when the VM is terminated.",
								},
								"device_number": schema.Int64Attribute{
									Computed:            true,
									Description:         "The device index for the NIC attachment (between `1` and `7`, both included).",
									MarkdownDescription: "The device index for the NIC attachment (between `1` and `7`, both included).",
								},
								"link_nic_id": schema.StringAttribute{
									Computed:            true,
									Description:         "The ID of the NIC to attach.",
									MarkdownDescription: "The ID of the NIC to attach.",
								},
								"state": schema.StringAttribute{
									Computed:            true,
									Description:         "The state of the attachment (`attaching` \\| `attached` \\| `detaching` \\| `detached`).",
									MarkdownDescription: "The state of the attachment (`attaching` \\| `attached` \\| `detaching` \\| `detached`).",
								},
							},
							CustomType: LinkNicType{
								ObjectType: types.ObjectType{
									AttrTypes: LinkNicValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "Information about the network interface card (NIC).",
							MarkdownDescription: "Information about the network interface card (NIC).",
						},
						"link_public_ip": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"public_dns_name": schema.StringAttribute{
									Computed:            true,
									Description:         "The name of the public DNS.",
									MarkdownDescription: "The name of the public DNS.",
								},
								"public_ip": schema.StringAttribute{
									Computed:            true,
									Description:         "The public IP associated with the NIC.",
									MarkdownDescription: "The public IP associated with the NIC.",
								},
							},
							CustomType: LinkPublicIpType{
								ObjectType: types.ObjectType{
									AttrTypes: LinkPublicIpValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "Information about the public IP associated with the NIC.",
							MarkdownDescription: "Information about the public IP associated with the NIC.",
						},
						"mac_address": schema.StringAttribute{
							Computed:            true,
							Description:         "The Media Access Control (MAC) address of the NIC.",
							MarkdownDescription: "The Media Access Control (MAC) address of the NIC.",
						},
						"net_id": schema.StringAttribute{
							Computed:            true,
							Description:         "The ID of the Net for the NIC.",
							MarkdownDescription: "The ID of the Net for the NIC.",
						},
						"nic_id": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "The ID of the NIC, if you are attaching an existing NIC when creating a VM.",
							MarkdownDescription: "The ID of the NIC, if you are attaching an existing NIC when creating a VM.",
						},
						"private_dns_name": schema.StringAttribute{
							Computed:            true,
							Description:         "The name of the private DNS.",
							MarkdownDescription: "The name of the private DNS.",
						},
						"private_ips": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"is_primary": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "If true, the IP is the primary private IP of the NIC.",
										MarkdownDescription: "If true, the IP is the primary private IP of the NIC.",
									},
									"link_public_ip": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"public_dns_name": schema.StringAttribute{
												Computed:            true,
												Description:         "The name of the public DNS.",
												MarkdownDescription: "The name of the public DNS.",
											},
											"public_ip": schema.StringAttribute{
												Computed:            true,
												Description:         "The public IP associated with the NIC.",
												MarkdownDescription: "The public IP associated with the NIC.",
											},
										},
										CustomType: LinkPublicIpType{
											ObjectType: types.ObjectType{
												AttrTypes: LinkPublicIpValue{}.AttributeTypes(ctx),
											},
										},
										Computed:            true,
										Description:         "Information about the public IP associated with the NIC.",
										MarkdownDescription: "Information about the public IP associated with the NIC.",
									},
									"private_dns_name": schema.StringAttribute{
										Computed:            true,
										Description:         "The name of the private DNS.",
										MarkdownDescription: "The name of the private DNS.",
									},
									"private_ip": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "The private IP of the NIC.",
										MarkdownDescription: "The private IP of the NIC.",
									},
								},
								CustomType: PrivateIpsType{
									ObjectType: types.ObjectType{
										AttrTypes: PrivateIpsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Computed:            true,
							Description:         "One or more private IPs to assign to the NIC, if you create a NIC when creating a VM. Only one private IP can be the primary private IP.",
							MarkdownDescription: "One or more private IPs to assign to the NIC, if you create a NIC when creating a VM. Only one private IP can be the primary private IP.",
						},
						"secondary_private_ip_count": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "The number of secondary private IPs, if you create a NIC when creating a VM. This parameter cannot be specified if you specified more than one private IP in the `PrivateIps` parameter.",
							MarkdownDescription: "The number of secondary private IPs, if you create a NIC when creating a VM. This parameter cannot be specified if you specified more than one private IP in the `PrivateIps` parameter.",
						},
						"security_group_ids": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "One or more IDs of security groups for the NIC, if you create a NIC when creating a VM.",
							MarkdownDescription: "One or more IDs of security groups for the NIC, if you create a NIC when creating a VM.",
						},
						"security_groups": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"security_group_id": schema.StringAttribute{
										Computed:            true,
										Description:         "The ID of the security group.",
										MarkdownDescription: "The ID of the security group.",
									},
									"security_group_name": schema.StringAttribute{
										Computed:            true,
										Description:         "The name of the security group.",
										MarkdownDescription: "The name of the security group.",
									},
								},
								CustomType: SecurityGroupsType{
									ObjectType: types.ObjectType{
										AttrTypes: SecurityGroupsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed:            true,
							Description:         "One or more IDs of security groups for the NIC.",
							MarkdownDescription: "One or more IDs of security groups for the NIC.",
						},
						"state": schema.StringAttribute{
							Computed:            true,
							Description:         "The state of the NIC (`available` \\| `attaching` \\| `in-use` \\| `detaching`).",
							MarkdownDescription: "The state of the NIC (`available` \\| `attaching` \\| `in-use` \\| `detaching`).",
						},
						"subnet_id": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "The ID of the Subnet for the NIC, if you create a NIC when creating a VM. This parameter is required if you create a NIC when creating the VM.",
							MarkdownDescription: "The ID of the Subnet for the NIC, if you create a NIC when creating a VM. This parameter is required if you create a NIC when creating the VM.",
						},
					},
					CustomType: NicsType{
						ObjectType: types.ObjectType{
							AttrTypes: NicsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "One or more NICs. If you specify this parameter, you must not specify the `SubnetId` and `SubregionName` parameters. You also must define one NIC as the primary network interface of the VM with `0` as its device number.",
				MarkdownDescription: "One or more NICs. If you specify this parameter, you must not specify the `SubnetId` and `SubregionName` parameters. You also must define one NIC as the primary network interface of the VM with `0` as its device number.",
			},
			"os_family": schema.StringAttribute{
				Computed:            true,
				Description:         "Indicates the operating system (OS) of the VM.",
				MarkdownDescription: "Indicates the operating system (OS) of the VM.",
			},
			"performance": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The performance of the VM (`medium` \\| `high` \\|  `highest`). By default, `high`. This parameter is ignored if you specify a performance flag directly in the `VmType` parameter.",
				MarkdownDescription: "The performance of the VM (`medium` \\| `high` \\|  `highest`). By default, `high`. This parameter is ignored if you specify a performance flag directly in the `VmType` parameter.",
				Validators: []validator.String{
					stringvalidator.OneOf(
						"medium",
						"high",
						"highest",
					),
				},
			},
			"placement": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"subregion_name": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The name of the Subregion. If you specify this parameter, you must not specify the `Nics` parameter.",
						MarkdownDescription: "The name of the Subregion. If you specify this parameter, you must not specify the `Nics` parameter.",
					},
					"tenancy": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The tenancy of the VM (`default` \\| `dedicated`).",
						MarkdownDescription: "The tenancy of the VM (`default` \\| `dedicated`).",
					},
				},
				CustomType: PlacementType{
					ObjectType: types.ObjectType{
						AttrTypes: PlacementValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Information about the placement of the VM.",
				MarkdownDescription: "Information about the placement of the VM.",
			},
			"private_dns_name": schema.StringAttribute{
				Computed:            true,
				Description:         "The name of the private DNS.",
				MarkdownDescription: "The name of the private DNS.",
			},
			"private_ip": schema.StringAttribute{
				Computed:            true,
				Description:         "The primary private IP of the VM.",
				MarkdownDescription: "The primary private IP of the VM.",
			},
			"private_ips": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "One or more private IPs of the VM.",
				MarkdownDescription: "One or more private IPs of the VM.",
			},
			"product_codes": schema.ListAttribute{
				ElementType:         types.StringType,
				Computed:            true,
				Description:         "The product codes associated with the OMI used to create the VM.",
				MarkdownDescription: "The product codes associated with the OMI used to create the VM.",
			},
			"public_dns_name": schema.StringAttribute{
				Computed:            true,
				Description:         "The name of the public DNS.",
				MarkdownDescription: "The name of the public DNS.",
			},
			"public_ip": schema.StringAttribute{
				Computed:            true,
				Description:         "The public IP of the VM.",
				MarkdownDescription: "The public IP of the VM.",
			},
			"reservation_id": schema.StringAttribute{
				Computed:            true,
				Description:         "The reservation ID of the VM.",
				MarkdownDescription: "The reservation ID of the VM.",
			},
			"root_device_name": schema.StringAttribute{
				Computed:            true,
				Description:         "The name of the root device for the VM (for example, `/dev/vda1`).",
				MarkdownDescription: "The name of the root device for the VM (for example, `/dev/vda1`).",
			},
			"root_device_type": schema.StringAttribute{
				Computed:            true,
				Description:         "The type of root device used by the VM (always `bsu`).",
				MarkdownDescription: "The type of root device used by the VM (always `bsu`).",
			},
			"security_group_ids": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "One or more IDs of security group for the VMs.",
				MarkdownDescription: "One or more IDs of security group for the VMs.",
			},
			"security_groups": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "One or more names of security groups for the VMs.",
				MarkdownDescription: "One or more names of security groups for the VMs.",
			},
			"state": schema.StringAttribute{
				Computed:            true,
				Description:         "The state of the VM (`pending` \\| `running` \\| `stopping` \\| `stopped` \\| `shutting-down` \\| `terminated` \\| `quarantine`).",
				MarkdownDescription: "The state of the VM (`pending` \\| `running` \\| `stopping` \\| `stopped` \\| `shutting-down` \\| `terminated` \\| `quarantine`).",
			},
			"state_reason": schema.StringAttribute{
				Computed:            true,
				Description:         "The reason explaining the current state of the VM.",
				MarkdownDescription: "The reason explaining the current state of the VM.",
			},
			"subnet_id": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The ID of the Subnet in which you want to create the VM. If you specify this parameter, you must not specify the `Nics` parameter.",
				MarkdownDescription: "The ID of the Subnet in which you want to create the VM. If you specify this parameter, you must not specify the `Nics` parameter.",
			},
			"type": schema.StringAttribute{
				Computed:            true,
				Description:         "The type of VM. For more information, see [Instance Types](https://docs.outscale.com/en/userguide/Instance-Types.html).",
				MarkdownDescription: "The type of VM. For more information, see [Instance Types](https://docs.outscale.com/en/userguide/Instance-Types.html).",
			},
			"user_data": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Data or script used to add a specific configuration to the VM. It must be Base64-encoded and is limited to 500 kibibytes (KiB).",
				MarkdownDescription: "Data or script used to add a specific configuration to the VM. It must be Base64-encoded and is limited to 500 kibibytes (KiB).",
			},
			"vm_initiated_shutdown_behavior": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The VM behavior when you stop it. By default or if set to `stop`, the VM stops. If set to `restart`, the VM stops then automatically restarts. If set to `terminate`, the VM stops and is terminated.",
				MarkdownDescription: "The VM behavior when you stop it. By default or if set to `stop`, the VM stops. If set to `restart`, the VM stops then automatically restarts. If set to `terminate`, the VM stops and is terminated.",
				Default:             stringdefault.StaticString("stop"),
			},
			"vm_type": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The type of VM. You can specify a TINA type (in the `tinavW.cXrYpZ` or `tinavW.cXrY` format), or an AWS type (for example, `t2.small`, which is the default value).<br />\nIf you specify an AWS type, it is converted in the background to its corresponding TINA type, but the AWS type is still returned. If the specified or converted TINA type includes a performance flag, this performance flag is applied regardless of the value you may have provided in the `Performance` parameter. For more information, see [Instance Types](https://docs.outscale.com/en/userguide/Instance-Types.html).",
				MarkdownDescription: "The type of VM. You can specify a TINA type (in the `tinavW.cXrYpZ` or `tinavW.cXrY` format), or an AWS type (for example, `t2.small`, which is the default value).<br />\nIf you specify an AWS type, it is converted in the background to its corresponding TINA type, but the AWS type is still returned. If the specified or converted TINA type includes a performance flag, this performance flag is applied regardless of the value you may have provided in the `Performance` parameter. For more information, see [Instance Types](https://docs.outscale.com/en/userguide/Instance-Types.html).",
			},
			"vms_count": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "The minimum number of VMs you want to create. If this number of VMs cannot be created, no VMs are created.",
				MarkdownDescription: "The minimum number of VMs you want to create. If this number of VMs cannot be created, no VMs are created.",
			},
			"tags": tags.TagsSchema(ctx),
		},
	}
}

type VmModel struct {
	Architecture                types.String   `tfsdk:"architecture"`
	BlockDeviceMappings         types.List     `tfsdk:"block_device_mappings"`
	BootOnCreation              types.Bool     `tfsdk:"boot_on_creation"`
	BsuOptimized                types.Bool     `tfsdk:"bsu_optimized"`
	ClientToken                 types.String   `tfsdk:"client_token"`
	CreationDate                types.String   `tfsdk:"creation_date"`
	DeletionProtection          types.Bool     `tfsdk:"deletion_protection"`
	Hypervisor                  types.String   `tfsdk:"hypervisor"`
	Id                          types.String   `tfsdk:"id"`
	ImageId                     types.String   `tfsdk:"image_id"`
	InitiatedShutdownBehavior   types.String   `tfsdk:"initiated_shutdown_behavior"`
	IsSourceDestChecked         types.Bool     `tfsdk:"is_source_dest_checked"`
	KeypairName                 types.String   `tfsdk:"keypair_name"`
	LaunchNumber                types.Int64    `tfsdk:"launch_number"`
	NestedVirtualization        types.Bool     `tfsdk:"nested_virtualization"`
	NetId                       types.String   `tfsdk:"net_id"`
	Nics                        types.List     `tfsdk:"nics"`
	OsFamily                    types.String   `tfsdk:"os_family"`
	Performance                 types.String   `tfsdk:"performance"`
	Placement                   PlacementValue `tfsdk:"placement"`
	PrivateDnsName              types.String   `tfsdk:"private_dns_name"`
	PrivateIp                   types.String   `tfsdk:"private_ip"`
	PrivateIps                  types.List     `tfsdk:"private_ips"`
	ProductCodes                types.List     `tfsdk:"product_codes"`
	PublicDnsName               types.String   `tfsdk:"public_dns_name"`
	PublicIp                    types.String   `tfsdk:"public_ip"`
	ReservationId               types.String   `tfsdk:"reservation_id"`
	RootDeviceName              types.String   `tfsdk:"root_device_name"`
	RootDeviceType              types.String   `tfsdk:"root_device_type"`
	SecurityGroupIds            types.List     `tfsdk:"security_group_ids"`
	SecurityGroups              types.List     `tfsdk:"security_groups"`
	State                       types.String   `tfsdk:"state"`
	StateReason                 types.String   `tfsdk:"state_reason"`
	SubnetId                    types.String   `tfsdk:"subnet_id"`
	Type                        types.String   `tfsdk:"type"`
	UserData                    types.String   `tfsdk:"user_data"`
	VmInitiatedShutdownBehavior types.String   `tfsdk:"vm_initiated_shutdown_behavior"`
	VmType                      types.String   `tfsdk:"vm_type"`
	VmsCount                    types.Int64    `tfsdk:"vms_count"`
	Tags                        types.List     `tfsdk:"tags"`
}

var _ basetypes.ObjectTypable = BlockDeviceMappingsType{}

type BlockDeviceMappingsType struct {
	basetypes.ObjectType
}

func (t BlockDeviceMappingsType) Equal(o attr.Type) bool {
	other, ok := o.(BlockDeviceMappingsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BlockDeviceMappingsType) String() string {
	return "BlockDeviceMappingsType"
}

func (t BlockDeviceMappingsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bsuAttribute, ok := attributes["bsu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bsu is missing from object`)

		return nil, diags
	}

	bsuVal, ok := bsuAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bsu expected to be basetypes.ObjectValue, was: %T`, bsuAttribute))
	}

	deviceNameAttribute, ok := attributes["device_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`device_name is missing from object`)

		return nil, diags
	}

	deviceNameVal, ok := deviceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`device_name expected to be basetypes.StringValue, was: %T`, deviceNameAttribute))
	}

	noDeviceAttribute, ok := attributes["no_device"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_device is missing from object`)

		return nil, diags
	}

	noDeviceVal, ok := noDeviceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_device expected to be basetypes.StringValue, was: %T`, noDeviceAttribute))
	}

	virtualDeviceNameAttribute, ok := attributes["virtual_device_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`virtual_device_name is missing from object`)

		return nil, diags
	}

	virtualDeviceNameVal, ok := virtualDeviceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`virtual_device_name expected to be basetypes.StringValue, was: %T`, virtualDeviceNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BlockDeviceMappingsValue{
		Bsu:               bsuVal,
		DeviceName:        deviceNameVal,
		NoDevice:          noDeviceVal,
		VirtualDeviceName: virtualDeviceNameVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewBlockDeviceMappingsValueNull() BlockDeviceMappingsValue {
	return BlockDeviceMappingsValue{
		state: attr.ValueStateNull,
	}
}

func NewBlockDeviceMappingsValueUnknown() BlockDeviceMappingsValue {
	return BlockDeviceMappingsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBlockDeviceMappingsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BlockDeviceMappingsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BlockDeviceMappingsValue Attribute Value",
				"While creating a BlockDeviceMappingsValue value, a missing attribute value was detected. "+
					"A BlockDeviceMappingsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BlockDeviceMappingsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BlockDeviceMappingsValue Attribute Type",
				"While creating a BlockDeviceMappingsValue value, an invalid attribute value was detected. "+
					"A BlockDeviceMappingsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BlockDeviceMappingsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BlockDeviceMappingsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BlockDeviceMappingsValue Attribute Value",
				"While creating a BlockDeviceMappingsValue value, an extra attribute value was detected. "+
					"A BlockDeviceMappingsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BlockDeviceMappingsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBlockDeviceMappingsValueUnknown(), diags
	}

	bsuAttribute, ok := attributes["bsu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bsu is missing from object`)

		return NewBlockDeviceMappingsValueUnknown(), diags
	}

	bsuVal, ok := bsuAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bsu expected to be basetypes.ObjectValue, was: %T`, bsuAttribute))
	}

	deviceNameAttribute, ok := attributes["device_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`device_name is missing from object`)

		return NewBlockDeviceMappingsValueUnknown(), diags
	}

	deviceNameVal, ok := deviceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`device_name expected to be basetypes.StringValue, was: %T`, deviceNameAttribute))
	}

	noDeviceAttribute, ok := attributes["no_device"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_device is missing from object`)

		return NewBlockDeviceMappingsValueUnknown(), diags
	}

	noDeviceVal, ok := noDeviceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_device expected to be basetypes.StringValue, was: %T`, noDeviceAttribute))
	}

	virtualDeviceNameAttribute, ok := attributes["virtual_device_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`virtual_device_name is missing from object`)

		return NewBlockDeviceMappingsValueUnknown(), diags
	}

	virtualDeviceNameVal, ok := virtualDeviceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`virtual_device_name expected to be basetypes.StringValue, was: %T`, virtualDeviceNameAttribute))
	}

	if diags.HasError() {
		return NewBlockDeviceMappingsValueUnknown(), diags
	}

	return BlockDeviceMappingsValue{
		Bsu:               bsuVal,
		DeviceName:        deviceNameVal,
		NoDevice:          noDeviceVal,
		VirtualDeviceName: virtualDeviceNameVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewBlockDeviceMappingsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BlockDeviceMappingsValue {
	object, diags := NewBlockDeviceMappingsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBlockDeviceMappingsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BlockDeviceMappingsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBlockDeviceMappingsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBlockDeviceMappingsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBlockDeviceMappingsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBlockDeviceMappingsValueMust(BlockDeviceMappingsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BlockDeviceMappingsType) ValueType(ctx context.Context) attr.Value {
	return BlockDeviceMappingsValue{}
}

var _ basetypes.ObjectValuable = BlockDeviceMappingsValue{}

type BlockDeviceMappingsValue struct {
	Bsu               basetypes.ObjectValue `tfsdk:"bsu"`
	DeviceName        basetypes.StringValue `tfsdk:"device_name"`
	NoDevice          basetypes.StringValue `tfsdk:"no_device"`
	VirtualDeviceName basetypes.StringValue `tfsdk:"virtual_device_name"`
	state             attr.ValueState
}

func (v BlockDeviceMappingsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["bsu"] = basetypes.ObjectType{
		AttrTypes: BsuValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["device_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["no_device"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["virtual_device_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Bsu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bsu"] = val

		val, err = v.DeviceName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["device_name"] = val

		val, err = v.NoDevice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_device"] = val

		val, err = v.VirtualDeviceName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["virtual_device_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BlockDeviceMappingsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BlockDeviceMappingsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BlockDeviceMappingsValue) String() string {
	return "BlockDeviceMappingsValue"
}

func (v BlockDeviceMappingsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var bsu basetypes.ObjectValue

	if v.Bsu.IsNull() {
		bsu = types.ObjectNull(
			BsuValue{}.AttributeTypes(ctx),
		)
	}

	if v.Bsu.IsUnknown() {
		bsu = types.ObjectUnknown(
			BsuValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Bsu.IsNull() && !v.Bsu.IsUnknown() {
		bsu = types.ObjectValueMust(
			BsuValue{}.AttributeTypes(ctx),
			v.Bsu.Attributes(),
		)
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"bsu": basetypes.ObjectType{
				AttrTypes: BsuValue{}.AttributeTypes(ctx),
			},
			"device_name":         basetypes.StringType{},
			"no_device":           basetypes.StringType{},
			"virtual_device_name": basetypes.StringType{},
		},
		map[string]attr.Value{
			"bsu":                 bsu,
			"device_name":         v.DeviceName,
			"no_device":           v.NoDevice,
			"virtual_device_name": v.VirtualDeviceName,
		})

	return objVal, diags
}

func (v BlockDeviceMappingsValue) Equal(o attr.Value) bool {
	other, ok := o.(BlockDeviceMappingsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Bsu.Equal(other.Bsu) {
		return false
	}

	if !v.DeviceName.Equal(other.DeviceName) {
		return false
	}

	if !v.NoDevice.Equal(other.NoDevice) {
		return false
	}

	if !v.VirtualDeviceName.Equal(other.VirtualDeviceName) {
		return false
	}

	return true
}

func (v BlockDeviceMappingsValue) Type(ctx context.Context) attr.Type {
	return BlockDeviceMappingsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BlockDeviceMappingsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bsu": basetypes.ObjectType{
			AttrTypes: BsuValue{}.AttributeTypes(ctx),
		},
		"device_name":         basetypes.StringType{},
		"no_device":           basetypes.StringType{},
		"virtual_device_name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = BsuType{}

type BsuType struct {
	basetypes.ObjectType
}

func (t BsuType) Equal(o attr.Type) bool {
	other, ok := o.(BsuType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BsuType) String() string {
	return "BsuType"
}

func (t BsuType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	deleteOnVmDeletionAttribute, ok := attributes["delete_on_vm_deletion"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`delete_on_vm_deletion is missing from object`)

		return nil, diags
	}

	deleteOnVmDeletionVal, ok := deleteOnVmDeletionAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`delete_on_vm_deletion expected to be basetypes.BoolValue, was: %T`, deleteOnVmDeletionAttribute))
	}

	iopsAttribute, ok := attributes["iops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iops is missing from object`)

		return nil, diags
	}

	iopsVal, ok := iopsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iops expected to be basetypes.Int64Value, was: %T`, iopsAttribute))
	}

	linkDateAttribute, ok := attributes["link_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`link_date is missing from object`)

		return nil, diags
	}

	linkDateVal, ok := linkDateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`link_date expected to be basetypes.StringValue, was: %T`, linkDateAttribute))
	}

	snapshotIdAttribute, ok := attributes["snapshot_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`snapshot_id is missing from object`)

		return nil, diags
	}

	snapshotIdVal, ok := snapshotIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`snapshot_id expected to be basetypes.StringValue, was: %T`, snapshotIdAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return nil, diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	volumeIdAttribute, ok := attributes["volume_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_id is missing from object`)

		return nil, diags
	}

	volumeIdVal, ok := volumeIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_id expected to be basetypes.StringValue, was: %T`, volumeIdAttribute))
	}

	volumeSizeAttribute, ok := attributes["volume_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_size is missing from object`)

		return nil, diags
	}

	volumeSizeVal, ok := volumeSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_size expected to be basetypes.Int64Value, was: %T`, volumeSizeAttribute))
	}

	volumeTypeAttribute, ok := attributes["volume_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_type is missing from object`)

		return nil, diags
	}

	volumeTypeVal, ok := volumeTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_type expected to be basetypes.StringValue, was: %T`, volumeTypeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BsuValue{
		DeleteOnVmDeletion: deleteOnVmDeletionVal,
		Iops:               iopsVal,
		LinkDate:           linkDateVal,
		SnapshotId:         snapshotIdVal,
		State:              stateVal,
		VolumeId:           volumeIdVal,
		VolumeSize:         volumeSizeVal,
		VolumeType:         volumeTypeVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewBsuValueNull() BsuValue {
	return BsuValue{
		state: attr.ValueStateNull,
	}
}

func NewBsuValueUnknown() BsuValue {
	return BsuValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBsuValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BsuValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BsuValue Attribute Value",
				"While creating a BsuValue value, a missing attribute value was detected. "+
					"A BsuValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BsuValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BsuValue Attribute Type",
				"While creating a BsuValue value, an invalid attribute value was detected. "+
					"A BsuValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BsuValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BsuValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BsuValue Attribute Value",
				"While creating a BsuValue value, an extra attribute value was detected. "+
					"A BsuValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BsuValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBsuValueUnknown(), diags
	}

	deleteOnVmDeletionAttribute, ok := attributes["delete_on_vm_deletion"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`delete_on_vm_deletion is missing from object`)

		return NewBsuValueUnknown(), diags
	}

	deleteOnVmDeletionVal, ok := deleteOnVmDeletionAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`delete_on_vm_deletion expected to be basetypes.BoolValue, was: %T`, deleteOnVmDeletionAttribute))
	}

	iopsAttribute, ok := attributes["iops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iops is missing from object`)

		return NewBsuValueUnknown(), diags
	}

	iopsVal, ok := iopsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iops expected to be basetypes.Int64Value, was: %T`, iopsAttribute))
	}

	linkDateAttribute, ok := attributes["link_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`link_date is missing from object`)

		return NewBsuValueUnknown(), diags
	}

	linkDateVal, ok := linkDateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`link_date expected to be basetypes.StringValue, was: %T`, linkDateAttribute))
	}

	snapshotIdAttribute, ok := attributes["snapshot_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`snapshot_id is missing from object`)

		return NewBsuValueUnknown(), diags
	}

	snapshotIdVal, ok := snapshotIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`snapshot_id expected to be basetypes.StringValue, was: %T`, snapshotIdAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return NewBsuValueUnknown(), diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	volumeIdAttribute, ok := attributes["volume_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_id is missing from object`)

		return NewBsuValueUnknown(), diags
	}

	volumeIdVal, ok := volumeIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_id expected to be basetypes.StringValue, was: %T`, volumeIdAttribute))
	}

	volumeSizeAttribute, ok := attributes["volume_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_size is missing from object`)

		return NewBsuValueUnknown(), diags
	}

	volumeSizeVal, ok := volumeSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_size expected to be basetypes.Int64Value, was: %T`, volumeSizeAttribute))
	}

	volumeTypeAttribute, ok := attributes["volume_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_type is missing from object`)

		return NewBsuValueUnknown(), diags
	}

	volumeTypeVal, ok := volumeTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_type expected to be basetypes.StringValue, was: %T`, volumeTypeAttribute))
	}

	if diags.HasError() {
		return NewBsuValueUnknown(), diags
	}

	return BsuValue{
		DeleteOnVmDeletion: deleteOnVmDeletionVal,
		Iops:               iopsVal,
		LinkDate:           linkDateVal,
		SnapshotId:         snapshotIdVal,
		State:              stateVal,
		VolumeId:           volumeIdVal,
		VolumeSize:         volumeSizeVal,
		VolumeType:         volumeTypeVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewBsuValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BsuValue {
	object, diags := NewBsuValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBsuValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BsuType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBsuValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBsuValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBsuValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBsuValueMust(BsuValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BsuType) ValueType(ctx context.Context) attr.Value {
	return BsuValue{}
}

var _ basetypes.ObjectValuable = BsuValue{}

type BsuValue struct {
	DeleteOnVmDeletion basetypes.BoolValue   `tfsdk:"delete_on_vm_deletion"`
	Iops               basetypes.Int64Value  `tfsdk:"iops"`
	LinkDate           basetypes.StringValue `tfsdk:"link_date"`
	SnapshotId         basetypes.StringValue `tfsdk:"snapshot_id"`
	State              basetypes.StringValue `tfsdk:"state"`
	VolumeId           basetypes.StringValue `tfsdk:"volume_id"`
	VolumeSize         basetypes.Int64Value  `tfsdk:"volume_size"`
	VolumeType         basetypes.StringValue `tfsdk:"volume_type"`
	state              attr.ValueState
}

func (v BsuValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["delete_on_vm_deletion"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["iops"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["link_date"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["snapshot_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["volume_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["volume_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["volume_type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.DeleteOnVmDeletion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["delete_on_vm_deletion"] = val

		val, err = v.Iops.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["iops"] = val

		val, err = v.LinkDate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["link_date"] = val

		val, err = v.SnapshotId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["snapshot_id"] = val

		val, err = v.State.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["state"] = val

		val, err = v.VolumeId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_id"] = val

		val, err = v.VolumeSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_size"] = val

		val, err = v.VolumeType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BsuValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BsuValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BsuValue) String() string {
	return "BsuValue"
}

func (v BsuValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"delete_on_vm_deletion": basetypes.BoolType{},
			"iops":                  basetypes.Int64Type{},
			"link_date":             basetypes.StringType{},
			"snapshot_id":           basetypes.StringType{},
			"state":                 basetypes.StringType{},
			"volume_id":             basetypes.StringType{},
			"volume_size":           basetypes.Int64Type{},
			"volume_type":           basetypes.StringType{},
		},
		map[string]attr.Value{
			"delete_on_vm_deletion": v.DeleteOnVmDeletion,
			"iops":                  v.Iops,
			"link_date":             v.LinkDate,
			"snapshot_id":           v.SnapshotId,
			"state":                 v.State,
			"volume_id":             v.VolumeId,
			"volume_size":           v.VolumeSize,
			"volume_type":           v.VolumeType,
		})

	return objVal, diags
}

func (v BsuValue) Equal(o attr.Value) bool {
	other, ok := o.(BsuValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DeleteOnVmDeletion.Equal(other.DeleteOnVmDeletion) {
		return false
	}

	if !v.Iops.Equal(other.Iops) {
		return false
	}

	if !v.LinkDate.Equal(other.LinkDate) {
		return false
	}

	if !v.SnapshotId.Equal(other.SnapshotId) {
		return false
	}

	if !v.State.Equal(other.State) {
		return false
	}

	if !v.VolumeId.Equal(other.VolumeId) {
		return false
	}

	if !v.VolumeSize.Equal(other.VolumeSize) {
		return false
	}

	if !v.VolumeType.Equal(other.VolumeType) {
		return false
	}

	return true
}

func (v BsuValue) Type(ctx context.Context) attr.Type {
	return BsuType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BsuValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"delete_on_vm_deletion": basetypes.BoolType{},
		"iops":                  basetypes.Int64Type{},
		"link_date":             basetypes.StringType{},
		"snapshot_id":           basetypes.StringType{},
		"state":                 basetypes.StringType{},
		"volume_id":             basetypes.StringType{},
		"volume_size":           basetypes.Int64Type{},
		"volume_type":           basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NicsType{}

type NicsType struct {
	basetypes.ObjectType
}

func (t NicsType) Equal(o attr.Type) bool {
	other, ok := o.(NicsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NicsType) String() string {
	return "NicsType"
}

func (t NicsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	deleteOnVmDeletionAttribute, ok := attributes["delete_on_vm_deletion"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`delete_on_vm_deletion is missing from object`)

		return nil, diags
	}

	deleteOnVmDeletionVal, ok := deleteOnVmDeletionAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`delete_on_vm_deletion expected to be basetypes.BoolValue, was: %T`, deleteOnVmDeletionAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	deviceNumberAttribute, ok := attributes["device_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`device_number is missing from object`)

		return nil, diags
	}

	deviceNumberVal, ok := deviceNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`device_number expected to be basetypes.Int64Value, was: %T`, deviceNumberAttribute))
	}

	isSourceDestCheckedAttribute, ok := attributes["is_source_dest_checked"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_source_dest_checked is missing from object`)

		return nil, diags
	}

	isSourceDestCheckedVal, ok := isSourceDestCheckedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_source_dest_checked expected to be basetypes.BoolValue, was: %T`, isSourceDestCheckedAttribute))
	}

	linkNicAttribute, ok := attributes["link_nic"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`link_nic is missing from object`)

		return nil, diags
	}

	linkNicVal, ok := linkNicAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`link_nic expected to be basetypes.ObjectValue, was: %T`, linkNicAttribute))
	}

	linkPublicIpAttribute, ok := attributes["link_public_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`link_public_ip is missing from object`)

		return nil, diags
	}

	linkPublicIpVal, ok := linkPublicIpAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`link_public_ip expected to be basetypes.ObjectValue, was: %T`, linkPublicIpAttribute))
	}

	macAddressAttribute, ok := attributes["mac_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_address is missing from object`)

		return nil, diags
	}

	macAddressVal, ok := macAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_address expected to be basetypes.StringValue, was: %T`, macAddressAttribute))
	}

	netIdAttribute, ok := attributes["net_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`net_id is missing from object`)

		return nil, diags
	}

	netIdVal, ok := netIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`net_id expected to be basetypes.StringValue, was: %T`, netIdAttribute))
	}

	nicIdAttribute, ok := attributes["nic_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nic_id is missing from object`)

		return nil, diags
	}

	nicIdVal, ok := nicIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nic_id expected to be basetypes.StringValue, was: %T`, nicIdAttribute))
	}

	privateDnsNameAttribute, ok := attributes["private_dns_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_dns_name is missing from object`)

		return nil, diags
	}

	privateDnsNameVal, ok := privateDnsNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_dns_name expected to be basetypes.StringValue, was: %T`, privateDnsNameAttribute))
	}

	privateIpsAttribute, ok := attributes["private_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_ips is missing from object`)

		return nil, diags
	}

	privateIpsVal, ok := privateIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_ips expected to be basetypes.ListValue, was: %T`, privateIpsAttribute))
	}

	secondaryPrivateIpCountAttribute, ok := attributes["secondary_private_ip_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secondary_private_ip_count is missing from object`)

		return nil, diags
	}

	secondaryPrivateIpCountVal, ok := secondaryPrivateIpCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secondary_private_ip_count expected to be basetypes.Int64Value, was: %T`, secondaryPrivateIpCountAttribute))
	}

	securityGroupIdsAttribute, ok := attributes["security_group_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_group_ids is missing from object`)

		return nil, diags
	}

	securityGroupIdsVal, ok := securityGroupIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_group_ids expected to be basetypes.ListValue, was: %T`, securityGroupIdsAttribute))
	}

	securityGroupsAttribute, ok := attributes["security_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_groups is missing from object`)

		return nil, diags
	}

	securityGroupsVal, ok := securityGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_groups expected to be basetypes.ListValue, was: %T`, securityGroupsAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return nil, diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	subnetIdAttribute, ok := attributes["subnet_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_id is missing from object`)

		return nil, diags
	}

	subnetIdVal, ok := subnetIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_id expected to be basetypes.StringValue, was: %T`, subnetIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NicsValue{
		DeleteOnVmDeletion:      deleteOnVmDeletionVal,
		Description:             descriptionVal,
		DeviceNumber:            deviceNumberVal,
		IsSourceDestChecked:     isSourceDestCheckedVal,
		LinkNic:                 linkNicVal,
		LinkPublicIp:            linkPublicIpVal,
		MacAddress:              macAddressVal,
		NetId:                   netIdVal,
		NicId:                   nicIdVal,
		PrivateDnsName:          privateDnsNameVal,
		PrivateIps:              privateIpsVal,
		SecondaryPrivateIpCount: secondaryPrivateIpCountVal,
		SecurityGroupIds:        securityGroupIdsVal,
		SecurityGroups:          securityGroupsVal,
		State:                   stateVal,
		SubnetId:                subnetIdVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewNicsValueNull() NicsValue {
	return NicsValue{
		state: attr.ValueStateNull,
	}
}

func NewNicsValueUnknown() NicsValue {
	return NicsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNicsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NicsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NicsValue Attribute Value",
				"While creating a NicsValue value, a missing attribute value was detected. "+
					"A NicsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NicsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NicsValue Attribute Type",
				"While creating a NicsValue value, an invalid attribute value was detected. "+
					"A NicsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NicsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NicsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NicsValue Attribute Value",
				"While creating a NicsValue value, an extra attribute value was detected. "+
					"A NicsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NicsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNicsValueUnknown(), diags
	}

	deleteOnVmDeletionAttribute, ok := attributes["delete_on_vm_deletion"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`delete_on_vm_deletion is missing from object`)

		return NewNicsValueUnknown(), diags
	}

	deleteOnVmDeletionVal, ok := deleteOnVmDeletionAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`delete_on_vm_deletion expected to be basetypes.BoolValue, was: %T`, deleteOnVmDeletionAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewNicsValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	deviceNumberAttribute, ok := attributes["device_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`device_number is missing from object`)

		return NewNicsValueUnknown(), diags
	}

	deviceNumberVal, ok := deviceNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`device_number expected to be basetypes.Int64Value, was: %T`, deviceNumberAttribute))
	}

	isSourceDestCheckedAttribute, ok := attributes["is_source_dest_checked"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_source_dest_checked is missing from object`)

		return NewNicsValueUnknown(), diags
	}

	isSourceDestCheckedVal, ok := isSourceDestCheckedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_source_dest_checked expected to be basetypes.BoolValue, was: %T`, isSourceDestCheckedAttribute))
	}

	linkNicAttribute, ok := attributes["link_nic"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`link_nic is missing from object`)

		return NewNicsValueUnknown(), diags
	}

	linkNicVal, ok := linkNicAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`link_nic expected to be basetypes.ObjectValue, was: %T`, linkNicAttribute))
	}

	linkPublicIpAttribute, ok := attributes["link_public_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`link_public_ip is missing from object`)

		return NewNicsValueUnknown(), diags
	}

	linkPublicIpVal, ok := linkPublicIpAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`link_public_ip expected to be basetypes.ObjectValue, was: %T`, linkPublicIpAttribute))
	}

	macAddressAttribute, ok := attributes["mac_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_address is missing from object`)

		return NewNicsValueUnknown(), diags
	}

	macAddressVal, ok := macAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_address expected to be basetypes.StringValue, was: %T`, macAddressAttribute))
	}

	netIdAttribute, ok := attributes["net_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`net_id is missing from object`)

		return NewNicsValueUnknown(), diags
	}

	netIdVal, ok := netIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`net_id expected to be basetypes.StringValue, was: %T`, netIdAttribute))
	}

	nicIdAttribute, ok := attributes["nic_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nic_id is missing from object`)

		return NewNicsValueUnknown(), diags
	}

	nicIdVal, ok := nicIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nic_id expected to be basetypes.StringValue, was: %T`, nicIdAttribute))
	}

	privateDnsNameAttribute, ok := attributes["private_dns_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_dns_name is missing from object`)

		return NewNicsValueUnknown(), diags
	}

	privateDnsNameVal, ok := privateDnsNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_dns_name expected to be basetypes.StringValue, was: %T`, privateDnsNameAttribute))
	}

	privateIpsAttribute, ok := attributes["private_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_ips is missing from object`)

		return NewNicsValueUnknown(), diags
	}

	privateIpsVal, ok := privateIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_ips expected to be basetypes.ListValue, was: %T`, privateIpsAttribute))
	}

	secondaryPrivateIpCountAttribute, ok := attributes["secondary_private_ip_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secondary_private_ip_count is missing from object`)

		return NewNicsValueUnknown(), diags
	}

	secondaryPrivateIpCountVal, ok := secondaryPrivateIpCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secondary_private_ip_count expected to be basetypes.Int64Value, was: %T`, secondaryPrivateIpCountAttribute))
	}

	securityGroupIdsAttribute, ok := attributes["security_group_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_group_ids is missing from object`)

		return NewNicsValueUnknown(), diags
	}

	securityGroupIdsVal, ok := securityGroupIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_group_ids expected to be basetypes.ListValue, was: %T`, securityGroupIdsAttribute))
	}

	securityGroupsAttribute, ok := attributes["security_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_groups is missing from object`)

		return NewNicsValueUnknown(), diags
	}

	securityGroupsVal, ok := securityGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_groups expected to be basetypes.ListValue, was: %T`, securityGroupsAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return NewNicsValueUnknown(), diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	subnetIdAttribute, ok := attributes["subnet_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_id is missing from object`)

		return NewNicsValueUnknown(), diags
	}

	subnetIdVal, ok := subnetIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_id expected to be basetypes.StringValue, was: %T`, subnetIdAttribute))
	}

	if diags.HasError() {
		return NewNicsValueUnknown(), diags
	}

	return NicsValue{
		DeleteOnVmDeletion:      deleteOnVmDeletionVal,
		Description:             descriptionVal,
		DeviceNumber:            deviceNumberVal,
		IsSourceDestChecked:     isSourceDestCheckedVal,
		LinkNic:                 linkNicVal,
		LinkPublicIp:            linkPublicIpVal,
		MacAddress:              macAddressVal,
		NetId:                   netIdVal,
		NicId:                   nicIdVal,
		PrivateDnsName:          privateDnsNameVal,
		PrivateIps:              privateIpsVal,
		SecondaryPrivateIpCount: secondaryPrivateIpCountVal,
		SecurityGroupIds:        securityGroupIdsVal,
		SecurityGroups:          securityGroupsVal,
		State:                   stateVal,
		SubnetId:                subnetIdVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewNicsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NicsValue {
	object, diags := NewNicsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNicsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NicsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNicsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNicsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNicsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNicsValueMust(NicsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NicsType) ValueType(ctx context.Context) attr.Value {
	return NicsValue{}
}

var _ basetypes.ObjectValuable = NicsValue{}

type NicsValue struct {
	DeleteOnVmDeletion      basetypes.BoolValue   `tfsdk:"delete_on_vm_deletion"`
	Description             basetypes.StringValue `tfsdk:"description"`
	DeviceNumber            basetypes.Int64Value  `tfsdk:"device_number"`
	IsSourceDestChecked     basetypes.BoolValue   `tfsdk:"is_source_dest_checked"`
	LinkNic                 basetypes.ObjectValue `tfsdk:"link_nic"`
	LinkPublicIp            basetypes.ObjectValue `tfsdk:"link_public_ip"`
	MacAddress              basetypes.StringValue `tfsdk:"mac_address"`
	NetId                   basetypes.StringValue `tfsdk:"net_id"`
	NicId                   basetypes.StringValue `tfsdk:"nic_id"`
	PrivateDnsName          basetypes.StringValue `tfsdk:"private_dns_name"`
	PrivateIps              basetypes.ListValue   `tfsdk:"private_ips"`
	SecondaryPrivateIpCount basetypes.Int64Value  `tfsdk:"secondary_private_ip_count"`
	SecurityGroupIds        basetypes.ListValue   `tfsdk:"security_group_ids"`
	SecurityGroups          basetypes.ListValue   `tfsdk:"security_groups"`
	State                   basetypes.StringValue `tfsdk:"state"`
	SubnetId                basetypes.StringValue `tfsdk:"subnet_id"`
	state                   attr.ValueState
}

func (v NicsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 17)

	var val tftypes.Value
	var err error

	attrTypes["delete_on_vm_deletion"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["device_number"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["is_source_dest_checked"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["link_nic"] = basetypes.ObjectType{
		AttrTypes: LinkNicValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["link_public_ip"] = basetypes.ObjectType{
		AttrTypes: LinkPublicIpValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["mac_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["net_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["nic_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["private_dns_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["private_ips"] = basetypes.ListType{
		ElemType: PrivateIpsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["secondary_private_ip_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["security_group_ids"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["security_groups"] = basetypes.ListType{
		ElemType: SecurityGroupsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 17)

		val, err = v.DeleteOnVmDeletion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["delete_on_vm_deletion"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.DeviceNumber.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["device_number"] = val

		val, err = v.IsSourceDestChecked.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_source_dest_checked"] = val

		val, err = v.LinkNic.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["link_nic"] = val

		val, err = v.LinkPublicIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["link_public_ip"] = val

		val, err = v.MacAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_address"] = val

		val, err = v.NetId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["net_id"] = val

		val, err = v.NicId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["nic_id"] = val

		val, err = v.PrivateDnsName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["private_dns_name"] = val

		val, err = v.PrivateIps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["private_ips"] = val

		val, err = v.SecondaryPrivateIpCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secondary_private_ip_count"] = val

		val, err = v.SecurityGroupIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["security_group_ids"] = val

		val, err = v.SecurityGroups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["security_groups"] = val

		val, err = v.State.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["state"] = val

		val, err = v.SubnetId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NicsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NicsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NicsValue) String() string {
	return "NicsValue"
}

func (v NicsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var linkNic basetypes.ObjectValue

	if v.LinkNic.IsNull() {
		linkNic = types.ObjectNull(
			LinkNicValue{}.AttributeTypes(ctx),
		)
	}

	if v.LinkNic.IsUnknown() {
		linkNic = types.ObjectUnknown(
			LinkNicValue{}.AttributeTypes(ctx),
		)
	}

	if !v.LinkNic.IsNull() && !v.LinkNic.IsUnknown() {
		linkNic = types.ObjectValueMust(
			LinkNicValue{}.AttributeTypes(ctx),
			v.LinkNic.Attributes(),
		)
	}

	var linkPublicIp basetypes.ObjectValue

	if v.LinkPublicIp.IsNull() {
		linkPublicIp = types.ObjectNull(
			LinkPublicIpValue{}.AttributeTypes(ctx),
		)
	}

	if v.LinkPublicIp.IsUnknown() {
		linkPublicIp = types.ObjectUnknown(
			LinkPublicIpValue{}.AttributeTypes(ctx),
		)
	}

	if !v.LinkPublicIp.IsNull() && !v.LinkPublicIp.IsUnknown() {
		linkPublicIp = types.ObjectValueMust(
			LinkPublicIpValue{}.AttributeTypes(ctx),
			v.LinkPublicIp.Attributes(),
		)
	}

	privateIps := types.ListValueMust(
		PrivateIpsType{
			basetypes.ObjectType{
				AttrTypes: PrivateIpsValue{}.AttributeTypes(ctx),
			},
		},
		v.PrivateIps.Elements(),
	)

	if v.PrivateIps.IsNull() {
		privateIps = types.ListNull(
			PrivateIpsType{
				basetypes.ObjectType{
					AttrTypes: PrivateIpsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.PrivateIps.IsUnknown() {
		privateIps = types.ListUnknown(
			PrivateIpsType{
				basetypes.ObjectType{
					AttrTypes: PrivateIpsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	securityGroups := types.ListValueMust(
		SecurityGroupsType{
			basetypes.ObjectType{
				AttrTypes: SecurityGroupsValue{}.AttributeTypes(ctx),
			},
		},
		v.SecurityGroups.Elements(),
	)

	if v.SecurityGroups.IsNull() {
		securityGroups = types.ListNull(
			SecurityGroupsType{
				basetypes.ObjectType{
					AttrTypes: SecurityGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.SecurityGroups.IsUnknown() {
		securityGroups = types.ListUnknown(
			SecurityGroupsType{
				basetypes.ObjectType{
					AttrTypes: SecurityGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	securityGroupIdsVal, d := types.ListValue(types.StringType, v.SecurityGroupIds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"delete_on_vm_deletion":  basetypes.BoolType{},
			"description":            basetypes.StringType{},
			"device_number":          basetypes.Int64Type{},
			"is_source_dest_checked": basetypes.BoolType{},
			"link_nic": basetypes.ObjectType{
				AttrTypes: LinkNicValue{}.AttributeTypes(ctx),
			},
			"link_public_ip": basetypes.ObjectType{
				AttrTypes: LinkPublicIpValue{}.AttributeTypes(ctx),
			},
			"mac_address":      basetypes.StringType{},
			"net_id":           basetypes.StringType{},
			"nic_id":           basetypes.StringType{},
			"private_dns_name": basetypes.StringType{},
			"private_ips": basetypes.ListType{
				ElemType: PrivateIpsValue{}.Type(ctx),
			},
			"secondary_private_ip_count": basetypes.Int64Type{},
			"security_group_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"security_groups": basetypes.ListType{
				ElemType: SecurityGroupsValue{}.Type(ctx),
			},
			"state":     basetypes.StringType{},
			"subnet_id": basetypes.StringType{},
		}), diags
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"delete_on_vm_deletion":  basetypes.BoolType{},
			"description":            basetypes.StringType{},
			"device_number":          basetypes.Int64Type{},
			"is_source_dest_checked": basetypes.BoolType{},
			"link_nic": basetypes.ObjectType{
				AttrTypes: LinkNicValue{}.AttributeTypes(ctx),
			},
			"link_public_ip": basetypes.ObjectType{
				AttrTypes: LinkPublicIpValue{}.AttributeTypes(ctx),
			},
			"mac_address":      basetypes.StringType{},
			"net_id":           basetypes.StringType{},
			"nic_id":           basetypes.StringType{},
			"private_dns_name": basetypes.StringType{},
			"private_ips": basetypes.ListType{
				ElemType: PrivateIpsValue{}.Type(ctx),
			},
			"secondary_private_ip_count": basetypes.Int64Type{},
			"security_group_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"security_groups": basetypes.ListType{
				ElemType: SecurityGroupsValue{}.Type(ctx),
			},
			"state":     basetypes.StringType{},
			"subnet_id": basetypes.StringType{},
		},
		map[string]attr.Value{
			"delete_on_vm_deletion":      v.DeleteOnVmDeletion,
			"description":                v.Description,
			"device_number":              v.DeviceNumber,
			"is_source_dest_checked":     v.IsSourceDestChecked,
			"link_nic":                   linkNic,
			"link_public_ip":             linkPublicIp,
			"mac_address":                v.MacAddress,
			"net_id":                     v.NetId,
			"nic_id":                     v.NicId,
			"private_dns_name":           v.PrivateDnsName,
			"private_ips":                privateIps,
			"secondary_private_ip_count": v.SecondaryPrivateIpCount,
			"security_group_ids":         securityGroupIdsVal,
			"security_groups":            securityGroups,
			"state":                      v.State,
			"subnet_id":                  v.SubnetId,
		})

	return objVal, diags
}

func (v NicsValue) Equal(o attr.Value) bool {
	other, ok := o.(NicsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DeleteOnVmDeletion.Equal(other.DeleteOnVmDeletion) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.DeviceNumber.Equal(other.DeviceNumber) {
		return false
	}

	if !v.IsSourceDestChecked.Equal(other.IsSourceDestChecked) {
		return false
	}

	if !v.LinkNic.Equal(other.LinkNic) {
		return false
	}

	if !v.LinkPublicIp.Equal(other.LinkPublicIp) {
		return false
	}

	if !v.MacAddress.Equal(other.MacAddress) {
		return false
	}

	if !v.NetId.Equal(other.NetId) {
		return false
	}

	if !v.NicId.Equal(other.NicId) {
		return false
	}

	if !v.PrivateDnsName.Equal(other.PrivateDnsName) {
		return false
	}

	if !v.PrivateIps.Equal(other.PrivateIps) {
		return false
	}

	if !v.SecondaryPrivateIpCount.Equal(other.SecondaryPrivateIpCount) {
		return false
	}

	if !v.SecurityGroupIds.Equal(other.SecurityGroupIds) {
		return false
	}

	if !v.SecurityGroups.Equal(other.SecurityGroups) {
		return false
	}

	if !v.State.Equal(other.State) {
		return false
	}

	if !v.SubnetId.Equal(other.SubnetId) {
		return false
	}

	return true
}

func (v NicsValue) Type(ctx context.Context) attr.Type {
	return NicsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NicsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"delete_on_vm_deletion":  basetypes.BoolType{},
		"description":            basetypes.StringType{},
		"device_number":          basetypes.Int64Type{},
		"is_source_dest_checked": basetypes.BoolType{},
		"link_nic": basetypes.ObjectType{
			AttrTypes: LinkNicValue{}.AttributeTypes(ctx),
		},
		"link_public_ip": basetypes.ObjectType{
			AttrTypes: LinkPublicIpValue{}.AttributeTypes(ctx),
		},
		"mac_address":      basetypes.StringType{},
		"net_id":           basetypes.StringType{},
		"nic_id":           basetypes.StringType{},
		"private_dns_name": basetypes.StringType{},
		"private_ips": basetypes.ListType{
			ElemType: PrivateIpsValue{}.Type(ctx),
		},
		"secondary_private_ip_count": basetypes.Int64Type{},
		"security_group_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"security_groups": basetypes.ListType{
			ElemType: SecurityGroupsValue{}.Type(ctx),
		},
		"state":     basetypes.StringType{},
		"subnet_id": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = LinkNicType{}

type LinkNicType struct {
	basetypes.ObjectType
}

func (t LinkNicType) Equal(o attr.Type) bool {
	other, ok := o.(LinkNicType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LinkNicType) String() string {
	return "LinkNicType"
}

func (t LinkNicType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	deleteOnVmDeletionAttribute, ok := attributes["delete_on_vm_deletion"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`delete_on_vm_deletion is missing from object`)

		return nil, diags
	}

	deleteOnVmDeletionVal, ok := deleteOnVmDeletionAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`delete_on_vm_deletion expected to be basetypes.BoolValue, was: %T`, deleteOnVmDeletionAttribute))
	}

	deviceNumberAttribute, ok := attributes["device_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`device_number is missing from object`)

		return nil, diags
	}

	deviceNumberVal, ok := deviceNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`device_number expected to be basetypes.Int64Value, was: %T`, deviceNumberAttribute))
	}

	linkNicIdAttribute, ok := attributes["link_nic_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`link_nic_id is missing from object`)

		return nil, diags
	}

	linkNicIdVal, ok := linkNicIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`link_nic_id expected to be basetypes.StringValue, was: %T`, linkNicIdAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return nil, diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LinkNicValue{
		DeleteOnVmDeletion: deleteOnVmDeletionVal,
		DeviceNumber:       deviceNumberVal,
		LinkNicId:          linkNicIdVal,
		State:              stateVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewLinkNicValueNull() LinkNicValue {
	return LinkNicValue{
		state: attr.ValueStateNull,
	}
}

func NewLinkNicValueUnknown() LinkNicValue {
	return LinkNicValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLinkNicValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LinkNicValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LinkNicValue Attribute Value",
				"While creating a LinkNicValue value, a missing attribute value was detected. "+
					"A LinkNicValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LinkNicValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LinkNicValue Attribute Type",
				"While creating a LinkNicValue value, an invalid attribute value was detected. "+
					"A LinkNicValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LinkNicValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LinkNicValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LinkNicValue Attribute Value",
				"While creating a LinkNicValue value, an extra attribute value was detected. "+
					"A LinkNicValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LinkNicValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLinkNicValueUnknown(), diags
	}

	deleteOnVmDeletionAttribute, ok := attributes["delete_on_vm_deletion"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`delete_on_vm_deletion is missing from object`)

		return NewLinkNicValueUnknown(), diags
	}

	deleteOnVmDeletionVal, ok := deleteOnVmDeletionAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`delete_on_vm_deletion expected to be basetypes.BoolValue, was: %T`, deleteOnVmDeletionAttribute))
	}

	deviceNumberAttribute, ok := attributes["device_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`device_number is missing from object`)

		return NewLinkNicValueUnknown(), diags
	}

	deviceNumberVal, ok := deviceNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`device_number expected to be basetypes.Int64Value, was: %T`, deviceNumberAttribute))
	}

	linkNicIdAttribute, ok := attributes["link_nic_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`link_nic_id is missing from object`)

		return NewLinkNicValueUnknown(), diags
	}

	linkNicIdVal, ok := linkNicIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`link_nic_id expected to be basetypes.StringValue, was: %T`, linkNicIdAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return NewLinkNicValueUnknown(), diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	if diags.HasError() {
		return NewLinkNicValueUnknown(), diags
	}

	return LinkNicValue{
		DeleteOnVmDeletion: deleteOnVmDeletionVal,
		DeviceNumber:       deviceNumberVal,
		LinkNicId:          linkNicIdVal,
		State:              stateVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewLinkNicValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LinkNicValue {
	object, diags := NewLinkNicValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLinkNicValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LinkNicType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLinkNicValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLinkNicValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLinkNicValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLinkNicValueMust(LinkNicValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LinkNicType) ValueType(ctx context.Context) attr.Value {
	return LinkNicValue{}
}

var _ basetypes.ObjectValuable = LinkNicValue{}

type LinkNicValue struct {
	DeleteOnVmDeletion basetypes.BoolValue   `tfsdk:"delete_on_vm_deletion"`
	DeviceNumber       basetypes.Int64Value  `tfsdk:"device_number"`
	LinkNicId          basetypes.StringValue `tfsdk:"link_nic_id"`
	State              basetypes.StringValue `tfsdk:"state"`
	state              attr.ValueState
}

func (v LinkNicValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["delete_on_vm_deletion"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["device_number"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["link_nic_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["state"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.DeleteOnVmDeletion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["delete_on_vm_deletion"] = val

		val, err = v.DeviceNumber.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["device_number"] = val

		val, err = v.LinkNicId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["link_nic_id"] = val

		val, err = v.State.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["state"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LinkNicValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LinkNicValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LinkNicValue) String() string {
	return "LinkNicValue"
}

func (v LinkNicValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"delete_on_vm_deletion": basetypes.BoolType{},
			"device_number":         basetypes.Int64Type{},
			"link_nic_id":           basetypes.StringType{},
			"state":                 basetypes.StringType{},
		},
		map[string]attr.Value{
			"delete_on_vm_deletion": v.DeleteOnVmDeletion,
			"device_number":         v.DeviceNumber,
			"link_nic_id":           v.LinkNicId,
			"state":                 v.State,
		})

	return objVal, diags
}

func (v LinkNicValue) Equal(o attr.Value) bool {
	other, ok := o.(LinkNicValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DeleteOnVmDeletion.Equal(other.DeleteOnVmDeletion) {
		return false
	}

	if !v.DeviceNumber.Equal(other.DeviceNumber) {
		return false
	}

	if !v.LinkNicId.Equal(other.LinkNicId) {
		return false
	}

	if !v.State.Equal(other.State) {
		return false
	}

	return true
}

func (v LinkNicValue) Type(ctx context.Context) attr.Type {
	return LinkNicType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LinkNicValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"delete_on_vm_deletion": basetypes.BoolType{},
		"device_number":         basetypes.Int64Type{},
		"link_nic_id":           basetypes.StringType{},
		"state":                 basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = LinkPublicIpType{}

type LinkPublicIpType struct {
	basetypes.ObjectType
}

func (t LinkPublicIpType) Equal(o attr.Type) bool {
	other, ok := o.(LinkPublicIpType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LinkPublicIpType) String() string {
	return "LinkPublicIpType"
}

func (t LinkPublicIpType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	publicDnsNameAttribute, ok := attributes["public_dns_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_dns_name is missing from object`)

		return nil, diags
	}

	publicDnsNameVal, ok := publicDnsNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_dns_name expected to be basetypes.StringValue, was: %T`, publicDnsNameAttribute))
	}

	publicIpAttribute, ok := attributes["public_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_ip is missing from object`)

		return nil, diags
	}

	publicIpVal, ok := publicIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_ip expected to be basetypes.StringValue, was: %T`, publicIpAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LinkPublicIpValue{
		PublicDnsName: publicDnsNameVal,
		PublicIp:      publicIpVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewLinkPublicIpValueNull() LinkPublicIpValue {
	return LinkPublicIpValue{
		state: attr.ValueStateNull,
	}
}

func NewLinkPublicIpValueUnknown() LinkPublicIpValue {
	return LinkPublicIpValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLinkPublicIpValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LinkPublicIpValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LinkPublicIpValue Attribute Value",
				"While creating a LinkPublicIpValue value, a missing attribute value was detected. "+
					"A LinkPublicIpValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LinkPublicIpValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LinkPublicIpValue Attribute Type",
				"While creating a LinkPublicIpValue value, an invalid attribute value was detected. "+
					"A LinkPublicIpValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LinkPublicIpValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LinkPublicIpValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LinkPublicIpValue Attribute Value",
				"While creating a LinkPublicIpValue value, an extra attribute value was detected. "+
					"A LinkPublicIpValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LinkPublicIpValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLinkPublicIpValueUnknown(), diags
	}

	publicDnsNameAttribute, ok := attributes["public_dns_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_dns_name is missing from object`)

		return NewLinkPublicIpValueUnknown(), diags
	}

	publicDnsNameVal, ok := publicDnsNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_dns_name expected to be basetypes.StringValue, was: %T`, publicDnsNameAttribute))
	}

	publicIpAttribute, ok := attributes["public_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_ip is missing from object`)

		return NewLinkPublicIpValueUnknown(), diags
	}

	publicIpVal, ok := publicIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_ip expected to be basetypes.StringValue, was: %T`, publicIpAttribute))
	}

	if diags.HasError() {
		return NewLinkPublicIpValueUnknown(), diags
	}

	return LinkPublicIpValue{
		PublicDnsName: publicDnsNameVal,
		PublicIp:      publicIpVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewLinkPublicIpValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LinkPublicIpValue {
	object, diags := NewLinkPublicIpValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLinkPublicIpValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LinkPublicIpType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLinkPublicIpValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLinkPublicIpValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLinkPublicIpValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLinkPublicIpValueMust(LinkPublicIpValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LinkPublicIpType) ValueType(ctx context.Context) attr.Value {
	return LinkPublicIpValue{}
}

var _ basetypes.ObjectValuable = LinkPublicIpValue{}

type LinkPublicIpValue struct {
	PublicDnsName basetypes.StringValue `tfsdk:"public_dns_name"`
	PublicIp      basetypes.StringValue `tfsdk:"public_ip"`
	state         attr.ValueState
}

func (v LinkPublicIpValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["public_dns_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["public_ip"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.PublicDnsName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["public_dns_name"] = val

		val, err = v.PublicIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["public_ip"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LinkPublicIpValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LinkPublicIpValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LinkPublicIpValue) String() string {
	return "LinkPublicIpValue"
}

func (v LinkPublicIpValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"public_dns_name": basetypes.StringType{},
			"public_ip":       basetypes.StringType{},
		},
		map[string]attr.Value{
			"public_dns_name": v.PublicDnsName,
			"public_ip":       v.PublicIp,
		})

	return objVal, diags
}

func (v LinkPublicIpValue) Equal(o attr.Value) bool {
	other, ok := o.(LinkPublicIpValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.PublicDnsName.Equal(other.PublicDnsName) {
		return false
	}

	if !v.PublicIp.Equal(other.PublicIp) {
		return false
	}

	return true
}

func (v LinkPublicIpValue) Type(ctx context.Context) attr.Type {
	return LinkPublicIpType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LinkPublicIpValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"public_dns_name": basetypes.StringType{},
		"public_ip":       basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PrivateIpsType{}

type PrivateIpsType struct {
	basetypes.ObjectType
}

func (t PrivateIpsType) Equal(o attr.Type) bool {
	other, ok := o.(PrivateIpsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrivateIpsType) String() string {
	return "PrivateIpsType"
}

func (t PrivateIpsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	isPrimaryAttribute, ok := attributes["is_primary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_primary is missing from object`)

		return nil, diags
	}

	isPrimaryVal, ok := isPrimaryAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_primary expected to be basetypes.BoolValue, was: %T`, isPrimaryAttribute))
	}

	linkPublicIpAttribute, ok := attributes["link_public_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`link_public_ip is missing from object`)

		return nil, diags
	}

	linkPublicIpVal, ok := linkPublicIpAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`link_public_ip expected to be basetypes.ObjectValue, was: %T`, linkPublicIpAttribute))
	}

	privateDnsNameAttribute, ok := attributes["private_dns_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_dns_name is missing from object`)

		return nil, diags
	}

	privateDnsNameVal, ok := privateDnsNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_dns_name expected to be basetypes.StringValue, was: %T`, privateDnsNameAttribute))
	}

	privateIpAttribute, ok := attributes["private_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_ip is missing from object`)

		return nil, diags
	}

	privateIpVal, ok := privateIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_ip expected to be basetypes.StringValue, was: %T`, privateIpAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrivateIpsValue{
		IsPrimary:      isPrimaryVal,
		LinkPublicIp:   linkPublicIpVal,
		PrivateDnsName: privateDnsNameVal,
		PrivateIp:      privateIpVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewPrivateIpsValueNull() PrivateIpsValue {
	return PrivateIpsValue{
		state: attr.ValueStateNull,
	}
}

func NewPrivateIpsValueUnknown() PrivateIpsValue {
	return PrivateIpsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPrivateIpsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrivateIpsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrivateIpsValue Attribute Value",
				"While creating a PrivateIpsValue value, a missing attribute value was detected. "+
					"A PrivateIpsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrivateIpsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrivateIpsValue Attribute Type",
				"While creating a PrivateIpsValue value, an invalid attribute value was detected. "+
					"A PrivateIpsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrivateIpsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrivateIpsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrivateIpsValue Attribute Value",
				"While creating a PrivateIpsValue value, an extra attribute value was detected. "+
					"A PrivateIpsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrivateIpsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrivateIpsValueUnknown(), diags
	}

	isPrimaryAttribute, ok := attributes["is_primary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_primary is missing from object`)

		return NewPrivateIpsValueUnknown(), diags
	}

	isPrimaryVal, ok := isPrimaryAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_primary expected to be basetypes.BoolValue, was: %T`, isPrimaryAttribute))
	}

	linkPublicIpAttribute, ok := attributes["link_public_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`link_public_ip is missing from object`)

		return NewPrivateIpsValueUnknown(), diags
	}

	linkPublicIpVal, ok := linkPublicIpAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`link_public_ip expected to be basetypes.ObjectValue, was: %T`, linkPublicIpAttribute))
	}

	privateDnsNameAttribute, ok := attributes["private_dns_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_dns_name is missing from object`)

		return NewPrivateIpsValueUnknown(), diags
	}

	privateDnsNameVal, ok := privateDnsNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_dns_name expected to be basetypes.StringValue, was: %T`, privateDnsNameAttribute))
	}

	privateIpAttribute, ok := attributes["private_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_ip is missing from object`)

		return NewPrivateIpsValueUnknown(), diags
	}

	privateIpVal, ok := privateIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_ip expected to be basetypes.StringValue, was: %T`, privateIpAttribute))
	}

	if diags.HasError() {
		return NewPrivateIpsValueUnknown(), diags
	}

	return PrivateIpsValue{
		IsPrimary:      isPrimaryVal,
		LinkPublicIp:   linkPublicIpVal,
		PrivateDnsName: privateDnsNameVal,
		PrivateIp:      privateIpVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewPrivateIpsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrivateIpsValue {
	object, diags := NewPrivateIpsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrivateIpsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrivateIpsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrivateIpsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrivateIpsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrivateIpsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrivateIpsValueMust(PrivateIpsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PrivateIpsType) ValueType(ctx context.Context) attr.Value {
	return PrivateIpsValue{}
}

var _ basetypes.ObjectValuable = PrivateIpsValue{}

type PrivateIpsValue struct {
	IsPrimary      basetypes.BoolValue   `tfsdk:"is_primary"`
	LinkPublicIp   basetypes.ObjectValue `tfsdk:"link_public_ip"`
	PrivateDnsName basetypes.StringValue `tfsdk:"private_dns_name"`
	PrivateIp      basetypes.StringValue `tfsdk:"private_ip"`
	state          attr.ValueState
}

func (v PrivateIpsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["is_primary"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["link_public_ip"] = basetypes.ObjectType{
		AttrTypes: LinkPublicIpValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["private_dns_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["private_ip"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.IsPrimary.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_primary"] = val

		val, err = v.LinkPublicIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["link_public_ip"] = val

		val, err = v.PrivateDnsName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["private_dns_name"] = val

		val, err = v.PrivateIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["private_ip"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrivateIpsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrivateIpsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrivateIpsValue) String() string {
	return "PrivateIpsValue"
}

func (v PrivateIpsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var linkPublicIp basetypes.ObjectValue

	if v.LinkPublicIp.IsNull() {
		linkPublicIp = types.ObjectNull(
			LinkPublicIpValue{}.AttributeTypes(ctx),
		)
	}

	if v.LinkPublicIp.IsUnknown() {
		linkPublicIp = types.ObjectUnknown(
			LinkPublicIpValue{}.AttributeTypes(ctx),
		)
	}

	if !v.LinkPublicIp.IsNull() && !v.LinkPublicIp.IsUnknown() {
		linkPublicIp = types.ObjectValueMust(
			LinkPublicIpValue{}.AttributeTypes(ctx),
			v.LinkPublicIp.Attributes(),
		)
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"is_primary": basetypes.BoolType{},
			"link_public_ip": basetypes.ObjectType{
				AttrTypes: LinkPublicIpValue{}.AttributeTypes(ctx),
			},
			"private_dns_name": basetypes.StringType{},
			"private_ip":       basetypes.StringType{},
		},
		map[string]attr.Value{
			"is_primary":       v.IsPrimary,
			"link_public_ip":   linkPublicIp,
			"private_dns_name": v.PrivateDnsName,
			"private_ip":       v.PrivateIp,
		})

	return objVal, diags
}

func (v PrivateIpsValue) Equal(o attr.Value) bool {
	other, ok := o.(PrivateIpsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.IsPrimary.Equal(other.IsPrimary) {
		return false
	}

	if !v.LinkPublicIp.Equal(other.LinkPublicIp) {
		return false
	}

	if !v.PrivateDnsName.Equal(other.PrivateDnsName) {
		return false
	}

	if !v.PrivateIp.Equal(other.PrivateIp) {
		return false
	}

	return true
}

func (v PrivateIpsValue) Type(ctx context.Context) attr.Type {
	return PrivateIpsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrivateIpsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"is_primary": basetypes.BoolType{},
		"link_public_ip": basetypes.ObjectType{
			AttrTypes: LinkPublicIpValue{}.AttributeTypes(ctx),
		},
		"private_dns_name": basetypes.StringType{},
		"private_ip":       basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SecurityGroupsType{}

type SecurityGroupsType struct {
	basetypes.ObjectType
}

func (t SecurityGroupsType) Equal(o attr.Type) bool {
	other, ok := o.(SecurityGroupsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SecurityGroupsType) String() string {
	return "SecurityGroupsType"
}

func (t SecurityGroupsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	securityGroupIdAttribute, ok := attributes["security_group_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_group_id is missing from object`)

		return nil, diags
	}

	securityGroupIdVal, ok := securityGroupIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_group_id expected to be basetypes.StringValue, was: %T`, securityGroupIdAttribute))
	}

	securityGroupNameAttribute, ok := attributes["security_group_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_group_name is missing from object`)

		return nil, diags
	}

	securityGroupNameVal, ok := securityGroupNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_group_name expected to be basetypes.StringValue, was: %T`, securityGroupNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SecurityGroupsValue{
		SecurityGroupId:   securityGroupIdVal,
		SecurityGroupName: securityGroupNameVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewSecurityGroupsValueNull() SecurityGroupsValue {
	return SecurityGroupsValue{
		state: attr.ValueStateNull,
	}
}

func NewSecurityGroupsValueUnknown() SecurityGroupsValue {
	return SecurityGroupsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSecurityGroupsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SecurityGroupsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SecurityGroupsValue Attribute Value",
				"While creating a SecurityGroupsValue value, a missing attribute value was detected. "+
					"A SecurityGroupsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecurityGroupsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SecurityGroupsValue Attribute Type",
				"While creating a SecurityGroupsValue value, an invalid attribute value was detected. "+
					"A SecurityGroupsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecurityGroupsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SecurityGroupsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SecurityGroupsValue Attribute Value",
				"While creating a SecurityGroupsValue value, an extra attribute value was detected. "+
					"A SecurityGroupsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SecurityGroupsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSecurityGroupsValueUnknown(), diags
	}

	securityGroupIdAttribute, ok := attributes["security_group_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_group_id is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	securityGroupIdVal, ok := securityGroupIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_group_id expected to be basetypes.StringValue, was: %T`, securityGroupIdAttribute))
	}

	securityGroupNameAttribute, ok := attributes["security_group_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_group_name is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	securityGroupNameVal, ok := securityGroupNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_group_name expected to be basetypes.StringValue, was: %T`, securityGroupNameAttribute))
	}

	if diags.HasError() {
		return NewSecurityGroupsValueUnknown(), diags
	}

	return SecurityGroupsValue{
		SecurityGroupId:   securityGroupIdVal,
		SecurityGroupName: securityGroupNameVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewSecurityGroupsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SecurityGroupsValue {
	object, diags := NewSecurityGroupsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSecurityGroupsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SecurityGroupsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSecurityGroupsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSecurityGroupsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSecurityGroupsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSecurityGroupsValueMust(SecurityGroupsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SecurityGroupsType) ValueType(ctx context.Context) attr.Value {
	return SecurityGroupsValue{}
}

var _ basetypes.ObjectValuable = SecurityGroupsValue{}

type SecurityGroupsValue struct {
	SecurityGroupId   basetypes.StringValue `tfsdk:"security_group_id"`
	SecurityGroupName basetypes.StringValue `tfsdk:"security_group_name"`
	state             attr.ValueState
}

func (v SecurityGroupsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["security_group_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["security_group_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.SecurityGroupId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["security_group_id"] = val

		val, err = v.SecurityGroupName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["security_group_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SecurityGroupsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SecurityGroupsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SecurityGroupsValue) String() string {
	return "SecurityGroupsValue"
}

func (v SecurityGroupsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"security_group_id":   basetypes.StringType{},
			"security_group_name": basetypes.StringType{},
		},
		map[string]attr.Value{
			"security_group_id":   v.SecurityGroupId,
			"security_group_name": v.SecurityGroupName,
		})

	return objVal, diags
}

func (v SecurityGroupsValue) Equal(o attr.Value) bool {
	other, ok := o.(SecurityGroupsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.SecurityGroupId.Equal(other.SecurityGroupId) {
		return false
	}

	if !v.SecurityGroupName.Equal(other.SecurityGroupName) {
		return false
	}

	return true
}

func (v SecurityGroupsValue) Type(ctx context.Context) attr.Type {
	return SecurityGroupsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SecurityGroupsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"security_group_id":   basetypes.StringType{},
		"security_group_name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PlacementType{}

type PlacementType struct {
	basetypes.ObjectType
}

func (t PlacementType) Equal(o attr.Type) bool {
	other, ok := o.(PlacementType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PlacementType) String() string {
	return "PlacementType"
}

func (t PlacementType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	subregionNameAttribute, ok := attributes["subregion_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subregion_name is missing from object`)

		return nil, diags
	}

	subregionNameVal, ok := subregionNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subregion_name expected to be basetypes.StringValue, was: %T`, subregionNameAttribute))
	}

	tenancyAttribute, ok := attributes["tenancy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenancy is missing from object`)

		return nil, diags
	}

	tenancyVal, ok := tenancyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenancy expected to be basetypes.StringValue, was: %T`, tenancyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PlacementValue{
		SubregionName: subregionNameVal,
		Tenancy:       tenancyVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewPlacementValueNull() PlacementValue {
	return PlacementValue{
		state: attr.ValueStateNull,
	}
}

func NewPlacementValueUnknown() PlacementValue {
	return PlacementValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPlacementValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PlacementValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PlacementValue Attribute Value",
				"While creating a PlacementValue value, a missing attribute value was detected. "+
					"A PlacementValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PlacementValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PlacementValue Attribute Type",
				"While creating a PlacementValue value, an invalid attribute value was detected. "+
					"A PlacementValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PlacementValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PlacementValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PlacementValue Attribute Value",
				"While creating a PlacementValue value, an extra attribute value was detected. "+
					"A PlacementValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PlacementValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPlacementValueUnknown(), diags
	}

	subregionNameAttribute, ok := attributes["subregion_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subregion_name is missing from object`)

		return NewPlacementValueUnknown(), diags
	}

	subregionNameVal, ok := subregionNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subregion_name expected to be basetypes.StringValue, was: %T`, subregionNameAttribute))
	}

	tenancyAttribute, ok := attributes["tenancy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenancy is missing from object`)

		return NewPlacementValueUnknown(), diags
	}

	tenancyVal, ok := tenancyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenancy expected to be basetypes.StringValue, was: %T`, tenancyAttribute))
	}

	if diags.HasError() {
		return NewPlacementValueUnknown(), diags
	}

	return PlacementValue{
		SubregionName: subregionNameVal,
		Tenancy:       tenancyVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewPlacementValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PlacementValue {
	object, diags := NewPlacementValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPlacementValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PlacementType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPlacementValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPlacementValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPlacementValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPlacementValueMust(PlacementValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PlacementType) ValueType(ctx context.Context) attr.Value {
	return PlacementValue{}
}

var _ basetypes.ObjectValuable = PlacementValue{}

type PlacementValue struct {
	SubregionName basetypes.StringValue `tfsdk:"subregion_name"`
	Tenancy       basetypes.StringValue `tfsdk:"tenancy"`
	state         attr.ValueState
}

func (v PlacementValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["subregion_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tenancy"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.SubregionName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subregion_name"] = val

		val, err = v.Tenancy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tenancy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PlacementValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PlacementValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PlacementValue) String() string {
	return "PlacementValue"
}

func (v PlacementValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"subregion_name": basetypes.StringType{},
			"tenancy":        basetypes.StringType{},
		},
		map[string]attr.Value{
			"subregion_name": v.SubregionName,
			"tenancy":        v.Tenancy,
		})

	return objVal, diags
}

func (v PlacementValue) Equal(o attr.Value) bool {
	other, ok := o.(PlacementValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.SubregionName.Equal(other.SubregionName) {
		return false
	}

	if !v.Tenancy.Equal(other.Tenancy) {
		return false
	}

	return true
}

func (v PlacementValue) Type(ctx context.Context) attr.Type {
	return PlacementType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PlacementValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"subregion_name": basetypes.StringType{},
		"tenancy":        basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = VmsType{}

type VmsType struct {
	basetypes.ObjectType
}

func (t VmsType) Equal(o attr.Type) bool {
	other, ok := o.(VmsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VmsType) String() string {
	return "VmsType"
}

func (t VmsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	architectureAttribute, ok := attributes["architecture"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`architecture is missing from object`)

		return nil, diags
	}

	architectureVal, ok := architectureAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`architecture expected to be basetypes.StringValue, was: %T`, architectureAttribute))
	}

	blockDeviceMappingsAttribute, ok := attributes["block_device_mappings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_device_mappings is missing from object`)

		return nil, diags
	}

	blockDeviceMappingsVal, ok := blockDeviceMappingsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_device_mappings expected to be basetypes.ListValue, was: %T`, blockDeviceMappingsAttribute))
	}

	bsuOptimizedAttribute, ok := attributes["bsu_optimized"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bsu_optimized is missing from object`)

		return nil, diags
	}

	bsuOptimizedVal, ok := bsuOptimizedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bsu_optimized expected to be basetypes.BoolValue, was: %T`, bsuOptimizedAttribute))
	}

	clientTokenAttribute, ok := attributes["client_token"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_token is missing from object`)

		return nil, diags
	}

	clientTokenVal, ok := clientTokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_token expected to be basetypes.StringValue, was: %T`, clientTokenAttribute))
	}

	creationDateAttribute, ok := attributes["creation_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`creation_date is missing from object`)

		return nil, diags
	}

	creationDateVal, ok := creationDateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`creation_date expected to be basetypes.StringValue, was: %T`, creationDateAttribute))
	}

	deletionProtectionAttribute, ok := attributes["deletion_protection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deletion_protection is missing from object`)

		return nil, diags
	}

	deletionProtectionVal, ok := deletionProtectionAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deletion_protection expected to be basetypes.BoolValue, was: %T`, deletionProtectionAttribute))
	}

	hypervisorAttribute, ok := attributes["hypervisor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hypervisor is missing from object`)

		return nil, diags
	}

	hypervisorVal, ok := hypervisorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hypervisor expected to be basetypes.StringValue, was: %T`, hypervisorAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	imageIdAttribute, ok := attributes["image_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image_id is missing from object`)

		return nil, diags
	}

	imageIdVal, ok := imageIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image_id expected to be basetypes.StringValue, was: %T`, imageIdAttribute))
	}

	initiatedShutdownBehaviorAttribute, ok := attributes["initiated_shutdown_behavior"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`initiated_shutdown_behavior is missing from object`)

		return nil, diags
	}

	initiatedShutdownBehaviorVal, ok := initiatedShutdownBehaviorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`initiated_shutdown_behavior expected to be basetypes.StringValue, was: %T`, initiatedShutdownBehaviorAttribute))
	}

	isSourceDestCheckedAttribute, ok := attributes["is_source_dest_checked"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_source_dest_checked is missing from object`)

		return nil, diags
	}

	isSourceDestCheckedVal, ok := isSourceDestCheckedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_source_dest_checked expected to be basetypes.BoolValue, was: %T`, isSourceDestCheckedAttribute))
	}

	keypairNameAttribute, ok := attributes["keypair_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keypair_name is missing from object`)

		return nil, diags
	}

	keypairNameVal, ok := keypairNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keypair_name expected to be basetypes.StringValue, was: %T`, keypairNameAttribute))
	}

	launchNumberAttribute, ok := attributes["launch_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`launch_number is missing from object`)

		return nil, diags
	}

	launchNumberVal, ok := launchNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`launch_number expected to be basetypes.Int64Value, was: %T`, launchNumberAttribute))
	}

	nestedVirtualizationAttribute, ok := attributes["nested_virtualization"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nested_virtualization is missing from object`)

		return nil, diags
	}

	nestedVirtualizationVal, ok := nestedVirtualizationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nested_virtualization expected to be basetypes.BoolValue, was: %T`, nestedVirtualizationAttribute))
	}

	netIdAttribute, ok := attributes["net_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`net_id is missing from object`)

		return nil, diags
	}

	netIdVal, ok := netIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`net_id expected to be basetypes.StringValue, was: %T`, netIdAttribute))
	}

	nicsAttribute, ok := attributes["nics"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nics is missing from object`)

		return nil, diags
	}

	nicsVal, ok := nicsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nics expected to be basetypes.ListValue, was: %T`, nicsAttribute))
	}

	osFamilyAttribute, ok := attributes["os_family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`os_family is missing from object`)

		return nil, diags
	}

	osFamilyVal, ok := osFamilyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`os_family expected to be basetypes.StringValue, was: %T`, osFamilyAttribute))
	}

	performanceAttribute, ok := attributes["performance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`performance is missing from object`)

		return nil, diags
	}

	performanceVal, ok := performanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`performance expected to be basetypes.StringValue, was: %T`, performanceAttribute))
	}

	placementAttribute, ok := attributes["placement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`placement is missing from object`)

		return nil, diags
	}

	placementVal, ok := placementAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`placement expected to be basetypes.ObjectValue, was: %T`, placementAttribute))
	}

	privateDnsNameAttribute, ok := attributes["private_dns_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_dns_name is missing from object`)

		return nil, diags
	}

	privateDnsNameVal, ok := privateDnsNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_dns_name expected to be basetypes.StringValue, was: %T`, privateDnsNameAttribute))
	}

	privateIpAttribute, ok := attributes["private_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_ip is missing from object`)

		return nil, diags
	}

	privateIpVal, ok := privateIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_ip expected to be basetypes.StringValue, was: %T`, privateIpAttribute))
	}

	productCodesAttribute, ok := attributes["product_codes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`product_codes is missing from object`)

		return nil, diags
	}

	productCodesVal, ok := productCodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`product_codes expected to be basetypes.ListValue, was: %T`, productCodesAttribute))
	}

	publicDnsNameAttribute, ok := attributes["public_dns_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_dns_name is missing from object`)

		return nil, diags
	}

	publicDnsNameVal, ok := publicDnsNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_dns_name expected to be basetypes.StringValue, was: %T`, publicDnsNameAttribute))
	}

	publicIpAttribute, ok := attributes["public_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_ip is missing from object`)

		return nil, diags
	}

	publicIpVal, ok := publicIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_ip expected to be basetypes.StringValue, was: %T`, publicIpAttribute))
	}

	reservationIdAttribute, ok := attributes["reservation_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reservation_id is missing from object`)

		return nil, diags
	}

	reservationIdVal, ok := reservationIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reservation_id expected to be basetypes.StringValue, was: %T`, reservationIdAttribute))
	}

	rootDeviceNameAttribute, ok := attributes["root_device_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`root_device_name is missing from object`)

		return nil, diags
	}

	rootDeviceNameVal, ok := rootDeviceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`root_device_name expected to be basetypes.StringValue, was: %T`, rootDeviceNameAttribute))
	}

	rootDeviceTypeAttribute, ok := attributes["root_device_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`root_device_type is missing from object`)

		return nil, diags
	}

	rootDeviceTypeVal, ok := rootDeviceTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`root_device_type expected to be basetypes.StringValue, was: %T`, rootDeviceTypeAttribute))
	}

	securityGroupsAttribute, ok := attributes["security_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_groups is missing from object`)

		return nil, diags
	}

	securityGroupsVal, ok := securityGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_groups expected to be basetypes.ListValue, was: %T`, securityGroupsAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return nil, diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	stateReasonAttribute, ok := attributes["state_reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state_reason is missing from object`)

		return nil, diags
	}

	stateReasonVal, ok := stateReasonAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state_reason expected to be basetypes.StringValue, was: %T`, stateReasonAttribute))
	}

	subnetIdAttribute, ok := attributes["subnet_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_id is missing from object`)

		return nil, diags
	}

	subnetIdVal, ok := subnetIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_id expected to be basetypes.StringValue, was: %T`, subnetIdAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return nil, diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.ListValue, was: %T`, tagsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	userDataAttribute, ok := attributes["user_data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user_data is missing from object`)

		return nil, diags
	}

	userDataVal, ok := userDataAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user_data expected to be basetypes.StringValue, was: %T`, userDataAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VmsValue{
		Architecture:              architectureVal,
		BlockDeviceMappings:       blockDeviceMappingsVal,
		BsuOptimized:              bsuOptimizedVal,
		ClientToken:               clientTokenVal,
		CreationDate:              creationDateVal,
		DeletionProtection:        deletionProtectionVal,
		Hypervisor:                hypervisorVal,
		Id:                        idVal,
		ImageId:                   imageIdVal,
		InitiatedShutdownBehavior: initiatedShutdownBehaviorVal,
		IsSourceDestChecked:       isSourceDestCheckedVal,
		KeypairName:               keypairNameVal,
		LaunchNumber:              launchNumberVal,
		NestedVirtualization:      nestedVirtualizationVal,
		NetId:                     netIdVal,
		Nics:                      nicsVal,
		OsFamily:                  osFamilyVal,
		Performance:               performanceVal,
		Placement:                 placementVal,
		PrivateDnsName:            privateDnsNameVal,
		PrivateIp:                 privateIpVal,
		ProductCodes:              productCodesVal,
		PublicDnsName:             publicDnsNameVal,
		PublicIp:                  publicIpVal,
		ReservationId:             reservationIdVal,
		RootDeviceName:            rootDeviceNameVal,
		RootDeviceType:            rootDeviceTypeVal,
		SecurityGroups:            securityGroupsVal,
		State:                     stateVal,
		StateReason:               stateReasonVal,
		SubnetId:                  subnetIdVal,
		Tags:                      tagsVal,
		VmsType:                   typeVal,
		UserData:                  userDataVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewVmsValueNull() VmsValue {
	return VmsValue{
		state: attr.ValueStateNull,
	}
}

func NewVmsValueUnknown() VmsValue {
	return VmsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVmsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VmsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VmsValue Attribute Value",
				"While creating a VmsValue value, a missing attribute value was detected. "+
					"A VmsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VmsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VmsValue Attribute Type",
				"While creating a VmsValue value, an invalid attribute value was detected. "+
					"A VmsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VmsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VmsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VmsValue Attribute Value",
				"While creating a VmsValue value, an extra attribute value was detected. "+
					"A VmsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VmsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVmsValueUnknown(), diags
	}

	architectureAttribute, ok := attributes["architecture"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`architecture is missing from object`)

		return NewVmsValueUnknown(), diags
	}

	architectureVal, ok := architectureAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`architecture expected to be basetypes.StringValue, was: %T`, architectureAttribute))
	}

	blockDeviceMappingsAttribute, ok := attributes["block_device_mappings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_device_mappings is missing from object`)

		return NewVmsValueUnknown(), diags
	}

	blockDeviceMappingsVal, ok := blockDeviceMappingsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_device_mappings expected to be basetypes.ListValue, was: %T`, blockDeviceMappingsAttribute))
	}

	bsuOptimizedAttribute, ok := attributes["bsu_optimized"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bsu_optimized is missing from object`)

		return NewVmsValueUnknown(), diags
	}

	bsuOptimizedVal, ok := bsuOptimizedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bsu_optimized expected to be basetypes.BoolValue, was: %T`, bsuOptimizedAttribute))
	}

	clientTokenAttribute, ok := attributes["client_token"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_token is missing from object`)

		return NewVmsValueUnknown(), diags
	}

	clientTokenVal, ok := clientTokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_token expected to be basetypes.StringValue, was: %T`, clientTokenAttribute))
	}

	creationDateAttribute, ok := attributes["creation_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`creation_date is missing from object`)

		return NewVmsValueUnknown(), diags
	}

	creationDateVal, ok := creationDateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`creation_date expected to be basetypes.StringValue, was: %T`, creationDateAttribute))
	}

	deletionProtectionAttribute, ok := attributes["deletion_protection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deletion_protection is missing from object`)

		return NewVmsValueUnknown(), diags
	}

	deletionProtectionVal, ok := deletionProtectionAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deletion_protection expected to be basetypes.BoolValue, was: %T`, deletionProtectionAttribute))
	}

	hypervisorAttribute, ok := attributes["hypervisor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hypervisor is missing from object`)

		return NewVmsValueUnknown(), diags
	}

	hypervisorVal, ok := hypervisorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hypervisor expected to be basetypes.StringValue, was: %T`, hypervisorAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewVmsValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	imageIdAttribute, ok := attributes["image_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image_id is missing from object`)

		return NewVmsValueUnknown(), diags
	}

	imageIdVal, ok := imageIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image_id expected to be basetypes.StringValue, was: %T`, imageIdAttribute))
	}

	initiatedShutdownBehaviorAttribute, ok := attributes["initiated_shutdown_behavior"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`initiated_shutdown_behavior is missing from object`)

		return NewVmsValueUnknown(), diags
	}

	initiatedShutdownBehaviorVal, ok := initiatedShutdownBehaviorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`initiated_shutdown_behavior expected to be basetypes.StringValue, was: %T`, initiatedShutdownBehaviorAttribute))
	}

	isSourceDestCheckedAttribute, ok := attributes["is_source_dest_checked"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_source_dest_checked is missing from object`)

		return NewVmsValueUnknown(), diags
	}

	isSourceDestCheckedVal, ok := isSourceDestCheckedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_source_dest_checked expected to be basetypes.BoolValue, was: %T`, isSourceDestCheckedAttribute))
	}

	keypairNameAttribute, ok := attributes["keypair_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keypair_name is missing from object`)

		return NewVmsValueUnknown(), diags
	}

	keypairNameVal, ok := keypairNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keypair_name expected to be basetypes.StringValue, was: %T`, keypairNameAttribute))
	}

	launchNumberAttribute, ok := attributes["launch_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`launch_number is missing from object`)

		return NewVmsValueUnknown(), diags
	}

	launchNumberVal, ok := launchNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`launch_number expected to be basetypes.Int64Value, was: %T`, launchNumberAttribute))
	}

	nestedVirtualizationAttribute, ok := attributes["nested_virtualization"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nested_virtualization is missing from object`)

		return NewVmsValueUnknown(), diags
	}

	nestedVirtualizationVal, ok := nestedVirtualizationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nested_virtualization expected to be basetypes.BoolValue, was: %T`, nestedVirtualizationAttribute))
	}

	netIdAttribute, ok := attributes["net_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`net_id is missing from object`)

		return NewVmsValueUnknown(), diags
	}

	netIdVal, ok := netIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`net_id expected to be basetypes.StringValue, was: %T`, netIdAttribute))
	}

	nicsAttribute, ok := attributes["nics"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nics is missing from object`)

		return NewVmsValueUnknown(), diags
	}

	nicsVal, ok := nicsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nics expected to be basetypes.ListValue, was: %T`, nicsAttribute))
	}

	osFamilyAttribute, ok := attributes["os_family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`os_family is missing from object`)

		return NewVmsValueUnknown(), diags
	}

	osFamilyVal, ok := osFamilyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`os_family expected to be basetypes.StringValue, was: %T`, osFamilyAttribute))
	}

	performanceAttribute, ok := attributes["performance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`performance is missing from object`)

		return NewVmsValueUnknown(), diags
	}

	performanceVal, ok := performanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`performance expected to be basetypes.StringValue, was: %T`, performanceAttribute))
	}

	placementAttribute, ok := attributes["placement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`placement is missing from object`)

		return NewVmsValueUnknown(), diags
	}

	placementVal, ok := placementAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`placement expected to be basetypes.ObjectValue, was: %T`, placementAttribute))
	}

	privateDnsNameAttribute, ok := attributes["private_dns_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_dns_name is missing from object`)

		return NewVmsValueUnknown(), diags
	}

	privateDnsNameVal, ok := privateDnsNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_dns_name expected to be basetypes.StringValue, was: %T`, privateDnsNameAttribute))
	}

	privateIpAttribute, ok := attributes["private_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_ip is missing from object`)

		return NewVmsValueUnknown(), diags
	}

	privateIpVal, ok := privateIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_ip expected to be basetypes.StringValue, was: %T`, privateIpAttribute))
	}

	productCodesAttribute, ok := attributes["product_codes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`product_codes is missing from object`)

		return NewVmsValueUnknown(), diags
	}

	productCodesVal, ok := productCodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`product_codes expected to be basetypes.ListValue, was: %T`, productCodesAttribute))
	}

	publicDnsNameAttribute, ok := attributes["public_dns_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_dns_name is missing from object`)

		return NewVmsValueUnknown(), diags
	}

	publicDnsNameVal, ok := publicDnsNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_dns_name expected to be basetypes.StringValue, was: %T`, publicDnsNameAttribute))
	}

	publicIpAttribute, ok := attributes["public_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_ip is missing from object`)

		return NewVmsValueUnknown(), diags
	}

	publicIpVal, ok := publicIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_ip expected to be basetypes.StringValue, was: %T`, publicIpAttribute))
	}

	reservationIdAttribute, ok := attributes["reservation_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reservation_id is missing from object`)

		return NewVmsValueUnknown(), diags
	}

	reservationIdVal, ok := reservationIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reservation_id expected to be basetypes.StringValue, was: %T`, reservationIdAttribute))
	}

	rootDeviceNameAttribute, ok := attributes["root_device_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`root_device_name is missing from object`)

		return NewVmsValueUnknown(), diags
	}

	rootDeviceNameVal, ok := rootDeviceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`root_device_name expected to be basetypes.StringValue, was: %T`, rootDeviceNameAttribute))
	}

	rootDeviceTypeAttribute, ok := attributes["root_device_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`root_device_type is missing from object`)

		return NewVmsValueUnknown(), diags
	}

	rootDeviceTypeVal, ok := rootDeviceTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`root_device_type expected to be basetypes.StringValue, was: %T`, rootDeviceTypeAttribute))
	}

	securityGroupsAttribute, ok := attributes["security_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_groups is missing from object`)

		return NewVmsValueUnknown(), diags
	}

	securityGroupsVal, ok := securityGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_groups expected to be basetypes.ListValue, was: %T`, securityGroupsAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return NewVmsValueUnknown(), diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	stateReasonAttribute, ok := attributes["state_reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state_reason is missing from object`)

		return NewVmsValueUnknown(), diags
	}

	stateReasonVal, ok := stateReasonAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state_reason expected to be basetypes.StringValue, was: %T`, stateReasonAttribute))
	}

	subnetIdAttribute, ok := attributes["subnet_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_id is missing from object`)

		return NewVmsValueUnknown(), diags
	}

	subnetIdVal, ok := subnetIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_id expected to be basetypes.StringValue, was: %T`, subnetIdAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return NewVmsValueUnknown(), diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.ListValue, was: %T`, tagsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewVmsValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	userDataAttribute, ok := attributes["user_data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user_data is missing from object`)

		return NewVmsValueUnknown(), diags
	}

	userDataVal, ok := userDataAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user_data expected to be basetypes.StringValue, was: %T`, userDataAttribute))
	}

	if diags.HasError() {
		return NewVmsValueUnknown(), diags
	}

	return VmsValue{
		Architecture:              architectureVal,
		BlockDeviceMappings:       blockDeviceMappingsVal,
		BsuOptimized:              bsuOptimizedVal,
		ClientToken:               clientTokenVal,
		CreationDate:              creationDateVal,
		DeletionProtection:        deletionProtectionVal,
		Hypervisor:                hypervisorVal,
		Id:                        idVal,
		ImageId:                   imageIdVal,
		InitiatedShutdownBehavior: initiatedShutdownBehaviorVal,
		IsSourceDestChecked:       isSourceDestCheckedVal,
		KeypairName:               keypairNameVal,
		LaunchNumber:              launchNumberVal,
		NestedVirtualization:      nestedVirtualizationVal,
		NetId:                     netIdVal,
		Nics:                      nicsVal,
		OsFamily:                  osFamilyVal,
		Performance:               performanceVal,
		Placement:                 placementVal,
		PrivateDnsName:            privateDnsNameVal,
		PrivateIp:                 privateIpVal,
		ProductCodes:              productCodesVal,
		PublicDnsName:             publicDnsNameVal,
		PublicIp:                  publicIpVal,
		ReservationId:             reservationIdVal,
		RootDeviceName:            rootDeviceNameVal,
		RootDeviceType:            rootDeviceTypeVal,
		SecurityGroups:            securityGroupsVal,
		State:                     stateVal,
		StateReason:               stateReasonVal,
		SubnetId:                  subnetIdVal,
		Tags:                      tagsVal,
		VmsType:                   typeVal,
		UserData:                  userDataVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewVmsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VmsValue {
	object, diags := NewVmsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVmsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VmsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVmsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVmsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVmsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVmsValueMust(VmsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VmsType) ValueType(ctx context.Context) attr.Value {
	return VmsValue{}
}

var _ basetypes.ObjectValuable = VmsValue{}

type VmsValue struct {
	Architecture              basetypes.StringValue `tfsdk:"architecture"`
	BlockDeviceMappings       basetypes.ListValue   `tfsdk:"block_device_mappings"`
	BsuOptimized              basetypes.BoolValue   `tfsdk:"bsu_optimized"`
	ClientToken               basetypes.StringValue `tfsdk:"client_token"`
	CreationDate              basetypes.StringValue `tfsdk:"creation_date"`
	DeletionProtection        basetypes.BoolValue   `tfsdk:"deletion_protection"`
	Hypervisor                basetypes.StringValue `tfsdk:"hypervisor"`
	Id                        basetypes.StringValue `tfsdk:"id"`
	ImageId                   basetypes.StringValue `tfsdk:"image_id"`
	InitiatedShutdownBehavior basetypes.StringValue `tfsdk:"initiated_shutdown_behavior"`
	IsSourceDestChecked       basetypes.BoolValue   `tfsdk:"is_source_dest_checked"`
	KeypairName               basetypes.StringValue `tfsdk:"keypair_name"`
	LaunchNumber              basetypes.Int64Value  `tfsdk:"launch_number"`
	NestedVirtualization      basetypes.BoolValue   `tfsdk:"nested_virtualization"`
	NetId                     basetypes.StringValue `tfsdk:"net_id"`
	Nics                      basetypes.ListValue   `tfsdk:"nics"`
	OsFamily                  basetypes.StringValue `tfsdk:"os_family"`
	Performance               basetypes.StringValue `tfsdk:"performance"`
	Placement                 basetypes.ObjectValue `tfsdk:"placement"`
	PrivateDnsName            basetypes.StringValue `tfsdk:"private_dns_name"`
	PrivateIp                 basetypes.StringValue `tfsdk:"private_ip"`
	ProductCodes              basetypes.ListValue   `tfsdk:"product_codes"`
	PublicDnsName             basetypes.StringValue `tfsdk:"public_dns_name"`
	PublicIp                  basetypes.StringValue `tfsdk:"public_ip"`
	ReservationId             basetypes.StringValue `tfsdk:"reservation_id"`
	RootDeviceName            basetypes.StringValue `tfsdk:"root_device_name"`
	RootDeviceType            basetypes.StringValue `tfsdk:"root_device_type"`
	SecurityGroups            basetypes.ListValue   `tfsdk:"security_groups"`
	State                     basetypes.StringValue `tfsdk:"state"`
	StateReason               basetypes.StringValue `tfsdk:"state_reason"`
	SubnetId                  basetypes.StringValue `tfsdk:"subnet_id"`
	Tags                      basetypes.ListValue   `tfsdk:"tags"`
	VmsType                   basetypes.StringValue `tfsdk:"type"`
	UserData                  basetypes.StringValue `tfsdk:"user_data"`
	state                     attr.ValueState
}

func (v VmsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 34)

	var val tftypes.Value
	var err error

	attrTypes["architecture"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["block_device_mappings"] = basetypes.ListType{
		ElemType: BlockDeviceMappingsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["bsu_optimized"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["client_token"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["creation_date"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["deletion_protection"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["hypervisor"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["image_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["initiated_shutdown_behavior"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["is_source_dest_checked"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["keypair_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["launch_number"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["nested_virtualization"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["net_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["nics"] = basetypes.ListType{
		ElemType: NicsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["os_family"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["performance"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["placement"] = basetypes.ObjectType{
		AttrTypes: PlacementValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["private_dns_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["private_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["product_codes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["public_dns_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["public_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["reservation_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["root_device_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["root_device_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["security_groups"] = basetypes.ListType{
		ElemType: SecurityGroupsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["state_reason"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tags"] = basetypes.ListType{
		ElemType: TagsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["user_data"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 34)

		val, err = v.Architecture.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["architecture"] = val

		val, err = v.BlockDeviceMappings.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["block_device_mappings"] = val

		val, err = v.BsuOptimized.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bsu_optimized"] = val

		val, err = v.ClientToken.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["client_token"] = val

		val, err = v.CreationDate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["creation_date"] = val

		val, err = v.DeletionProtection.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["deletion_protection"] = val

		val, err = v.Hypervisor.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hypervisor"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.ImageId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["image_id"] = val

		val, err = v.InitiatedShutdownBehavior.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["initiated_shutdown_behavior"] = val

		val, err = v.IsSourceDestChecked.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_source_dest_checked"] = val

		val, err = v.KeypairName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keypair_name"] = val

		val, err = v.LaunchNumber.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["launch_number"] = val

		val, err = v.NestedVirtualization.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["nested_virtualization"] = val

		val, err = v.NetId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["net_id"] = val

		val, err = v.Nics.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["nics"] = val

		val, err = v.OsFamily.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["os_family"] = val

		val, err = v.Performance.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["performance"] = val

		val, err = v.Placement.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["placement"] = val

		val, err = v.PrivateDnsName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["private_dns_name"] = val

		val, err = v.PrivateIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["private_ip"] = val

		val, err = v.ProductCodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["product_codes"] = val

		val, err = v.PublicDnsName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["public_dns_name"] = val

		val, err = v.PublicIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["public_ip"] = val

		val, err = v.ReservationId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reservation_id"] = val

		val, err = v.RootDeviceName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["root_device_name"] = val

		val, err = v.RootDeviceType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["root_device_type"] = val

		val, err = v.SecurityGroups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["security_groups"] = val

		val, err = v.State.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["state"] = val

		val, err = v.StateReason.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["state_reason"] = val

		val, err = v.SubnetId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_id"] = val

		val, err = v.Tags.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tags"] = val

		val, err = v.VmsType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.UserData.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["user_data"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VmsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VmsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VmsValue) String() string {
	return "VmsValue"
}

func (v VmsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	blockDeviceMappings := types.ListValueMust(
		BlockDeviceMappingsType{
			basetypes.ObjectType{
				AttrTypes: BlockDeviceMappingsValue{}.AttributeTypes(ctx),
			},
		},
		v.BlockDeviceMappings.Elements(),
	)

	if v.BlockDeviceMappings.IsNull() {
		blockDeviceMappings = types.ListNull(
			BlockDeviceMappingsType{
				basetypes.ObjectType{
					AttrTypes: BlockDeviceMappingsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.BlockDeviceMappings.IsUnknown() {
		blockDeviceMappings = types.ListUnknown(
			BlockDeviceMappingsType{
				basetypes.ObjectType{
					AttrTypes: BlockDeviceMappingsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	nics := types.ListValueMust(
		NicsType{
			basetypes.ObjectType{
				AttrTypes: NicsValue{}.AttributeTypes(ctx),
			},
		},
		v.Nics.Elements(),
	)

	if v.Nics.IsNull() {
		nics = types.ListNull(
			NicsType{
				basetypes.ObjectType{
					AttrTypes: NicsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Nics.IsUnknown() {
		nics = types.ListUnknown(
			NicsType{
				basetypes.ObjectType{
					AttrTypes: NicsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var placement basetypes.ObjectValue

	if v.Placement.IsNull() {
		placement = types.ObjectNull(
			PlacementValue{}.AttributeTypes(ctx),
		)
	}

	if v.Placement.IsUnknown() {
		placement = types.ObjectUnknown(
			PlacementValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Placement.IsNull() && !v.Placement.IsUnknown() {
		placement = types.ObjectValueMust(
			PlacementValue{}.AttributeTypes(ctx),
			v.Placement.Attributes(),
		)
	}

	securityGroups := types.ListValueMust(
		SecurityGroupsType{
			basetypes.ObjectType{
				AttrTypes: SecurityGroupsValue{}.AttributeTypes(ctx),
			},
		},
		v.SecurityGroups.Elements(),
	)

	if v.SecurityGroups.IsNull() {
		securityGroups = types.ListNull(
			SecurityGroupsType{
				basetypes.ObjectType{
					AttrTypes: SecurityGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.SecurityGroups.IsUnknown() {
		securityGroups = types.ListUnknown(
			SecurityGroupsType{
				basetypes.ObjectType{
					AttrTypes: SecurityGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	tags := types.ListValueMust(
		TagsType{
			basetypes.ObjectType{
				AttrTypes: TagsValue{}.AttributeTypes(ctx),
			},
		},
		v.Tags.Elements(),
	)

	if v.Tags.IsNull() {
		tags = types.ListNull(
			TagsType{
				basetypes.ObjectType{
					AttrTypes: TagsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Tags.IsUnknown() {
		tags = types.ListUnknown(
			TagsType{
				basetypes.ObjectType{
					AttrTypes: TagsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	productCodesVal, d := types.ListValue(types.StringType, v.ProductCodes.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"architecture": basetypes.StringType{},
			"block_device_mappings": basetypes.ListType{
				ElemType: BlockDeviceMappingsValue{}.Type(ctx),
			},
			"bsu_optimized":               basetypes.BoolType{},
			"client_token":                basetypes.StringType{},
			"creation_date":               basetypes.StringType{},
			"deletion_protection":         basetypes.BoolType{},
			"hypervisor":                  basetypes.StringType{},
			"id":                          basetypes.StringType{},
			"image_id":                    basetypes.StringType{},
			"initiated_shutdown_behavior": basetypes.StringType{},
			"is_source_dest_checked":      basetypes.BoolType{},
			"keypair_name":                basetypes.StringType{},
			"launch_number":               basetypes.Int64Type{},
			"nested_virtualization":       basetypes.BoolType{},
			"net_id":                      basetypes.StringType{},
			"nics": basetypes.ListType{
				ElemType: NicsValue{}.Type(ctx),
			},
			"os_family":   basetypes.StringType{},
			"performance": basetypes.StringType{},
			"placement": basetypes.ObjectType{
				AttrTypes: PlacementValue{}.AttributeTypes(ctx),
			},
			"private_dns_name": basetypes.StringType{},
			"private_ip":       basetypes.StringType{},
			"product_codes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"public_dns_name":  basetypes.StringType{},
			"public_ip":        basetypes.StringType{},
			"reservation_id":   basetypes.StringType{},
			"root_device_name": basetypes.StringType{},
			"root_device_type": basetypes.StringType{},
			"security_groups": basetypes.ListType{
				ElemType: SecurityGroupsValue{}.Type(ctx),
			},
			"state":        basetypes.StringType{},
			"state_reason": basetypes.StringType{},
			"subnet_id":    basetypes.StringType{},
			"tags": basetypes.ListType{
				ElemType: TagsValue{}.Type(ctx),
			},
			"type":      basetypes.StringType{},
			"user_data": basetypes.StringType{},
		}), diags
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"architecture": basetypes.StringType{},
			"block_device_mappings": basetypes.ListType{
				ElemType: BlockDeviceMappingsValue{}.Type(ctx),
			},
			"bsu_optimized":               basetypes.BoolType{},
			"client_token":                basetypes.StringType{},
			"creation_date":               basetypes.StringType{},
			"deletion_protection":         basetypes.BoolType{},
			"hypervisor":                  basetypes.StringType{},
			"id":                          basetypes.StringType{},
			"image_id":                    basetypes.StringType{},
			"initiated_shutdown_behavior": basetypes.StringType{},
			"is_source_dest_checked":      basetypes.BoolType{},
			"keypair_name":                basetypes.StringType{},
			"launch_number":               basetypes.Int64Type{},
			"nested_virtualization":       basetypes.BoolType{},
			"net_id":                      basetypes.StringType{},
			"nics": basetypes.ListType{
				ElemType: NicsValue{}.Type(ctx),
			},
			"os_family":   basetypes.StringType{},
			"performance": basetypes.StringType{},
			"placement": basetypes.ObjectType{
				AttrTypes: PlacementValue{}.AttributeTypes(ctx),
			},
			"private_dns_name": basetypes.StringType{},
			"private_ip":       basetypes.StringType{},
			"product_codes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"public_dns_name":  basetypes.StringType{},
			"public_ip":        basetypes.StringType{},
			"reservation_id":   basetypes.StringType{},
			"root_device_name": basetypes.StringType{},
			"root_device_type": basetypes.StringType{},
			"security_groups": basetypes.ListType{
				ElemType: SecurityGroupsValue{}.Type(ctx),
			},
			"state":        basetypes.StringType{},
			"state_reason": basetypes.StringType{},
			"subnet_id":    basetypes.StringType{},
			"tags": basetypes.ListType{
				ElemType: TagsValue{}.Type(ctx),
			},
			"type":      basetypes.StringType{},
			"user_data": basetypes.StringType{},
		},
		map[string]attr.Value{
			"architecture":                v.Architecture,
			"block_device_mappings":       blockDeviceMappings,
			"bsu_optimized":               v.BsuOptimized,
			"client_token":                v.ClientToken,
			"creation_date":               v.CreationDate,
			"deletion_protection":         v.DeletionProtection,
			"hypervisor":                  v.Hypervisor,
			"id":                          v.Id,
			"image_id":                    v.ImageId,
			"initiated_shutdown_behavior": v.InitiatedShutdownBehavior,
			"is_source_dest_checked":      v.IsSourceDestChecked,
			"keypair_name":                v.KeypairName,
			"launch_number":               v.LaunchNumber,
			"nested_virtualization":       v.NestedVirtualization,
			"net_id":                      v.NetId,
			"nics":                        nics,
			"os_family":                   v.OsFamily,
			"performance":                 v.Performance,
			"placement":                   placement,
			"private_dns_name":            v.PrivateDnsName,
			"private_ip":                  v.PrivateIp,
			"product_codes":               productCodesVal,
			"public_dns_name":             v.PublicDnsName,
			"public_ip":                   v.PublicIp,
			"reservation_id":              v.ReservationId,
			"root_device_name":            v.RootDeviceName,
			"root_device_type":            v.RootDeviceType,
			"security_groups":             securityGroups,
			"state":                       v.State,
			"state_reason":                v.StateReason,
			"subnet_id":                   v.SubnetId,
			"tags":                        tags,
			"type":                        v.VmsType,
			"user_data":                   v.UserData,
		})

	return objVal, diags
}

func (v VmsValue) Equal(o attr.Value) bool {
	other, ok := o.(VmsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Architecture.Equal(other.Architecture) {
		return false
	}

	if !v.BlockDeviceMappings.Equal(other.BlockDeviceMappings) {
		return false
	}

	if !v.BsuOptimized.Equal(other.BsuOptimized) {
		return false
	}

	if !v.ClientToken.Equal(other.ClientToken) {
		return false
	}

	if !v.CreationDate.Equal(other.CreationDate) {
		return false
	}

	if !v.DeletionProtection.Equal(other.DeletionProtection) {
		return false
	}

	if !v.Hypervisor.Equal(other.Hypervisor) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.ImageId.Equal(other.ImageId) {
		return false
	}

	if !v.InitiatedShutdownBehavior.Equal(other.InitiatedShutdownBehavior) {
		return false
	}

	if !v.IsSourceDestChecked.Equal(other.IsSourceDestChecked) {
		return false
	}

	if !v.KeypairName.Equal(other.KeypairName) {
		return false
	}

	if !v.LaunchNumber.Equal(other.LaunchNumber) {
		return false
	}

	if !v.NestedVirtualization.Equal(other.NestedVirtualization) {
		return false
	}

	if !v.NetId.Equal(other.NetId) {
		return false
	}

	if !v.Nics.Equal(other.Nics) {
		return false
	}

	if !v.OsFamily.Equal(other.OsFamily) {
		return false
	}

	if !v.Performance.Equal(other.Performance) {
		return false
	}

	if !v.Placement.Equal(other.Placement) {
		return false
	}

	if !v.PrivateDnsName.Equal(other.PrivateDnsName) {
		return false
	}

	if !v.PrivateIp.Equal(other.PrivateIp) {
		return false
	}

	if !v.ProductCodes.Equal(other.ProductCodes) {
		return false
	}

	if !v.PublicDnsName.Equal(other.PublicDnsName) {
		return false
	}

	if !v.PublicIp.Equal(other.PublicIp) {
		return false
	}

	if !v.ReservationId.Equal(other.ReservationId) {
		return false
	}

	if !v.RootDeviceName.Equal(other.RootDeviceName) {
		return false
	}

	if !v.RootDeviceType.Equal(other.RootDeviceType) {
		return false
	}

	if !v.SecurityGroups.Equal(other.SecurityGroups) {
		return false
	}

	if !v.State.Equal(other.State) {
		return false
	}

	if !v.StateReason.Equal(other.StateReason) {
		return false
	}

	if !v.SubnetId.Equal(other.SubnetId) {
		return false
	}

	if !v.Tags.Equal(other.Tags) {
		return false
	}

	if !v.VmsType.Equal(other.VmsType) {
		return false
	}

	if !v.UserData.Equal(other.UserData) {
		return false
	}

	return true
}

func (v VmsValue) Type(ctx context.Context) attr.Type {
	return VmsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VmsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"architecture": basetypes.StringType{},
		"block_device_mappings": basetypes.ListType{
			ElemType: BlockDeviceMappingsValue{}.Type(ctx),
		},
		"bsu_optimized":               basetypes.BoolType{},
		"client_token":                basetypes.StringType{},
		"creation_date":               basetypes.StringType{},
		"deletion_protection":         basetypes.BoolType{},
		"hypervisor":                  basetypes.StringType{},
		"id":                          basetypes.StringType{},
		"image_id":                    basetypes.StringType{},
		"initiated_shutdown_behavior": basetypes.StringType{},
		"is_source_dest_checked":      basetypes.BoolType{},
		"keypair_name":                basetypes.StringType{},
		"launch_number":               basetypes.Int64Type{},
		"nested_virtualization":       basetypes.BoolType{},
		"net_id":                      basetypes.StringType{},
		"nics": basetypes.ListType{
			ElemType: NicsValue{}.Type(ctx),
		},
		"os_family":   basetypes.StringType{},
		"performance": basetypes.StringType{},
		"placement": basetypes.ObjectType{
			AttrTypes: PlacementValue{}.AttributeTypes(ctx),
		},
		"private_dns_name": basetypes.StringType{},
		"private_ip":       basetypes.StringType{},
		"product_codes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"public_dns_name":  basetypes.StringType{},
		"public_ip":        basetypes.StringType{},
		"reservation_id":   basetypes.StringType{},
		"root_device_name": basetypes.StringType{},
		"root_device_type": basetypes.StringType{},
		"security_groups": basetypes.ListType{
			ElemType: SecurityGroupsValue{}.Type(ctx),
		},
		"state":        basetypes.StringType{},
		"state_reason": basetypes.StringType{},
		"subnet_id":    basetypes.StringType{},
		"tags": basetypes.ListType{
			ElemType: TagsValue{}.Type(ctx),
		},
		"type":      basetypes.StringType{},
		"user_data": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TagsType{}

type TagsType struct {
	basetypes.ObjectType
}

func (t TagsType) Equal(o attr.Type) bool {
	other, ok := o.(TagsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TagsType) String() string {
	return "TagsType"
}

func (t TagsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return nil, diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TagsValue{
		Key:   keyVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewTagsValueNull() TagsValue {
	return TagsValue{
		state: attr.ValueStateNull,
	}
}

func NewTagsValueUnknown() TagsValue {
	return TagsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTagsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TagsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TagsValue Attribute Value",
				"While creating a TagsValue value, a missing attribute value was detected. "+
					"A TagsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TagsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TagsValue Attribute Type",
				"While creating a TagsValue value, an invalid attribute value was detected. "+
					"A TagsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TagsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TagsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TagsValue Attribute Value",
				"While creating a TagsValue value, an extra attribute value was detected. "+
					"A TagsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TagsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTagsValueUnknown(), diags
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return NewTagsValueUnknown(), diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewTagsValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewTagsValueUnknown(), diags
	}

	return TagsValue{
		Key:   keyVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewTagsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TagsValue {
	object, diags := NewTagsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTagsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TagsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTagsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTagsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTagsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTagsValueMust(TagsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TagsType) ValueType(ctx context.Context) attr.Value {
	return TagsValue{}
}

var _ basetypes.ObjectValuable = TagsValue{}

type TagsValue struct {
	Key   basetypes.StringValue `tfsdk:"key"`
	Value basetypes.StringValue `tfsdk:"value"`
	state attr.ValueState
}

func (v TagsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Key.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["key"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TagsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TagsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TagsValue) String() string {
	return "TagsValue"
}

func (v TagsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"key":   basetypes.StringType{},
			"value": basetypes.StringType{},
		},
		map[string]attr.Value{
			"key":   v.Key,
			"value": v.Value,
		})

	return objVal, diags
}

func (v TagsValue) Equal(o attr.Value) bool {
	other, ok := o.(TagsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Key.Equal(other.Key) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v TagsValue) Type(ctx context.Context) attr.Type {
	return TagsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TagsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"key":   basetypes.StringType{},
		"value": basetypes.StringType{},
	}
}
