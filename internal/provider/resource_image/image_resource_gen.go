// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_image

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func ImageResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"architecture": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Description:         "**(when registering from a snapshot, or from a bucket without using a manifest file)** The architecture of the OMI (`i386` or `x84_64`).",
				MarkdownDescription: "**(when registering from a snapshot, or from a bucket without using a manifest file)** The architecture of the OMI (`i386` or `x84_64`).",
			},
			"block_device_mappings": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"bsu": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"delete_on_vm_deletion": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "By default or if set to true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.",
									MarkdownDescription: "By default or if set to true, the volume is deleted when terminating the VM. If false, the volume is not deleted when terminating the VM.",
									Default:             booldefault.StaticBool(true),
								},
								"iops": schema.Int64Attribute{
									Optional:            true,
									Computed:            true,
									Description:         "The number of I/O operations per second (IOPS). This parameter must be specified only if you create an `io1` volume. The maximum number of IOPS allowed for `io1` volumes is `13000` with a maximum performance ratio of 300 IOPS per gibibyte.",
									MarkdownDescription: "The number of I/O operations per second (IOPS). This parameter must be specified only if you create an `io1` volume. The maximum number of IOPS allowed for `io1` volumes is `13000` with a maximum performance ratio of 300 IOPS per gibibyte.",
								},
								"snapshot_id": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "The ID of the snapshot used to create the volume.",
									MarkdownDescription: "The ID of the snapshot used to create the volume.",
								},
								"volume_size": schema.Int64Attribute{
									Optional:            true,
									Computed:            true,
									Description:         "The size of the volume, in gibibytes (GiB).<br />\nIf you specify a snapshot ID, the volume size must be at least equal to the snapshot size.<br />\nIf you specify a snapshot ID but no volume size, the volume is created with a size similar to the snapshot one.",
									MarkdownDescription: "The size of the volume, in gibibytes (GiB).<br />\nIf you specify a snapshot ID, the volume size must be at least equal to the snapshot size.<br />\nIf you specify a snapshot ID but no volume size, the volume is created with a size similar to the snapshot one.",
								},
								"volume_type": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "The type of the volume (`standard` \\| `io1` \\| `gp2`). If not specified in the request, a `standard` volume is created.<br />\n For more information about volume types, see [About Volumes > Volume Types and IOPS](https://docs.outscale.com/en/userguide/About-Volumes.html#_volume_types_and_iops).",
									MarkdownDescription: "The type of the volume (`standard` \\| `io1` \\| `gp2`). If not specified in the request, a `standard` volume is created.<br />\n For more information about volume types, see [About Volumes > Volume Types and IOPS](https://docs.outscale.com/en/userguide/About-Volumes.html#_volume_types_and_iops).",
								},
							},
							CustomType: BsuType{
								ObjectType: types.ObjectType{
									AttrTypes: BsuValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Computed:            true,
							Description:         "Information about the BSU volume to create.",
							MarkdownDescription: "Information about the BSU volume to create.",
						},
						"device_name": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "The device name for the volume. For a root device, you must use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, and the second `X` is a letter between `a` and `z`).",
							MarkdownDescription: "The device name for the volume. For a root device, you must use `/dev/sda1`. For other volumes, you must use `/dev/sdX`, `/dev/sdXX`, `/dev/xvdX`, or `/dev/xvdXX` (where the first `X` is a letter between `b` and `z`, and the second `X` is a letter between `a` and `z`).",
						},
						"virtual_device_name": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "The name of the virtual device (`ephemeralN`).",
							MarkdownDescription: "The name of the virtual device (`ephemeralN`).",
						},
					},
					CustomType: BlockDeviceMappingsType{
						ObjectType: types.ObjectType{
							AttrTypes: BlockDeviceMappingsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.List{
					listplanmodifier.RequiresReplace(),
				},
				Description:         "**(when registering from a snapshot, or from a bucket without using a manifest file)** One or more block device mappings.",
				MarkdownDescription: "**(when registering from a snapshot, or from a bucket without using a manifest file)** One or more block device mappings.",
			},
			"creation_date": schema.StringAttribute{
				Computed:            true,
				Description:         "The date and time of creation of the OMI, in ISO 8601 date-time format.",
				MarkdownDescription: "The date and time of creation of the OMI, in ISO 8601 date-time format.",
			},
			"description": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Description:         "A description for the new OMI.",
				MarkdownDescription: "A description for the new OMI.",
			},
			"id": schema.StringAttribute{
				Computed:            true,
				Description:         "The ID of the OMI.",
				MarkdownDescription: "The ID of the OMI.",
			},
			"name": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Description:         "A unique name for the new OMI.<br />\nConstraints: 3-128 alphanumeric characters, underscores (`_`), spaces (` `), parentheses (`()`), slashes (`/`), periods (`.`), or dashes (`-`).",
				MarkdownDescription: "A unique name for the new OMI.<br />\nConstraints: 3-128 alphanumeric characters, underscores (`_`), spaces (` `), parentheses (`()`), slashes (`/`), periods (`.`), or dashes (`-`).",
			},
			"no_reboot": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Bool{
					boolplanmodifier.RequiresReplace(),
				},
				Description:         "**(when creating from a VM)** If false, the VM shuts down before creating the OMI and then reboots. If true, the VM does not.",
				MarkdownDescription: "**(when creating from a VM)** If false, the VM shuts down before creating the OMI and then reboots. If true, the VM does not.",
			},
			"product_codes": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "The product codes associated with the OMI.",
				MarkdownDescription: "The product codes associated with the OMI.",
			},
			"root_device_name": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Description:         "**(when registering from a snapshot, or from a bucket without using a manifest file)** The name of the root device for the new OMI.",
				MarkdownDescription: "**(when registering from a snapshot, or from a bucket without using a manifest file)** The name of the root device for the new OMI.",
			},
			"root_device_type": schema.StringAttribute{
				Computed:            true,
				Description:         "The type of root device used by the OMI (always `bsu`).",
				MarkdownDescription: "The type of root device used by the OMI (always `bsu`).",
			},
			"source_image_id": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Description:         "**(when copying an OMI)** The ID of the OMI you want to copy.",
				MarkdownDescription: "**(when copying an OMI)** The ID of the OMI you want to copy.",
			},
			"source_region_name": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Description:         "**(when copying an OMI)** The name of the source Region (always the same as the Region of your account).",
				MarkdownDescription: "**(when copying an OMI)** The name of the source Region (always the same as the Region of your account).",
			},
			"space_id": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Description:         "space identifier",
				MarkdownDescription: "space identifier",
			},
			"state": schema.StringAttribute{
				Computed:            true,
				Description:         "The state of the OMI (`pending` \\| `available` \\| `failed`).",
				MarkdownDescription: "The state of the OMI (`pending` \\| `available` \\| `failed`).",
			},
			"state_comment": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"state_code": schema.StringAttribute{
						Computed:            true,
						Description:         "The code of the change of state.",
						MarkdownDescription: "The code of the change of state.",
					},
					"state_message": schema.StringAttribute{
						Computed:            true,
						Description:         "A message explaining the change of state.",
						MarkdownDescription: "A message explaining the change of state.",
					},
				},
				CustomType: StateCommentType{
					ObjectType: types.ObjectType{
						AttrTypes: StateCommentValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "Information about the change of state.",
				MarkdownDescription: "Information about the change of state.",
			},
			"type": schema.StringAttribute{
				Computed:            true,
				Description:         "The type of the OMI.",
				MarkdownDescription: "The type of the OMI.",
			},
			"vm_id": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Description:         "**(when creating from a VM)** The ID of the VM from which you want to create the OMI.",
				MarkdownDescription: "**(when creating from a VM)** The ID of the VM from which you want to create the OMI.",
			},
		},
	}
}

type ImageModel struct {
	Architecture        types.String      `tfsdk:"architecture"`
	BlockDeviceMappings types.List        `tfsdk:"block_device_mappings"`
	CreationDate        types.String      `tfsdk:"creation_date"`
	Description         types.String      `tfsdk:"description"`
	Id                  types.String      `tfsdk:"id"`
	Name                types.String      `tfsdk:"name"`
	NoReboot            types.Bool        `tfsdk:"no_reboot"`
	ProductCodes        types.List        `tfsdk:"product_codes"`
	RootDeviceName      types.String      `tfsdk:"root_device_name"`
	RootDeviceType      types.String      `tfsdk:"root_device_type"`
	SourceImageId       types.String      `tfsdk:"source_image_id"`
	SourceRegionName    types.String      `tfsdk:"source_region_name"`
	SpaceId             types.String      `tfsdk:"space_id"`
	State               types.String      `tfsdk:"state"`
	StateComment        StateCommentValue `tfsdk:"state_comment"`
	Type                types.String      `tfsdk:"type"`
	VmId                types.String      `tfsdk:"vm_id"`
}

var _ basetypes.ObjectTypable = BlockDeviceMappingsType{}

type BlockDeviceMappingsType struct {
	basetypes.ObjectType
}

func (t BlockDeviceMappingsType) Equal(o attr.Type) bool {
	other, ok := o.(BlockDeviceMappingsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BlockDeviceMappingsType) String() string {
	return "BlockDeviceMappingsType"
}

func (t BlockDeviceMappingsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bsuAttribute, ok := attributes["bsu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bsu is missing from object`)

		return nil, diags
	}

	bsuVal, ok := bsuAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bsu expected to be basetypes.ObjectValue, was: %T`, bsuAttribute))
	}

	deviceNameAttribute, ok := attributes["device_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`device_name is missing from object`)

		return nil, diags
	}

	deviceNameVal, ok := deviceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`device_name expected to be basetypes.StringValue, was: %T`, deviceNameAttribute))
	}

	virtualDeviceNameAttribute, ok := attributes["virtual_device_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`virtual_device_name is missing from object`)

		return nil, diags
	}

	virtualDeviceNameVal, ok := virtualDeviceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`virtual_device_name expected to be basetypes.StringValue, was: %T`, virtualDeviceNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BlockDeviceMappingsValue{
		Bsu:               bsuVal,
		DeviceName:        deviceNameVal,
		VirtualDeviceName: virtualDeviceNameVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewBlockDeviceMappingsValueNull() BlockDeviceMappingsValue {
	return BlockDeviceMappingsValue{
		state: attr.ValueStateNull,
	}
}

func NewBlockDeviceMappingsValueUnknown() BlockDeviceMappingsValue {
	return BlockDeviceMappingsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBlockDeviceMappingsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BlockDeviceMappingsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BlockDeviceMappingsValue Attribute Value",
				"While creating a BlockDeviceMappingsValue value, a missing attribute value was detected. "+
					"A BlockDeviceMappingsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BlockDeviceMappingsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BlockDeviceMappingsValue Attribute Type",
				"While creating a BlockDeviceMappingsValue value, an invalid attribute value was detected. "+
					"A BlockDeviceMappingsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BlockDeviceMappingsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BlockDeviceMappingsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BlockDeviceMappingsValue Attribute Value",
				"While creating a BlockDeviceMappingsValue value, an extra attribute value was detected. "+
					"A BlockDeviceMappingsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BlockDeviceMappingsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBlockDeviceMappingsValueUnknown(), diags
	}

	bsuAttribute, ok := attributes["bsu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bsu is missing from object`)

		return NewBlockDeviceMappingsValueUnknown(), diags
	}

	bsuVal, ok := bsuAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bsu expected to be basetypes.ObjectValue, was: %T`, bsuAttribute))
	}

	deviceNameAttribute, ok := attributes["device_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`device_name is missing from object`)

		return NewBlockDeviceMappingsValueUnknown(), diags
	}

	deviceNameVal, ok := deviceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`device_name expected to be basetypes.StringValue, was: %T`, deviceNameAttribute))
	}

	virtualDeviceNameAttribute, ok := attributes["virtual_device_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`virtual_device_name is missing from object`)

		return NewBlockDeviceMappingsValueUnknown(), diags
	}

	virtualDeviceNameVal, ok := virtualDeviceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`virtual_device_name expected to be basetypes.StringValue, was: %T`, virtualDeviceNameAttribute))
	}

	if diags.HasError() {
		return NewBlockDeviceMappingsValueUnknown(), diags
	}

	return BlockDeviceMappingsValue{
		Bsu:               bsuVal,
		DeviceName:        deviceNameVal,
		VirtualDeviceName: virtualDeviceNameVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewBlockDeviceMappingsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BlockDeviceMappingsValue {
	object, diags := NewBlockDeviceMappingsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBlockDeviceMappingsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BlockDeviceMappingsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBlockDeviceMappingsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBlockDeviceMappingsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBlockDeviceMappingsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBlockDeviceMappingsValueMust(BlockDeviceMappingsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BlockDeviceMappingsType) ValueType(ctx context.Context) attr.Value {
	return BlockDeviceMappingsValue{}
}

var _ basetypes.ObjectValuable = BlockDeviceMappingsValue{}

type BlockDeviceMappingsValue struct {
	Bsu               basetypes.ObjectValue `tfsdk:"bsu"`
	DeviceName        basetypes.StringValue `tfsdk:"device_name"`
	VirtualDeviceName basetypes.StringValue `tfsdk:"virtual_device_name"`
	state             attr.ValueState
}

func (v BlockDeviceMappingsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["bsu"] = basetypes.ObjectType{
		AttrTypes: BsuValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["device_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["virtual_device_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Bsu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bsu"] = val

		val, err = v.DeviceName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["device_name"] = val

		val, err = v.VirtualDeviceName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["virtual_device_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BlockDeviceMappingsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BlockDeviceMappingsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BlockDeviceMappingsValue) String() string {
	return "BlockDeviceMappingsValue"
}

func (v BlockDeviceMappingsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var bsu basetypes.ObjectValue

	if v.Bsu.IsNull() {
		bsu = types.ObjectNull(
			BsuValue{}.AttributeTypes(ctx),
		)
	}

	if v.Bsu.IsUnknown() {
		bsu = types.ObjectUnknown(
			BsuValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Bsu.IsNull() && !v.Bsu.IsUnknown() {
		bsu = types.ObjectValueMust(
			BsuValue{}.AttributeTypes(ctx),
			v.Bsu.Attributes(),
		)
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"bsu": basetypes.ObjectType{
				AttrTypes: BsuValue{}.AttributeTypes(ctx),
			},
			"device_name":         basetypes.StringType{},
			"virtual_device_name": basetypes.StringType{},
		},
		map[string]attr.Value{
			"bsu":                 bsu,
			"device_name":         v.DeviceName,
			"virtual_device_name": v.VirtualDeviceName,
		})

	return objVal, diags
}

func (v BlockDeviceMappingsValue) Equal(o attr.Value) bool {
	other, ok := o.(BlockDeviceMappingsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Bsu.Equal(other.Bsu) {
		return false
	}

	if !v.DeviceName.Equal(other.DeviceName) {
		return false
	}

	if !v.VirtualDeviceName.Equal(other.VirtualDeviceName) {
		return false
	}

	return true
}

func (v BlockDeviceMappingsValue) Type(ctx context.Context) attr.Type {
	return BlockDeviceMappingsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BlockDeviceMappingsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bsu": basetypes.ObjectType{
			AttrTypes: BsuValue{}.AttributeTypes(ctx),
		},
		"device_name":         basetypes.StringType{},
		"virtual_device_name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = BsuType{}

type BsuType struct {
	basetypes.ObjectType
}

func (t BsuType) Equal(o attr.Type) bool {
	other, ok := o.(BsuType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BsuType) String() string {
	return "BsuType"
}

func (t BsuType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	deleteOnVmDeletionAttribute, ok := attributes["delete_on_vm_deletion"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`delete_on_vm_deletion is missing from object`)

		return nil, diags
	}

	deleteOnVmDeletionVal, ok := deleteOnVmDeletionAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`delete_on_vm_deletion expected to be basetypes.BoolValue, was: %T`, deleteOnVmDeletionAttribute))
	}

	iopsAttribute, ok := attributes["iops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iops is missing from object`)

		return nil, diags
	}

	iopsVal, ok := iopsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iops expected to be basetypes.Int64Value, was: %T`, iopsAttribute))
	}

	snapshotIdAttribute, ok := attributes["snapshot_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`snapshot_id is missing from object`)

		return nil, diags
	}

	snapshotIdVal, ok := snapshotIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`snapshot_id expected to be basetypes.StringValue, was: %T`, snapshotIdAttribute))
	}

	volumeSizeAttribute, ok := attributes["volume_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_size is missing from object`)

		return nil, diags
	}

	volumeSizeVal, ok := volumeSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_size expected to be basetypes.Int64Value, was: %T`, volumeSizeAttribute))
	}

	volumeTypeAttribute, ok := attributes["volume_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_type is missing from object`)

		return nil, diags
	}

	volumeTypeVal, ok := volumeTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_type expected to be basetypes.StringValue, was: %T`, volumeTypeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BsuValue{
		DeleteOnVmDeletion: deleteOnVmDeletionVal,
		Iops:               iopsVal,
		SnapshotId:         snapshotIdVal,
		VolumeSize:         volumeSizeVal,
		VolumeType:         volumeTypeVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewBsuValueNull() BsuValue {
	return BsuValue{
		state: attr.ValueStateNull,
	}
}

func NewBsuValueUnknown() BsuValue {
	return BsuValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBsuValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BsuValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BsuValue Attribute Value",
				"While creating a BsuValue value, a missing attribute value was detected. "+
					"A BsuValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BsuValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BsuValue Attribute Type",
				"While creating a BsuValue value, an invalid attribute value was detected. "+
					"A BsuValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BsuValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BsuValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BsuValue Attribute Value",
				"While creating a BsuValue value, an extra attribute value was detected. "+
					"A BsuValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BsuValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBsuValueUnknown(), diags
	}

	deleteOnVmDeletionAttribute, ok := attributes["delete_on_vm_deletion"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`delete_on_vm_deletion is missing from object`)

		return NewBsuValueUnknown(), diags
	}

	deleteOnVmDeletionVal, ok := deleteOnVmDeletionAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`delete_on_vm_deletion expected to be basetypes.BoolValue, was: %T`, deleteOnVmDeletionAttribute))
	}

	iopsAttribute, ok := attributes["iops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iops is missing from object`)

		return NewBsuValueUnknown(), diags
	}

	iopsVal, ok := iopsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iops expected to be basetypes.Int64Value, was: %T`, iopsAttribute))
	}

	snapshotIdAttribute, ok := attributes["snapshot_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`snapshot_id is missing from object`)

		return NewBsuValueUnknown(), diags
	}

	snapshotIdVal, ok := snapshotIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`snapshot_id expected to be basetypes.StringValue, was: %T`, snapshotIdAttribute))
	}

	volumeSizeAttribute, ok := attributes["volume_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_size is missing from object`)

		return NewBsuValueUnknown(), diags
	}

	volumeSizeVal, ok := volumeSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_size expected to be basetypes.Int64Value, was: %T`, volumeSizeAttribute))
	}

	volumeTypeAttribute, ok := attributes["volume_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_type is missing from object`)

		return NewBsuValueUnknown(), diags
	}

	volumeTypeVal, ok := volumeTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_type expected to be basetypes.StringValue, was: %T`, volumeTypeAttribute))
	}

	if diags.HasError() {
		return NewBsuValueUnknown(), diags
	}

	return BsuValue{
		DeleteOnVmDeletion: deleteOnVmDeletionVal,
		Iops:               iopsVal,
		SnapshotId:         snapshotIdVal,
		VolumeSize:         volumeSizeVal,
		VolumeType:         volumeTypeVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewBsuValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BsuValue {
	object, diags := NewBsuValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBsuValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BsuType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBsuValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBsuValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBsuValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBsuValueMust(BsuValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BsuType) ValueType(ctx context.Context) attr.Value {
	return BsuValue{}
}

var _ basetypes.ObjectValuable = BsuValue{}

type BsuValue struct {
	DeleteOnVmDeletion basetypes.BoolValue   `tfsdk:"delete_on_vm_deletion"`
	Iops               basetypes.Int64Value  `tfsdk:"iops"`
	SnapshotId         basetypes.StringValue `tfsdk:"snapshot_id"`
	VolumeSize         basetypes.Int64Value  `tfsdk:"volume_size"`
	VolumeType         basetypes.StringValue `tfsdk:"volume_type"`
	state              attr.ValueState
}

func (v BsuValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["delete_on_vm_deletion"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["iops"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["snapshot_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["volume_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["volume_type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.DeleteOnVmDeletion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["delete_on_vm_deletion"] = val

		val, err = v.Iops.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["iops"] = val

		val, err = v.SnapshotId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["snapshot_id"] = val

		val, err = v.VolumeSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_size"] = val

		val, err = v.VolumeType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BsuValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BsuValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BsuValue) String() string {
	return "BsuValue"
}

func (v BsuValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"delete_on_vm_deletion": basetypes.BoolType{},
			"iops":                  basetypes.Int64Type{},
			"snapshot_id":           basetypes.StringType{},
			"volume_size":           basetypes.Int64Type{},
			"volume_type":           basetypes.StringType{},
		},
		map[string]attr.Value{
			"delete_on_vm_deletion": v.DeleteOnVmDeletion,
			"iops":                  v.Iops,
			"snapshot_id":           v.SnapshotId,
			"volume_size":           v.VolumeSize,
			"volume_type":           v.VolumeType,
		})

	return objVal, diags
}

func (v BsuValue) Equal(o attr.Value) bool {
	other, ok := o.(BsuValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DeleteOnVmDeletion.Equal(other.DeleteOnVmDeletion) {
		return false
	}

	if !v.Iops.Equal(other.Iops) {
		return false
	}

	if !v.SnapshotId.Equal(other.SnapshotId) {
		return false
	}

	if !v.VolumeSize.Equal(other.VolumeSize) {
		return false
	}

	if !v.VolumeType.Equal(other.VolumeType) {
		return false
	}

	return true
}

func (v BsuValue) Type(ctx context.Context) attr.Type {
	return BsuType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BsuValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"delete_on_vm_deletion": basetypes.BoolType{},
		"iops":                  basetypes.Int64Type{},
		"snapshot_id":           basetypes.StringType{},
		"volume_size":           basetypes.Int64Type{},
		"volume_type":           basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = StateCommentType{}

type StateCommentType struct {
	basetypes.ObjectType
}

func (t StateCommentType) Equal(o attr.Type) bool {
	other, ok := o.(StateCommentType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StateCommentType) String() string {
	return "StateCommentType"
}

func (t StateCommentType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	stateCodeAttribute, ok := attributes["state_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state_code is missing from object`)

		return nil, diags
	}

	stateCodeVal, ok := stateCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state_code expected to be basetypes.StringValue, was: %T`, stateCodeAttribute))
	}

	stateMessageAttribute, ok := attributes["state_message"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state_message is missing from object`)

		return nil, diags
	}

	stateMessageVal, ok := stateMessageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state_message expected to be basetypes.StringValue, was: %T`, stateMessageAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StateCommentValue{
		StateCode:    stateCodeVal,
		StateMessage: stateMessageVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewStateCommentValueNull() StateCommentValue {
	return StateCommentValue{
		state: attr.ValueStateNull,
	}
}

func NewStateCommentValueUnknown() StateCommentValue {
	return StateCommentValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStateCommentValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StateCommentValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StateCommentValue Attribute Value",
				"While creating a StateCommentValue value, a missing attribute value was detected. "+
					"A StateCommentValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StateCommentValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StateCommentValue Attribute Type",
				"While creating a StateCommentValue value, an invalid attribute value was detected. "+
					"A StateCommentValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StateCommentValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StateCommentValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StateCommentValue Attribute Value",
				"While creating a StateCommentValue value, an extra attribute value was detected. "+
					"A StateCommentValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StateCommentValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStateCommentValueUnknown(), diags
	}

	stateCodeAttribute, ok := attributes["state_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state_code is missing from object`)

		return NewStateCommentValueUnknown(), diags
	}

	stateCodeVal, ok := stateCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state_code expected to be basetypes.StringValue, was: %T`, stateCodeAttribute))
	}

	stateMessageAttribute, ok := attributes["state_message"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state_message is missing from object`)

		return NewStateCommentValueUnknown(), diags
	}

	stateMessageVal, ok := stateMessageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state_message expected to be basetypes.StringValue, was: %T`, stateMessageAttribute))
	}

	if diags.HasError() {
		return NewStateCommentValueUnknown(), diags
	}

	return StateCommentValue{
		StateCode:    stateCodeVal,
		StateMessage: stateMessageVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewStateCommentValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StateCommentValue {
	object, diags := NewStateCommentValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStateCommentValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StateCommentType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStateCommentValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStateCommentValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStateCommentValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStateCommentValueMust(StateCommentValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StateCommentType) ValueType(ctx context.Context) attr.Value {
	return StateCommentValue{}
}

var _ basetypes.ObjectValuable = StateCommentValue{}

type StateCommentValue struct {
	StateCode    basetypes.StringValue `tfsdk:"state_code"`
	StateMessage basetypes.StringValue `tfsdk:"state_message"`
	state        attr.ValueState
}

func (v StateCommentValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["state_code"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["state_message"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.StateCode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["state_code"] = val

		val, err = v.StateMessage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["state_message"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StateCommentValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StateCommentValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StateCommentValue) String() string {
	return "StateCommentValue"
}

func (v StateCommentValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"state_code":    basetypes.StringType{},
			"state_message": basetypes.StringType{},
		},
		map[string]attr.Value{
			"state_code":    v.StateCode,
			"state_message": v.StateMessage,
		})

	return objVal, diags
}

func (v StateCommentValue) Equal(o attr.Value) bool {
	other, ok := o.(StateCommentValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.StateCode.Equal(other.StateCode) {
		return false
	}

	if !v.StateMessage.Equal(other.StateMessage) {
		return false
	}

	return true
}

func (v StateCommentValue) Type(ctx context.Context) attr.Type {
	return StateCommentType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StateCommentValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"state_code":    basetypes.StringType{},
		"state_message": basetypes.StringType{},
	}
}
